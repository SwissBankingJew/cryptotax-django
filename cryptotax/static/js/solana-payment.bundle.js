(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod2) => function __require() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));
  var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

  // node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js"(exports) {
      "use strict";
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1) validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer, offset2, isLE2, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE2 ? nBytes - 1 : 0;
        var d = isLE2 ? -1 : 1;
        var s = buffer[offset2 + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset2 + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset2 + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset2, isLE2, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE2 ? 0 : nBytes - 1;
        var d = isLE2 ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset2 + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset2 + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset2 + i - d] |= s * 128;
      };
    }
  });

  // node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/buffer/index.js"(exports) {
      "use strict";
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer5;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer5.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer5.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer5.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer5.isBuffer(this)) return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer5.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer5.isBuffer(this)) return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer5.prototype);
        return buf;
      }
      function Buffer5(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer5.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer5.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b) return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer5.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer5.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer5.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer5, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer5.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer5.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer5.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string2, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer5.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string2, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string2, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array2) {
        const length = array2.length < 0 ? 0 : checked(array2.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array2[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array2, byteOffset, length) {
        if (byteOffset < 0 || array2.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array2.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array2);
        } else if (length === void 0) {
          buf = new Uint8Array(array2, byteOffset);
        } else {
          buf = new Uint8Array(array2, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer5.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer5.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer5.alloc(+length);
      }
      Buffer5.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer5.prototype;
      };
      Buffer5.compare = function compare2(a, b) {
        if (isInstance(a, Uint8Array)) a = Buffer5.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array)) b = Buffer5.from(b, b.offset, b.byteLength);
        if (!Buffer5.isBuffer(a) || !Buffer5.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b) return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      Buffer5.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer5.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer5.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer5.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer5.isBuffer(buf)) buf = Buffer5.from(buf);
              buf.copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer5.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string2, encoding) {
        if (Buffer5.isBuffer(string2)) {
          return string2.length;
        }
        if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
          return string2.byteLength;
        }
        if (typeof string2 !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
          );
        }
        const len = string2.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0) return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes2(string2).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string2).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes2(string2).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer5.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding) encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer5.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer5.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer5.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer5.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer5.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0) return "";
        if (arguments.length === 0) return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer5.prototype.toLocaleString = Buffer5.prototype.toString;
      Buffer5.prototype.equals = function equals(b) {
        if (!Buffer5.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
        if (this === b) return true;
        return Buffer5.compare(this, b) === 0;
      };
      Buffer5.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max) str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer5.prototype[customInspectSymbol] = Buffer5.prototype.inspect;
      }
      Buffer5.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer5.from(target, target.offset, target.byteLength);
        }
        if (!Buffer5.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target) return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0) return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir) return -1;
          else byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0;
          else return -1;
        }
        if (typeof val === "string") {
          val = Buffer5.from(val, encoding);
        }
        if (Buffer5.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1) foundIndex = i;
              if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1) i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found) return i;
          }
        }
        return -1;
      }
      Buffer5.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer5.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer5.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string2, offset2, length) {
        offset2 = Number(offset2) || 0;
        const remaining = buf.length - offset2;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string2.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string2.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed)) return i;
          buf[offset2 + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string2, offset2, length) {
        return blitBuffer(utf8ToBytes2(string2, buf.length - offset2), buf, offset2, length);
      }
      function asciiWrite(buf, string2, offset2, length) {
        return blitBuffer(asciiToBytes(string2), buf, offset2, length);
      }
      function base64Write(buf, string2, offset2, length) {
        return blitBuffer(base64ToBytes(string2), buf, offset2, length);
      }
      function ucs2Write(buf, string2, offset2, length) {
        return blitBuffer(utf16leToBytes(string2, buf.length - offset2), buf, offset2, length);
      }
      Buffer5.prototype.write = function write(string2, offset2, length, encoding) {
        if (offset2 === void 0) {
          encoding = "utf8";
          length = this.length;
          offset2 = 0;
        } else if (length === void 0 && typeof offset2 === "string") {
          encoding = offset2;
          length = this.length;
          offset2 = 0;
        } else if (isFinite(offset2)) {
          offset2 = offset2 >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0) encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset2;
        if (length === void 0 || length > remaining) length = remaining;
        if (string2.length > 0 && (length < 0 || offset2 < 0) || offset2 > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding) encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string2, offset2, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string2, offset2, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string2, offset2, length);
            case "base64":
              return base64Write(this, string2, offset2, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string2, offset2, length);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer5.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0) start = 0;
        if (!end || end < 0 || end > len) end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer5.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0) start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0) end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start) end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer5.prototype);
        return newBuf;
      };
      function checkOffset(offset2, ext, length) {
        if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
        if (offset2 + ext > length) throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer5.prototype.readUintLE = Buffer5.prototype.readUIntLE = function readUIntLE(offset2, byteLength2, noAssert) {
        offset2 = offset2 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset2, byteLength2, this.length);
        let val = this[offset2];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset2 + i] * mul;
        }
        return val;
      };
      Buffer5.prototype.readUintBE = Buffer5.prototype.readUIntBE = function readUIntBE(offset2, byteLength2, noAssert) {
        offset2 = offset2 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset2, byteLength2, this.length);
        }
        let val = this[offset2 + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset2 + --byteLength2] * mul;
        }
        return val;
      };
      Buffer5.prototype.readUint8 = Buffer5.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 1, this.length);
        return this[offset2];
      };
      Buffer5.prototype.readUint16LE = Buffer5.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 2, this.length);
        return this[offset2] | this[offset2 + 1] << 8;
      };
      Buffer5.prototype.readUint16BE = Buffer5.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 2, this.length);
        return this[offset2] << 8 | this[offset2 + 1];
      };
      Buffer5.prototype.readUint32LE = Buffer5.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
      };
      Buffer5.prototype.readUint32BE = Buffer5.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
      };
      Buffer5.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset2) {
        offset2 = offset2 >>> 0;
        validateNumber(offset2, "offset");
        const first = this[offset2];
        const last = this[offset2 + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset2, this.length - 8);
        }
        const lo = first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24;
        const hi = this[++offset2] + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer5.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset2) {
        offset2 = offset2 >>> 0;
        validateNumber(offset2, "offset");
        const first = this[offset2];
        const last = this[offset2 + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset2, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
        const lo = this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer5.prototype.readIntLE = function readIntLE(offset2, byteLength2, noAssert) {
        offset2 = offset2 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset2, byteLength2, this.length);
        let val = this[offset2];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset2 + i] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer5.prototype.readIntBE = function readIntBE(offset2, byteLength2, noAssert) {
        offset2 = offset2 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset2, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset2 + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset2 + --i] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer5.prototype.readInt8 = function readInt8(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 1, this.length);
        if (!(this[offset2] & 128)) return this[offset2];
        return (255 - this[offset2] + 1) * -1;
      };
      Buffer5.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 2, this.length);
        const val = this[offset2] | this[offset2 + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer5.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 2, this.length);
        const val = this[offset2 + 1] | this[offset2] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer5.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
      };
      Buffer5.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
      };
      Buffer5.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset2) {
        offset2 = offset2 >>> 0;
        validateNumber(offset2, "offset");
        const first = this[offset2];
        const last = this[offset2 + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset2, this.length - 8);
        }
        const val = this[offset2 + 4] + this[offset2 + 5] * 2 ** 8 + this[offset2 + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24);
      });
      Buffer5.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset2) {
        offset2 = offset2 >>> 0;
        validateNumber(offset2, "offset");
        const first = this[offset2];
        const last = this[offset2 + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset2, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last);
      });
      Buffer5.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return ieee754.read(this, offset2, true, 23, 4);
      };
      Buffer5.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return ieee754.read(this, offset2, false, 23, 4);
      };
      Buffer5.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 8, this.length);
        return ieee754.read(this, offset2, true, 52, 8);
      };
      Buffer5.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 8, this.length);
        return ieee754.read(this, offset2, false, 52, 8);
      };
      function checkInt(buf, value, offset2, ext, max, min) {
        if (!Buffer5.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
        if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
      }
      Buffer5.prototype.writeUintLE = Buffer5.prototype.writeUIntLE = function writeUIntLE(value, offset2, byteLength2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset2, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset2] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset2 + i] = value / mul & 255;
        }
        return offset2 + byteLength2;
      };
      Buffer5.prototype.writeUintBE = Buffer5.prototype.writeUIntBE = function writeUIntBE(value, offset2, byteLength2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset2, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset2 + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset2 + i] = value / mul & 255;
        }
        return offset2 + byteLength2;
      };
      Buffer5.prototype.writeUint8 = Buffer5.prototype.writeUInt8 = function writeUInt8(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 1, 255, 0);
        this[offset2] = value & 255;
        return offset2 + 1;
      };
      Buffer5.prototype.writeUint16LE = Buffer5.prototype.writeUInt16LE = function writeUInt16LE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 2, 65535, 0);
        this[offset2] = value & 255;
        this[offset2 + 1] = value >>> 8;
        return offset2 + 2;
      };
      Buffer5.prototype.writeUint16BE = Buffer5.prototype.writeUInt16BE = function writeUInt16BE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 2, 65535, 0);
        this[offset2] = value >>> 8;
        this[offset2 + 1] = value & 255;
        return offset2 + 2;
      };
      Buffer5.prototype.writeUint32LE = Buffer5.prototype.writeUInt32LE = function writeUInt32LE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 4, 4294967295, 0);
        this[offset2 + 3] = value >>> 24;
        this[offset2 + 2] = value >>> 16;
        this[offset2 + 1] = value >>> 8;
        this[offset2] = value & 255;
        return offset2 + 4;
      };
      Buffer5.prototype.writeUint32BE = Buffer5.prototype.writeUInt32BE = function writeUInt32BE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 4, 4294967295, 0);
        this[offset2] = value >>> 24;
        this[offset2 + 1] = value >>> 16;
        this[offset2 + 2] = value >>> 8;
        this[offset2 + 3] = value & 255;
        return offset2 + 4;
      };
      function wrtBigUInt64LE(buf, value, offset2, min, max) {
        checkIntBI(value, min, max, buf, offset2, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset2++] = lo;
        lo = lo >> 8;
        buf[offset2++] = lo;
        lo = lo >> 8;
        buf[offset2++] = lo;
        lo = lo >> 8;
        buf[offset2++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset2++] = hi;
        hi = hi >> 8;
        buf[offset2++] = hi;
        hi = hi >> 8;
        buf[offset2++] = hi;
        hi = hi >> 8;
        buf[offset2++] = hi;
        return offset2;
      }
      function wrtBigUInt64BE(buf, value, offset2, min, max) {
        checkIntBI(value, min, max, buf, offset2, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset2 + 7] = lo;
        lo = lo >> 8;
        buf[offset2 + 6] = lo;
        lo = lo >> 8;
        buf[offset2 + 5] = lo;
        lo = lo >> 8;
        buf[offset2 + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset2 + 3] = hi;
        hi = hi >> 8;
        buf[offset2 + 2] = hi;
        hi = hi >> 8;
        buf[offset2 + 1] = hi;
        hi = hi >> 8;
        buf[offset2] = hi;
        return offset2 + 8;
      }
      Buffer5.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset2 = 0) {
        return wrtBigUInt64LE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer5.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset2 = 0) {
        return wrtBigUInt64BE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer5.prototype.writeIntLE = function writeIntLE(value, offset2, byteLength2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset2, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset2] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset2 + i - 1] !== 0) {
            sub = 1;
          }
          this[offset2 + i] = (value / mul >> 0) - sub & 255;
        }
        return offset2 + byteLength2;
      };
      Buffer5.prototype.writeIntBE = function writeIntBE(value, offset2, byteLength2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset2, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset2 + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset2 + i + 1] !== 0) {
            sub = 1;
          }
          this[offset2 + i] = (value / mul >> 0) - sub & 255;
        }
        return offset2 + byteLength2;
      };
      Buffer5.prototype.writeInt8 = function writeInt8(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 1, 127, -128);
        if (value < 0) value = 255 + value + 1;
        this[offset2] = value & 255;
        return offset2 + 1;
      };
      Buffer5.prototype.writeInt16LE = function writeInt16LE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 2, 32767, -32768);
        this[offset2] = value & 255;
        this[offset2 + 1] = value >>> 8;
        return offset2 + 2;
      };
      Buffer5.prototype.writeInt16BE = function writeInt16BE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 2, 32767, -32768);
        this[offset2] = value >>> 8;
        this[offset2 + 1] = value & 255;
        return offset2 + 2;
      };
      Buffer5.prototype.writeInt32LE = function writeInt32LE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 4, 2147483647, -2147483648);
        this[offset2] = value & 255;
        this[offset2 + 1] = value >>> 8;
        this[offset2 + 2] = value >>> 16;
        this[offset2 + 3] = value >>> 24;
        return offset2 + 4;
      };
      Buffer5.prototype.writeInt32BE = function writeInt32BE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 4, 2147483647, -2147483648);
        if (value < 0) value = 4294967295 + value + 1;
        this[offset2] = value >>> 24;
        this[offset2 + 1] = value >>> 16;
        this[offset2 + 2] = value >>> 8;
        this[offset2 + 3] = value & 255;
        return offset2 + 4;
      };
      Buffer5.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset2 = 0) {
        return wrtBigUInt64LE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer5.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset2 = 0) {
        return wrtBigUInt64BE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset2, ext, max, min) {
        if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
        if (offset2 < 0) throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset2, littleEndian, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset2, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset2, littleEndian, 23, 4);
        return offset2 + 4;
      }
      Buffer5.prototype.writeFloatLE = function writeFloatLE(value, offset2, noAssert) {
        return writeFloat(this, value, offset2, true, noAssert);
      };
      Buffer5.prototype.writeFloatBE = function writeFloatBE(value, offset2, noAssert) {
        return writeFloat(this, value, offset2, false, noAssert);
      };
      function writeDouble(buf, value, offset2, littleEndian, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset2, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset2, littleEndian, 52, 8);
        return offset2 + 8;
      }
      Buffer5.prototype.writeDoubleLE = function writeDoubleLE(value, offset2, noAssert) {
        return writeDouble(this, value, offset2, true, noAssert);
      };
      Buffer5.prototype.writeDoubleBE = function writeDoubleBE(value, offset2, noAssert) {
        return writeDouble(this, value, offset2, false, noAssert);
      };
      Buffer5.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer5.isBuffer(target)) throw new TypeError("argument should be a Buffer");
        if (!start) start = 0;
        if (!end && end !== 0) end = this.length;
        if (targetStart >= target.length) targetStart = target.length;
        if (!targetStart) targetStart = 0;
        if (end > 0 && end < start) end = start;
        if (end === start) return 0;
        if (target.length === 0 || this.length === 0) return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
        if (end < 0) throw new RangeError("sourceEnd out of bounds");
        if (end > this.length) end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer5.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer5.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val) val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer5.isBuffer(val) ? val : Buffer5.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset2, byteLength2) {
        validateNumber(offset2, "offset");
        if (buf[offset2] === void 0 || buf[offset2 + byteLength2] === void 0) {
          boundsError(offset2, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset2, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset2, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type2) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type2);
          throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type2 || "offset",
          `>= ${type2 ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2) return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes2(string2, units) {
        units = units || Infinity;
        let codePoint;
        const length = string2.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string2.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0) break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset2, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset2 >= dst.length || i >= src.length) break;
          dst[i + offset2] = src[i];
        }
        return i;
      }
      function isInstance(obj, type2) {
        return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // (disabled):node_modules/buffer/index.js
  var require_buffer2 = __commonJS({
    "(disabled):node_modules/buffer/index.js"() {
    }
  });

  // node_modules/bn.js/lib/bn.js
  var require_bn = __commonJS({
    "node_modules/bn.js/lib/bn.js"(exports, module) {
      (function(module2, exports2) {
        "use strict";
        function assert3(val, msg) {
          if (!val) throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN2(number2, base, endian) {
          if (BN2.isBN(number2)) {
            return number2;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number2 !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number2 || 0, base || 10, endian || "be");
          }
        }
        if (typeof module2 === "object") {
          module2.exports = BN2;
        } else {
          exports2.BN = BN2;
        }
        BN2.BN = BN2;
        BN2.wordSize = 26;
        var Buffer5;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer5 = window.Buffer;
          } else {
            Buffer5 = require_buffer2().Buffer;
          }
        } catch (e) {
        }
        BN2.isBN = function isBN(num) {
          if (num instanceof BN2) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
        };
        BN2.max = function max(left, right) {
          if (left.cmp(right) > 0) return left;
          return right;
        };
        BN2.min = function min(left, right) {
          if (left.cmp(right) < 0) return left;
          return right;
        };
        BN2.prototype._init = function init(number2, base, endian) {
          if (typeof number2 === "number") {
            return this._initNumber(number2, base, endian);
          }
          if (typeof number2 === "object") {
            return this._initArray(number2, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert3(base === (base | 0) && base >= 2 && base <= 36);
          number2 = number2.toString().replace(/\s+/g, "");
          var start = 0;
          if (number2[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number2.length) {
            if (base === 16) {
              this._parseHex(number2, start, endian);
            } else {
              this._parseBase(number2, base, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
              }
            }
          }
        };
        BN2.prototype._initNumber = function _initNumber(number2, base, endian) {
          if (number2 < 0) {
            this.negative = 1;
            number2 = -number2;
          }
          if (number2 < 67108864) {
            this.words = [number2 & 67108863];
            this.length = 1;
          } else if (number2 < 4503599627370496) {
            this.words = [
              number2 & 67108863,
              number2 / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert3(number2 < 9007199254740992);
            this.words = [
              number2 & 67108863,
              number2 / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le") return;
          this._initArray(this.toArray(), base, endian);
        };
        BN2.prototype._initArray = function _initArray(number2, base, endian) {
          assert3(typeof number2.length === "number");
          if (number2.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number2.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number2.length - 1, j = 0; i >= 0; i -= 3) {
              w = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number2.length; i += 3) {
              w = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this._strip();
        };
        function parseHex4Bits(string2, index) {
          var c = string2.charCodeAt(index);
          if (c >= 48 && c <= 57) {
            return c - 48;
          } else if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            assert3(false, "Invalid character in " + string2);
          }
        }
        function parseHexByte(string2, lowerBound, index) {
          var r = parseHex4Bits(string2, index);
          if (index - 1 >= lowerBound) {
            r |= parseHex4Bits(string2, index - 1) << 4;
          }
          return r;
        }
        BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
          this.length = Math.ceil((number2.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off = 0;
          var j = 0;
          var w;
          if (endian === "be") {
            for (i = number2.length - 1; i >= start; i -= 2) {
              w = parseHexByte(number2, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number2.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number2.length; i += 2) {
              w = parseHexByte(number2, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this._strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var b = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              b = c - 49 + 10;
            } else if (c >= 17) {
              b = c - 17 + 10;
            } else {
              b = c;
            }
            assert3(c >= 0 && b < mul, "Invalid character");
            r += b;
          }
          return r;
        }
        BN2.prototype._parseBase = function _parseBase(number2, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number2.length - start;
          var mod2 = total % limbLen;
          var end = Math.min(total, total - mod2) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number2, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod2 !== 0) {
            var pow = 1;
            word = parseBase(number2, i, number2.length, base);
            for (i = 0; i < mod2; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this._strip();
        };
        BN2.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        function move(dest, src) {
          dest.words = src.words;
          dest.length = src.length;
          dest.negative = src.negative;
          dest.red = src.red;
        }
        BN2.prototype._move = function _move(dest) {
          move(dest, this);
        };
        BN2.prototype.clone = function clone2() {
          var r = new BN2(null);
          this.copy(r);
          return r;
        };
        BN2.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN2.prototype._strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN2.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
          try {
            BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
          } catch (e) {
            BN2.prototype.inspect = inspect;
          }
        } else {
          BN2.prototype.inspect = inspect;
        }
        function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN2.prototype.toString = function toString(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry) & 16777215).toString(16);
              carry = w >>> 24 - off & 16777215;
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modrn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert3(false, "Base should be between 2 and 36");
        };
        BN2.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert3(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN2.prototype.toJSON = function toJSON() {
          return this.toString(16, 2);
        };
        if (Buffer5) {
          BN2.prototype.toBuffer = function toBuffer2(endian, length) {
            return this.toArrayLike(Buffer5, endian, length);
          };
        }
        BN2.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        var allocate = function allocate2(ArrayType, size) {
          if (ArrayType.allocUnsafe) {
            return ArrayType.allocUnsafe(size);
          }
          return new ArrayType(size);
        };
        BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          this._strip();
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert3(byteLength <= reqLength, "byte array longer than desired length");
          assert3(reqLength > 0, "Requested array length <= 0");
          var res = allocate(ArrayType, reqLength);
          var postfix = endian === "le" ? "LE" : "BE";
          this["_toArrayLike" + postfix](res, byteLength);
          return res;
        };
        BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
          var position = 0;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position++] = word & 255;
            if (position < res.length) {
              res[position++] = word >> 8 & 255;
            }
            if (position < res.length) {
              res[position++] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position < res.length) {
                res[position++] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position < res.length) {
            res[position++] = carry;
            while (position < res.length) {
              res[position++] = 0;
            }
          }
        };
        BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
          var position = res.length - 1;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position--] = word & 255;
            if (position >= 0) {
              res[position--] = word >> 8 & 255;
            }
            if (position >= 0) {
              res[position--] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position >= 0) {
                res[position--] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position >= 0) {
            res[position--] = carry;
            while (position >= 0) {
              res[position--] = 0;
            }
          }
        };
        if (Math.clz32) {
          BN2.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN2.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN2.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0) return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN2.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 1;
          }
          return w;
        }
        BN2.prototype.zeroBits = function zeroBits() {
          if (this.isZero()) return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
          }
          return r;
        };
        BN2.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN2.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN2.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN2.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN2.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN2.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN2.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this._strip();
        };
        BN2.prototype.ior = function ior(num) {
          assert3((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN2.prototype.or = function or(num) {
          if (this.length > num.length) return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN2.prototype.uor = function uor(num) {
          if (this.length > num.length) return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN2.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this._strip();
        };
        BN2.prototype.iand = function iand(num) {
          assert3((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN2.prototype.and = function and(num) {
          if (this.length > num.length) return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN2.prototype.uand = function uand(num) {
          if (this.length > num.length) return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN2.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this._strip();
        };
        BN2.prototype.ixor = function ixor(num) {
          assert3((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN2.prototype.xor = function xor(num) {
          if (this.length > num.length) return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN2.prototype.uxor = function uxor(num) {
          if (this.length > num.length) return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN2.prototype.inotn = function inotn(width) {
          assert3(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this._strip();
        };
        BN2.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN2.prototype.setn = function setn(bit, val) {
          assert3(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this._strip();
        };
        BN2.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN2.prototype.add = function add2(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length) return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN2.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this._strip();
        };
        BN2.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self, num, out) {
          out.negative = num.negative ^ self.negative;
          var len = self.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out._strip();
        }
        var comb10MulTo = function comb10MulTo2(self, num, out) {
          var a = self.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self, num, out) {
          out.negative = num.negative ^ self.negative;
          out.length = self.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out._strip();
        }
        function jumboMulTo(self, num, out) {
          return bigMulTo(self, num, out);
        }
        BN2.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN2.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1) return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1) return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert3(carry === 0);
          assert3((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out._strip();
        };
        BN2.prototype.mul = function mul(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN2.prototype.mulf = function mulf(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN2.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN2.prototype.imuln = function imuln(num) {
          var isNegNum = num < 0;
          if (isNegNum) num = -num;
          assert3(typeof num === "number");
          assert3(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          this.length = num === 0 ? 1 : this.length;
          return isNegNum ? this.ineg() : this;
        };
        BN2.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN2.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN2.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN2.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0) return new BN2(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0) break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0) continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN2.prototype.iushln = function iushln(bits) {
          assert3(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this._strip();
        };
        BN2.prototype.ishln = function ishln(bits) {
          assert3(this.negative === 0);
          return this.iushln(bits);
        };
        BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert3(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask2 = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0) {
          } else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask2;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this._strip();
        };
        BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert3(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN2.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN2.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN2.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN2.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN2.prototype.testn = function testn(bit) {
          assert3(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN2.prototype.imaskn = function imaskn(bits) {
          assert3(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert3(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask2 = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask2;
          }
          return this._strip();
        };
        BN2.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN2.prototype.iaddn = function iaddn(num) {
          assert3(typeof num === "number");
          assert3(num < 67108864);
          if (num < 0) return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN2.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN2.prototype.isubn = function isubn(num) {
          assert3(typeof num === "number");
          assert3(num < 67108864);
          if (num < 0) return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this._strip();
        };
        BN2.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN2.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN2.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN2.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0) return this._strip();
          assert3(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this._strip();
        };
        BN2.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN2(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q._strip();
          }
          a._strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN2.prototype.divmod = function divmod(num, mode, positive) {
          assert3(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN2(0),
              mod: new BN2(0)
            };
          }
          var div, mod2, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod2 = res.mod.neg();
              if (positive && mod2.negative !== 0) {
                mod2.iadd(num);
              }
            }
            return {
              div,
              mod: mod2
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod2 = res.mod.neg();
              if (positive && mod2.negative !== 0) {
                mod2.isub(num);
              }
            }
            return {
              div: res.div,
              mod: mod2
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN2(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN2(this.modrn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN2.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN2.prototype.mod = function mod2(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN2.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN2.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero()) return dm.div;
          var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod2.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN2.prototype.modrn = function modrn(num) {
          var isNegNum = num < 0;
          if (isNegNum) num = -num;
          assert3(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return isNegNum ? -acc : acc;
        };
        BN2.prototype.modn = function modn(num) {
          return this.modrn(num);
        };
        BN2.prototype.idivn = function idivn(num) {
          var isNegNum = num < 0;
          if (isNegNum) num = -num;
          assert3(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          this._strip();
          return isNegNum ? this.ineg() : this;
        };
        BN2.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN2.prototype.egcd = function egcd(p) {
          assert3(p.negative === 0);
          assert3(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN2(1);
          var B = new BN2(0);
          var C = new BN2(0);
          var D = new BN2(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN2.prototype._invmp = function _invmp(p) {
          assert3(p.negative === 0);
          assert3(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN2(1);
          var x2 = new BN2(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN2.prototype.gcd = function gcd(num) {
          if (this.isZero()) return num.abs();
          if (num.isZero()) return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN2.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN2.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN2.prototype.isOdd = function isOdd2() {
          return (this.words[0] & 1) === 1;
        };
        BN2.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN2.prototype.bincn = function bincn(bit) {
          assert3(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN2.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative) return -1;
          if (this.negative === 0 && negative) return 1;
          this._strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert3(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0) return -res | 0;
          return res;
        };
        BN2.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0) return -1;
          if (this.negative === 0 && num.negative !== 0) return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0) return -res | 0;
          return res;
        };
        BN2.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length) return 1;
          if (this.length < num.length) return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN2.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN2.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN2.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN2.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN2.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN2.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN2.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN2.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN2.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN2.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN2.red = function red(num) {
          return new Red(num);
        };
        BN2.prototype.toRed = function toRed(ctx) {
          assert3(!this.red, "Already a number in reduction context");
          assert3(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN2.prototype.fromRed = function fromRed() {
          assert3(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN2.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN2.prototype.forceRed = function forceRed(ctx) {
          assert3(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN2.prototype.redAdd = function redAdd(num) {
          assert3(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN2.prototype.redIAdd = function redIAdd(num) {
          assert3(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN2.prototype.redSub = function redSub(num) {
          assert3(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN2.prototype.redISub = function redISub(num) {
          assert3(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN2.prototype.redShl = function redShl(num) {
          assert3(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN2.prototype.redMul = function redMul(num) {
          assert3(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN2.prototype.redIMul = function redIMul(num) {
          assert3(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN2.prototype.redSqr = function redSqr() {
          assert3(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN2.prototype.redISqr = function redISqr() {
          assert3(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN2.prototype.redSqrt = function redSqrt() {
          assert3(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN2.prototype.redInvm = function redInvm() {
          assert3(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN2.prototype.redNeg = function redNeg() {
          assert3(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN2.prototype.redPow = function redPow(num) {
          assert3(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN2(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN2(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN2(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split2(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split2(input, output) {
          var mask2 = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask2;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask2) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN2._prime = function prime(name) {
          if (primes[name]) return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN2._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert3(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert3(a.negative === 0, "red works only with positives");
          assert3(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert3((a.negative | b.negative) === 0, "red works only with positives");
          assert3(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime) return this.prime.ireduce(a)._forceRed(this);
          move(a, a.umod(this.m)._forceRed(this));
          return a;
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add2(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero()) return a.clone();
          var mod3 = this.m.andln(3);
          assert3(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN2(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert3(!q.isZero());
          var one = new BN2(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN2(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert3(i < m);
            var b = this.pow(c, new BN2(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero()) return new BN2(1).toRed(this);
          if (num.cmpn(1) === 0) return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN2(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN2.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN2(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero()) return new BN2(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    }
  });

  // node_modules/safe-buffer/index.js
  var require_safe_buffer = __commonJS({
    "node_modules/safe-buffer/index.js"(exports, module) {
      var buffer = require_buffer();
      var Buffer5 = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer5.from && Buffer5.alloc && Buffer5.allocUnsafe && Buffer5.allocUnsafeSlow) {
        module.exports = buffer;
      } else {
        copyProps(buffer, exports);
        exports.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer5(arg, encodingOrOffset, length);
      }
      SafeBuffer.prototype = Object.create(Buffer5.prototype);
      copyProps(Buffer5, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer5(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer5(size);
        if (fill !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer5(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    }
  });

  // node_modules/base-x/src/index.js
  var require_src = __commonJS({
    "node_modules/base-x/src/index.js"(exports, module) {
      "use strict";
      var _Buffer = require_safe_buffer().Buffer;
      function base(ALPHABET) {
        if (ALPHABET.length >= 255) {
          throw new TypeError("Alphabet too long");
        }
        var BASE_MAP = new Uint8Array(256);
        for (var j = 0; j < BASE_MAP.length; j++) {
          BASE_MAP[j] = 255;
        }
        for (var i = 0; i < ALPHABET.length; i++) {
          var x = ALPHABET.charAt(i);
          var xc = x.charCodeAt(0);
          if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + " is ambiguous");
          }
          BASE_MAP[xc] = i;
        }
        var BASE2 = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        var FACTOR = Math.log(BASE2) / Math.log(256);
        var iFACTOR = Math.log(256) / Math.log(BASE2);
        function encode(source) {
          if (Array.isArray(source) || source instanceof Uint8Array) {
            source = _Buffer.from(source);
          }
          if (!_Buffer.isBuffer(source)) {
            throw new TypeError("Expected Buffer");
          }
          if (source.length === 0) {
            return "";
          }
          var zeroes = 0;
          var length = 0;
          var pbegin = 0;
          var pend = source.length;
          while (pbegin !== pend && source[pbegin] === 0) {
            pbegin++;
            zeroes++;
          }
          var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
          var b58 = new Uint8Array(size);
          while (pbegin !== pend) {
            var carry = source[pbegin];
            var i2 = 0;
            for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
              carry += 256 * b58[it1] >>> 0;
              b58[it1] = carry % BASE2 >>> 0;
              carry = carry / BASE2 >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i2;
            pbegin++;
          }
          var it2 = size - length;
          while (it2 !== size && b58[it2] === 0) {
            it2++;
          }
          var str = LEADER.repeat(zeroes);
          for (; it2 < size; ++it2) {
            str += ALPHABET.charAt(b58[it2]);
          }
          return str;
        }
        function decodeUnsafe(source) {
          if (typeof source !== "string") {
            throw new TypeError("Expected String");
          }
          if (source.length === 0) {
            return _Buffer.alloc(0);
          }
          var psz = 0;
          var zeroes = 0;
          var length = 0;
          while (source[psz] === LEADER) {
            zeroes++;
            psz++;
          }
          var size = (source.length - psz) * FACTOR + 1 >>> 0;
          var b256 = new Uint8Array(size);
          while (psz < source.length) {
            var charCode = source.charCodeAt(psz);
            if (charCode > 255) {
              return;
            }
            var carry = BASE_MAP[charCode];
            if (carry === 255) {
              return;
            }
            var i2 = 0;
            for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
              carry += BASE2 * b256[it3] >>> 0;
              b256[it3] = carry % 256 >>> 0;
              carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i2;
            psz++;
          }
          var it4 = size - length;
          while (it4 !== size && b256[it4] === 0) {
            it4++;
          }
          var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
          vch.fill(0, 0, zeroes);
          var j2 = zeroes;
          while (it4 !== size) {
            vch[j2++] = b256[it4++];
          }
          return vch;
        }
        function decode(string2) {
          var buffer = decodeUnsafe(string2);
          if (buffer) {
            return buffer;
          }
          throw new Error("Non-base" + BASE2 + " character");
        }
        return {
          encode,
          decodeUnsafe,
          decode
        };
      }
      module.exports = base;
    }
  });

  // node_modules/bs58/index.js
  var require_bs58 = __commonJS({
    "node_modules/bs58/index.js"(exports, module) {
      var basex = require_src();
      var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      module.exports = basex(ALPHABET);
    }
  });

  // node_modules/text-encoding-utf-8/lib/encoding.lib.js
  var require_encoding_lib = __commonJS({
    "node_modules/text-encoding-utf-8/lib/encoding.lib.js"(exports) {
      "use strict";
      function inRange2(a, min, max) {
        return min <= a && a <= max;
      }
      function ToDictionary(o) {
        if (o === void 0) return {};
        if (o === Object(o)) return o;
        throw TypeError("Could not convert argument to dictionary");
      }
      function stringToCodePoints(string2) {
        var s = String(string2);
        var n = s.length;
        var i = 0;
        var u = [];
        while (i < n) {
          var c = s.charCodeAt(i);
          if (c < 55296 || c > 57343) {
            u.push(c);
          } else if (56320 <= c && c <= 57343) {
            u.push(65533);
          } else if (55296 <= c && c <= 56319) {
            if (i === n - 1) {
              u.push(65533);
            } else {
              var d = string2.charCodeAt(i + 1);
              if (56320 <= d && d <= 57343) {
                var a = c & 1023;
                var b = d & 1023;
                u.push(65536 + (a << 10) + b);
                i += 1;
              } else {
                u.push(65533);
              }
            }
          }
          i += 1;
        }
        return u;
      }
      function codePointsToString(code_points) {
        var s = "";
        for (var i = 0; i < code_points.length; ++i) {
          var cp = code_points[i];
          if (cp <= 65535) {
            s += String.fromCharCode(cp);
          } else {
            cp -= 65536;
            s += String.fromCharCode(
              (cp >> 10) + 55296,
              (cp & 1023) + 56320
            );
          }
        }
        return s;
      }
      var end_of_stream = -1;
      function Stream(tokens) {
        this.tokens = [].slice.call(tokens);
      }
      Stream.prototype = {
        /**
         * @return {boolean} True if end-of-stream has been hit.
         */
        endOfStream: function() {
          return !this.tokens.length;
        },
        /**
         * When a token is read from a stream, the first token in the
         * stream must be returned and subsequently removed, and
         * end-of-stream must be returned otherwise.
         *
         * @return {number} Get the next token from the stream, or
         * end_of_stream.
         */
        read: function() {
          if (!this.tokens.length)
            return end_of_stream;
          return this.tokens.shift();
        },
        /**
         * When one or more tokens are prepended to a stream, those tokens
         * must be inserted, in given order, before the first token in the
         * stream.
         *
         * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
         */
        prepend: function(token) {
          if (Array.isArray(token)) {
            var tokens = (
              /**@type {!Array.<number>}*/
              token
            );
            while (tokens.length)
              this.tokens.unshift(tokens.pop());
          } else {
            this.tokens.unshift(token);
          }
        },
        /**
         * When one or more tokens are pushed to a stream, those tokens
         * must be inserted, in given order, after the last token in the
         * stream.
         *
         * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
         */
        push: function(token) {
          if (Array.isArray(token)) {
            var tokens = (
              /**@type {!Array.<number>}*/
              token
            );
            while (tokens.length)
              this.tokens.push(tokens.shift());
          } else {
            this.tokens.push(token);
          }
        }
      };
      var finished = -1;
      function decoderError(fatal, opt_code_point) {
        if (fatal)
          throw TypeError("Decoder error");
        return opt_code_point || 65533;
      }
      var DEFAULT_ENCODING = "utf-8";
      function TextDecoder2(encoding, options) {
        if (!(this instanceof TextDecoder2)) {
          return new TextDecoder2(encoding, options);
        }
        encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
        if (encoding !== DEFAULT_ENCODING) {
          throw new Error("Encoding not supported. Only utf-8 is supported");
        }
        options = ToDictionary(options);
        this._streaming = false;
        this._BOMseen = false;
        this._decoder = null;
        this._fatal = Boolean(options["fatal"]);
        this._ignoreBOM = Boolean(options["ignoreBOM"]);
        Object.defineProperty(this, "encoding", { value: "utf-8" });
        Object.defineProperty(this, "fatal", { value: this._fatal });
        Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
      }
      TextDecoder2.prototype = {
        /**
         * @param {ArrayBufferView=} input The buffer of bytes to decode.
         * @param {Object=} options
         * @return {string} The decoded string.
         */
        decode: function decode(input, options) {
          var bytes;
          if (typeof input === "object" && input instanceof ArrayBuffer) {
            bytes = new Uint8Array(input);
          } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
            bytes = new Uint8Array(
              input.buffer,
              input.byteOffset,
              input.byteLength
            );
          } else {
            bytes = new Uint8Array(0);
          }
          options = ToDictionary(options);
          if (!this._streaming) {
            this._decoder = new UTF8Decoder({ fatal: this._fatal });
            this._BOMseen = false;
          }
          this._streaming = Boolean(options["stream"]);
          var input_stream = new Stream(bytes);
          var code_points = [];
          var result;
          while (!input_stream.endOfStream()) {
            result = this._decoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (result === null)
              continue;
            if (Array.isArray(result))
              code_points.push.apply(
                code_points,
                /**@type {!Array.<number>}*/
                result
              );
            else
              code_points.push(result);
          }
          if (!this._streaming) {
            do {
              result = this._decoder.handler(input_stream, input_stream.read());
              if (result === finished)
                break;
              if (result === null)
                continue;
              if (Array.isArray(result))
                code_points.push.apply(
                  code_points,
                  /**@type {!Array.<number>}*/
                  result
                );
              else
                code_points.push(result);
            } while (!input_stream.endOfStream());
            this._decoder = null;
          }
          if (code_points.length) {
            if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
              if (code_points[0] === 65279) {
                this._BOMseen = true;
                code_points.shift();
              } else {
                this._BOMseen = true;
              }
            }
          }
          return codePointsToString(code_points);
        }
      };
      function TextEncoder2(encoding, options) {
        if (!(this instanceof TextEncoder2))
          return new TextEncoder2(encoding, options);
        encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
        if (encoding !== DEFAULT_ENCODING) {
          throw new Error("Encoding not supported. Only utf-8 is supported");
        }
        options = ToDictionary(options);
        this._streaming = false;
        this._encoder = null;
        this._options = { fatal: Boolean(options["fatal"]) };
        Object.defineProperty(this, "encoding", { value: "utf-8" });
      }
      TextEncoder2.prototype = {
        /**
         * @param {string=} opt_string The string to encode.
         * @param {Object=} options
         * @return {Uint8Array} Encoded bytes, as a Uint8Array.
         */
        encode: function encode(opt_string, options) {
          opt_string = opt_string ? String(opt_string) : "";
          options = ToDictionary(options);
          if (!this._streaming)
            this._encoder = new UTF8Encoder(this._options);
          this._streaming = Boolean(options["stream"]);
          var bytes = [];
          var input_stream = new Stream(stringToCodePoints(opt_string));
          var result;
          while (!input_stream.endOfStream()) {
            result = this._encoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (Array.isArray(result))
              bytes.push.apply(
                bytes,
                /**@type {!Array.<number>}*/
                result
              );
            else
              bytes.push(result);
          }
          if (!this._streaming) {
            while (true) {
              result = this._encoder.handler(input_stream, input_stream.read());
              if (result === finished)
                break;
              if (Array.isArray(result))
                bytes.push.apply(
                  bytes,
                  /**@type {!Array.<number>}*/
                  result
                );
              else
                bytes.push(result);
            }
            this._encoder = null;
          }
          return new Uint8Array(bytes);
        }
      };
      function UTF8Decoder(options) {
        var fatal = options.fatal;
        var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream && utf8_bytes_needed !== 0) {
            utf8_bytes_needed = 0;
            return decoderError(fatal);
          }
          if (bite === end_of_stream)
            return finished;
          if (utf8_bytes_needed === 0) {
            if (inRange2(bite, 0, 127)) {
              return bite;
            }
            if (inRange2(bite, 194, 223)) {
              utf8_bytes_needed = 1;
              utf8_code_point = bite - 192;
            } else if (inRange2(bite, 224, 239)) {
              if (bite === 224)
                utf8_lower_boundary = 160;
              if (bite === 237)
                utf8_upper_boundary = 159;
              utf8_bytes_needed = 2;
              utf8_code_point = bite - 224;
            } else if (inRange2(bite, 240, 244)) {
              if (bite === 240)
                utf8_lower_boundary = 144;
              if (bite === 244)
                utf8_upper_boundary = 143;
              utf8_bytes_needed = 3;
              utf8_code_point = bite - 240;
            } else {
              return decoderError(fatal);
            }
            utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
            return null;
          }
          if (!inRange2(bite, utf8_lower_boundary, utf8_upper_boundary)) {
            utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
            utf8_lower_boundary = 128;
            utf8_upper_boundary = 191;
            stream.prepend(bite);
            return decoderError(fatal);
          }
          utf8_lower_boundary = 128;
          utf8_upper_boundary = 191;
          utf8_bytes_seen += 1;
          utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
          if (utf8_bytes_seen !== utf8_bytes_needed)
            return null;
          var code_point = utf8_code_point;
          utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
          return code_point;
        };
      }
      function UTF8Encoder(options) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished;
          if (inRange2(code_point, 0, 127))
            return code_point;
          var count, offset2;
          if (inRange2(code_point, 128, 2047)) {
            count = 1;
            offset2 = 192;
          } else if (inRange2(code_point, 2048, 65535)) {
            count = 2;
            offset2 = 224;
          } else if (inRange2(code_point, 65536, 1114111)) {
            count = 3;
            offset2 = 240;
          }
          var bytes = [(code_point >> 6 * count) + offset2];
          while (count > 0) {
            var temp = code_point >> 6 * (count - 1);
            bytes.push(128 | temp & 63);
            count -= 1;
          }
          return bytes;
        };
      }
      exports.TextEncoder = TextEncoder2;
      exports.TextDecoder = TextDecoder2;
    }
  });

  // node_modules/borsh/lib/index.js
  var require_lib = __commonJS({
    "node_modules/borsh/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __importStar = exports && exports.__importStar || function(mod2) {
        if (mod2 && mod2.__esModule) return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k in mod2) if (k !== "default" && Object.hasOwnProperty.call(mod2, k)) __createBinding(result, mod2, k);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      var __importDefault = exports && exports.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;
      var bn_js_1 = __importDefault(require_bn());
      var bs58_1 = __importDefault(require_bs58());
      var encoding = __importStar(require_encoding_lib());
      var ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
      var textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
      function baseEncode(value) {
        if (typeof value === "string") {
          value = Buffer.from(value, "utf8");
        }
        return bs58_1.default.encode(Buffer.from(value));
      }
      exports.baseEncode = baseEncode;
      function baseDecode(value) {
        return Buffer.from(bs58_1.default.decode(value));
      }
      exports.baseDecode = baseDecode;
      var INITIAL_LENGTH = 1024;
      var BorshError = class extends Error {
        constructor(message) {
          super(message);
          this.fieldPath = [];
          this.originalMessage = message;
        }
        addToFieldPath(fieldName) {
          this.fieldPath.splice(0, 0, fieldName);
          this.message = this.originalMessage + ": " + this.fieldPath.join(".");
        }
      };
      exports.BorshError = BorshError;
      var BinaryWriter = class {
        constructor() {
          this.buf = Buffer.alloc(INITIAL_LENGTH);
          this.length = 0;
        }
        maybeResize() {
          if (this.buf.length < 16 + this.length) {
            this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
          }
        }
        writeU8(value) {
          this.maybeResize();
          this.buf.writeUInt8(value, this.length);
          this.length += 1;
        }
        writeU16(value) {
          this.maybeResize();
          this.buf.writeUInt16LE(value, this.length);
          this.length += 2;
        }
        writeU32(value) {
          this.maybeResize();
          this.buf.writeUInt32LE(value, this.length);
          this.length += 4;
        }
        writeU64(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
        }
        writeU128(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
        }
        writeU256(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
        }
        writeU512(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
        }
        writeBuffer(buffer) {
          this.buf = Buffer.concat([
            Buffer.from(this.buf.subarray(0, this.length)),
            buffer,
            Buffer.alloc(INITIAL_LENGTH)
          ]);
          this.length += buffer.length;
        }
        writeString(str) {
          this.maybeResize();
          const b = Buffer.from(str, "utf8");
          this.writeU32(b.length);
          this.writeBuffer(b);
        }
        writeFixedArray(array2) {
          this.writeBuffer(Buffer.from(array2));
        }
        writeArray(array2, fn) {
          this.maybeResize();
          this.writeU32(array2.length);
          for (const elem of array2) {
            this.maybeResize();
            fn(elem);
          }
        }
        toArray() {
          return this.buf.subarray(0, this.length);
        }
      };
      exports.BinaryWriter = BinaryWriter;
      function handlingRangeError(target, propertyKey, propertyDescriptor) {
        const originalMethod = propertyDescriptor.value;
        propertyDescriptor.value = function(...args) {
          try {
            return originalMethod.apply(this, args);
          } catch (e) {
            if (e instanceof RangeError) {
              const code = e.code;
              if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code) >= 0) {
                throw new BorshError("Reached the end of buffer when deserializing");
              }
            }
            throw e;
          }
        };
      }
      var BinaryReader = class {
        constructor(buf) {
          this.buf = buf;
          this.offset = 0;
        }
        readU8() {
          const value = this.buf.readUInt8(this.offset);
          this.offset += 1;
          return value;
        }
        readU16() {
          const value = this.buf.readUInt16LE(this.offset);
          this.offset += 2;
          return value;
        }
        readU32() {
          const value = this.buf.readUInt32LE(this.offset);
          this.offset += 4;
          return value;
        }
        readU64() {
          const buf = this.readBuffer(8);
          return new bn_js_1.default(buf, "le");
        }
        readU128() {
          const buf = this.readBuffer(16);
          return new bn_js_1.default(buf, "le");
        }
        readU256() {
          const buf = this.readBuffer(32);
          return new bn_js_1.default(buf, "le");
        }
        readU512() {
          const buf = this.readBuffer(64);
          return new bn_js_1.default(buf, "le");
        }
        readBuffer(len) {
          if (this.offset + len > this.buf.length) {
            throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
          }
          const result = this.buf.slice(this.offset, this.offset + len);
          this.offset += len;
          return result;
        }
        readString() {
          const len = this.readU32();
          const buf = this.readBuffer(len);
          try {
            return textDecoder.decode(buf);
          } catch (e) {
            throw new BorshError(`Error decoding UTF-8 string: ${e}`);
          }
        }
        readFixedArray(len) {
          return new Uint8Array(this.readBuffer(len));
        }
        readArray(fn) {
          const len = this.readU32();
          const result = Array();
          for (let i = 0; i < len; ++i) {
            result.push(fn());
          }
          return result;
        }
      };
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU8", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU16", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU32", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU64", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU128", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU256", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU512", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readString", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readFixedArray", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readArray", null);
      exports.BinaryReader = BinaryReader;
      function capitalizeFirstLetter(string2) {
        return string2.charAt(0).toUpperCase() + string2.slice(1);
      }
      function serializeField(schema, fieldName, value, fieldType, writer) {
        try {
          if (typeof fieldType === "string") {
            writer[`write${capitalizeFirstLetter(fieldType)}`](value);
          } else if (fieldType instanceof Array) {
            if (typeof fieldType[0] === "number") {
              if (value.length !== fieldType[0]) {
                throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
              }
              writer.writeFixedArray(value);
            } else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
              if (value.length !== fieldType[1]) {
                throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
              }
              for (let i = 0; i < fieldType[1]; i++) {
                serializeField(schema, null, value[i], fieldType[0], writer);
              }
            } else {
              writer.writeArray(value, (item) => {
                serializeField(schema, fieldName, item, fieldType[0], writer);
              });
            }
          } else if (fieldType.kind !== void 0) {
            switch (fieldType.kind) {
              case "option": {
                if (value === null || value === void 0) {
                  writer.writeU8(0);
                } else {
                  writer.writeU8(1);
                  serializeField(schema, fieldName, value, fieldType.type, writer);
                }
                break;
              }
              case "map": {
                writer.writeU32(value.size);
                value.forEach((val, key) => {
                  serializeField(schema, fieldName, key, fieldType.key, writer);
                  serializeField(schema, fieldName, val, fieldType.value, writer);
                });
                break;
              }
              default:
                throw new BorshError(`FieldType ${fieldType} unrecognized`);
            }
          } else {
            serializeStruct(schema, value, writer);
          }
        } catch (error) {
          if (error instanceof BorshError) {
            error.addToFieldPath(fieldName);
          }
          throw error;
        }
      }
      function serializeStruct(schema, obj, writer) {
        if (typeof obj.borshSerialize === "function") {
          obj.borshSerialize(writer);
          return;
        }
        const structSchema = schema.get(obj.constructor);
        if (!structSchema) {
          throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
        }
        if (structSchema.kind === "struct") {
          structSchema.fields.map(([fieldName, fieldType]) => {
            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
          });
        } else if (structSchema.kind === "enum") {
          const name = obj[structSchema.field];
          for (let idx = 0; idx < structSchema.values.length; ++idx) {
            const [fieldName, fieldType] = structSchema.values[idx];
            if (fieldName === name) {
              writer.writeU8(idx);
              serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
              break;
            }
          }
        } else {
          throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
        }
      }
      function serialize2(schema, obj, Writer = BinaryWriter) {
        const writer = new Writer();
        serializeStruct(schema, obj, writer);
        return writer.toArray();
      }
      exports.serialize = serialize2;
      function deserializeField(schema, fieldName, fieldType, reader) {
        try {
          if (typeof fieldType === "string") {
            return reader[`read${capitalizeFirstLetter(fieldType)}`]();
          }
          if (fieldType instanceof Array) {
            if (typeof fieldType[0] === "number") {
              return reader.readFixedArray(fieldType[0]);
            } else if (typeof fieldType[1] === "number") {
              const arr = [];
              for (let i = 0; i < fieldType[1]; i++) {
                arr.push(deserializeField(schema, null, fieldType[0], reader));
              }
              return arr;
            } else {
              return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
            }
          }
          if (fieldType.kind === "option") {
            const option = reader.readU8();
            if (option) {
              return deserializeField(schema, fieldName, fieldType.type, reader);
            }
            return void 0;
          }
          if (fieldType.kind === "map") {
            let map = /* @__PURE__ */ new Map();
            const length = reader.readU32();
            for (let i = 0; i < length; i++) {
              const key = deserializeField(schema, fieldName, fieldType.key, reader);
              const val = deserializeField(schema, fieldName, fieldType.value, reader);
              map.set(key, val);
            }
            return map;
          }
          return deserializeStruct(schema, fieldType, reader);
        } catch (error) {
          if (error instanceof BorshError) {
            error.addToFieldPath(fieldName);
          }
          throw error;
        }
      }
      function deserializeStruct(schema, classType, reader) {
        if (typeof classType.borshDeserialize === "function") {
          return classType.borshDeserialize(reader);
        }
        const structSchema = schema.get(classType);
        if (!structSchema) {
          throw new BorshError(`Class ${classType.name} is missing in schema`);
        }
        if (structSchema.kind === "struct") {
          const result = {};
          for (const [fieldName, fieldType] of schema.get(classType).fields) {
            result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
          }
          return new classType(result);
        }
        if (structSchema.kind === "enum") {
          const idx = reader.readU8();
          if (idx >= structSchema.values.length) {
            throw new BorshError(`Enum index: ${idx} is out of range`);
          }
          const [fieldName, fieldType] = structSchema.values[idx];
          const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
          return new classType({ [fieldName]: fieldValue });
        }
        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
      }
      function deserialize2(schema, classType, buffer, Reader = BinaryReader) {
        const reader = new Reader(buffer);
        const result = deserializeStruct(schema, classType, reader);
        if (reader.offset < buffer.length) {
          throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);
        }
        return result;
      }
      exports.deserialize = deserialize2;
      function deserializeUnchecked2(schema, classType, buffer, Reader = BinaryReader) {
        const reader = new Reader(buffer);
        return deserializeStruct(schema, classType, reader);
      }
      exports.deserializeUnchecked = deserializeUnchecked2;
    }
  });

  // node_modules/@solana/buffer-layout/lib/Layout.js
  var require_Layout = __commonJS({
    "node_modules/@solana/buffer-layout/lib/Layout.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;
      exports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;
      var buffer_1 = require_buffer();
      function checkUint8Array(b) {
        if (!(b instanceof Uint8Array)) {
          throw new TypeError("b must be a Uint8Array");
        }
      }
      exports.checkUint8Array = checkUint8Array;
      function uint8ArrayToBuffer(b) {
        checkUint8Array(b);
        return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);
      }
      exports.uint8ArrayToBuffer = uint8ArrayToBuffer;
      var Layout = class {
        constructor(span, property) {
          if (!Number.isInteger(span)) {
            throw new TypeError("span must be an integer");
          }
          this.span = span;
          this.property = property;
        }
        /** Function to create an Object into which decoded properties will
         * be written.
         *
         * Used only for layouts that {@link Layout#decode|decode} to Object
         * instances, which means:
         * * {@link Structure}
         * * {@link Union}
         * * {@link VariantLayout}
         * * {@link BitStructure}
         *
         * If left undefined the JavaScript representation of these layouts
         * will be Object instances.
         *
         * See {@link bindConstructorLayout}.
         */
        makeDestinationObject() {
          return {};
        }
        /**
         * Calculate the span of a specific instance of a layout.
         *
         * @param {Uint8Array} b - the buffer that contains an encoded instance.
         *
         * @param {Number} [offset] - the offset at which the encoded instance
         * starts.  If absent a zero offset is inferred.
         *
         * @return {Number} - the number of bytes covered by the layout
         * instance.  If this method is not overridden in a subclass the
         * definition-time constant {@link Layout#span|span} will be
         * returned.
         *
         * @throws {RangeError} - if the length of the value cannot be
         * determined.
         */
        getSpan(b, offset2) {
          if (0 > this.span) {
            throw new RangeError("indeterminate span");
          }
          return this.span;
        }
        /**
         * Replicate the layout using a new property.
         *
         * This function must be used to get a structurally-equivalent layout
         * with a different name since all {@link Layout} instances are
         * immutable.
         *
         * **NOTE** This is a shallow copy.  All fields except {@link
         * Layout#property|property} are strictly equal to the origin layout.
         *
         * @param {String} property - the value for {@link
         * Layout#property|property} in the replica.
         *
         * @returns {Layout} - the copy with {@link Layout#property|property}
         * set to `property`.
         */
        replicate(property) {
          const rv = Object.create(this.constructor.prototype);
          Object.assign(rv, this);
          rv.property = property;
          return rv;
        }
        /**
         * Create an object from layout properties and an array of values.
         *
         * **NOTE** This function returns `undefined` if invoked on a layout
         * that does not return its value as an Object.  Objects are
         * returned for things that are a {@link Structure}, which includes
         * {@link VariantLayout|variant layouts} if they are structures, and
         * excludes {@link Union}s.  If you want this feature for a union
         * you must use {@link Union.getVariant|getVariant} to select the
         * desired layout.
         *
         * @param {Array} values - an array of values that correspond to the
         * default order for properties.  As with {@link Layout#decode|decode}
         * layout elements that have no property name are skipped when
         * iterating over the array values.  Only the top-level properties are
         * assigned; arguments are not assigned to properties of contained
         * layouts.  Any unused values are ignored.
         *
         * @return {(Object|undefined)}
         */
        fromArray(values) {
          return void 0;
        }
      };
      exports.Layout = Layout;
      function nameWithProperty(name, lo) {
        if (lo.property) {
          return name + "[" + lo.property + "]";
        }
        return name;
      }
      exports.nameWithProperty = nameWithProperty;
      function bindConstructorLayout(Class, layout) {
        if ("function" !== typeof Class) {
          throw new TypeError("Class must be constructor");
        }
        if (Object.prototype.hasOwnProperty.call(Class, "layout_")) {
          throw new Error("Class is already bound to a layout");
        }
        if (!(layout && layout instanceof Layout)) {
          throw new TypeError("layout must be a Layout");
        }
        if (Object.prototype.hasOwnProperty.call(layout, "boundConstructor_")) {
          throw new Error("layout is already bound to a constructor");
        }
        Class.layout_ = layout;
        layout.boundConstructor_ = Class;
        layout.makeDestinationObject = () => new Class();
        Object.defineProperty(Class.prototype, "encode", {
          value(b, offset2) {
            return layout.encode(this, b, offset2);
          },
          writable: true
        });
        Object.defineProperty(Class, "decode", {
          value(b, offset2) {
            return layout.decode(b, offset2);
          },
          writable: true
        });
      }
      exports.bindConstructorLayout = bindConstructorLayout;
      var ExternalLayout = class extends Layout {
        /**
         * Return `true` iff the external layout decodes to an unsigned
         * integer layout.
         *
         * In that case it can be used as the source of {@link
         * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
         * or as {@link UnionLayoutDiscriminator#layout|external union
         * discriminators}.
         *
         * @abstract
         */
        isCount() {
          throw new Error("ExternalLayout is abstract");
        }
      };
      exports.ExternalLayout = ExternalLayout;
      var GreedyCount = class extends ExternalLayout {
        constructor(elementSpan = 1, property) {
          if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
            throw new TypeError("elementSpan must be a (positive) integer");
          }
          super(-1, property);
          this.elementSpan = elementSpan;
        }
        /** @override */
        isCount() {
          return true;
        }
        /** @override */
        decode(b, offset2 = 0) {
          checkUint8Array(b);
          const rem = b.length - offset2;
          return Math.floor(rem / this.elementSpan);
        }
        /** @override */
        encode(src, b, offset2) {
          return 0;
        }
      };
      exports.GreedyCount = GreedyCount;
      var OffsetLayout = class extends ExternalLayout {
        constructor(layout, offset2 = 0, property) {
          if (!(layout instanceof Layout)) {
            throw new TypeError("layout must be a Layout");
          }
          if (!Number.isInteger(offset2)) {
            throw new TypeError("offset must be integer or undefined");
          }
          super(layout.span, property || layout.property);
          this.layout = layout;
          this.offset = offset2;
        }
        /** @override */
        isCount() {
          return this.layout instanceof UInt || this.layout instanceof UIntBE;
        }
        /** @override */
        decode(b, offset2 = 0) {
          return this.layout.decode(b, offset2 + this.offset);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          return this.layout.encode(src, b, offset2 + this.offset);
        }
      };
      exports.OffsetLayout = OffsetLayout;
      var UInt = class extends Layout {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readUIntLE(offset2, this.span);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeUIntLE(src, offset2, this.span);
          return this.span;
        }
      };
      exports.UInt = UInt;
      var UIntBE = class extends Layout {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readUIntBE(offset2, this.span);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeUIntBE(src, offset2, this.span);
          return this.span;
        }
      };
      exports.UIntBE = UIntBE;
      var Int = class extends Layout {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readIntLE(offset2, this.span);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeIntLE(src, offset2, this.span);
          return this.span;
        }
      };
      exports.Int = Int;
      var IntBE = class extends Layout {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readIntBE(offset2, this.span);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeIntBE(src, offset2, this.span);
          return this.span;
        }
      };
      exports.IntBE = IntBE;
      var V2E32 = Math.pow(2, 32);
      function divmodInt64(src) {
        const hi32 = Math.floor(src / V2E32);
        const lo32 = src - hi32 * V2E32;
        return { hi32, lo32 };
      }
      function roundedInt64(hi32, lo32) {
        return hi32 * V2E32 + lo32;
      }
      var NearUInt64 = class extends Layout {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          const buffer = uint8ArrayToBuffer(b);
          const lo32 = buffer.readUInt32LE(offset2);
          const hi32 = buffer.readUInt32LE(offset2 + 4);
          return roundedInt64(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          const split2 = divmodInt64(src);
          const buffer = uint8ArrayToBuffer(b);
          buffer.writeUInt32LE(split2.lo32, offset2);
          buffer.writeUInt32LE(split2.hi32, offset2 + 4);
          return 8;
        }
      };
      exports.NearUInt64 = NearUInt64;
      var NearUInt64BE = class extends Layout {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          const buffer = uint8ArrayToBuffer(b);
          const hi32 = buffer.readUInt32BE(offset2);
          const lo32 = buffer.readUInt32BE(offset2 + 4);
          return roundedInt64(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          const split2 = divmodInt64(src);
          const buffer = uint8ArrayToBuffer(b);
          buffer.writeUInt32BE(split2.hi32, offset2);
          buffer.writeUInt32BE(split2.lo32, offset2 + 4);
          return 8;
        }
      };
      exports.NearUInt64BE = NearUInt64BE;
      var NearInt64 = class extends Layout {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          const buffer = uint8ArrayToBuffer(b);
          const lo32 = buffer.readUInt32LE(offset2);
          const hi32 = buffer.readInt32LE(offset2 + 4);
          return roundedInt64(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          const split2 = divmodInt64(src);
          const buffer = uint8ArrayToBuffer(b);
          buffer.writeUInt32LE(split2.lo32, offset2);
          buffer.writeInt32LE(split2.hi32, offset2 + 4);
          return 8;
        }
      };
      exports.NearInt64 = NearInt64;
      var NearInt64BE = class extends Layout {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          const buffer = uint8ArrayToBuffer(b);
          const hi32 = buffer.readInt32BE(offset2);
          const lo32 = buffer.readUInt32BE(offset2 + 4);
          return roundedInt64(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          const split2 = divmodInt64(src);
          const buffer = uint8ArrayToBuffer(b);
          buffer.writeInt32BE(split2.hi32, offset2);
          buffer.writeUInt32BE(split2.lo32, offset2 + 4);
          return 8;
        }
      };
      exports.NearInt64BE = NearInt64BE;
      var Float = class extends Layout {
        constructor(property) {
          super(4, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readFloatLE(offset2);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeFloatLE(src, offset2);
          return 4;
        }
      };
      exports.Float = Float;
      var FloatBE = class extends Layout {
        constructor(property) {
          super(4, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readFloatBE(offset2);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeFloatBE(src, offset2);
          return 4;
        }
      };
      exports.FloatBE = FloatBE;
      var Double = class extends Layout {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readDoubleLE(offset2);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeDoubleLE(src, offset2);
          return 8;
        }
      };
      exports.Double = Double;
      var DoubleBE = class extends Layout {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readDoubleBE(offset2);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeDoubleBE(src, offset2);
          return 8;
        }
      };
      exports.DoubleBE = DoubleBE;
      var Sequence = class extends Layout {
        constructor(elementLayout, count, property) {
          if (!(elementLayout instanceof Layout)) {
            throw new TypeError("elementLayout must be a Layout");
          }
          if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {
            throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
          }
          let span = -1;
          if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {
            span = count * elementLayout.span;
          }
          super(span, property);
          this.elementLayout = elementLayout;
          this.count = count;
        }
        /** @override */
        getSpan(b, offset2 = 0) {
          if (0 <= this.span) {
            return this.span;
          }
          let span = 0;
          let count = this.count;
          if (count instanceof ExternalLayout) {
            count = count.decode(b, offset2);
          }
          if (0 < this.elementLayout.span) {
            span = count * this.elementLayout.span;
          } else {
            let idx = 0;
            while (idx < count) {
              span += this.elementLayout.getSpan(b, offset2 + span);
              ++idx;
            }
          }
          return span;
        }
        /** @override */
        decode(b, offset2 = 0) {
          const rv = [];
          let i = 0;
          let count = this.count;
          if (count instanceof ExternalLayout) {
            count = count.decode(b, offset2);
          }
          while (i < count) {
            rv.push(this.elementLayout.decode(b, offset2));
            offset2 += this.elementLayout.getSpan(b, offset2);
            i += 1;
          }
          return rv;
        }
        /** Implement {@link Layout#encode|encode} for {@link Sequence}.
         *
         * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
         * the unused space in the buffer is left unchanged.  If `src` is
         * longer than {@link Sequence#count|count} the unneeded elements are
         * ignored.
         *
         * **NOTE** If {@link Layout#count|count} is an instance of {@link
         * ExternalLayout} then the length of `src` will be encoded as the
         * count after `src` is encoded. */
        encode(src, b, offset2 = 0) {
          const elo = this.elementLayout;
          const span = src.reduce((span2, v) => {
            return span2 + elo.encode(v, b, offset2 + span2);
          }, 0);
          if (this.count instanceof ExternalLayout) {
            this.count.encode(src.length, b, offset2);
          }
          return span;
        }
      };
      exports.Sequence = Sequence;
      var Structure = class extends Layout {
        constructor(fields, property, decodePrefixes) {
          if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout, true))) {
            throw new TypeError("fields must be array of Layout instances");
          }
          if ("boolean" === typeof property && void 0 === decodePrefixes) {
            decodePrefixes = property;
            property = void 0;
          }
          for (const fd of fields) {
            if (0 > fd.span && void 0 === fd.property) {
              throw new Error("fields cannot contain unnamed variable-length layout");
            }
          }
          let span = -1;
          try {
            span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
          } catch (e) {
          }
          super(span, property);
          this.fields = fields;
          this.decodePrefixes = !!decodePrefixes;
        }
        /** @override */
        getSpan(b, offset2 = 0) {
          if (0 <= this.span) {
            return this.span;
          }
          let span = 0;
          try {
            span = this.fields.reduce((span2, fd) => {
              const fsp = fd.getSpan(b, offset2);
              offset2 += fsp;
              return span2 + fsp;
            }, 0);
          } catch (e) {
            throw new RangeError("indeterminate span");
          }
          return span;
        }
        /** @override */
        decode(b, offset2 = 0) {
          checkUint8Array(b);
          const dest = this.makeDestinationObject();
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              dest[fd.property] = fd.decode(b, offset2);
            }
            offset2 += fd.getSpan(b, offset2);
            if (this.decodePrefixes && b.length === offset2) {
              break;
            }
          }
          return dest;
        }
        /** Implement {@link Layout#encode|encode} for {@link Structure}.
         *
         * If `src` is missing a property for a member with a defined {@link
         * Layout#property|property} the corresponding region of the buffer is
         * left unmodified. */
        encode(src, b, offset2 = 0) {
          const firstOffset = offset2;
          let lastOffset = 0;
          let lastWrote = 0;
          for (const fd of this.fields) {
            let span = fd.span;
            lastWrote = 0 < span ? span : 0;
            if (void 0 !== fd.property) {
              const fv = src[fd.property];
              if (void 0 !== fv) {
                lastWrote = fd.encode(fv, b, offset2);
                if (0 > span) {
                  span = fd.getSpan(b, offset2);
                }
              }
            }
            lastOffset = offset2;
            offset2 += span;
          }
          return lastOffset + lastWrote - firstOffset;
        }
        /** @override */
        fromArray(values) {
          const dest = this.makeDestinationObject();
          for (const fd of this.fields) {
            if (void 0 !== fd.property && 0 < values.length) {
              dest[fd.property] = values.shift();
            }
          }
          return dest;
        }
        /**
         * Get access to the layout of a given property.
         *
         * @param {String} property - the structure member of interest.
         *
         * @return {Layout} - the layout associated with `property`, or
         * undefined if there is no such property.
         */
        layoutFor(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          for (const fd of this.fields) {
            if (fd.property === property) {
              return fd;
            }
          }
          return void 0;
        }
        /**
         * Get the offset of a structure member.
         *
         * @param {String} property - the structure member of interest.
         *
         * @return {Number} - the offset in bytes to the start of `property`
         * within the structure, or undefined if `property` is not a field
         * within the structure.  If the property is a member but follows a
         * variable-length structure member a negative number will be
         * returned.
         */
        offsetOf(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          let offset2 = 0;
          for (const fd of this.fields) {
            if (fd.property === property) {
              return offset2;
            }
            if (0 > fd.span) {
              offset2 = -1;
            } else if (0 <= offset2) {
              offset2 += fd.span;
            }
          }
          return void 0;
        }
      };
      exports.Structure = Structure;
      var UnionDiscriminator = class {
        constructor(property) {
          this.property = property;
        }
        /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
         *
         * The implementation of this method need not reference the buffer if
         * variant information is available through other means. */
        decode(b, offset2) {
          throw new Error("UnionDiscriminator is abstract");
        }
        /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
         *
         * The implementation of this method need not store the value if
         * variant information is maintained through other means. */
        encode(src, b, offset2) {
          throw new Error("UnionDiscriminator is abstract");
        }
      };
      exports.UnionDiscriminator = UnionDiscriminator;
      var UnionLayoutDiscriminator = class extends UnionDiscriminator {
        constructor(layout, property) {
          if (!(layout instanceof ExternalLayout && layout.isCount())) {
            throw new TypeError("layout must be an unsigned integer ExternalLayout");
          }
          super(property || layout.property || "variant");
          this.layout = layout;
        }
        /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
        decode(b, offset2) {
          return this.layout.decode(b, offset2);
        }
        /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
        encode(src, b, offset2) {
          return this.layout.encode(src, b, offset2);
        }
      };
      exports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
      var Union = class extends Layout {
        constructor(discr, defaultLayout, property) {
          let discriminator;
          if (discr instanceof UInt || discr instanceof UIntBE) {
            discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));
          } else if (discr instanceof ExternalLayout && discr.isCount()) {
            discriminator = new UnionLayoutDiscriminator(discr);
          } else if (!(discr instanceof UnionDiscriminator)) {
            throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
          } else {
            discriminator = discr;
          }
          if (void 0 === defaultLayout) {
            defaultLayout = null;
          }
          if (!(null === defaultLayout || defaultLayout instanceof Layout)) {
            throw new TypeError("defaultLayout must be null or a Layout");
          }
          if (null !== defaultLayout) {
            if (0 > defaultLayout.span) {
              throw new Error("defaultLayout must have constant span");
            }
            if (void 0 === defaultLayout.property) {
              defaultLayout = defaultLayout.replicate("content");
            }
          }
          let span = -1;
          if (defaultLayout) {
            span = defaultLayout.span;
            if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) {
              span += discriminator.layout.span;
            }
          }
          super(span, property);
          this.discriminator = discriminator;
          this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;
          this.defaultLayout = defaultLayout;
          this.registry = {};
          let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
          this.getSourceVariant = function(src) {
            return boundGetSourceVariant(src);
          };
          this.configGetSourceVariant = function(gsv) {
            boundGetSourceVariant = gsv.bind(this);
          };
        }
        /** @override */
        getSpan(b, offset2 = 0) {
          if (0 <= this.span) {
            return this.span;
          }
          const vlo = this.getVariant(b, offset2);
          if (!vlo) {
            throw new Error("unable to determine span for unrecognized variant");
          }
          return vlo.getSpan(b, offset2);
        }
        /**
         * Method to infer a registered Union variant compatible with `src`.
         *
         * The first satisfied rule in the following sequence defines the
         * return value:
         * * If `src` has properties matching the Union discriminator and
         *   the default layout, `undefined` is returned regardless of the
         *   value of the discriminator property (this ensures the default
         *   layout will be used);
         * * If `src` has a property matching the Union discriminator, the
         *   value of the discriminator identifies a registered variant, and
         *   either (a) the variant has no layout, or (b) `src` has the
         *   variant's property, then the variant is returned (because the
         *   source satisfies the constraints of the variant it identifies);
         * * If `src` does not have a property matching the Union
         *   discriminator, but does have a property matching a registered
         *   variant, then the variant is returned (because the source
         *   matches a variant without an explicit conflict);
         * * An error is thrown (because we either can't identify a variant,
         *   or we were explicitly told the variant but can't satisfy it).
         *
         * @param {Object} src - an object presumed to be compatible with
         * the content of the Union.
         *
         * @return {(undefined|VariantLayout)} - as described above.
         *
         * @throws {Error} - if `src` cannot be associated with a default or
         * registered variant.
         */
        defaultGetSourceVariant(src) {
          if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {
            if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {
              return void 0;
            }
            const vlo = this.registry[src[this.discriminator.property]];
            if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {
              return vlo;
            }
          } else {
            for (const tag in this.registry) {
              const vlo = this.registry[tag];
              if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {
                return vlo;
              }
            }
          }
          throw new Error("unable to infer src variant");
        }
        /** Implement {@link Layout#decode|decode} for {@link Union}.
         *
         * If the variant is {@link Union#addVariant|registered} the return
         * value is an instance of that variant, with no explicit
         * discriminator.  Otherwise the {@link Union#defaultLayout|default
         * layout} is used to decode the content. */
        decode(b, offset2 = 0) {
          let dest;
          const dlo = this.discriminator;
          const discr = dlo.decode(b, offset2);
          const clo = this.registry[discr];
          if (void 0 === clo) {
            const defaultLayout = this.defaultLayout;
            let contentOffset = 0;
            if (this.usesPrefixDiscriminator) {
              contentOffset = dlo.layout.span;
            }
            dest = this.makeDestinationObject();
            dest[dlo.property] = discr;
            dest[defaultLayout.property] = defaultLayout.decode(b, offset2 + contentOffset);
          } else {
            dest = clo.decode(b, offset2);
          }
          return dest;
        }
        /** Implement {@link Layout#encode|encode} for {@link Union}.
         *
         * This API assumes the `src` object is consistent with the union's
         * {@link Union#defaultLayout|default layout}.  To encode variants
         * use the appropriate variant-specific {@link VariantLayout#encode}
         * method. */
        encode(src, b, offset2 = 0) {
          const vlo = this.getSourceVariant(src);
          if (void 0 === vlo) {
            const dlo = this.discriminator;
            const clo = this.defaultLayout;
            let contentOffset = 0;
            if (this.usesPrefixDiscriminator) {
              contentOffset = dlo.layout.span;
            }
            dlo.encode(src[dlo.property], b, offset2);
            return contentOffset + clo.encode(src[clo.property], b, offset2 + contentOffset);
          }
          return vlo.encode(src, b, offset2);
        }
        /** Register a new variant structure within a union.  The newly
         * created variant is returned.
         *
         * @param {Number} variant - initializer for {@link
         * VariantLayout#variant|variant}.
         *
         * @param {Layout} layout - initializer for {@link
         * VariantLayout#layout|layout}.
         *
         * @param {String} property - initializer for {@link
         * Layout#property|property}.
         *
         * @return {VariantLayout} */
        addVariant(variant, layout, property) {
          const rv = new VariantLayout(this, variant, layout, property);
          this.registry[variant] = rv;
          return rv;
        }
        /**
         * Get the layout associated with a registered variant.
         *
         * If `vb` does not produce a registered variant the function returns
         * `undefined`.
         *
         * @param {(Number|Uint8Array)} vb - either the variant number, or a
         * buffer from which the discriminator is to be read.
         *
         * @param {Number} offset - offset into `vb` for the start of the
         * union.  Used only when `vb` is an instance of {Uint8Array}.
         *
         * @return {({VariantLayout}|undefined)}
         */
        getVariant(vb, offset2 = 0) {
          let variant;
          if (vb instanceof Uint8Array) {
            variant = this.discriminator.decode(vb, offset2);
          } else {
            variant = vb;
          }
          return this.registry[variant];
        }
      };
      exports.Union = Union;
      var VariantLayout = class extends Layout {
        constructor(union2, variant, layout, property) {
          if (!(union2 instanceof Union)) {
            throw new TypeError("union must be a Union");
          }
          if (!Number.isInteger(variant) || 0 > variant) {
            throw new TypeError("variant must be a (non-negative) integer");
          }
          if ("string" === typeof layout && void 0 === property) {
            property = layout;
            layout = null;
          }
          if (layout) {
            if (!(layout instanceof Layout)) {
              throw new TypeError("layout must be a Layout");
            }
            if (null !== union2.defaultLayout && 0 <= layout.span && layout.span > union2.defaultLayout.span) {
              throw new Error("variant span exceeds span of containing union");
            }
            if ("string" !== typeof property) {
              throw new TypeError("variant must have a String property");
            }
          }
          let span = union2.span;
          if (0 > union2.span) {
            span = layout ? layout.span : 0;
            if (0 <= span && union2.usesPrefixDiscriminator) {
              span += union2.discriminator.layout.span;
            }
          }
          super(span, property);
          this.union = union2;
          this.variant = variant;
          this.layout = layout || null;
        }
        /** @override */
        getSpan(b, offset2 = 0) {
          if (0 <= this.span) {
            return this.span;
          }
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          let span = 0;
          if (this.layout) {
            span = this.layout.getSpan(b, offset2 + contentOffset);
          }
          return contentOffset + span;
        }
        /** @override */
        decode(b, offset2 = 0) {
          const dest = this.makeDestinationObject();
          if (this !== this.union.getVariant(b, offset2)) {
            throw new Error("variant mismatch");
          }
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          if (this.layout) {
            dest[this.property] = this.layout.decode(b, offset2 + contentOffset);
          } else if (this.property) {
            dest[this.property] = true;
          } else if (this.union.usesPrefixDiscriminator) {
            dest[this.union.discriminator.property] = this.variant;
          }
          return dest;
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {
            throw new TypeError("variant lacks property " + this.property);
          }
          this.union.discriminator.encode(this.variant, b, offset2);
          let span = contentOffset;
          if (this.layout) {
            this.layout.encode(src[this.property], b, offset2 + contentOffset);
            span += this.layout.getSpan(b, offset2 + contentOffset);
            if (0 <= this.union.span && span > this.union.span) {
              throw new Error("encoded variant overruns containing union");
            }
          }
          return span;
        }
        /** Delegate {@link Layout#fromArray|fromArray} to {@link
         * VariantLayout#layout|layout}. */
        fromArray(values) {
          if (this.layout) {
            return this.layout.fromArray(values);
          }
          return void 0;
        }
      };
      exports.VariantLayout = VariantLayout;
      function fixBitwiseResult(v) {
        if (0 > v) {
          v += 4294967296;
        }
        return v;
      }
      var BitStructure = class extends Layout {
        constructor(word, msb, property) {
          if (!(word instanceof UInt || word instanceof UIntBE)) {
            throw new TypeError("word must be a UInt or UIntBE layout");
          }
          if ("string" === typeof msb && void 0 === property) {
            property = msb;
            msb = false;
          }
          if (4 < word.span) {
            throw new RangeError("word cannot exceed 32 bits");
          }
          super(word.span, property);
          this.word = word;
          this.msb = !!msb;
          this.fields = [];
          let value = 0;
          this._packedSetValue = function(v) {
            value = fixBitwiseResult(v);
            return this;
          };
          this._packedGetValue = function() {
            return value;
          };
        }
        /** @override */
        decode(b, offset2 = 0) {
          const dest = this.makeDestinationObject();
          const value = this.word.decode(b, offset2);
          this._packedSetValue(value);
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              dest[fd.property] = fd.decode(b);
            }
          }
          return dest;
        }
        /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
         *
         * If `src` is missing a property for a member with a defined {@link
         * Layout#property|property} the corresponding region of the packed
         * value is left unmodified.  Unused bits are also left unmodified. */
        encode(src, b, offset2 = 0) {
          const value = this.word.decode(b, offset2);
          this._packedSetValue(value);
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              const fv = src[fd.property];
              if (void 0 !== fv) {
                fd.encode(fv);
              }
            }
          }
          return this.word.encode(this._packedGetValue(), b, offset2);
        }
        /** Register a new bitfield with a containing bit structure.  The
         * resulting bitfield is returned.
         *
         * @param {Number} bits - initializer for {@link BitField#bits|bits}.
         *
         * @param {string} property - initializer for {@link
         * Layout#property|property}.
         *
         * @return {BitField} */
        addField(bits, property) {
          const bf = new BitField(this, bits, property);
          this.fields.push(bf);
          return bf;
        }
        /** As with {@link BitStructure#addField|addField} for single-bit
         * fields with `boolean` value representation.
         *
         * @param {string} property - initializer for {@link
         * Layout#property|property}.
         *
         * @return {Boolean} */
        // `Boolean` conflicts with the native primitive type
        // eslint-disable-next-line @typescript-eslint/ban-types
        addBoolean(property) {
          const bf = new Boolean2(this, property);
          this.fields.push(bf);
          return bf;
        }
        /**
         * Get access to the bit field for a given property.
         *
         * @param {String} property - the bit field of interest.
         *
         * @return {BitField} - the field associated with `property`, or
         * undefined if there is no such property.
         */
        fieldFor(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          for (const fd of this.fields) {
            if (fd.property === property) {
              return fd;
            }
          }
          return void 0;
        }
      };
      exports.BitStructure = BitStructure;
      var BitField = class {
        constructor(container, bits, property) {
          if (!(container instanceof BitStructure)) {
            throw new TypeError("container must be a BitStructure");
          }
          if (!Number.isInteger(bits) || 0 >= bits) {
            throw new TypeError("bits must be positive integer");
          }
          const totalBits = 8 * container.span;
          const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
          if (bits + usedBits > totalBits) {
            throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
          }
          this.container = container;
          this.bits = bits;
          this.valueMask = (1 << bits) - 1;
          if (32 === bits) {
            this.valueMask = 4294967295;
          }
          this.start = usedBits;
          if (this.container.msb) {
            this.start = totalBits - usedBits - bits;
          }
          this.wordMask = fixBitwiseResult(this.valueMask << this.start);
          this.property = property;
        }
        /** Store a value into the corresponding subsequence of the containing
         * bit field. */
        decode(b, offset2) {
          const word = this.container._packedGetValue();
          const wordValue = fixBitwiseResult(word & this.wordMask);
          const value = wordValue >>> this.start;
          return value;
        }
        /** Store a value into the corresponding subsequence of the containing
         * bit field.
         *
         * **NOTE** This is not a specialization of {@link
         * Layout#encode|Layout.encode} and there is no return value. */
        encode(value) {
          if ("number" !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
            throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
          }
          const word = this.container._packedGetValue();
          const wordValue = fixBitwiseResult(value << this.start);
          this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
        }
      };
      exports.BitField = BitField;
      var Boolean2 = class extends BitField {
        constructor(container, property) {
          super(container, 1, property);
        }
        /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
         *
         * @returns {boolean} */
        decode(b, offset2) {
          return !!super.decode(b, offset2);
        }
        /** @override */
        encode(value) {
          if ("boolean" === typeof value) {
            value = +value;
          }
          super.encode(value);
        }
      };
      exports.Boolean = Boolean2;
      var Blob = class extends Layout {
        constructor(length, property) {
          if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
            throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
          }
          let span = -1;
          if (!(length instanceof ExternalLayout)) {
            span = length;
          }
          super(span, property);
          this.length = length;
        }
        /** @override */
        getSpan(b, offset2) {
          let span = this.span;
          if (0 > span) {
            span = this.length.decode(b, offset2);
          }
          return span;
        }
        /** @override */
        decode(b, offset2 = 0) {
          let span = this.span;
          if (0 > span) {
            span = this.length.decode(b, offset2);
          }
          return uint8ArrayToBuffer(b).slice(offset2, offset2 + span);
        }
        /** Implement {@link Layout#encode|encode} for {@link Blob}.
         *
         * **NOTE** If {@link Layout#count|count} is an instance of {@link
         * ExternalLayout} then the length of `src` will be encoded as the
         * count after `src` is encoded. */
        encode(src, b, offset2) {
          let span = this.length;
          if (this.length instanceof ExternalLayout) {
            span = src.length;
          }
          if (!(src instanceof Uint8Array && span === src.length)) {
            throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Uint8Array as src");
          }
          if (offset2 + span > b.length) {
            throw new RangeError("encoding overruns Uint8Array");
          }
          const srcBuffer = uint8ArrayToBuffer(src);
          uint8ArrayToBuffer(b).write(srcBuffer.toString("hex"), offset2, span, "hex");
          if (this.length instanceof ExternalLayout) {
            this.length.encode(span, b, offset2);
          }
          return span;
        }
      };
      exports.Blob = Blob;
      var CString = class extends Layout {
        constructor(property) {
          super(-1, property);
        }
        /** @override */
        getSpan(b, offset2 = 0) {
          checkUint8Array(b);
          let idx = offset2;
          while (idx < b.length && 0 !== b[idx]) {
            idx += 1;
          }
          return 1 + idx - offset2;
        }
        /** @override */
        decode(b, offset2 = 0) {
          const span = this.getSpan(b, offset2);
          return uint8ArrayToBuffer(b).slice(offset2, offset2 + span - 1).toString("utf-8");
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          if ("string" !== typeof src) {
            src = String(src);
          }
          const srcb = buffer_1.Buffer.from(src, "utf8");
          const span = srcb.length;
          if (offset2 + span > b.length) {
            throw new RangeError("encoding overruns Buffer");
          }
          const buffer = uint8ArrayToBuffer(b);
          srcb.copy(buffer, offset2);
          buffer[offset2 + span] = 0;
          return span + 1;
        }
      };
      exports.CString = CString;
      var UTF8 = class extends Layout {
        constructor(maxSpan, property) {
          if ("string" === typeof maxSpan && void 0 === property) {
            property = maxSpan;
            maxSpan = void 0;
          }
          if (void 0 === maxSpan) {
            maxSpan = -1;
          } else if (!Number.isInteger(maxSpan)) {
            throw new TypeError("maxSpan must be an integer");
          }
          super(-1, property);
          this.maxSpan = maxSpan;
        }
        /** @override */
        getSpan(b, offset2 = 0) {
          checkUint8Array(b);
          return b.length - offset2;
        }
        /** @override */
        decode(b, offset2 = 0) {
          const span = this.getSpan(b, offset2);
          if (0 <= this.maxSpan && this.maxSpan < span) {
            throw new RangeError("text length exceeds maxSpan");
          }
          return uint8ArrayToBuffer(b).slice(offset2, offset2 + span).toString("utf-8");
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          if ("string" !== typeof src) {
            src = String(src);
          }
          const srcb = buffer_1.Buffer.from(src, "utf8");
          const span = srcb.length;
          if (0 <= this.maxSpan && this.maxSpan < span) {
            throw new RangeError("text length exceeds maxSpan");
          }
          if (offset2 + span > b.length) {
            throw new RangeError("encoding overruns Buffer");
          }
          srcb.copy(uint8ArrayToBuffer(b), offset2);
          return span;
        }
      };
      exports.UTF8 = UTF8;
      var Constant = class extends Layout {
        constructor(value, property) {
          super(0, property);
          this.value = value;
        }
        /** @override */
        decode(b, offset2) {
          return this.value;
        }
        /** @override */
        encode(src, b, offset2) {
          return 0;
        }
      };
      exports.Constant = Constant;
      exports.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);
      exports.offset = (layout, offset2, property) => new OffsetLayout(layout, offset2, property);
      exports.u8 = (property) => new UInt(1, property);
      exports.u16 = (property) => new UInt(2, property);
      exports.u24 = (property) => new UInt(3, property);
      exports.u32 = (property) => new UInt(4, property);
      exports.u40 = (property) => new UInt(5, property);
      exports.u48 = (property) => new UInt(6, property);
      exports.nu64 = (property) => new NearUInt64(property);
      exports.u16be = (property) => new UIntBE(2, property);
      exports.u24be = (property) => new UIntBE(3, property);
      exports.u32be = (property) => new UIntBE(4, property);
      exports.u40be = (property) => new UIntBE(5, property);
      exports.u48be = (property) => new UIntBE(6, property);
      exports.nu64be = (property) => new NearUInt64BE(property);
      exports.s8 = (property) => new Int(1, property);
      exports.s16 = (property) => new Int(2, property);
      exports.s24 = (property) => new Int(3, property);
      exports.s32 = (property) => new Int(4, property);
      exports.s40 = (property) => new Int(5, property);
      exports.s48 = (property) => new Int(6, property);
      exports.ns64 = (property) => new NearInt64(property);
      exports.s16be = (property) => new IntBE(2, property);
      exports.s24be = (property) => new IntBE(3, property);
      exports.s32be = (property) => new IntBE(4, property);
      exports.s40be = (property) => new IntBE(5, property);
      exports.s48be = (property) => new IntBE(6, property);
      exports.ns64be = (property) => new NearInt64BE(property);
      exports.f32 = (property) => new Float(property);
      exports.f32be = (property) => new FloatBE(property);
      exports.f64 = (property) => new Double(property);
      exports.f64be = (property) => new DoubleBE(property);
      exports.struct = (fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes);
      exports.bits = (word, msb, property) => new BitStructure(word, msb, property);
      exports.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);
      exports.union = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);
      exports.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property);
      exports.blob = (length, property) => new Blob(length, property);
      exports.cstr = (property) => new CString(property);
      exports.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);
      exports.constant = (value, property) => new Constant(value, property);
    }
  });

  // node_modules/uuid/dist/esm-browser/rng.js
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  var getRandomValues, rnds8;
  var init_rng = __esm({
    "node_modules/uuid/dist/esm-browser/rng.js"() {
      rnds8 = new Uint8Array(16);
    }
  });

  // node_modules/uuid/dist/esm-browser/regex.js
  var regex_default;
  var init_regex = __esm({
    "node_modules/uuid/dist/esm-browser/regex.js"() {
      regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    }
  });

  // node_modules/uuid/dist/esm-browser/validate.js
  function validate2(uuid) {
    return typeof uuid === "string" && regex_default.test(uuid);
  }
  var validate_default;
  var init_validate = __esm({
    "node_modules/uuid/dist/esm-browser/validate.js"() {
      init_regex();
      validate_default = validate2;
    }
  });

  // node_modules/uuid/dist/esm-browser/stringify.js
  function stringify(arr) {
    var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var uuid = (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
    if (!validate_default(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  var byteToHex, i, stringify_default;
  var init_stringify = __esm({
    "node_modules/uuid/dist/esm-browser/stringify.js"() {
      init_validate();
      byteToHex = [];
      for (i = 0; i < 256; ++i) {
        byteToHex.push((i + 256).toString(16).substr(1));
      }
      stringify_default = stringify;
    }
  });

  // node_modules/uuid/dist/esm-browser/v1.js
  function v1(options, buf, offset2) {
    var i = buf && offset2 || 0;
    var b = buf || new Array(16);
    options = options || {};
    var node = options.node || _nodeId;
    var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      var seedBytes = options.random || (options.rng || rng)();
      if (node == null) {
        node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
    var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === void 0) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 122192928e5;
    var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    var tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (var n = 0; n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf || stringify_default(b);
  }
  var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
  var init_v1 = __esm({
    "node_modules/uuid/dist/esm-browser/v1.js"() {
      init_rng();
      init_stringify();
      _lastMSecs = 0;
      _lastNSecs = 0;
      v1_default = v1;
    }
  });

  // node_modules/uuid/dist/esm-browser/parse.js
  function parse(uuid) {
    if (!validate_default(uuid)) {
      throw TypeError("Invalid UUID");
    }
    var v;
    var arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  }
  var parse_default;
  var init_parse = __esm({
    "node_modules/uuid/dist/esm-browser/parse.js"() {
      init_validate();
      parse_default = parse;
    }
  });

  // node_modules/uuid/dist/esm-browser/v35.js
  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    var bytes = [];
    for (var i = 0; i < str.length; ++i) {
      bytes.push(str.charCodeAt(i));
    }
    return bytes;
  }
  function v35_default(name, version2, hashfunc) {
    function generateUUID(value, namespace, buf, offset2) {
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = parse_default(namespace);
      }
      if (namespace.length !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      var bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version2;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset2 = offset2 || 0;
        for (var i = 0; i < 16; ++i) {
          buf[offset2 + i] = bytes[i];
        }
        return buf;
      }
      return stringify_default(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  }
  var DNS, URL2;
  var init_v35 = __esm({
    "node_modules/uuid/dist/esm-browser/v35.js"() {
      init_stringify();
      init_parse();
      DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
      URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    }
  });

  // node_modules/uuid/dist/esm-browser/md5.js
  function md5(bytes) {
    if (typeof bytes === "string") {
      var msg = unescape(encodeURIComponent(bytes));
      bytes = new Uint8Array(msg.length);
      for (var i = 0; i < msg.length; ++i) {
        bytes[i] = msg.charCodeAt(i);
      }
    }
    return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
  }
  function md5ToHexEncodedArray(input) {
    var output = [];
    var length32 = input.length * 32;
    var hexTab = "0123456789abcdef";
    for (var i = 0; i < length32; i += 8) {
      var x = input[i >> 5] >>> i % 32 & 255;
      var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
      output.push(hex);
    }
    return output;
  }
  function getOutputLength(inputLength8) {
    return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
  }
  function wordsToMd5(x, len) {
    x[len >> 5] |= 128 << len % 32;
    x[getOutputLength(len) - 1] = len;
    var a = 1732584193;
    var b = -271733879;
    var c = -1732584194;
    var d = 271733878;
    for (var i = 0; i < x.length; i += 16) {
      var olda = a;
      var oldb = b;
      var oldc = c;
      var oldd = d;
      a = md5ff(a, b, c, d, x[i], 7, -680876936);
      d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
      c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
      b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
      a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
      d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
      c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
      b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
      a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
      d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
      c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
      b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
      a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
      d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
      c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
      b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
      a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
      d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
      c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
      b = md5gg(b, c, d, a, x[i], 20, -373897302);
      a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
      d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
      c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
      b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
      a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
      d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
      c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
      b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
      a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
      d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
      c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
      b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
      a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
      d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
      c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
      b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
      a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
      d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
      c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
      b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
      a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
      d = md5hh(d, a, b, c, x[i], 11, -358537222);
      c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
      b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
      a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
      d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
      c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
      b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
      a = md5ii(a, b, c, d, x[i], 6, -198630844);
      d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
      c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
      b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
      a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
      d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
      c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
      b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
      a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
      d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
      c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
      b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
      a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
      d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
      c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
      b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
      a = safeAdd(a, olda);
      b = safeAdd(b, oldb);
      c = safeAdd(c, oldc);
      d = safeAdd(d, oldd);
    }
    return [a, b, c, d];
  }
  function bytesToWords(input) {
    if (input.length === 0) {
      return [];
    }
    var length8 = input.length * 8;
    var output = new Uint32Array(getOutputLength(length8));
    for (var i = 0; i < length8; i += 8) {
      output[i >> 5] |= (input[i / 8] & 255) << i % 32;
    }
    return output;
  }
  function safeAdd(x, y) {
    var lsw = (x & 65535) + (y & 65535);
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 65535;
  }
  function bitRotateLeft(num, cnt) {
    return num << cnt | num >>> 32 - cnt;
  }
  function md5cmn(q, a, b, x, s, t) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
  }
  function md5ff(a, b, c, d, x, s, t) {
    return md5cmn(b & c | ~b & d, a, b, x, s, t);
  }
  function md5gg(a, b, c, d, x, s, t) {
    return md5cmn(b & d | c & ~d, a, b, x, s, t);
  }
  function md5hh(a, b, c, d, x, s, t) {
    return md5cmn(b ^ c ^ d, a, b, x, s, t);
  }
  function md5ii(a, b, c, d, x, s, t) {
    return md5cmn(c ^ (b | ~d), a, b, x, s, t);
  }
  var md5_default;
  var init_md5 = __esm({
    "node_modules/uuid/dist/esm-browser/md5.js"() {
      md5_default = md5;
    }
  });

  // node_modules/uuid/dist/esm-browser/v3.js
  var v3, v3_default;
  var init_v3 = __esm({
    "node_modules/uuid/dist/esm-browser/v3.js"() {
      init_v35();
      init_md5();
      v3 = v35_default("v3", 48, md5_default);
      v3_default = v3;
    }
  });

  // node_modules/uuid/dist/esm-browser/v4.js
  function v4(options, buf, offset2) {
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset2 = offset2 || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset2 + i] = rnds[i];
      }
      return buf;
    }
    return stringify_default(rnds);
  }
  var v4_default;
  var init_v4 = __esm({
    "node_modules/uuid/dist/esm-browser/v4.js"() {
      init_rng();
      init_stringify();
      v4_default = v4;
    }
  });

  // node_modules/uuid/dist/esm-browser/sha1.js
  function f(s, x, y, z) {
    switch (s) {
      case 0:
        return x & y ^ ~x & z;
      case 1:
        return x ^ y ^ z;
      case 2:
        return x & y ^ x & z ^ y & z;
      case 3:
        return x ^ y ^ z;
    }
  }
  function ROTL(x, n) {
    return x << n | x >>> 32 - n;
  }
  function sha1(bytes) {
    var K = [1518500249, 1859775393, 2400959708, 3395469782];
    var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if (typeof bytes === "string") {
      var msg = unescape(encodeURIComponent(bytes));
      bytes = [];
      for (var i = 0; i < msg.length; ++i) {
        bytes.push(msg.charCodeAt(i));
      }
    } else if (!Array.isArray(bytes)) {
      bytes = Array.prototype.slice.call(bytes);
    }
    bytes.push(128);
    var l = bytes.length / 4 + 2;
    var N = Math.ceil(l / 16);
    var M = new Array(N);
    for (var _i = 0; _i < N; ++_i) {
      var arr = new Uint32Array(16);
      for (var j = 0; j < 16; ++j) {
        arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
      }
      M[_i] = arr;
    }
    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
    M[N - 1][14] = Math.floor(M[N - 1][14]);
    M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
    for (var _i2 = 0; _i2 < N; ++_i2) {
      var W = new Uint32Array(80);
      for (var t = 0; t < 16; ++t) {
        W[t] = M[_i2][t];
      }
      for (var _t = 16; _t < 80; ++_t) {
        W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
      }
      var a = H[0];
      var b = H[1];
      var c = H[2];
      var d = H[3];
      var e = H[4];
      for (var _t2 = 0; _t2 < 80; ++_t2) {
        var s = Math.floor(_t2 / 20);
        var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
        e = d;
        d = c;
        c = ROTL(b, 30) >>> 0;
        b = a;
        a = T;
      }
      H[0] = H[0] + a >>> 0;
      H[1] = H[1] + b >>> 0;
      H[2] = H[2] + c >>> 0;
      H[3] = H[3] + d >>> 0;
      H[4] = H[4] + e >>> 0;
    }
    return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
  }
  var sha1_default;
  var init_sha1 = __esm({
    "node_modules/uuid/dist/esm-browser/sha1.js"() {
      sha1_default = sha1;
    }
  });

  // node_modules/uuid/dist/esm-browser/v5.js
  var v5, v5_default;
  var init_v5 = __esm({
    "node_modules/uuid/dist/esm-browser/v5.js"() {
      init_v35();
      init_sha1();
      v5 = v35_default("v5", 80, sha1_default);
      v5_default = v5;
    }
  });

  // node_modules/uuid/dist/esm-browser/nil.js
  var nil_default;
  var init_nil = __esm({
    "node_modules/uuid/dist/esm-browser/nil.js"() {
      nil_default = "00000000-0000-0000-0000-000000000000";
    }
  });

  // node_modules/uuid/dist/esm-browser/version.js
  function version(uuid) {
    if (!validate_default(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.substr(14, 1), 16);
  }
  var version_default;
  var init_version = __esm({
    "node_modules/uuid/dist/esm-browser/version.js"() {
      init_validate();
      version_default = version;
    }
  });

  // node_modules/uuid/dist/esm-browser/index.js
  var esm_browser_exports = {};
  __export(esm_browser_exports, {
    NIL: () => nil_default,
    parse: () => parse_default,
    stringify: () => stringify_default,
    v1: () => v1_default,
    v3: () => v3_default,
    v4: () => v4_default,
    v5: () => v5_default,
    validate: () => validate_default,
    version: () => version_default
  });
  var init_esm_browser = __esm({
    "node_modules/uuid/dist/esm-browser/index.js"() {
      init_v1();
      init_v3();
      init_v4();
      init_v5();
      init_nil();
      init_version();
      init_validate();
      init_stringify();
      init_parse();
    }
  });

  // node_modules/jayson/lib/generateRequest.js
  var require_generateRequest = __commonJS({
    "node_modules/jayson/lib/generateRequest.js"(exports, module) {
      "use strict";
      var uuid = (init_esm_browser(), __toCommonJS(esm_browser_exports)).v4;
      var generateRequest = function(method, params, id, options) {
        if (typeof method !== "string") {
          throw new TypeError(method + " must be a string");
        }
        options = options || {};
        const version2 = typeof options.version === "number" ? options.version : 2;
        if (version2 !== 1 && version2 !== 2) {
          throw new TypeError(version2 + " must be 1 or 2");
        }
        const request = {
          method
        };
        if (version2 === 2) {
          request.jsonrpc = "2.0";
        }
        if (params) {
          if (typeof params !== "object" && !Array.isArray(params)) {
            throw new TypeError(params + " must be an object, array or omitted");
          }
          request.params = params;
        }
        if (typeof id === "undefined") {
          const generator = typeof options.generator === "function" ? options.generator : function() {
            return uuid();
          };
          request.id = generator(request, options);
        } else if (version2 === 2 && id === null) {
          if (options.notificationIdNull) {
            request.id = null;
          }
        } else {
          request.id = id;
        }
        return request;
      };
      module.exports = generateRequest;
    }
  });

  // node_modules/jayson/lib/client/browser/index.js
  var require_browser = __commonJS({
    "node_modules/jayson/lib/client/browser/index.js"(exports, module) {
      "use strict";
      var uuid = (init_esm_browser(), __toCommonJS(esm_browser_exports)).v4;
      var generateRequest = require_generateRequest();
      var ClientBrowser = function(callServer, options) {
        if (!(this instanceof ClientBrowser)) {
          return new ClientBrowser(callServer, options);
        }
        if (!options) {
          options = {};
        }
        this.options = {
          reviver: typeof options.reviver !== "undefined" ? options.reviver : null,
          replacer: typeof options.replacer !== "undefined" ? options.replacer : null,
          generator: typeof options.generator !== "undefined" ? options.generator : function() {
            return uuid();
          },
          version: typeof options.version !== "undefined" ? options.version : 2,
          notificationIdNull: typeof options.notificationIdNull === "boolean" ? options.notificationIdNull : false
        };
        this.callServer = callServer;
      };
      module.exports = ClientBrowser;
      ClientBrowser.prototype.request = function(method, params, id, callback) {
        const self = this;
        let request = null;
        const isBatch = Array.isArray(method) && typeof params === "function";
        if (this.options.version === 1 && isBatch) {
          throw new TypeError("JSON-RPC 1.0 does not support batching");
        }
        const isRaw = !isBatch && method && typeof method === "object" && typeof params === "function";
        if (isBatch || isRaw) {
          callback = params;
          request = method;
        } else {
          if (typeof id === "function") {
            callback = id;
            id = void 0;
          }
          const hasCallback = typeof callback === "function";
          try {
            request = generateRequest(method, params, id, {
              generator: this.options.generator,
              version: this.options.version,
              notificationIdNull: this.options.notificationIdNull
            });
          } catch (err) {
            if (hasCallback) {
              return callback(err);
            }
            throw err;
          }
          if (!hasCallback) {
            return request;
          }
        }
        let message;
        try {
          message = JSON.stringify(request, this.options.replacer);
        } catch (err) {
          return callback(err);
        }
        this.callServer(message, function(err, response) {
          self._parseResponse(err, response, callback);
        });
        return request;
      };
      ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {
        if (err) {
          callback(err);
          return;
        }
        if (!responseText) {
          return callback();
        }
        let response;
        try {
          response = JSON.parse(responseText, this.options.reviver);
        } catch (err2) {
          return callback(err2);
        }
        if (callback.length === 3) {
          if (Array.isArray(response)) {
            const isError = function(res) {
              return typeof res.error !== "undefined";
            };
            const isNotError = function(res) {
              return !isError(res);
            };
            return callback(null, response.filter(isError), response.filter(isNotError));
          } else {
            return callback(null, response.error, response.result);
          }
        }
        callback(null, response);
      };
    }
  });

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__) prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
        else emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();
        else delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0) return names;
        for (name in events = this._events) {
          if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i = 0; i < length; i++) {
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
              events.push(listeners[i]);
            }
          }
          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
          else clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter2;
      }
    }
  });

  // node_modules/bigint-buffer/dist/browser.js
  var require_browser2 = __commonJS({
    "node_modules/bigint-buffer/dist/browser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var converter;
      function toBigIntLE2(buf) {
        {
          const reversed = Buffer.from(buf);
          reversed.reverse();
          const hex = reversed.toString("hex");
          if (hex.length === 0) {
            return BigInt(0);
          }
          return BigInt(`0x${hex}`);
        }
        return converter.toBigInt(buf, false);
      }
      exports.toBigIntLE = toBigIntLE2;
      function toBigIntBE2(buf) {
        {
          const hex = buf.toString("hex");
          if (hex.length === 0) {
            return BigInt(0);
          }
          return BigInt(`0x${hex}`);
        }
        return converter.toBigInt(buf, true);
      }
      exports.toBigIntBE = toBigIntBE2;
      function toBufferLE2(num, width) {
        {
          const hex = num.toString(16);
          const buffer = Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
          buffer.reverse();
          return buffer;
        }
        return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);
      }
      exports.toBufferLE = toBufferLE2;
      function toBufferBE2(num, width) {
        {
          const hex = num.toString(16);
          return Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
        }
        return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);
      }
      exports.toBufferBE = toBufferBE2;
    }
  });

  // node_modules/@solana/web3.js/lib/index.browser.esm.js
  var import_buffer2 = __toESM(require_buffer());

  // node_modules/@noble/hashes/esm/crypto.js
  var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

  // node_modules/@noble/hashes/esm/utils.js
  function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error("positive integer expected, got " + n);
  }
  function abytes(b, ...lengths) {
    if (!isBytes(b))
      throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
  }
  function ahash(h) {
    if (typeof h !== "function" || typeof h.create !== "function")
      throw new Error("Hash should be wrapped by utils.createHasher");
    anumber(h.outputLen);
    anumber(h.blockLen);
  }
  function aexists(instance2, checkFinished = true) {
    if (instance2.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance2.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput(out, instance2) {
    abytes(out);
    const min = instance2.outputLen;
    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least " + min);
    }
  }
  function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  }
  function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
      arrays[i].fill(0);
    }
  }
  function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function rotr(word, shift) {
    return word << 32 - shift | word >>> shift;
  }
  var isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
  function byteSwap(word) {
    return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
  }
  function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) {
      arr[i] = byteSwap(arr[i]);
    }
    return arr;
  }
  var swap32IfBE = isLE ? (u) => u : byteSwap32;
  var hasHexBuiltin = /* @__PURE__ */ (() => (
    // @ts-ignore
    typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
  ))();
  var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex(bytes) {
    abytes(bytes);
    if (hasHexBuiltin)
      return bytes.toHex();
    let hex = "";
    for (let i = 0; i < bytes.length; i++) {
      hex += hexes[bytes[i]];
    }
    return hex;
  }
  var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
      return ch - asciis._0;
    if (ch >= asciis.A && ch <= asciis.F)
      return ch - (asciis.A - 10);
    if (ch >= asciis.a && ch <= asciis.f)
      return ch - (asciis.a - 10);
    return;
  }
  function hexToBytes(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    if (hasHexBuiltin)
      return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("hex string expected, got unpadded hex of length " + hl);
    const array2 = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      const n1 = asciiToBase16(hex.charCodeAt(hi));
      const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array2[ai] = n1 * 16 + n2;
    }
    return array2;
  }
  function utf8ToBytes(str) {
    if (typeof str !== "string")
      throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    abytes(data);
    return data;
  }
  function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      abytes(a);
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad);
      pad += a.length;
    }
    return res;
  }
  var Hash = class {
  };
  function createHasher(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function randomBytes(bytesLength = 32) {
    if (crypto2 && typeof crypto2.getRandomValues === "function") {
      return crypto2.getRandomValues(new Uint8Array(bytesLength));
    }
    if (crypto2 && typeof crypto2.randomBytes === "function") {
      return Uint8Array.from(crypto2.randomBytes(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }

  // node_modules/@noble/hashes/esm/_md.js
  function setBigUint64(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n2 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE2 ? 4 : 0;
    const l = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE2);
    view.setUint32(byteOffset + l, wl, isLE2);
  }
  function Chi(a, b, c) {
    return a & b ^ ~a & c;
  }
  function Maj(a, b, c) {
    return a & b ^ a & c ^ b & c;
  }
  var HashMD = class extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE2) {
      super();
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      aexists(this);
      data = toBytes(data);
      abytes(data);
      const { view, buffer, blockLen } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      aexists(this);
      aoutput(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      clean(this.buffer.subarray(pos));
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE2);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.destroyed = destroyed;
      to.finished = finished;
      to.length = length;
      to.pos = pos;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
  };
  var SHA256_IV = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA512_IV = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ]);

  // node_modules/@noble/hashes/esm/_u64.js
  var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  var _32n = /* @__PURE__ */ BigInt(32);
  function fromBig(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  }
  function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  var shrSH = (h, _l, s) => h >>> s;
  var shrSL = (h, l, s) => h << 32 - s | l >>> s;
  var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
  var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
  var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
  var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
  var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
  var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
  var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
  var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
  function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

  // node_modules/@noble/hashes/esm/sha2.js
  var SHA256_K = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  var SHA256 = class extends HashMD {
    constructor(outputLen = 32) {
      super(64, outputLen, 8, false);
      this.A = SHA256_IV[0] | 0;
      this.B = SHA256_IV[1] | 0;
      this.C = SHA256_IV[2] | 0;
      this.D = SHA256_IV[3] | 0;
      this.E = SHA256_IV[4] | 0;
      this.F = SHA256_IV[5] | 0;
      this.G = SHA256_IV[6] | 0;
      this.H = SHA256_IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset2) {
      for (let i = 0; i < 16; i++, offset2 += 4)
        SHA256_W[i] = view.getUint32(offset2, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      clean(SHA256_W);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      clean(this.buffer);
    }
  };
  var K512 = /* @__PURE__ */ (() => split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n) => BigInt(n))))();
  var SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
  var SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
  var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
  var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
  var SHA512 = class extends HashMD {
    constructor(outputLen = 64) {
      super(128, outputLen, 16, false);
      this.Ah = SHA512_IV[0] | 0;
      this.Al = SHA512_IV[1] | 0;
      this.Bh = SHA512_IV[2] | 0;
      this.Bl = SHA512_IV[3] | 0;
      this.Ch = SHA512_IV[4] | 0;
      this.Cl = SHA512_IV[5] | 0;
      this.Dh = SHA512_IV[6] | 0;
      this.Dl = SHA512_IV[7] | 0;
      this.Eh = SHA512_IV[8] | 0;
      this.El = SHA512_IV[9] | 0;
      this.Fh = SHA512_IV[10] | 0;
      this.Fl = SHA512_IV[11] | 0;
      this.Gh = SHA512_IV[12] | 0;
      this.Gl = SHA512_IV[13] | 0;
      this.Hh = SHA512_IV[14] | 0;
      this.Hl = SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset2) {
      for (let i = 0; i < 16; i++, offset2 += 4) {
        SHA512_W_H[i] = view.getUint32(offset2);
        SHA512_W_L[i] = view.getUint32(offset2 += 4);
      }
      for (let i = 16; i < 80; i++) {
        const W15h = SHA512_W_H[i - 15] | 0;
        const W15l = SHA512_W_L[i - 15] | 0;
        const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
        const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H[i - 2] | 0;
        const W2l = SHA512_W_L[i - 2] | 0;
        const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
        const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
        const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
        const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
        SHA512_W_H[i] = SUMh | 0;
        SHA512_W_L[i] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i = 0; i < 80; i++) {
        const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
        const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
        const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
        const T1l = T1ll | 0;
        const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
        const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = add3L(T1l, sigma0l, MAJl);
        Ah = add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      clean(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
      clean(this.buffer);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  var sha256 = /* @__PURE__ */ createHasher(() => new SHA256());
  var sha512 = /* @__PURE__ */ createHasher(() => new SHA512());

  // node_modules/@noble/curves/esm/utils.js
  var _0n = /* @__PURE__ */ BigInt(0);
  var _1n = /* @__PURE__ */ BigInt(1);
  function _abool2(value, title = "") {
    if (typeof value !== "boolean") {
      const prefix = title && `"${title}"`;
      throw new Error(prefix + "expected boolean, got type=" + typeof value);
    }
    return value;
  }
  function _abytes2(value, length, title = "") {
    const bytes = isBytes(value);
    const len = value?.length;
    const needsLen = length !== void 0;
    if (!bytes || needsLen && len !== length) {
      const prefix = title && `"${title}" `;
      const ofLen = needsLen ? ` of length ${length}` : "";
      const got = bytes ? `length=${len}` : `type=${typeof value}`;
      throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
    }
    return value;
  }
  function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? "0" + hex : hex;
  }
  function hexToNumber(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return hex === "" ? _0n : BigInt("0x" + hex);
  }
  function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
  }
  function bytesToNumberLE(bytes) {
    abytes(bytes);
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
  }
  function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
  }
  function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") {
      try {
        res = hexToBytes(hex);
      } catch (e) {
        throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
      }
    } else if (isBytes(hex)) {
      res = Uint8Array.from(hex);
    } else {
      throw new Error(title + " must be hex string or Uint8Array");
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(title + " of length " + expectedLength + " expected, got " + len);
    return res;
  }
  function equalBytes(a, b) {
    if (a.length !== b.length)
      return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
      diff |= a[i] ^ b[i];
    return diff === 0;
  }
  function copyBytes(bytes) {
    return Uint8Array.from(bytes);
  }
  var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
  function inRange(n, min, max) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
  }
  function aInRange(title, n, min, max) {
    if (!inRange(n, min, max))
      throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
  }
  function bitLen(n) {
    let len;
    for (len = 0; n > _0n; n >>= _1n, len += 1)
      ;
    return len;
  }
  var bitMask = (n) => (_1n << BigInt(n)) - _1n;
  function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    const u8n = (len) => new Uint8Array(len);
    const u8of = (byte) => Uint8Array.of(byte);
    let v = u8n(hashLen);
    let k = u8n(hashLen);
    let i = 0;
    const reset = () => {
      v.fill(1);
      k.fill(0);
      i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b);
    const reseed = (seed = u8n(0)) => {
      k = h(u8of(0), seed);
      v = h();
      if (seed.length === 0)
        return;
      k = h(u8of(1), seed);
      v = h();
    };
    const gen2 = () => {
      if (i++ >= 1e3)
        throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v = h();
        const sl = v.slice();
        out.push(sl);
        len += v.length;
      }
      return concatBytes(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = void 0;
      while (!(res = pred(gen2())))
        reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  function _validateObject(object, fields, optFields = {}) {
    if (!object || typeof object !== "object")
      throw new Error("expected valid options object");
    function checkField(fieldName, expectedType, isOpt) {
      const val = object[fieldName];
      if (isOpt && val === void 0)
        return;
      const current = typeof val;
      if (current !== expectedType || val === null)
        throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
    }
    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
  }
  var notImplemented = () => {
    throw new Error("not implemented");
  };
  function memoized(fn) {
    const map = /* @__PURE__ */ new WeakMap();
    return (arg, ...args) => {
      const val = map.get(arg);
      if (val !== void 0)
        return val;
      const computed = fn(arg, ...args);
      map.set(arg, computed);
      return computed;
    };
  }

  // node_modules/@noble/curves/esm/abstract/modular.js
  var _0n2 = BigInt(0);
  var _1n2 = BigInt(1);
  var _2n = /* @__PURE__ */ BigInt(2);
  var _3n = /* @__PURE__ */ BigInt(3);
  var _4n = /* @__PURE__ */ BigInt(4);
  var _5n = /* @__PURE__ */ BigInt(5);
  var _7n = /* @__PURE__ */ BigInt(7);
  var _8n = /* @__PURE__ */ BigInt(8);
  var _9n = /* @__PURE__ */ BigInt(9);
  var _16n = /* @__PURE__ */ BigInt(16);
  function mod(a, b) {
    const result = a % b;
    return result >= _0n2 ? result : b + result;
  }
  function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n2) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert(number2, modulo) {
    if (number2 === _0n2)
      throw new Error("invert: expected non-zero number");
    if (modulo <= _0n2)
      throw new Error("invert: expected positive modulus, got " + modulo);
    let a = mod(number2, modulo);
    let b = modulo;
    let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
    while (a !== _0n2) {
      const q = b / a;
      const r = b % a;
      const m = x - u * q;
      const n = y - v * q;
      b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n2)
      throw new Error("invert: does not exist");
    return mod(x, modulo);
  }
  function assertIsSquare(Fp2, root, n) {
    if (!Fp2.eql(Fp2.sqr(root), n))
      throw new Error("Cannot find square root");
  }
  function sqrt3mod4(Fp2, n) {
    const p1div4 = (Fp2.ORDER + _1n2) / _4n;
    const root = Fp2.pow(n, p1div4);
    assertIsSquare(Fp2, root, n);
    return root;
  }
  function sqrt5mod8(Fp2, n) {
    const p5div8 = (Fp2.ORDER - _5n) / _8n;
    const n2 = Fp2.mul(n, _2n);
    const v = Fp2.pow(n2, p5div8);
    const nv = Fp2.mul(n, v);
    const i = Fp2.mul(Fp2.mul(nv, _2n), v);
    const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
    assertIsSquare(Fp2, root, n);
    return root;
  }
  function sqrt9mod16(P) {
    const Fp_ = Field(P);
    const tn = tonelliShanks(P);
    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
    const c2 = tn(Fp_, c1);
    const c3 = tn(Fp_, Fp_.neg(c1));
    const c4 = (P + _7n) / _16n;
    return (Fp2, n) => {
      let tv1 = Fp2.pow(n, c4);
      let tv2 = Fp2.mul(tv1, c1);
      const tv3 = Fp2.mul(tv1, c2);
      const tv4 = Fp2.mul(tv1, c3);
      const e1 = Fp2.eql(Fp2.sqr(tv2), n);
      const e2 = Fp2.eql(Fp2.sqr(tv3), n);
      tv1 = Fp2.cmov(tv1, tv2, e1);
      tv2 = Fp2.cmov(tv4, tv3, e2);
      const e3 = Fp2.eql(Fp2.sqr(tv2), n);
      const root = Fp2.cmov(tv1, tv2, e3);
      assertIsSquare(Fp2, root, n);
      return root;
    };
  }
  function tonelliShanks(P) {
    if (P < _3n)
      throw new Error("sqrt is not defined for small field");
    let Q = P - _1n2;
    let S = 0;
    while (Q % _2n === _0n2) {
      Q /= _2n;
      S++;
    }
    let Z = _2n;
    const _Fp = Field(P);
    while (FpLegendre(_Fp, Z) === 1) {
      if (Z++ > 1e3)
        throw new Error("Cannot find square root: probably non-prime P");
    }
    if (S === 1)
      return sqrt3mod4;
    let cc = _Fp.pow(Z, Q);
    const Q1div2 = (Q + _1n2) / _2n;
    return function tonelliSlow(Fp2, n) {
      if (Fp2.is0(n))
        return n;
      if (FpLegendre(Fp2, n) !== 1)
        throw new Error("Cannot find square root");
      let M = S;
      let c = Fp2.mul(Fp2.ONE, cc);
      let t = Fp2.pow(n, Q);
      let R = Fp2.pow(n, Q1div2);
      while (!Fp2.eql(t, Fp2.ONE)) {
        if (Fp2.is0(t))
          return Fp2.ZERO;
        let i = 1;
        let t_tmp = Fp2.sqr(t);
        while (!Fp2.eql(t_tmp, Fp2.ONE)) {
          i++;
          t_tmp = Fp2.sqr(t_tmp);
          if (i === M)
            throw new Error("Cannot find square root");
        }
        const exponent = _1n2 << BigInt(M - i - 1);
        const b = Fp2.pow(c, exponent);
        M = i;
        c = Fp2.sqr(b);
        t = Fp2.mul(t, c);
        R = Fp2.mul(R, b);
      }
      return R;
    };
  }
  function FpSqrt(P) {
    if (P % _4n === _3n)
      return sqrt3mod4;
    if (P % _8n === _5n)
      return sqrt5mod8;
    if (P % _16n === _9n)
      return sqrt9mod16(P);
    return tonelliShanks(P);
  }
  var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n2) === _1n2;
  var FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function validateField(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "number",
      BITS: "number"
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
      map[val] = "function";
      return map;
    }, initial);
    _validateObject(field, opts);
    return field;
  }
  function FpPow(Fp2, num, power) {
    if (power < _0n2)
      throw new Error("invalid exponent, negatives unsupported");
    if (power === _0n2)
      return Fp2.ONE;
    if (power === _1n2)
      return num;
    let p = Fp2.ONE;
    let d = num;
    while (power > _0n2) {
      if (power & _1n2)
        p = Fp2.mul(p, d);
      d = Fp2.sqr(d);
      power >>= _1n2;
    }
    return p;
  }
  function FpInvertBatch(Fp2, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp2.ZERO : void 0);
    const multipliedAcc = nums.reduce((acc, num, i) => {
      if (Fp2.is0(num))
        return acc;
      inverted[i] = acc;
      return Fp2.mul(acc, num);
    }, Fp2.ONE);
    const invertedAcc = Fp2.inv(multipliedAcc);
    nums.reduceRight((acc, num, i) => {
      if (Fp2.is0(num))
        return acc;
      inverted[i] = Fp2.mul(acc, inverted[i]);
      return Fp2.mul(acc, num);
    }, invertedAcc);
    return inverted;
  }
  function FpLegendre(Fp2, n) {
    const p1mod2 = (Fp2.ORDER - _1n2) / _2n;
    const powered = Fp2.pow(n, p1mod2);
    const yes = Fp2.eql(powered, Fp2.ONE);
    const zero = Fp2.eql(powered, Fp2.ZERO);
    const no = Fp2.eql(powered, Fp2.neg(Fp2.ONE));
    if (!yes && !zero && !no)
      throw new Error("invalid Legendre symbol result");
    return yes ? 1 : zero ? 0 : -1;
  }
  function nLength(n, nBitLength) {
    if (nBitLength !== void 0)
      anumber(nBitLength);
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field(ORDER, bitLenOrOpts, isLE2 = false, opts = {}) {
    if (ORDER <= _0n2)
      throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
    let _nbitLength = void 0;
    let _sqrt = void 0;
    let modFromBytes = false;
    let allowedLengths = void 0;
    if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
      if (opts.sqrt || isLE2)
        throw new Error("cannot specify opts in two arguments");
      const _opts = bitLenOrOpts;
      if (_opts.BITS)
        _nbitLength = _opts.BITS;
      if (_opts.sqrt)
        _sqrt = _opts.sqrt;
      if (typeof _opts.isLE === "boolean")
        isLE2 = _opts.isLE;
      if (typeof _opts.modFromBytes === "boolean")
        modFromBytes = _opts.modFromBytes;
      allowedLengths = _opts.allowedLengths;
    } else {
      if (typeof bitLenOrOpts === "number")
        _nbitLength = bitLenOrOpts;
      if (opts.sqrt)
        _sqrt = opts.sqrt;
    }
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
    if (BYTES > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let sqrtP;
    const f2 = Object.freeze({
      ORDER,
      isLE: isLE2,
      BITS,
      BYTES,
      MASK: bitMask(BITS),
      ZERO: _0n2,
      ONE: _1n2,
      allowedLengths,
      create: (num) => mod(num, ORDER),
      isValid: (num) => {
        if (typeof num !== "bigint")
          throw new Error("invalid field element: expected bigint, got " + typeof num);
        return _0n2 <= num && num < ORDER;
      },
      is0: (num) => num === _0n2,
      // is valid and invertible
      isValidNot0: (num) => !f2.is0(num) && f2.isValid(num),
      isOdd: (num) => (num & _1n2) === _1n2,
      neg: (num) => mod(-num, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num) => mod(num * num, ORDER),
      add: (lhs, rhs) => mod(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
      pow: (num, power) => FpPow(f2, num, power),
      div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
      // Same as above, but doesn't normalize
      sqrN: (num) => num * num,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num) => invert(num, ORDER),
      sqrt: _sqrt || ((n) => {
        if (!sqrtP)
          sqrtP = FpSqrt(ORDER);
        return sqrtP(f2, n);
      }),
      toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
      fromBytes: (bytes, skipValidation = true) => {
        if (allowedLengths) {
          if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
            throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
          }
          const padded = new Uint8Array(BYTES);
          padded.set(bytes, isLE2 ? 0 : padded.length - bytes.length);
          bytes = padded;
        }
        if (bytes.length !== BYTES)
          throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
        let scalar = isLE2 ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
        if (modFromBytes)
          scalar = mod(scalar, ORDER);
        if (!skipValidation) {
          if (!f2.isValid(scalar))
            throw new Error("invalid field element: outside of range 0..ORDER");
        }
        return scalar;
      },
      // TODO: we don't need it here, move out to separate fn
      invertBatch: (lst) => FpInvertBatch(f2, lst),
      // We can't move this out because Fp6, Fp12 implement it
      // and it's unclear what to return in there.
      cmov: (a, b, c) => c ? b : a
    });
    return Object.freeze(f2);
  }
  function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== "bigint")
      throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
  }
  function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
  }
  function mapHashToField(key, fieldOrder, isLE2 = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    if (len < 16 || len < minLen || len > 1024)
      throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
    const num = isLE2 ? bytesToNumberLE(key) : bytesToNumberBE(key);
    const reduced = mod(num, fieldOrder - _1n2) + _1n2;
    return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
  }

  // node_modules/@noble/curves/esm/abstract/curve.js
  var _0n3 = BigInt(0);
  var _1n3 = BigInt(1);
  function negateCt(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
  }
  function normalizeZ(c, points) {
    const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));
    return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
  }
  function validateW(W, bits) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
      throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
  }
  function calcWOpts(W, scalarBits) {
    validateW(W, scalarBits);
    const windows = Math.ceil(scalarBits / W) + 1;
    const windowSize = 2 ** (W - 1);
    const maxNumber = 2 ** W;
    const mask2 = bitMask(W);
    const shiftBy = BigInt(W);
    return { windows, windowSize, mask: mask2, maxNumber, shiftBy };
  }
  function calcOffsets(n, window2, wOpts) {
    const { windowSize, mask: mask2, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n & mask2);
    let nextN = n >> shiftBy;
    if (wbits > windowSize) {
      wbits -= maxNumber;
      nextN += _1n3;
    }
    const offsetStart = window2 * windowSize;
    const offset2 = offsetStart + Math.abs(wbits) - 1;
    const isZero = wbits === 0;
    const isNeg = wbits < 0;
    const isNegF = window2 % 2 !== 0;
    const offsetF = offsetStart;
    return { nextN, offset: offset2, isZero, isNeg, isNegF, offsetF };
  }
  function validateMSMPoints(points, c) {
    if (!Array.isArray(points))
      throw new Error("array expected");
    points.forEach((p, i) => {
      if (!(p instanceof c))
        throw new Error("invalid point at index " + i);
    });
  }
  function validateMSMScalars(scalars, field) {
    if (!Array.isArray(scalars))
      throw new Error("array of scalars expected");
    scalars.forEach((s, i) => {
      if (!field.isValid(s))
        throw new Error("invalid scalar at index " + i);
    });
  }
  var pointPrecomputes = /* @__PURE__ */ new WeakMap();
  var pointWindowSizes = /* @__PURE__ */ new WeakMap();
  function getW(P) {
    return pointWindowSizes.get(P) || 1;
  }
  function assert0(n) {
    if (n !== _0n3)
      throw new Error("invalid wNAF");
  }
  var wNAF = class {
    // Parametrized with a given Point class (not individual point)
    constructor(Point, bits) {
      this.BASE = Point.BASE;
      this.ZERO = Point.ZERO;
      this.Fn = Point.Fn;
      this.bits = bits;
    }
    // non-const time multiplication ladder
    _unsafeLadder(elm, n, p = this.ZERO) {
      let d = elm;
      while (n > _0n3) {
        if (n & _1n3)
          p = p.add(d);
        d = d.double();
        n >>= _1n3;
      }
      return p;
    }
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param point Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(point, W) {
      const { windows, windowSize } = calcWOpts(W, this.bits);
      const points = [];
      let p = point;
      let base = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    }
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * More compact implementation:
     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      if (!this.Fn.isValid(n))
        throw new Error("invalid scalar");
      let p = this.ZERO;
      let f2 = this.BASE;
      const wo = calcWOpts(W, this.bits);
      for (let window2 = 0; window2 < wo.windows; window2++) {
        const { nextN, offset: offset2, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
        n = nextN;
        if (isZero) {
          f2 = f2.add(negateCt(isNegF, precomputes[offsetF]));
        } else {
          p = p.add(negateCt(isNeg, precomputes[offset2]));
        }
      }
      assert0(n);
      return { p, f: f2 };
    }
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
      const wo = calcWOpts(W, this.bits);
      for (let window2 = 0; window2 < wo.windows; window2++) {
        if (n === _0n3)
          break;
        const { nextN, offset: offset2, isZero, isNeg } = calcOffsets(n, window2, wo);
        n = nextN;
        if (isZero) {
          continue;
        } else {
          const item = precomputes[offset2];
          acc = acc.add(isNeg ? item.negate() : item);
        }
      }
      assert0(n);
      return acc;
    }
    getPrecomputes(W, point, transform) {
      let comp = pointPrecomputes.get(point);
      if (!comp) {
        comp = this.precomputeWindow(point, W);
        if (W !== 1) {
          if (typeof transform === "function")
            comp = transform(comp);
          pointPrecomputes.set(point, comp);
        }
      }
      return comp;
    }
    cached(point, scalar, transform) {
      const W = getW(point);
      return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
    }
    unsafe(point, scalar, transform, prev) {
      const W = getW(point);
      if (W === 1)
        return this._unsafeLadder(point, scalar, prev);
      return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
    }
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    createCache(P, W) {
      validateW(W, this.bits);
      pointWindowSizes.set(P, W);
      pointPrecomputes.delete(P);
    }
    hasCache(elm) {
      return getW(elm) !== 1;
    }
  };
  function mulEndoUnsafe(Point, point, k1, k2) {
    let acc = point;
    let p1 = Point.ZERO;
    let p2 = Point.ZERO;
    while (k1 > _0n3 || k2 > _0n3) {
      if (k1 & _1n3)
        p1 = p1.add(acc);
      if (k2 & _1n3)
        p2 = p2.add(acc);
      acc = acc.double();
      k1 >>= _1n3;
      k2 >>= _1n3;
    }
    return { p1, p2 };
  }
  function pippenger(c, fieldN, points, scalars) {
    validateMSMPoints(points, c);
    validateMSMScalars(scalars, fieldN);
    const plength = points.length;
    const slength = scalars.length;
    if (plength !== slength)
      throw new Error("arrays of points and scalars must have equal length");
    const zero = c.ZERO;
    const wbits = bitLen(BigInt(plength));
    let windowSize = 1;
    if (wbits > 12)
      windowSize = wbits - 3;
    else if (wbits > 4)
      windowSize = wbits - 2;
    else if (wbits > 0)
      windowSize = 2;
    const MASK = bitMask(windowSize);
    const buckets = new Array(Number(MASK) + 1).fill(zero);
    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    let sum = zero;
    for (let i = lastBits; i >= 0; i -= windowSize) {
      buckets.fill(zero);
      for (let j = 0; j < slength; j++) {
        const scalar = scalars[j];
        const wbits2 = Number(scalar >> BigInt(i) & MASK);
        buckets[wbits2] = buckets[wbits2].add(points[j]);
      }
      let resI = zero;
      for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
        sumI = sumI.add(buckets[j]);
        resI = resI.add(sumI);
      }
      sum = sum.add(resI);
      if (i !== 0)
        for (let j = 0; j < windowSize; j++)
          sum = sum.double();
    }
    return sum;
  }
  function createField(order, field, isLE2) {
    if (field) {
      if (field.ORDER !== order)
        throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
      validateField(field);
      return field;
    } else {
      return Field(order, { isLE: isLE2 });
    }
  }
  function _createCurveFields(type2, CURVE, curveOpts = {}, FpFnLE) {
    if (FpFnLE === void 0)
      FpFnLE = type2 === "edwards";
    if (!CURVE || typeof CURVE !== "object")
      throw new Error(`expected valid ${type2} CURVE object`);
    for (const p of ["p", "n", "h"]) {
      const val = CURVE[p];
      if (!(typeof val === "bigint" && val > _0n3))
        throw new Error(`CURVE.${p} must be positive bigint`);
    }
    const Fp2 = createField(CURVE.p, curveOpts.Fp, FpFnLE);
    const Fn2 = createField(CURVE.n, curveOpts.Fn, FpFnLE);
    const _b = type2 === "weierstrass" ? "b" : "d";
    const params = ["Gx", "Gy", "a", _b];
    for (const p of params) {
      if (!Fp2.isValid(CURVE[p]))
        throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
    }
    CURVE = Object.freeze(Object.assign({}, CURVE));
    return { CURVE, Fp: Fp2, Fn: Fn2 };
  }

  // node_modules/@noble/curves/esm/abstract/edwards.js
  var _0n4 = BigInt(0);
  var _1n4 = BigInt(1);
  var _2n2 = BigInt(2);
  var _8n2 = BigInt(8);
  function isEdValidXY(Fp2, CURVE, x, y) {
    const x2 = Fp2.sqr(x);
    const y2 = Fp2.sqr(y);
    const left = Fp2.add(Fp2.mul(CURVE.a, x2), y2);
    const right = Fp2.add(Fp2.ONE, Fp2.mul(CURVE.d, Fp2.mul(x2, y2)));
    return Fp2.eql(left, right);
  }
  function edwards(params, extraOpts = {}) {
    const validated = _createCurveFields("edwards", params, extraOpts, extraOpts.FpFnLE);
    const { Fp: Fp2, Fn: Fn2 } = validated;
    let CURVE = validated.CURVE;
    const { h: cofactor } = CURVE;
    _validateObject(extraOpts, {}, { uvRatio: "function" });
    const MASK = _2n2 << BigInt(Fn2.BYTES * 8) - _1n4;
    const modP = (n) => Fp2.create(n);
    const uvRatio2 = extraOpts.uvRatio || ((u, v) => {
      try {
        return { isValid: true, value: Fp2.sqrt(Fp2.div(u, v)) };
      } catch (e) {
        return { isValid: false, value: _0n4 };
      }
    });
    if (!isEdValidXY(Fp2, CURVE, CURVE.Gx, CURVE.Gy))
      throw new Error("bad curve params: generator point");
    function acoord(title, n, banZero = false) {
      const min = banZero ? _1n4 : _0n4;
      aInRange("coordinate " + title, n, min, MASK);
      return n;
    }
    function aextpoint(other) {
      if (!(other instanceof Point))
        throw new Error("ExtendedPoint expected");
    }
    const toAffineMemo = memoized((p, iz) => {
      const { X, Y, Z } = p;
      const is0 = p.is0();
      if (iz == null)
        iz = is0 ? _8n2 : Fp2.inv(Z);
      const x = modP(X * iz);
      const y = modP(Y * iz);
      const zz = Fp2.mul(Z, iz);
      if (is0)
        return { x: _0n4, y: _1n4 };
      if (zz !== _1n4)
        throw new Error("invZ was invalid");
      return { x, y };
    });
    const assertValidMemo = memoized((p) => {
      const { a, d } = CURVE;
      if (p.is0())
        throw new Error("bad point: ZERO");
      const { X, Y, Z, T } = p;
      const X2 = modP(X * X);
      const Y2 = modP(Y * Y);
      const Z2 = modP(Z * Z);
      const Z4 = modP(Z2 * Z2);
      const aX2 = modP(X2 * a);
      const left = modP(Z2 * modP(aX2 + Y2));
      const right = modP(Z4 + modP(d * modP(X2 * Y2)));
      if (left !== right)
        throw new Error("bad point: equation left != right (1)");
      const XY = modP(X * Y);
      const ZT = modP(Z * T);
      if (XY !== ZT)
        throw new Error("bad point: equation left != right (2)");
      return true;
    });
    class Point {
      constructor(X, Y, Z, T) {
        this.X = acoord("x", X);
        this.Y = acoord("y", Y);
        this.Z = acoord("z", Z, true);
        this.T = acoord("t", T);
        Object.freeze(this);
      }
      static CURVE() {
        return CURVE;
      }
      static fromAffine(p) {
        if (p instanceof Point)
          throw new Error("extended point not allowed");
        const { x, y } = p || {};
        acoord("x", x);
        acoord("y", y);
        return new Point(x, y, _1n4, modP(x * y));
      }
      // Uses algo from RFC8032 5.1.3.
      static fromBytes(bytes, zip215 = false) {
        const len = Fp2.BYTES;
        const { a, d } = CURVE;
        bytes = copyBytes(_abytes2(bytes, len, "point"));
        _abool2(zip215, "zip215");
        const normed = copyBytes(bytes);
        const lastByte = bytes[len - 1];
        normed[len - 1] = lastByte & ~128;
        const y = bytesToNumberLE(normed);
        const max = zip215 ? MASK : Fp2.ORDER;
        aInRange("point.y", y, _0n4, max);
        const y2 = modP(y * y);
        const u = modP(y2 - _1n4);
        const v = modP(d * y2 - a);
        let { isValid, value: x } = uvRatio2(u, v);
        if (!isValid)
          throw new Error("bad point: invalid y coordinate");
        const isXOdd = (x & _1n4) === _1n4;
        const isLastByteOdd = (lastByte & 128) !== 0;
        if (!zip215 && x === _0n4 && isLastByteOdd)
          throw new Error("bad point: x=0 and x_0=1");
        if (isLastByteOdd !== isXOdd)
          x = modP(-x);
        return Point.fromAffine({ x, y });
      }
      static fromHex(bytes, zip215 = false) {
        return Point.fromBytes(ensureBytes("point", bytes), zip215);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      precompute(windowSize = 8, isLazy = true) {
        wnaf.createCache(this, windowSize);
        if (!isLazy)
          this.multiply(_2n2);
        return this;
      }
      // Useful in fromAffine() - not for fromBytes(), which always created valid points.
      assertValidity() {
        assertValidMemo(this);
      }
      // Compare one point to another.
      equals(other) {
        aextpoint(other);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const { X: X2, Y: Y2, Z: Z2 } = other;
        const X1Z2 = modP(X1 * Z2);
        const X2Z1 = modP(X2 * Z1);
        const Y1Z2 = modP(Y1 * Z2);
        const Y2Z1 = modP(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      is0() {
        return this.equals(Point.ZERO);
      }
      negate() {
        return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));
      }
      // Fast algo for doubling Extended Point.
      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
      // Cost: 4M + 4S + 1*a + 6add + 1*2.
      double() {
        const { a } = CURVE;
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const A = modP(X1 * X1);
        const B = modP(Y1 * Y1);
        const C = modP(_2n2 * modP(Z1 * Z1));
        const D = modP(a * A);
        const x1y1 = X1 + Y1;
        const E = modP(modP(x1y1 * x1y1) - A - B);
        const G = D + B;
        const F = G - C;
        const H = D - B;
        const X3 = modP(E * F);
        const Y3 = modP(G * H);
        const T3 = modP(E * H);
        const Z3 = modP(F * G);
        return new Point(X3, Y3, Z3, T3);
      }
      // Fast algo for adding 2 Extended Points.
      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
      // Cost: 9M + 1*a + 1*d + 7add.
      add(other) {
        aextpoint(other);
        const { a, d } = CURVE;
        const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
        const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
        const A = modP(X1 * X2);
        const B = modP(Y1 * Y2);
        const C = modP(T1 * d * T2);
        const D = modP(Z1 * Z2);
        const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
        const F = D - C;
        const G = D + C;
        const H = modP(B - a * A);
        const X3 = modP(E * F);
        const Y3 = modP(G * H);
        const T3 = modP(E * H);
        const Z3 = modP(F * G);
        return new Point(X3, Y3, Z3, T3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      // Constant-time multiplication.
      multiply(scalar) {
        if (!Fn2.isValidNot0(scalar))
          throw new Error("invalid scalar: expected 1 <= sc < curve.n");
        const { p, f: f2 } = wnaf.cached(this, scalar, (p2) => normalizeZ(Point, p2));
        return normalizeZ(Point, [p, f2])[0];
      }
      // Non-constant-time multiplication. Uses double-and-add algorithm.
      // It's faster, but should only be used when you don't care about
      // an exposed private key e.g. sig verification.
      // Does NOT allow scalars higher than CURVE.n.
      // Accepts optional accumulator to merge with multiply (important for sparse scalars)
      multiplyUnsafe(scalar, acc = Point.ZERO) {
        if (!Fn2.isValid(scalar))
          throw new Error("invalid scalar: expected 0 <= sc < curve.n");
        if (scalar === _0n4)
          return Point.ZERO;
        if (this.is0() || scalar === _1n4)
          return this;
        return wnaf.unsafe(this, scalar, (p) => normalizeZ(Point, p), acc);
      }
      // Checks if point is of small order.
      // If you add something to small order point, you will have "dirty"
      // point with torsion component.
      // Multiplies point by cofactor and checks if the result is 0.
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      // Multiplies point by curve order and checks if the result is 0.
      // Returns `false` is the point is dirty.
      isTorsionFree() {
        return wnaf.unsafe(this, CURVE.n).is0();
      }
      // Converts Extended point to default (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      toAffine(invertedZ) {
        return toAffineMemo(this, invertedZ);
      }
      clearCofactor() {
        if (cofactor === _1n4)
          return this;
        return this.multiplyUnsafe(cofactor);
      }
      toBytes() {
        const { x, y } = this.toAffine();
        const bytes = Fp2.toBytes(y);
        bytes[bytes.length - 1] |= x & _1n4 ? 128 : 0;
        return bytes;
      }
      toHex() {
        return bytesToHex(this.toBytes());
      }
      toString() {
        return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
      }
      // TODO: remove
      get ex() {
        return this.X;
      }
      get ey() {
        return this.Y;
      }
      get ez() {
        return this.Z;
      }
      get et() {
        return this.T;
      }
      static normalizeZ(points) {
        return normalizeZ(Point, points);
      }
      static msm(points, scalars) {
        return pippenger(Point, Fn2, points, scalars);
      }
      _setWindowSize(windowSize) {
        this.precompute(windowSize);
      }
      toRawBytes() {
        return this.toBytes();
      }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n4, modP(CURVE.Gx * CURVE.Gy));
    Point.ZERO = new Point(_0n4, _1n4, _1n4, _0n4);
    Point.Fp = Fp2;
    Point.Fn = Fn2;
    const wnaf = new wNAF(Point, Fn2.BITS);
    Point.BASE.precompute(8);
    return Point;
  }
  var PrimeEdwardsPoint = class {
    constructor(ep) {
      this.ep = ep;
    }
    // Static methods that must be implemented by subclasses
    static fromBytes(_bytes) {
      notImplemented();
    }
    static fromHex(_hex) {
      notImplemented();
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    // Common implementations
    clearCofactor() {
      return this;
    }
    assertValidity() {
      this.ep.assertValidity();
    }
    toAffine(invertedZ) {
      return this.ep.toAffine(invertedZ);
    }
    toHex() {
      return bytesToHex(this.toBytes());
    }
    toString() {
      return this.toHex();
    }
    isTorsionFree() {
      return true;
    }
    isSmallOrder() {
      return false;
    }
    add(other) {
      this.assertSame(other);
      return this.init(this.ep.add(other.ep));
    }
    subtract(other) {
      this.assertSame(other);
      return this.init(this.ep.subtract(other.ep));
    }
    multiply(scalar) {
      return this.init(this.ep.multiply(scalar));
    }
    multiplyUnsafe(scalar) {
      return this.init(this.ep.multiplyUnsafe(scalar));
    }
    double() {
      return this.init(this.ep.double());
    }
    negate() {
      return this.init(this.ep.negate());
    }
    precompute(windowSize, isLazy) {
      return this.init(this.ep.precompute(windowSize, isLazy));
    }
    /** @deprecated use `toBytes` */
    toRawBytes() {
      return this.toBytes();
    }
  };
  function eddsa(Point, cHash, eddsaOpts = {}) {
    if (typeof cHash !== "function")
      throw new Error('"hash" function param is required');
    _validateObject(eddsaOpts, {}, {
      adjustScalarBytes: "function",
      randomBytes: "function",
      domain: "function",
      prehash: "function",
      mapToCurve: "function"
    });
    const { prehash } = eddsaOpts;
    const { BASE: BASE2, Fp: Fp2, Fn: Fn2 } = Point;
    const randomBytes2 = eddsaOpts.randomBytes || randomBytes;
    const adjustScalarBytes2 = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
    const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
      _abool2(phflag, "phflag");
      if (ctx.length || phflag)
        throw new Error("Contexts/pre-hash are not supported");
      return data;
    });
    function modN_LE(hash) {
      return Fn2.create(bytesToNumberLE(hash));
    }
    function getPrivateScalar(key) {
      const len = lengths.secretKey;
      key = ensureBytes("private key", key, len);
      const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
      const head = adjustScalarBytes2(hashed.slice(0, len));
      const prefix = hashed.slice(len, 2 * len);
      const scalar = modN_LE(head);
      return { head, prefix, scalar };
    }
    function getExtendedPublicKey(secretKey) {
      const { head, prefix, scalar } = getPrivateScalar(secretKey);
      const point = BASE2.multiply(scalar);
      const pointBytes = point.toBytes();
      return { head, prefix, scalar, point, pointBytes };
    }
    function getPublicKey2(secretKey) {
      return getExtendedPublicKey(secretKey).pointBytes;
    }
    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
      const msg = concatBytes(...msgs);
      return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
    }
    function sign2(msg, secretKey, options = {}) {
      msg = ensureBytes("message", msg);
      if (prehash)
        msg = prehash(msg);
      const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
      const r = hashDomainToScalar(options.context, prefix, msg);
      const R = BASE2.multiply(r).toBytes();
      const k = hashDomainToScalar(options.context, R, pointBytes, msg);
      const s = Fn2.create(r + k * scalar);
      if (!Fn2.isValid(s))
        throw new Error("sign failed: invalid s");
      const rs = concatBytes(R, Fn2.toBytes(s));
      return _abytes2(rs, lengths.signature, "result");
    }
    const verifyOpts = { zip215: true };
    function verify2(sig, msg, publicKey3, options = verifyOpts) {
      const { context, zip215 } = options;
      const len = lengths.signature;
      sig = ensureBytes("signature", sig, len);
      msg = ensureBytes("message", msg);
      publicKey3 = ensureBytes("publicKey", publicKey3, lengths.publicKey);
      if (zip215 !== void 0)
        _abool2(zip215, "zip215");
      if (prehash)
        msg = prehash(msg);
      const mid = len / 2;
      const r = sig.subarray(0, mid);
      const s = bytesToNumberLE(sig.subarray(mid, len));
      let A, R, SB;
      try {
        A = Point.fromBytes(publicKey3, zip215);
        R = Point.fromBytes(r, zip215);
        SB = BASE2.multiplyUnsafe(s);
      } catch (error) {
        return false;
      }
      if (!zip215 && A.isSmallOrder())
        return false;
      const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
      const RkA = R.add(A.multiplyUnsafe(k));
      return RkA.subtract(SB).clearCofactor().is0();
    }
    const _size = Fp2.BYTES;
    const lengths = {
      secretKey: _size,
      publicKey: _size,
      signature: 2 * _size,
      seed: _size
    };
    function randomSecretKey(seed = randomBytes2(lengths.seed)) {
      return _abytes2(seed, lengths.seed, "seed");
    }
    function keygen(seed) {
      const secretKey = utils.randomSecretKey(seed);
      return { secretKey, publicKey: getPublicKey2(secretKey) };
    }
    function isValidSecretKey(key) {
      return isBytes(key) && key.length === Fn2.BYTES;
    }
    function isValidPublicKey(key, zip215) {
      try {
        return !!Point.fromBytes(key, zip215);
      } catch (error) {
        return false;
      }
    }
    const utils = {
      getExtendedPublicKey,
      randomSecretKey,
      isValidSecretKey,
      isValidPublicKey,
      /**
       * Converts ed public key to x public key. Uses formula:
       * - ed25519:
       *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
       *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
       * - ed448:
       *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
       *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
       */
      toMontgomery(publicKey3) {
        const { y } = Point.fromBytes(publicKey3);
        const size = lengths.publicKey;
        const is25519 = size === 32;
        if (!is25519 && size !== 57)
          throw new Error("only defined for 25519 and 448");
        const u = is25519 ? Fp2.div(_1n4 + y, _1n4 - y) : Fp2.div(y - _1n4, y + _1n4);
        return Fp2.toBytes(u);
      },
      toMontgomerySecret(secretKey) {
        const size = lengths.secretKey;
        _abytes2(secretKey, size);
        const hashed = cHash(secretKey.subarray(0, size));
        return adjustScalarBytes2(hashed).subarray(0, size);
      },
      /** @deprecated */
      randomPrivateKey: randomSecretKey,
      /** @deprecated */
      precompute(windowSize = 8, point = Point.BASE) {
        return point.precompute(windowSize, false);
      }
    };
    return Object.freeze({
      keygen,
      getPublicKey: getPublicKey2,
      sign: sign2,
      verify: verify2,
      utils,
      Point,
      lengths
    });
  }
  function _eddsa_legacy_opts_to_new(c) {
    const CURVE = {
      a: c.a,
      d: c.d,
      p: c.Fp.ORDER,
      n: c.n,
      h: c.h,
      Gx: c.Gx,
      Gy: c.Gy
    };
    const Fp2 = c.Fp;
    const Fn2 = Field(CURVE.n, c.nBitLength, true);
    const curveOpts = { Fp: Fp2, Fn: Fn2, uvRatio: c.uvRatio };
    const eddsaOpts = {
      randomBytes: c.randomBytes,
      adjustScalarBytes: c.adjustScalarBytes,
      domain: c.domain,
      prehash: c.prehash,
      mapToCurve: c.mapToCurve
    };
    return { CURVE, curveOpts, hash: c.hash, eddsaOpts };
  }
  function _eddsa_new_output_to_legacy(c, eddsa2) {
    const Point = eddsa2.Point;
    const legacy = Object.assign({}, eddsa2, {
      ExtendedPoint: Point,
      CURVE: c,
      nBitLength: Point.Fn.BITS,
      nByteLength: Point.Fn.BYTES
    });
    return legacy;
  }
  function twistedEdwards(c) {
    const { CURVE, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
    const Point = edwards(CURVE, curveOpts);
    const EDDSA = eddsa(Point, hash, eddsaOpts);
    return _eddsa_new_output_to_legacy(c, EDDSA);
  }

  // node_modules/@noble/curves/esm/ed25519.js
  var _0n5 = /* @__PURE__ */ BigInt(0);
  var _1n5 = BigInt(1);
  var _2n3 = BigInt(2);
  var _3n2 = BigInt(3);
  var _5n2 = BigInt(5);
  var _8n3 = BigInt(8);
  var ed25519_CURVE_p = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
  var ed25519_CURVE = /* @__PURE__ */ (() => ({
    p: ed25519_CURVE_p,
    n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
    h: _8n3,
    a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
    d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
    Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
    Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
  }))();
  function ed25519_pow_2_252_3(x) {
    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
    const P = ed25519_CURVE_p;
    const x2 = x * x % P;
    const b2 = x2 * x % P;
    const b4 = pow2(b2, _2n3, P) * b2 % P;
    const b5 = pow2(b4, _1n5, P) * x % P;
    const b10 = pow2(b5, _5n2, P) * b5 % P;
    const b20 = pow2(b10, _10n, P) * b10 % P;
    const b40 = pow2(b20, _20n, P) * b20 % P;
    const b80 = pow2(b40, _40n, P) * b40 % P;
    const b160 = pow2(b80, _80n, P) * b80 % P;
    const b240 = pow2(b160, _80n, P) * b80 % P;
    const b250 = pow2(b240, _10n, P) * b10 % P;
    const pow_p_5_8 = pow2(b250, _2n3, P) * x % P;
    return { pow_p_5_8, b2 };
  }
  function adjustScalarBytes(bytes) {
    bytes[0] &= 248;
    bytes[31] &= 127;
    bytes[31] |= 64;
    return bytes;
  }
  var ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
  function uvRatio(u, v) {
    const P = ed25519_CURVE_p;
    const v32 = mod(v * v * v, P);
    const v7 = mod(v32 * v32 * v, P);
    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
    let x = mod(u * v32 * pow, P);
    const vx2 = mod(v * x * x, P);
    const root1 = x;
    const root2 = mod(x * ED25519_SQRT_M1, P);
    const useRoot1 = vx2 === u;
    const useRoot2 = vx2 === mod(-u, P);
    const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);
    if (useRoot1)
      x = root1;
    if (useRoot2 || noRoot)
      x = root2;
    if (isNegativeLE(x, P))
      x = mod(-x, P);
    return { isValid: useRoot1 || useRoot2, value: x };
  }
  var Fp = /* @__PURE__ */ (() => Field(ed25519_CURVE.p, { isLE: true }))();
  var Fn = /* @__PURE__ */ (() => Field(ed25519_CURVE.n, { isLE: true }))();
  var ed25519Defaults = /* @__PURE__ */ (() => ({
    ...ed25519_CURVE,
    Fp,
    hash: sha512,
    adjustScalarBytes,
    // dom2
    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
    // Constant-time, u/√v
    uvRatio
  }))();
  var ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();
  var SQRT_M1 = ED25519_SQRT_M1;
  var SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
  var INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
  var ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
  var D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
  var invertSqrt = (number2) => uvRatio(_1n5, number2);
  var MAX_255B = /* @__PURE__ */ BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  var bytes255ToNumberLE = (bytes) => ed25519.Point.Fp.create(bytesToNumberLE(bytes) & MAX_255B);
  function calcElligatorRistrettoMap(r0) {
    const { d } = ed25519_CURVE;
    const P = ed25519_CURVE_p;
    const mod2 = (n) => Fp.create(n);
    const r = mod2(SQRT_M1 * r0 * r0);
    const Ns = mod2((r + _1n5) * ONE_MINUS_D_SQ);
    let c = BigInt(-1);
    const D = mod2((c - d * r) * mod2(r + d));
    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
    let s_ = mod2(s * r0);
    if (!isNegativeLE(s_, P))
      s_ = mod2(-s_);
    if (!Ns_D_is_sq)
      s = s_;
    if (!Ns_D_is_sq)
      c = r;
    const Nt = mod2(c * (r - _1n5) * D_MINUS_ONE_SQ - D);
    const s2 = s * s;
    const W0 = mod2((s + s) * D);
    const W1 = mod2(Nt * SQRT_AD_MINUS_ONE);
    const W2 = mod2(_1n5 - s2);
    const W3 = mod2(_1n5 + s2);
    return new ed25519.Point(mod2(W0 * W3), mod2(W2 * W1), mod2(W1 * W3), mod2(W0 * W2));
  }
  function ristretto255_map(bytes) {
    abytes(bytes, 64);
    const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));
    const R1 = calcElligatorRistrettoMap(r1);
    const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));
    const R2 = calcElligatorRistrettoMap(r2);
    return new _RistrettoPoint(R1.add(R2));
  }
  var _RistrettoPoint = class __RistrettoPoint extends PrimeEdwardsPoint {
    constructor(ep) {
      super(ep);
    }
    static fromAffine(ap) {
      return new __RistrettoPoint(ed25519.Point.fromAffine(ap));
    }
    assertSame(other) {
      if (!(other instanceof __RistrettoPoint))
        throw new Error("RistrettoPoint expected");
    }
    init(ep) {
      return new __RistrettoPoint(ep);
    }
    /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
    static hashToCurve(hex) {
      return ristretto255_map(ensureBytes("ristrettoHash", hex, 64));
    }
    static fromBytes(bytes) {
      abytes(bytes, 32);
      const { a, d } = ed25519_CURVE;
      const P = ed25519_CURVE_p;
      const mod2 = (n) => Fp.create(n);
      const s = bytes255ToNumberLE(bytes);
      if (!equalBytes(Fp.toBytes(s), bytes) || isNegativeLE(s, P))
        throw new Error("invalid ristretto255 encoding 1");
      const s2 = mod2(s * s);
      const u1 = mod2(_1n5 + a * s2);
      const u2 = mod2(_1n5 - a * s2);
      const u1_2 = mod2(u1 * u1);
      const u2_2 = mod2(u2 * u2);
      const v = mod2(a * d * u1_2 - u2_2);
      const { isValid, value: I } = invertSqrt(mod2(v * u2_2));
      const Dx = mod2(I * u2);
      const Dy = mod2(I * Dx * v);
      let x = mod2((s + s) * Dx);
      if (isNegativeLE(x, P))
        x = mod2(-x);
      const y = mod2(u1 * Dy);
      const t = mod2(x * y);
      if (!isValid || isNegativeLE(t, P) || y === _0n5)
        throw new Error("invalid ristretto255 encoding 2");
      return new __RistrettoPoint(new ed25519.Point(x, y, _1n5, t));
    }
    /**
     * Converts ristretto-encoded string to ristretto point.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
     */
    static fromHex(hex) {
      return __RistrettoPoint.fromBytes(ensureBytes("ristrettoHex", hex, 32));
    }
    static msm(points, scalars) {
      return pippenger(__RistrettoPoint, ed25519.Point.Fn, points, scalars);
    }
    /**
     * Encodes ristretto point to Uint8Array.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
     */
    toBytes() {
      let { X, Y, Z, T } = this.ep;
      const P = ed25519_CURVE_p;
      const mod2 = (n) => Fp.create(n);
      const u1 = mod2(mod2(Z + Y) * mod2(Z - Y));
      const u2 = mod2(X * Y);
      const u2sq = mod2(u2 * u2);
      const { value: invsqrt } = invertSqrt(mod2(u1 * u2sq));
      const D1 = mod2(invsqrt * u1);
      const D2 = mod2(invsqrt * u2);
      const zInv = mod2(D1 * D2 * T);
      let D;
      if (isNegativeLE(T * zInv, P)) {
        let _x = mod2(Y * SQRT_M1);
        let _y = mod2(X * SQRT_M1);
        X = _x;
        Y = _y;
        D = mod2(D1 * INVSQRT_A_MINUS_D);
      } else {
        D = D2;
      }
      if (isNegativeLE(X * zInv, P))
        Y = mod2(-Y);
      let s = mod2((Z - Y) * D);
      if (isNegativeLE(s, P))
        s = mod2(-s);
      return Fp.toBytes(s);
    }
    /**
     * Compares two Ristretto points.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
     */
    equals(other) {
      this.assertSame(other);
      const { X: X1, Y: Y1 } = this.ep;
      const { X: X2, Y: Y2 } = other.ep;
      const mod2 = (n) => Fp.create(n);
      const one = mod2(X1 * Y2) === mod2(Y1 * X2);
      const two = mod2(Y1 * Y2) === mod2(X1 * X2);
      return one || two;
    }
    is0() {
      return this.equals(__RistrettoPoint.ZERO);
    }
  };
  _RistrettoPoint.BASE = /* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.BASE))();
  _RistrettoPoint.ZERO = /* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.ZERO))();
  _RistrettoPoint.Fp = /* @__PURE__ */ (() => Fp)();
  _RistrettoPoint.Fn = /* @__PURE__ */ (() => Fn)();

  // node_modules/@solana/web3.js/lib/index.browser.esm.js
  var import_bn = __toESM(require_bn());
  var import_bs58 = __toESM(require_bs58());

  // node_modules/@noble/hashes/esm/sha256.js
  var sha2562 = sha256;

  // node_modules/@solana/web3.js/lib/index.browser.esm.js
  var import_borsh = __toESM(require_lib());
  var BufferLayout = __toESM(require_Layout());
  var import_buffer_layout = __toESM(require_Layout());

  // node_modules/@solana/web3.js/node_modules/@solana/errors/dist/index.browser.mjs
  var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;
  var SOLANA_ERROR__INVALID_NONCE = 2;
  var SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;
  var SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;
  var SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;
  var SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;
  var SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;
  var SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;
  var SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;
  var SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;
  var SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;
  var SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;
  var SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;
  var SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;
  var SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;
  var SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;
  var SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 28e5;
  var SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;
  var SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;
  var SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;
  var SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;
  var SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;
  var SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;
  var SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;
  var SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;
  var SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;
  var SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;
  var SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011;
  var SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 323e4;
  var SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;
  var SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;
  var SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;
  var SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;
  var SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 361e4;
  var SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;
  var SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;
  var SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;
  var SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;
  var SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;
  var SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;
  var SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;
  var SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611e3;
  var SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704e3;
  var SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;
  var SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;
  var SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;
  var SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;
  var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128e3;
  var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;
  var SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;
  var SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615e3;
  var SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;
  var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;
  var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;
  var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;
  var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;
  var SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;
  var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;
  var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;
  var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;
  var SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;
  var SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;
  var SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;
  var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;
  var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;
  var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;
  var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;
  var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;
  var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;
  var SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;
  var SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;
  var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;
  var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;
  var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;
  var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;
  var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;
  var SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;
  var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;
  var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;
  var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;
  var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;
  var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;
  var SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;
  var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;
  var SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;
  var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;
  var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;
  var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;
  var SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;
  var SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;
  var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;
  var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;
  var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;
  var SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;
  var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;
  var SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;
  var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;
  var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;
  var SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;
  var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;
  var SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;
  var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;
  var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;
  var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;
  var SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;
  var SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508e3;
  var SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;
  var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;
  var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;
  var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;
  var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;
  var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;
  var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;
  var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;
  var SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;
  var SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;
  var SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;
  var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663e3;
  var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;
  var SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;
  var SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;
  var SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;
  var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;
  var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;
  var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;
  var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;
  var SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;
  var SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;
  var SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;
  var SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;
  var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;
  var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;
  var SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;
  var SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;
  var SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;
  var SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;
  var SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;
  var SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020;
  var SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 705e4;
  var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;
  var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;
  var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;
  var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;
  var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;
  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;
  var SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;
  var SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;
  var SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;
  var SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;
  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;
  var SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;
  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;
  var SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;
  var SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;
  var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;
  var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;
  var SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;
  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;
  var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;
  var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;
  var SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;
  var SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;
  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;
  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;
  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;
  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;
  var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;
  var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;
  var SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;
  var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;
  var SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;
  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;
  var SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;
  var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;
  var SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;
  var SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3;
  var SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;
  var SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;
  var SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;
  var SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;
  var SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;
  var SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;
  var SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;
  var SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;
  var SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;
  var SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;
  var SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;
  var SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;
  var SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;
  var SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;
  var SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;
  var SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;
  var SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;
  var SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;
  var SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;
  var SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;
  var SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;
  var SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;
  var SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 81e5;
  var SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;
  var SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;
  var SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;
  var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 819e4;
  var SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;
  var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;
  var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;
  var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;
  var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 99e5;
  var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;
  var SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;
  var SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;
  var SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;
  var SolanaErrorMessages = {
    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: "Account not found at address: $address",
    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: "Expected decoded account at address: $address",
    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: "Failed to decode account data at address: $address",
    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: "Accounts not found at addresses: $addresses",
    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: "Unable to find a viable program address bump seed.",
    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: "$putativeAddress is not a base58-encoded address.",
    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: "The `CryptoKey` must be an `Ed25519` public key.",
    [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]: "$putativeOffCurveAddress is not a base58-encoded off-curve address.",
    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: "Invalid seeds; point must fall off the Ed25519 curve.",
    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: "Program address cannot end with PDA marker.",
    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: "The network has progressed past the last block for which this transaction could have been committed.",
    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: "Codec [$codecDescription] cannot decode empty byte arrays.",
    [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
    [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: "Encoder and decoder must either both be fixed-size or variable-size.",
    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: "Expected a fixed-size codec, got a variable-size one.",
    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: "Expected a variable-size codec, got a fixed-size one.",
    [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
    [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
    [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
    [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
    [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: "Invalid literal union variant. Expected one of [$variants], got $value.",
    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: "Expected [$codecDescription] to have $expected items, got $actual.",
    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: "Invalid value $value for base $base with alphabet $alphabet.",
    [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
    [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
    [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
    [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: "No random values implementation could be found.",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: "instruction requires an uninitialized account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: "instruction tries to borrow reference for an account which is already borrowed",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "instruction left account with an outstanding borrowed reference",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: "program other than the account's owner changed the size of the account data",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: "account data too small for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: "instruction expected an executable account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: "An account does not have enough lamports to be rent-exempt",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: "Program arithmetic overflowed",
    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: "Failed to serialize or deserialize account data: $encodedData",
    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: "Builtin programs must consume compute units",
    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: "Cross-program invocation call depth too deep",
    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: "Computational budget exceeded",
    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: "custom program error: #$code",
    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: "instruction contains duplicate accounts",
    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: "instruction modifications of multiply-passed account differ",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: "executable accounts must be rent exempt",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: "instruction changed executable accounts data",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: "instruction changed the balance of an executable account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: "instruction changed executable bit of an account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: "instruction modified data of an account it does not own",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: "instruction spent from the balance of an account it does not own",
    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: "generic instruction error",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: "Provided owner is not allowed",
    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: "Account is immutable",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: "Incorrect authority provided",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: "incorrect program id for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: "insufficient funds for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: "invalid account data for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: "Invalid account owner",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: "invalid program argument",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: "program returned invalid error code",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: "invalid instruction data",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: "Failed to reallocate account data",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: "Provided seeds do not result in a valid address",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: "Accounts data allocations exceeded the maximum allowed per transaction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: "Max accounts exceeded",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: "Max instruction trace length exceeded",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: "Length of the seed is too long for address generation",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: "An account required by the instruction is missing",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: "missing required signature for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: "instruction illegally modified the program id of an account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: "insufficient account keys for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: "Cross-program invocation with unauthorized signer or writable account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: "Failed to create program execution environment",
    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: "Program failed to compile",
    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: "Program failed to complete",
    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: "instruction modified data of a read-only account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: "instruction changed the balance of a read-only account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: "Cross-program invocation reentrancy not allowed for this instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: "instruction modified rent epoch of an account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: "sum of account balances before and after instruction do not match",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: "instruction requires an initialized account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: "",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: "Unsupported program id",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: "Unsupported sysvar",
    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: "The instruction does not have any accounts.",
    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: "The instruction does not have any data.",
    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
    [SOLANA_ERROR__INVALID_NONCE]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
    [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: "Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",
    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: "Minimum context slot has not been reached",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: "Node is unhealthy; behind by $numSlotsBehind slots",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: "No snapshot",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: "Transaction simulation failed",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: "Transaction history is not available from this node",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: "Transaction signature length mismatch",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: "Transaction signature verification failure",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: "$__serverMessage",
    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: "Key pair bytes must be of length 64, got $byteLength.",
    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: "Expected private key bytes with length 32. Actual length: $actualLength.",
    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
    [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: "The provided private key does not match the provided public key.",
    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: "Lamports value must be in the range [0, 2e64-1]",
    [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: "`$value` cannot be parsed as a `BigInt`",
    [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: "$message",
    [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: "`$value` cannot be parsed as a `Number`",
    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: "No nonce account could be found at address `$nonceAccountAddress`",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: "The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]: "WebSocket was closed before payload could be added to the send buffer",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: "WebSocket connection closed",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: "WebSocket failed to connect",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: "Failed to obtain a subscription id from the server",
    [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: "Could not find an API plan for RPC method: `$method`",
    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: "HTTP error ($statusCode): $message",
    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: "The provided value does not implement the `KeyPairSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: "The provided value does not implement the `MessageModifyingSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: "The provided value does not implement the `MessagePartialSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: "The provided value does not implement any of the `MessageSigner` interfaces",
    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: "The provided value does not implement the `TransactionModifyingSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: "The provided value does not implement the `TransactionPartialSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: "The provided value does not implement the `TransactionSendingSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: "The provided value does not implement any of the `TransactionSigner` interfaces",
    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: "More than one `TransactionSendingSigner` was identified.",
    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: "No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.",
    [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
    [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: "Cannot export a non-extractable key.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: "No digest implementation could be found.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: "This runtime does not support the generation of Ed25519 key pairs.\n\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\n\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: "No signature verification implementation could be found.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: "No key generation implementation could be found.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: "No signing implementation could be found.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: "No key export implementation could be found.",
    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: "Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",
    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "Transaction processing left an account with an outstanding borrowed reference",
    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: "Account in use",
    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: "Account loaded twice",
    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: "Attempt to debit an account but found no record of a prior credit.",
    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: "Transaction loads an address table account that doesn't exist",
    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: "This transaction has already been processed",
    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: "Blockhash not found",
    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: "Loader call chain is too deep",
    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: "Transactions are currently disabled due to cluster maintenance",
    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: "Transaction contains a duplicate instruction ($index) that is not allowed",
    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: "Insufficient funds for fee",
    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: "This account may not be used to pay transaction fees",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: "Transaction contains an invalid account reference",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: "Transaction loads an address table account with invalid data",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: "Transaction address table lookup uses an invalid index",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: "Transaction loads an address table account with an invalid owner",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: "This program may not be used for executing instructions",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: "Transaction loads a writable account that cannot be written",
    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: "Transaction exceeded max loaded accounts data size cap",
    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: "Transaction requires a fee but has no signature present",
    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: "Attempt to load a program that does not exist",
    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: "ResanitizationNeeded",
    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: "Transaction failed to sanitize accounts offsets correctly",
    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: "Transaction did not pass signature verification",
    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: "Transaction locked too many accounts",
    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: "Sum of account balances before and after transaction do not match",
    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: "The transaction failed with the error `$errorName`",
    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: "Transaction version is unsupported",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: "Transaction would exceed account data limit within the block",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: "Transaction would exceed total account data limit",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: "Transaction would exceed max account limit within the block",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: "Transaction would exceed max Block Cost Limit",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: "Transaction would exceed max Vote Cost Limit",
    [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: "Attempted to sign a transaction with an address that is not a signer for it",
    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: "Transaction is missing an address at index: $index.",
    [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: "Transaction has no expected signers therefore it cannot be encoded",
    [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: "Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes",
    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: "Transaction does not have a blockhash lifetime",
    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: "Transaction is not a durable nonce transaction",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: "No fee payer set in CompiledTransaction",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: "Could not find program address at index $index",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
    [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: "Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",
    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: "Transaction is missing a fee payer.",
    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: "Transaction first instruction is not advance nonce account instruction.",
    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: "Transaction with no instructions cannot be durable nonce transaction.",
    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
    [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: "The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",
    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: "Transaction is missing signatures for addresses: $addresses.",
    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: "Transaction version must be in the range [0, 127]. `$actualVersion` given"
  };
  var START_INDEX = "i";
  var TYPE = "t";
  function getHumanReadableErrorMessage(code, context = {}) {
    const messageFormatString = SolanaErrorMessages[code];
    if (messageFormatString.length === 0) {
      return "";
    }
    let state;
    function commitStateUpTo(endIndex) {
      if (state[TYPE] === 2) {
        const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);
        fragments.push(
          variableName in context ? (
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${context[variableName]}`
          ) : `$${variableName}`
        );
      } else if (state[TYPE] === 1) {
        fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));
      }
    }
    const fragments = [];
    messageFormatString.split("").forEach((char, ii) => {
      if (ii === 0) {
        state = {
          [START_INDEX]: 0,
          [TYPE]: messageFormatString[0] === "\\" ? 0 : messageFormatString[0] === "$" ? 2 : 1
          /* Text */
        };
        return;
      }
      let nextState;
      switch (state[TYPE]) {
        case 0:
          nextState = {
            [START_INDEX]: ii,
            [TYPE]: 1
            /* Text */
          };
          break;
        case 1:
          if (char === "\\") {
            nextState = {
              [START_INDEX]: ii,
              [TYPE]: 0
              /* EscapeSequence */
            };
          } else if (char === "$") {
            nextState = {
              [START_INDEX]: ii,
              [TYPE]: 2
              /* Variable */
            };
          }
          break;
        case 2:
          if (char === "\\") {
            nextState = {
              [START_INDEX]: ii,
              [TYPE]: 0
              /* EscapeSequence */
            };
          } else if (char === "$") {
            nextState = {
              [START_INDEX]: ii,
              [TYPE]: 2
              /* Variable */
            };
          } else if (!char.match(/\w/)) {
            nextState = {
              [START_INDEX]: ii,
              [TYPE]: 1
              /* Text */
            };
          }
          break;
      }
      if (nextState) {
        if (state !== nextState) {
          commitStateUpTo(ii);
        }
        state = nextState;
      }
    });
    commitStateUpTo();
    return fragments.join("");
  }
  function getErrorMessage(code, context = {}) {
    if (true) {
      return getHumanReadableErrorMessage(code, context);
    } else {
      let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \`npx @solana/errors decode -- ${code}`;
      if (Object.keys(context).length) {
        decodingAdviceMessage += ` '${encodeContextObject(context)}'`;
      }
      return `${decodingAdviceMessage}\``;
    }
  }
  var SolanaError = class extends Error {
    constructor(...[code, contextAndErrorOptions]) {
      let context;
      let errorOptions;
      if (contextAndErrorOptions) {
        const { cause, ...contextRest } = contextAndErrorOptions;
        if (cause) {
          errorOptions = { cause };
        }
        if (Object.keys(contextRest).length > 0) {
          context = contextRest;
        }
      }
      const message = getErrorMessage(code, context);
      super(message, errorOptions);
      /**
       * Indicates the root cause of this {@link SolanaError}, if any.
       *
       * For example, a transaction error might have an instruction error as its root cause. In this
       * case, you will be able to access the instruction error on the transaction error as `cause`.
       */
      __publicField(this, "cause", this.cause);
      /**
       * Contains context that can assist in understanding or recovering from a {@link SolanaError}.
       */
      __publicField(this, "context");
      this.context = {
        __code: code,
        ...context
      };
      this.name = "SolanaError";
    }
  };

  // node_modules/@solana/web3.js/node_modules/@solana/codecs-core/dist/index.browser.mjs
  function getEncodedSize(value, encoder) {
    return "fixedSize" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);
  }
  function createEncoder(encoder) {
    return Object.freeze({
      ...encoder,
      encode: (value) => {
        const bytes = new Uint8Array(getEncodedSize(value, encoder));
        encoder.write(value, bytes, 0);
        return bytes;
      }
    });
  }
  function createDecoder(decoder) {
    return Object.freeze({
      ...decoder,
      decode: (bytes, offset2 = 0) => decoder.read(bytes, offset2)[0]
    });
  }
  function isFixedSize(codec) {
    return "fixedSize" in codec && typeof codec.fixedSize === "number";
  }
  function combineCodec(encoder, decoder) {
    if (isFixedSize(encoder) !== isFixedSize(decoder)) {
      throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);
    }
    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {
      throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {
        decoderFixedSize: decoder.fixedSize,
        encoderFixedSize: encoder.fixedSize
      });
    }
    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {
      throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {
        decoderMaxSize: decoder.maxSize,
        encoderMaxSize: encoder.maxSize
      });
    }
    return {
      ...decoder,
      ...encoder,
      decode: decoder.decode,
      encode: encoder.encode,
      read: decoder.read,
      write: encoder.write
    };
  }
  function assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset2 = 0) {
    if (bytes.length - offset2 <= 0) {
      throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {
        codecDescription
      });
    }
  }
  function assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset2 = 0) {
    const bytesLength = bytes.length - offset2;
    if (bytesLength < expected) {
      throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {
        bytesLength,
        codecDescription,
        expected
      });
    }
  }

  // node_modules/@solana/web3.js/node_modules/@solana/codecs-numbers/dist/index.browser.mjs
  function assertNumberIsBetweenForCodec(codecDescription, min, max, value) {
    if (value < min || value > max) {
      throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {
        codecDescription,
        max,
        min,
        value
      });
    }
  }
  function isLittleEndian(config) {
    return config?.endian === 1 ? false : true;
  }
  function numberEncoderFactory(input) {
    return createEncoder({
      fixedSize: input.size,
      write(value, bytes, offset2) {
        if (input.range) {
          assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);
        }
        const arrayBuffer = new ArrayBuffer(input.size);
        input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));
        bytes.set(new Uint8Array(arrayBuffer), offset2);
        return offset2 + input.size;
      }
    });
  }
  function numberDecoderFactory(input) {
    return createDecoder({
      fixedSize: input.size,
      read(bytes, offset2 = 0) {
        assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset2);
        assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset2);
        const view = new DataView(toArrayBuffer(bytes, offset2, input.size));
        return [input.get(view, isLittleEndian(input.config)), offset2 + input.size];
      }
    });
  }
  function toArrayBuffer(bytes, offset2, length) {
    const bytesOffset = bytes.byteOffset + (offset2 ?? 0);
    const bytesLength = length ?? bytes.byteLength;
    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);
  }
  var getU64Encoder = (config = {}) => numberEncoderFactory({
    config,
    name: "u64",
    range: [0n, BigInt("0xffffffffffffffff")],
    set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),
    size: 8
  });
  var getU64Decoder = (config = {}) => numberDecoderFactory({
    config,
    get: (view, le) => view.getBigUint64(0, le),
    name: "u64",
    size: 8
  });
  var getU64Codec = (config = {}) => combineCodec(getU64Encoder(config), getU64Decoder(config));

  // node_modules/superstruct/dist/index.mjs
  var StructError = class extends TypeError {
    constructor(failure, failures) {
      let cached;
      const { message, explanation, ...rest } = failure;
      const { path } = failure;
      const msg = path.length === 0 ? message : `At path: ${path.join(".")} -- ${message}`;
      super(explanation ?? msg);
      if (explanation != null)
        this.cause = msg;
      Object.assign(this, rest);
      this.name = this.constructor.name;
      this.failures = () => {
        return cached ?? (cached = [failure, ...failures()]);
      };
    }
  };
  function isIterable(x) {
    return isObject(x) && typeof x[Symbol.iterator] === "function";
  }
  function isObject(x) {
    return typeof x === "object" && x != null;
  }
  function isNonArrayObject(x) {
    return isObject(x) && !Array.isArray(x);
  }
  function print(value) {
    if (typeof value === "symbol") {
      return value.toString();
    }
    return typeof value === "string" ? JSON.stringify(value) : `${value}`;
  }
  function shiftIterator(input) {
    const { done, value } = input.next();
    return done ? void 0 : value;
  }
  function toFailure(result, context, struct6, value) {
    if (result === true) {
      return;
    } else if (result === false) {
      result = {};
    } else if (typeof result === "string") {
      result = { message: result };
    }
    const { path, branch } = context;
    const { type: type2 } = struct6;
    const { refinement, message = `Expected a value of type \`${type2}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print(value)}\`` } = result;
    return {
      value,
      type: type2,
      refinement,
      key: path[path.length - 1],
      path,
      branch,
      ...result,
      message
    };
  }
  function* toFailures(result, context, struct6, value) {
    if (!isIterable(result)) {
      result = [result];
    }
    for (const r of result) {
      const failure = toFailure(r, context, struct6, value);
      if (failure) {
        yield failure;
      }
    }
  }
  function* run(value, struct6, options = {}) {
    const { path = [], branch = [value], coerce: coerce2 = false, mask: mask2 = false } = options;
    const ctx = { path, branch, mask: mask2 };
    if (coerce2) {
      value = struct6.coercer(value, ctx);
    }
    let status = "valid";
    for (const failure of struct6.validator(value, ctx)) {
      failure.explanation = options.message;
      status = "not_valid";
      yield [failure, void 0];
    }
    for (let [k, v, s] of struct6.entries(value, ctx)) {
      const ts = run(v, s, {
        path: k === void 0 ? path : [...path, k],
        branch: k === void 0 ? branch : [...branch, v],
        coerce: coerce2,
        mask: mask2,
        message: options.message
      });
      for (const t of ts) {
        if (t[0]) {
          status = t[0].refinement != null ? "not_refined" : "not_valid";
          yield [t[0], void 0];
        } else if (coerce2) {
          v = t[1];
          if (k === void 0) {
            value = v;
          } else if (value instanceof Map) {
            value.set(k, v);
          } else if (value instanceof Set) {
            value.add(v);
          } else if (isObject(value)) {
            if (v !== void 0 || k in value)
              value[k] = v;
          }
        }
      }
    }
    if (status !== "not_valid") {
      for (const failure of struct6.refiner(value, ctx)) {
        failure.explanation = options.message;
        status = "not_refined";
        yield [failure, void 0];
      }
    }
    if (status === "valid") {
      yield [void 0, value];
    }
  }
  var Struct = class {
    constructor(props) {
      const { type: type2, schema, validator, refiner, coercer = (value) => value, entries = function* () {
      } } = props;
      this.type = type2;
      this.schema = schema;
      this.entries = entries;
      this.coercer = coercer;
      if (validator) {
        this.validator = (value, context) => {
          const result = validator(value, context);
          return toFailures(result, context, this, value);
        };
      } else {
        this.validator = () => [];
      }
      if (refiner) {
        this.refiner = (value, context) => {
          const result = refiner(value, context);
          return toFailures(result, context, this, value);
        };
      } else {
        this.refiner = () => [];
      }
    }
    /**
     * Assert that a value passes the struct's validation, throwing if it doesn't.
     */
    assert(value, message) {
      return assert(value, this, message);
    }
    /**
     * Create a value with the struct's coercion logic, then validate it.
     */
    create(value, message) {
      return create(value, this, message);
    }
    /**
     * Check if a value passes the struct's validation.
     */
    is(value) {
      return is(value, this);
    }
    /**
     * Mask a value, coercing and validating it, but returning only the subset of
     * properties defined by the struct's schema. Masking applies recursively to
     * props of `object` structs only.
     */
    mask(value, message) {
      return mask(value, this, message);
    }
    /**
     * Validate a value with the struct's validation logic, returning a tuple
     * representing the result.
     *
     * You may optionally pass `true` for the `coerce` argument to coerce
     * the value before attempting to validate it. If you do, the result will
     * contain the coerced result when successful. Also, `mask` will turn on
     * masking of the unknown `object` props recursively if passed.
     */
    validate(value, options = {}) {
      return validate(value, this, options);
    }
  };
  function assert(value, struct6, message) {
    const result = validate(value, struct6, { message });
    if (result[0]) {
      throw result[0];
    }
  }
  function create(value, struct6, message) {
    const result = validate(value, struct6, { coerce: true, message });
    if (result[0]) {
      throw result[0];
    } else {
      return result[1];
    }
  }
  function mask(value, struct6, message) {
    const result = validate(value, struct6, { coerce: true, mask: true, message });
    if (result[0]) {
      throw result[0];
    } else {
      return result[1];
    }
  }
  function is(value, struct6) {
    const result = validate(value, struct6);
    return !result[0];
  }
  function validate(value, struct6, options = {}) {
    const tuples = run(value, struct6, options);
    const tuple2 = shiftIterator(tuples);
    if (tuple2[0]) {
      const error = new StructError(tuple2[0], function* () {
        for (const t of tuples) {
          if (t[0]) {
            yield t[0];
          }
        }
      });
      return [error, void 0];
    } else {
      const v = tuple2[1];
      return [void 0, v];
    }
  }
  function define(name, validator) {
    return new Struct({ type: name, schema: null, validator });
  }
  function any() {
    return define("any", () => true);
  }
  function array(Element) {
    return new Struct({
      type: "array",
      schema: Element,
      *entries(value) {
        if (Element && Array.isArray(value)) {
          for (const [i, v] of value.entries()) {
            yield [i, v, Element];
          }
        }
      },
      coercer(value) {
        return Array.isArray(value) ? value.slice() : value;
      },
      validator(value) {
        return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;
      }
    });
  }
  function boolean() {
    return define("boolean", (value) => {
      return typeof value === "boolean";
    });
  }
  function instance(Class) {
    return define("instance", (value) => {
      return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print(value)}`;
    });
  }
  function literal(constant) {
    const description = print(constant);
    const t = typeof constant;
    return new Struct({
      type: "literal",
      schema: t === "string" || t === "number" || t === "boolean" ? constant : null,
      validator(value) {
        return value === constant || `Expected the literal \`${description}\`, but received: ${print(value)}`;
      }
    });
  }
  function never() {
    return define("never", () => false);
  }
  function nullable(struct6) {
    return new Struct({
      ...struct6,
      validator: (value, ctx) => value === null || struct6.validator(value, ctx),
      refiner: (value, ctx) => value === null || struct6.refiner(value, ctx)
    });
  }
  function number() {
    return define("number", (value) => {
      return typeof value === "number" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;
    });
  }
  function optional(struct6) {
    return new Struct({
      ...struct6,
      validator: (value, ctx) => value === void 0 || struct6.validator(value, ctx),
      refiner: (value, ctx) => value === void 0 || struct6.refiner(value, ctx)
    });
  }
  function record(Key, Value) {
    return new Struct({
      type: "record",
      schema: null,
      *entries(value) {
        if (isObject(value)) {
          for (const k in value) {
            const v = value[k];
            yield [k, k, Key];
            yield [k, v, Value];
          }
        }
      },
      validator(value) {
        return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;
      },
      coercer(value) {
        return isNonArrayObject(value) ? { ...value } : value;
      }
    });
  }
  function string() {
    return define("string", (value) => {
      return typeof value === "string" || `Expected a string, but received: ${print(value)}`;
    });
  }
  function tuple(Structs) {
    const Never = never();
    return new Struct({
      type: "tuple",
      schema: null,
      *entries(value) {
        if (Array.isArray(value)) {
          const length = Math.max(Structs.length, value.length);
          for (let i = 0; i < length; i++) {
            yield [i, value[i], Structs[i] || Never];
          }
        }
      },
      validator(value) {
        return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;
      },
      coercer(value) {
        return Array.isArray(value) ? value.slice() : value;
      }
    });
  }
  function type(schema) {
    const keys = Object.keys(schema);
    return new Struct({
      type: "type",
      schema,
      *entries(value) {
        if (isObject(value)) {
          for (const k of keys) {
            yield [k, value[k], schema[k]];
          }
        }
      },
      validator(value) {
        return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;
      },
      coercer(value) {
        return isNonArrayObject(value) ? { ...value } : value;
      }
    });
  }
  function union(Structs) {
    const description = Structs.map((s) => s.type).join(" | ");
    return new Struct({
      type: "union",
      schema: null,
      coercer(value, ctx) {
        for (const S of Structs) {
          const [error, coerced] = S.validate(value, {
            coerce: true,
            mask: ctx.mask
          });
          if (!error) {
            return coerced;
          }
        }
        return value;
      },
      validator(value, ctx) {
        const failures = [];
        for (const S of Structs) {
          const [...tuples] = run(value, S, ctx);
          const [first] = tuples;
          if (!first[0]) {
            return [];
          } else {
            for (const [failure] of tuples) {
              if (failure) {
                failures.push(failure);
              }
            }
          }
        }
        return [
          `Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`,
          ...failures
        ];
      }
    });
  }
  function unknown() {
    return define("unknown", () => true);
  }
  function coerce(struct6, condition, coercer) {
    return new Struct({
      ...struct6,
      coercer: (value, ctx) => {
        return is(value, condition) ? struct6.coercer(coercer(value, ctx), ctx) : struct6.coercer(value, ctx);
      }
    });
  }

  // node_modules/@solana/web3.js/lib/index.browser.esm.js
  var import_browser = __toESM(require_browser());

  // node_modules/rpc-websockets/dist/index.browser.mjs
  var import_buffer = __toESM(require_buffer(), 1);

  // node_modules/eventemitter3/index.mjs
  var import_index = __toESM(require_eventemitter3(), 1);

  // node_modules/rpc-websockets/dist/index.browser.mjs
  var WebSocketBrowserImpl = class extends import_index.default {
    /** Instantiate a WebSocket class
    * @constructor
    * @param {String} address - url to a websocket server
    * @param {(Object)} options - websocket options
    * @param {(String|Array)} protocols - a list of protocols
    * @return {WebSocketBrowserImpl} - returns a WebSocket instance
    */
    constructor(address, options, protocols) {
      super();
      __publicField(this, "socket");
      this.socket = new window.WebSocket(address, protocols);
      this.socket.onopen = () => this.emit("open");
      this.socket.onmessage = (event) => this.emit("message", event.data);
      this.socket.onerror = (error) => this.emit("error", error);
      this.socket.onclose = (event) => {
        this.emit("close", event.code, event.reason);
      };
    }
    /**
    * Sends data through a websocket connection
    * @method
    * @param {(String|Object)} data - data to be sent via websocket
    * @param {Object} optionsOrCallback - ws options
    * @param {Function} callback - a callback called once the data is sent
    * @return {Undefined}
    */
    send(data, optionsOrCallback, callback) {
      const cb = callback || optionsOrCallback;
      try {
        this.socket.send(data);
        cb();
      } catch (error) {
        cb(error);
      }
    }
    /**
    * Closes an underlying socket
    * @method
    * @param {Number} code - status code explaining why the connection is being closed
    * @param {String} reason - a description why the connection is closing
    * @return {Undefined}
    * @throws {Error}
    */
    close(code, reason) {
      this.socket.close(code, reason);
    }
    addEventListener(type2, listener, options) {
      this.socket.addEventListener(type2, listener, options);
    }
  };
  function WebSocket(address, options) {
    return new WebSocketBrowserImpl(address, options);
  }
  var DefaultDataPack = class {
    encode(value) {
      return JSON.stringify(value);
    }
    decode(value) {
      return JSON.parse(value);
    }
  };
  var CommonClient = class extends import_index.default {
    /**
    * Instantiate a Client class.
    * @constructor
    * @param {webSocketFactory} webSocketFactory - factory method for WebSocket
    * @param {String} address - url to a websocket server
    * @param {Object} options - ws options object with reconnect parameters
    * @param {Function} generate_request_id - custom generation request Id
    * @param {DataPack} dataPack - data pack contains encoder and decoder
    * @return {CommonClient}
    */
    constructor(webSocketFactory, address = "ws://localhost:8080", {
      autoconnect = true,
      reconnect = true,
      reconnect_interval = 1e3,
      max_reconnects = 5,
      ...rest_options
    } = {}, generate_request_id, dataPack) {
      super();
      __publicField(this, "address");
      __publicField(this, "rpc_id");
      __publicField(this, "queue");
      __publicField(this, "options");
      __publicField(this, "autoconnect");
      __publicField(this, "ready");
      __publicField(this, "reconnect");
      __publicField(this, "reconnect_timer_id");
      __publicField(this, "reconnect_interval");
      __publicField(this, "max_reconnects");
      __publicField(this, "rest_options");
      __publicField(this, "current_reconnects");
      __publicField(this, "generate_request_id");
      __publicField(this, "socket");
      __publicField(this, "webSocketFactory");
      __publicField(this, "dataPack");
      this.webSocketFactory = webSocketFactory;
      this.queue = {};
      this.rpc_id = 0;
      this.address = address;
      this.autoconnect = autoconnect;
      this.ready = false;
      this.reconnect = reconnect;
      this.reconnect_timer_id = void 0;
      this.reconnect_interval = reconnect_interval;
      this.max_reconnects = max_reconnects;
      this.rest_options = rest_options;
      this.current_reconnects = 0;
      this.generate_request_id = generate_request_id || (() => typeof this.rpc_id === "number" ? ++this.rpc_id : Number(this.rpc_id) + 1);
      if (!dataPack) this.dataPack = new DefaultDataPack();
      else this.dataPack = dataPack;
      if (this.autoconnect)
        this._connect(this.address, {
          autoconnect: this.autoconnect,
          reconnect: this.reconnect,
          reconnect_interval: this.reconnect_interval,
          max_reconnects: this.max_reconnects,
          ...this.rest_options
        });
    }
    /**
    * Connects to a defined server if not connected already.
    * @method
    * @return {Undefined}
    */
    connect() {
      if (this.socket) return;
      this._connect(this.address, {
        autoconnect: this.autoconnect,
        reconnect: this.reconnect,
        reconnect_interval: this.reconnect_interval,
        max_reconnects: this.max_reconnects,
        ...this.rest_options
      });
    }
    /**
    * Calls a registered RPC method on server.
    * @method
    * @param {String} method - RPC method name
    * @param {Object|Array} params - optional method parameters
    * @param {Number} timeout - RPC reply timeout value
    * @param {Object} ws_opts - options passed to ws
    * @return {Promise}
    */
    call(method, params, timeout, ws_opts) {
      if (!ws_opts && "object" === typeof timeout) {
        ws_opts = timeout;
        timeout = null;
      }
      return new Promise((resolve, reject) => {
        if (!this.ready) return reject(new Error("socket not ready"));
        const rpc_id = this.generate_request_id(method, params);
        const message = {
          jsonrpc: "2.0",
          method,
          params: params || void 0,
          id: rpc_id
        };
        this.socket.send(this.dataPack.encode(message), ws_opts, (error) => {
          if (error) return reject(error);
          this.queue[rpc_id] = { promise: [resolve, reject] };
          if (timeout) {
            this.queue[rpc_id].timeout = setTimeout(() => {
              delete this.queue[rpc_id];
              reject(new Error("reply timeout"));
            }, timeout);
          }
        });
      });
    }
    /**
    * Logins with the other side of the connection.
    * @method
    * @param {Object} params - Login credentials object
    * @return {Promise}
    */
    async login(params) {
      const resp = await this.call("rpc.login", params);
      if (!resp) throw new Error("authentication failed");
      return resp;
    }
    /**
    * Fetches a list of client's methods registered on server.
    * @method
    * @return {Array}
    */
    async listMethods() {
      return await this.call("__listMethods");
    }
    /**
    * Sends a JSON-RPC 2.0 notification to server.
    * @method
    * @param {String} method - RPC method name
    * @param {Object} params - optional method parameters
    * @return {Promise}
    */
    notify(method, params) {
      return new Promise((resolve, reject) => {
        if (!this.ready) return reject(new Error("socket not ready"));
        const message = {
          jsonrpc: "2.0",
          method,
          params
        };
        this.socket.send(this.dataPack.encode(message), (error) => {
          if (error) return reject(error);
          resolve();
        });
      });
    }
    /**
    * Subscribes for a defined event.
    * @method
    * @param {String|Array} event - event name
    * @return {Undefined}
    * @throws {Error}
    */
    async subscribe(event) {
      if (typeof event === "string") event = [event];
      const result = await this.call("rpc.on", event);
      if (typeof event === "string" && result[event] !== "ok")
        throw new Error(
          "Failed subscribing to an event '" + event + "' with: " + result[event]
        );
      return result;
    }
    /**
    * Unsubscribes from a defined event.
    * @method
    * @param {String|Array} event - event name
    * @return {Undefined}
    * @throws {Error}
    */
    async unsubscribe(event) {
      if (typeof event === "string") event = [event];
      const result = await this.call("rpc.off", event);
      if (typeof event === "string" && result[event] !== "ok")
        throw new Error("Failed unsubscribing from an event with: " + result);
      return result;
    }
    /**
    * Closes a WebSocket connection gracefully.
    * @method
    * @param {Number} code - socket close code
    * @param {String} data - optional data to be sent before closing
    * @return {Undefined}
    */
    close(code, data) {
      if (this.socket) this.socket.close(code || 1e3, data);
    }
    /**
    * Enable / disable automatic reconnection.
    * @method
    * @param {Boolean} reconnect - enable / disable reconnection
    * @return {Undefined}
    */
    setAutoReconnect(reconnect) {
      this.reconnect = reconnect;
    }
    /**
    * Set the interval between reconnection attempts.
    * @method
    * @param {Number} interval - reconnection interval in milliseconds
    * @return {Undefined}
    */
    setReconnectInterval(interval) {
      this.reconnect_interval = interval;
    }
    /**
    * Set the maximum number of reconnection attempts.
    * @method
    * @param {Number} max_reconnects - maximum reconnection attempts
    * @return {Undefined}
    */
    setMaxReconnects(max_reconnects) {
      this.max_reconnects = max_reconnects;
    }
    /**
    * Get the current number of reconnection attempts made.
    * @method
    * @return {Number} current reconnection attempts
    */
    getCurrentReconnects() {
      return this.current_reconnects;
    }
    /**
    * Get the maximum number of reconnection attempts.
    * @method
    * @return {Number} maximum reconnection attempts
    */
    getMaxReconnects() {
      return this.max_reconnects;
    }
    /**
    * Check if the client is currently attempting to reconnect.
    * @method
    * @return {Boolean} true if reconnection is in progress
    */
    isReconnecting() {
      return this.reconnect_timer_id !== void 0;
    }
    /**
    * Check if the client will attempt to reconnect on the next close event.
    * @method
    * @return {Boolean} true if reconnection will be attempted
    */
    willReconnect() {
      return this.reconnect && (this.max_reconnects === 0 || this.current_reconnects < this.max_reconnects);
    }
    /**
    * Connection/Message handler.
    * @method
    * @private
    * @param {String} address - WebSocket API address
    * @param {Object} options - ws options object
    * @return {Undefined}
    */
    _connect(address, options) {
      clearTimeout(this.reconnect_timer_id);
      this.socket = this.webSocketFactory(address, options);
      this.socket.addEventListener("open", () => {
        this.ready = true;
        this.emit("open");
        this.current_reconnects = 0;
      });
      this.socket.addEventListener("message", ({ data: message }) => {
        if (message instanceof ArrayBuffer)
          message = import_buffer.Buffer.from(message).toString();
        try {
          message = this.dataPack.decode(message);
        } catch (error) {
          return;
        }
        if (message.notification && this.listeners(message.notification).length) {
          if (!Object.keys(message.params).length)
            return this.emit(message.notification);
          const args = [message.notification];
          if (message.params.constructor === Object) args.push(message.params);
          else
            for (let i = 0; i < message.params.length; i++)
              args.push(message.params[i]);
          return Promise.resolve().then(() => {
            this.emit.apply(this, args);
          });
        }
        if (!this.queue[message.id]) {
          if (message.method) {
            return Promise.resolve().then(() => {
              this.emit(message.method, message?.params);
            });
          }
          return;
        }
        if ("error" in message === "result" in message)
          this.queue[message.id].promise[1](
            new Error(
              'Server response malformed. Response must include either "result" or "error", but not both.'
            )
          );
        if (this.queue[message.id].timeout)
          clearTimeout(this.queue[message.id].timeout);
        if (message.error) this.queue[message.id].promise[1](message.error);
        else this.queue[message.id].promise[0](message.result);
        delete this.queue[message.id];
      });
      this.socket.addEventListener("error", (error) => this.emit("error", error));
      this.socket.addEventListener("close", ({ code, reason }) => {
        if (this.ready)
          setTimeout(() => this.emit("close", code, reason), 0);
        this.ready = false;
        this.socket = void 0;
        if (code === 1e3) return;
        this.current_reconnects++;
        if (this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0))
          this.reconnect_timer_id = setTimeout(
            () => this._connect(address, options),
            this.reconnect_interval
          );
        else if (this.reconnect && this.max_reconnects > 0 && this.current_reconnects >= this.max_reconnects) {
          setTimeout(() => this.emit("max_reconnects_reached", code, reason), 1);
        }
      });
    }
  };

  // node_modules/@noble/hashes/esm/sha3.js
  var _0n6 = BigInt(0);
  var _1n6 = BigInt(1);
  var _2n4 = BigInt(2);
  var _7n2 = BigInt(7);
  var _256n = BigInt(256);
  var _0x71n = BigInt(113);
  var SHA3_PI = [];
  var SHA3_ROTL = [];
  var _SHA3_IOTA = [];
  for (let round = 0, R = _1n6, x = 1, y = 0; round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n6;
    for (let j = 0; j < 7; j++) {
      R = (R << _1n6 ^ (R >> _7n2) * _0x71n) % _256n;
      if (R & _2n4)
        t ^= _1n6 << (_1n6 << /* @__PURE__ */ BigInt(j)) - _1n6;
    }
    _SHA3_IOTA.push(t);
  }
  var IOTAS = split(_SHA3_IOTA, true);
  var SHA3_IOTA_H = IOTAS[0];
  var SHA3_IOTA_L = IOTAS[1];
  var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
  var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
  function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x = 0; x < 10; x++)
        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
      for (let x = 0; x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
        for (let y = 0; y < 50; y += 10) {
          s[x + y] ^= Th;
          s[x + y + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t = 0; t < 24; t++) {
        const shift = SHA3_ROTL[t];
        const Th = rotlH(curH, curL, shift);
        const Tl = rotlL(curH, curL, shift);
        const PI = SHA3_PI[t];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = Th;
        s[PI + 1] = Tl;
      }
      for (let y = 0; y < 50; y += 10) {
        for (let x = 0; x < 10; x++)
          B[x] = s[y + x];
        for (let x = 0; x < 10; x++)
          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H[round];
      s[1] ^= SHA3_IOTA_L[round];
    }
    clean(B);
  }
  var Keccak = class _Keccak extends Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      this.enableXOF = false;
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      anumber(outputLen);
      if (!(0 < blockLen && blockLen < 200))
        throw new Error("only keccak-f1600 function is supported");
      this.state = new Uint8Array(200);
      this.state32 = u32(this.state);
    }
    clone() {
      return this._cloneInto();
    }
    keccak() {
      swap32IfBE(this.state32);
      keccakP(this.state32, this.rounds);
      swap32IfBE(this.state32);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      aexists(this);
      data = toBytes(data);
      abytes(data);
      const { blockLen, state } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i = 0; i < take; i++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      aexists(this, false);
      abytes(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length; pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes) {
      anumber(bytes);
      return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
      aoutput(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      clean(this.state);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  };
  var gen = (suffix, blockLen, outputLen) => createHasher(() => new Keccak(blockLen, suffix, outputLen));
  var keccak_256 = /* @__PURE__ */ (() => gen(1, 136, 256 / 8))();

  // node_modules/@noble/hashes/esm/hmac.js
  var HMAC = class extends Hash {
    constructor(hash, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      ahash(hash);
      const key = toBytes(_key);
      this.iHash = hash.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash.create();
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54 ^ 92;
      this.oHash.update(pad);
      clean(pad);
    }
    update(buf) {
      aexists(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      aexists(this);
      abytes(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
  hmac.create = (hash, key) => new HMAC(hash, key);

  // node_modules/@noble/curves/esm/abstract/weierstrass.js
  var divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n5) / den;
  function _splitEndoScalar(k, basis, n) {
    const [[a1, b1], [a2, b2]] = basis;
    const c1 = divNearest(b2 * k, n);
    const c2 = divNearest(-b1 * k, n);
    let k1 = k - c1 * a1 - c2 * a2;
    let k2 = -c1 * b1 - c2 * b2;
    const k1neg = k1 < _0n7;
    const k2neg = k2 < _0n7;
    if (k1neg)
      k1 = -k1;
    if (k2neg)
      k2 = -k2;
    const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n7;
    if (k1 < _0n7 || k1 >= MAX_NUM || k2 < _0n7 || k2 >= MAX_NUM) {
      throw new Error("splitScalar (endomorphism): failed, k=" + k);
    }
    return { k1neg, k1, k2neg, k2 };
  }
  function validateSigFormat(format) {
    if (!["compact", "recovered", "der"].includes(format))
      throw new Error('Signature format must be "compact", "recovered", or "der"');
    return format;
  }
  function validateSigOpts(opts, def) {
    const optsn = {};
    for (let optName of Object.keys(def)) {
      optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
    }
    _abool2(optsn.lowS, "lowS");
    _abool2(optsn.prehash, "prehash");
    if (optsn.format !== void 0)
      validateSigFormat(optsn.format);
    return optsn;
  }
  var DERErr = class extends Error {
    constructor(m = "") {
      super(m);
    }
  };
  var DER = {
    // asn.1 DER encoding utils
    Err: DERErr,
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
      encode: (tag, data) => {
        const { Err: E } = DER;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length & 1)
          throw new E("tlv.encode: unpadded data");
        const dataLen = data.length / 2;
        const len = numberToHexUnpadded(dataLen);
        if (len.length / 2 & 128)
          throw new E("tlv.encode: long form length too big");
        const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
        const t = numberToHexUnpadded(tag);
        return t + lenLen + len + data;
      },
      // v - value, l - left bytes (unparsed)
      decode(tag, data) {
        const { Err: E } = DER;
        let pos = 0;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length < 2 || data[pos++] !== tag)
          throw new E("tlv.decode: wrong tlv");
        const first = data[pos++];
        const isLong = !!(first & 128);
        let length = 0;
        if (!isLong)
          length = first;
        else {
          const lenLen = first & 127;
          if (!lenLen)
            throw new E("tlv.decode(long): indefinite length not supported");
          if (lenLen > 4)
            throw new E("tlv.decode(long): byte length is too big");
          const lengthBytes = data.subarray(pos, pos + lenLen);
          if (lengthBytes.length !== lenLen)
            throw new E("tlv.decode: length bytes not complete");
          if (lengthBytes[0] === 0)
            throw new E("tlv.decode(long): zero leftmost byte");
          for (const b of lengthBytes)
            length = length << 8 | b;
          pos += lenLen;
          if (length < 128)
            throw new E("tlv.decode(long): not minimal encoding");
        }
        const v = data.subarray(pos, pos + length);
        if (v.length !== length)
          throw new E("tlv.decode: wrong value length");
        return { v, l: data.subarray(pos + length) };
      }
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
      encode(num) {
        const { Err: E } = DER;
        if (num < _0n7)
          throw new E("integer: negative integers are not allowed");
        let hex = numberToHexUnpadded(num);
        if (Number.parseInt(hex[0], 16) & 8)
          hex = "00" + hex;
        if (hex.length & 1)
          throw new E("unexpected DER parsing assertion: unpadded hex");
        return hex;
      },
      decode(data) {
        const { Err: E } = DER;
        if (data[0] & 128)
          throw new E("invalid signature integer: negative");
        if (data[0] === 0 && !(data[1] & 128))
          throw new E("invalid signature integer: unnecessary leading zero");
        return bytesToNumberBE(data);
      }
    },
    toSig(hex) {
      const { Err: E, _int: int, _tlv: tlv } = DER;
      const data = ensureBytes("signature", hex);
      const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
      if (seqLeftBytes.length)
        throw new E("invalid signature: left bytes after parsing");
      const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
      const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
      if (sLeftBytes.length)
        throw new E("invalid signature: left bytes after parsing");
      return { r: int.decode(rBytes), s: int.decode(sBytes) };
    },
    hexFromSig(sig) {
      const { _tlv: tlv, _int: int } = DER;
      const rs = tlv.encode(2, int.encode(sig.r));
      const ss = tlv.encode(2, int.encode(sig.s));
      const seq2 = rs + ss;
      return tlv.encode(48, seq2);
    }
  };
  var _0n7 = BigInt(0);
  var _1n7 = BigInt(1);
  var _2n5 = BigInt(2);
  var _3n3 = BigInt(3);
  var _4n2 = BigInt(4);
  function _normFnElement(Fn2, key) {
    const { BYTES: expected } = Fn2;
    let num;
    if (typeof key === "bigint") {
      num = key;
    } else {
      let bytes = ensureBytes("private key", key);
      try {
        num = Fn2.fromBytes(bytes);
      } catch (error) {
        throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
      }
    }
    if (!Fn2.isValidNot0(num))
      throw new Error("invalid private key: out of range [1..N-1]");
    return num;
  }
  function weierstrassN(params, extraOpts = {}) {
    const validated = _createCurveFields("weierstrass", params, extraOpts);
    const { Fp: Fp2, Fn: Fn2 } = validated;
    let CURVE = validated.CURVE;
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    _validateObject(extraOpts, {}, {
      allowInfinityPoint: "boolean",
      clearCofactor: "function",
      isTorsionFree: "function",
      fromBytes: "function",
      toBytes: "function",
      endo: "object",
      wrapPrivateKey: "boolean"
    });
    const { endo } = extraOpts;
    if (endo) {
      if (!Fp2.is0(CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
        throw new Error('invalid endo: expected "beta": bigint and "basises": array');
      }
    }
    const lengths = getWLengths(Fp2, Fn2);
    function assertCompressionIsSupported() {
      if (!Fp2.isOdd)
        throw new Error("compression is not supported: Field does not have .isOdd()");
    }
    function pointToBytes(_c, point, isCompressed) {
      const { x, y } = point.toAffine();
      const bx = Fp2.toBytes(x);
      _abool2(isCompressed, "isCompressed");
      if (isCompressed) {
        assertCompressionIsSupported();
        const hasEvenY = !Fp2.isOdd(y);
        return concatBytes(pprefix(hasEvenY), bx);
      } else {
        return concatBytes(Uint8Array.of(4), bx, Fp2.toBytes(y));
      }
    }
    function pointFromBytes(bytes) {
      _abytes2(bytes, void 0, "Point");
      const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
      const length = bytes.length;
      const head = bytes[0];
      const tail = bytes.subarray(1);
      if (length === comp && (head === 2 || head === 3)) {
        const x = Fp2.fromBytes(tail);
        if (!Fp2.isValid(x))
          throw new Error("bad point: is not on curve, wrong x");
        const y2 = weierstrassEquation(x);
        let y;
        try {
          y = Fp2.sqrt(y2);
        } catch (sqrtError) {
          const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("bad point: is not on curve, sqrt error" + err);
        }
        assertCompressionIsSupported();
        const isYOdd = Fp2.isOdd(y);
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp2.neg(y);
        return { x, y };
      } else if (length === uncomp && head === 4) {
        const L = Fp2.BYTES;
        const x = Fp2.fromBytes(tail.subarray(0, L));
        const y = Fp2.fromBytes(tail.subarray(L, L * 2));
        if (!isValidXY(x, y))
          throw new Error("bad point: is not on curve");
        return { x, y };
      } else {
        throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
      }
    }
    const encodePoint = extraOpts.toBytes || pointToBytes;
    const decodePoint = extraOpts.fromBytes || pointFromBytes;
    function weierstrassEquation(x) {
      const x2 = Fp2.sqr(x);
      const x3 = Fp2.mul(x2, x);
      return Fp2.add(Fp2.add(x3, Fp2.mul(x, CURVE.a)), CURVE.b);
    }
    function isValidXY(x, y) {
      const left = Fp2.sqr(y);
      const right = weierstrassEquation(x);
      return Fp2.eql(left, right);
    }
    if (!isValidXY(CURVE.Gx, CURVE.Gy))
      throw new Error("bad curve params: generator point");
    const _4a3 = Fp2.mul(Fp2.pow(CURVE.a, _3n3), _4n2);
    const _27b2 = Fp2.mul(Fp2.sqr(CURVE.b), BigInt(27));
    if (Fp2.is0(Fp2.add(_4a3, _27b2)))
      throw new Error("bad curve params: a or b");
    function acoord(title, n, banZero = false) {
      if (!Fp2.isValid(n) || banZero && Fp2.is0(n))
        throw new Error(`bad point coordinate ${title}`);
      return n;
    }
    function aprjpoint(other) {
      if (!(other instanceof Point))
        throw new Error("ProjectivePoint expected");
    }
    function splitEndoScalarN(k) {
      if (!endo || !endo.basises)
        throw new Error("no endo");
      return _splitEndoScalar(k, endo.basises, Fn2.ORDER);
    }
    const toAffineMemo = memoized((p, iz) => {
      const { X, Y, Z } = p;
      if (Fp2.eql(Z, Fp2.ONE))
        return { x: X, y: Y };
      const is0 = p.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(Z);
      const x = Fp2.mul(X, iz);
      const y = Fp2.mul(Y, iz);
      const zz = Fp2.mul(Z, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x, y };
    });
    const assertValidMemo = memoized((p) => {
      if (p.is0()) {
        if (extraOpts.allowInfinityPoint && !Fp2.is0(p.Y))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = p.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("bad point: x or y not field elements");
      if (!isValidXY(x, y))
        throw new Error("bad point: equation left != right");
      if (!p.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
      return true;
    });
    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
      k2p = new Point(Fp2.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
      k1p = negateCt(k1neg, k1p);
      k2p = negateCt(k2neg, k2p);
      return k1p.add(k2p);
    }
    class Point {
      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
      constructor(X, Y, Z) {
        this.X = acoord("x", X);
        this.Y = acoord("y", Y, true);
        this.Z = acoord("z", Z);
        Object.freeze(this);
      }
      static CURVE() {
        return CURVE;
      }
      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
      static fromAffine(p) {
        const { x, y } = p || {};
        if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
          throw new Error("invalid affine point");
        if (p instanceof Point)
          throw new Error("projective point not allowed");
        if (Fp2.is0(x) && Fp2.is0(y))
          return Point.ZERO;
        return new Point(x, y, Fp2.ONE);
      }
      static fromBytes(bytes) {
        const P = Point.fromAffine(decodePoint(_abytes2(bytes, void 0, "point")));
        P.assertValidity();
        return P;
      }
      static fromHex(hex) {
        return Point.fromBytes(ensureBytes("pointHex", hex));
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       *
       * @param windowSize
       * @param isLazy true will defer table computation until the first multiplication
       * @returns
       */
      precompute(windowSize = 8, isLazy = true) {
        wnaf.createCache(this, windowSize);
        if (!isLazy)
          this.multiply(_3n3);
        return this;
      }
      // TODO: return `this`
      /** A point on curve is valid if it conforms to equation. */
      assertValidity() {
        assertValidMemo(this);
      }
      hasEvenY() {
        const { y } = this.toAffine();
        if (!Fp2.isOdd)
          throw new Error("Field doesn't support isOdd");
        return !Fp2.isOdd(y);
      }
      /** Compare one point to another. */
      equals(other) {
        aprjpoint(other);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const { X: X2, Y: Y2, Z: Z2 } = other;
        const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
        const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
        return U1 && U2;
      }
      /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
      negate() {
        return new Point(this.X, Fp2.neg(this.Y), this.Z);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a, b } = CURVE;
        const b3 = Fp2.mul(b, _3n3);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        let t0 = Fp2.mul(X1, X1);
        let t1 = Fp2.mul(Y1, Y1);
        let t2 = Fp2.mul(Z1, Z1);
        let t3 = Fp2.mul(X1, Y1);
        t3 = Fp2.add(t3, t3);
        Z3 = Fp2.mul(X1, Z1);
        Z3 = Fp2.add(Z3, Z3);
        X3 = Fp2.mul(a, Z3);
        Y3 = Fp2.mul(b3, t2);
        Y3 = Fp2.add(X3, Y3);
        X3 = Fp2.sub(t1, Y3);
        Y3 = Fp2.add(t1, Y3);
        Y3 = Fp2.mul(X3, Y3);
        X3 = Fp2.mul(t3, X3);
        Z3 = Fp2.mul(b3, Z3);
        t2 = Fp2.mul(a, t2);
        t3 = Fp2.sub(t0, t2);
        t3 = Fp2.mul(a, t3);
        t3 = Fp2.add(t3, Z3);
        Z3 = Fp2.add(t0, t0);
        t0 = Fp2.add(Z3, t0);
        t0 = Fp2.add(t0, t2);
        t0 = Fp2.mul(t0, t3);
        Y3 = Fp2.add(Y3, t0);
        t2 = Fp2.mul(Y1, Z1);
        t2 = Fp2.add(t2, t2);
        t0 = Fp2.mul(t2, t3);
        X3 = Fp2.sub(X3, t0);
        Z3 = Fp2.mul(t2, t1);
        Z3 = Fp2.add(Z3, Z3);
        Z3 = Fp2.add(Z3, Z3);
        return new Point(X3, Y3, Z3);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(other) {
        aprjpoint(other);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const { X: X2, Y: Y2, Z: Z2 } = other;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        const a = CURVE.a;
        const b3 = Fp2.mul(CURVE.b, _3n3);
        let t0 = Fp2.mul(X1, X2);
        let t1 = Fp2.mul(Y1, Y2);
        let t2 = Fp2.mul(Z1, Z2);
        let t3 = Fp2.add(X1, Y1);
        let t4 = Fp2.add(X2, Y2);
        t3 = Fp2.mul(t3, t4);
        t4 = Fp2.add(t0, t1);
        t3 = Fp2.sub(t3, t4);
        t4 = Fp2.add(X1, Z1);
        let t5 = Fp2.add(X2, Z2);
        t4 = Fp2.mul(t4, t5);
        t5 = Fp2.add(t0, t2);
        t4 = Fp2.sub(t4, t5);
        t5 = Fp2.add(Y1, Z1);
        X3 = Fp2.add(Y2, Z2);
        t5 = Fp2.mul(t5, X3);
        X3 = Fp2.add(t1, t2);
        t5 = Fp2.sub(t5, X3);
        Z3 = Fp2.mul(a, t4);
        X3 = Fp2.mul(b3, t2);
        Z3 = Fp2.add(X3, Z3);
        X3 = Fp2.sub(t1, Z3);
        Z3 = Fp2.add(t1, Z3);
        Y3 = Fp2.mul(X3, Z3);
        t1 = Fp2.add(t0, t0);
        t1 = Fp2.add(t1, t0);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.mul(b3, t4);
        t1 = Fp2.add(t1, t2);
        t2 = Fp2.sub(t0, t2);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.add(t4, t2);
        t0 = Fp2.mul(t1, t4);
        Y3 = Fp2.add(Y3, t0);
        t0 = Fp2.mul(t5, t4);
        X3 = Fp2.mul(t3, X3);
        X3 = Fp2.sub(X3, t0);
        t0 = Fp2.mul(t3, t1);
        Z3 = Fp2.mul(t5, Z3);
        Z3 = Fp2.add(Z3, t0);
        return new Point(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point.ZERO);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(scalar) {
        const { endo: endo2 } = extraOpts;
        if (!Fn2.isValidNot0(scalar))
          throw new Error("invalid scalar: out of range");
        let point, fake;
        const mul = (n) => wnaf.cached(this, n, (p) => normalizeZ(Point, p));
        if (endo2) {
          const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
          const { p: k1p, f: k1f } = mul(k1);
          const { p: k2p, f: k2f } = mul(k2);
          fake = k1f.add(k2f);
          point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
        } else {
          const { p, f: f2 } = mul(scalar);
          point = p;
          fake = f2;
        }
        return normalizeZ(Point, [point, fake])[0];
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed secret key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(sc) {
        const { endo: endo2 } = extraOpts;
        const p = this;
        if (!Fn2.isValid(sc))
          throw new Error("invalid scalar: out of range");
        if (sc === _0n7 || p.is0())
          return Point.ZERO;
        if (sc === _1n7)
          return p;
        if (wnaf.hasCache(this))
          return this.multiply(sc);
        if (endo2) {
          const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
          const { p1, p2 } = mulEndoUnsafe(Point, p, k1, k2);
          return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
        } else {
          return wnaf.unsafe(p, sc);
        }
      }
      multiplyAndAddUnsafe(Q, a, b) {
        const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
        return sum.is0() ? void 0 : sum;
      }
      /**
       * Converts Projective point to affine (x, y) coordinates.
       * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
       */
      toAffine(invertedZ) {
        return toAffineMemo(this, invertedZ);
      }
      /**
       * Checks whether Point is free of torsion elements (is in prime subgroup).
       * Always torsion-free for cofactor=1 curves.
       */
      isTorsionFree() {
        const { isTorsionFree } = extraOpts;
        if (cofactor === _1n7)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point, this);
        return wnaf.unsafe(this, CURVE_ORDER).is0();
      }
      clearCofactor() {
        const { clearCofactor } = extraOpts;
        if (cofactor === _1n7)
          return this;
        if (clearCofactor)
          return clearCofactor(Point, this);
        return this.multiplyUnsafe(cofactor);
      }
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      toBytes(isCompressed = true) {
        _abool2(isCompressed, "isCompressed");
        this.assertValidity();
        return encodePoint(Point, this, isCompressed);
      }
      toHex(isCompressed = true) {
        return bytesToHex(this.toBytes(isCompressed));
      }
      toString() {
        return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
      }
      // TODO: remove
      get px() {
        return this.X;
      }
      get py() {
        return this.X;
      }
      get pz() {
        return this.Z;
      }
      toRawBytes(isCompressed = true) {
        return this.toBytes(isCompressed);
      }
      _setWindowSize(windowSize) {
        this.precompute(windowSize);
      }
      static normalizeZ(points) {
        return normalizeZ(Point, points);
      }
      static msm(points, scalars) {
        return pippenger(Point, Fn2, points, scalars);
      }
      static fromPrivateKey(privateKey) {
        return Point.BASE.multiply(_normFnElement(Fn2, privateKey));
      }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp2.ONE);
    Point.ZERO = new Point(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
    Point.Fp = Fp2;
    Point.Fn = Fn2;
    const bits = Fn2.BITS;
    const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);
    Point.BASE.precompute(8);
    return Point;
  }
  function pprefix(hasEvenY) {
    return Uint8Array.of(hasEvenY ? 2 : 3);
  }
  function getWLengths(Fp2, Fn2) {
    return {
      secretKey: Fn2.BYTES,
      publicKey: 1 + Fp2.BYTES,
      publicKeyUncompressed: 1 + 2 * Fp2.BYTES,
      publicKeyHasPrefix: true,
      signature: 2 * Fn2.BYTES
    };
  }
  function ecdh(Point, ecdhOpts = {}) {
    const { Fn: Fn2 } = Point;
    const randomBytes_ = ecdhOpts.randomBytes || randomBytes;
    const lengths = Object.assign(getWLengths(Point.Fp, Fn2), { seed: getMinHashLength(Fn2.ORDER) });
    function isValidSecretKey(secretKey) {
      try {
        return !!_normFnElement(Fn2, secretKey);
      } catch (error) {
        return false;
      }
    }
    function isValidPublicKey(publicKey3, isCompressed) {
      const { publicKey: comp, publicKeyUncompressed } = lengths;
      try {
        const l = publicKey3.length;
        if (isCompressed === true && l !== comp)
          return false;
        if (isCompressed === false && l !== publicKeyUncompressed)
          return false;
        return !!Point.fromBytes(publicKey3);
      } catch (error) {
        return false;
      }
    }
    function randomSecretKey(seed = randomBytes_(lengths.seed)) {
      return mapHashToField(_abytes2(seed, lengths.seed, "seed"), Fn2.ORDER);
    }
    function getPublicKey2(secretKey, isCompressed = true) {
      return Point.BASE.multiply(_normFnElement(Fn2, secretKey)).toBytes(isCompressed);
    }
    function keygen(seed) {
      const secretKey = randomSecretKey(seed);
      return { secretKey, publicKey: getPublicKey2(secretKey) };
    }
    function isProbPub(item) {
      if (typeof item === "bigint")
        return false;
      if (item instanceof Point)
        return true;
      const { secretKey, publicKey: publicKey3, publicKeyUncompressed } = lengths;
      if (Fn2.allowedLengths || secretKey === publicKey3)
        return void 0;
      const l = ensureBytes("key", item).length;
      return l === publicKey3 || l === publicKeyUncompressed;
    }
    function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
      if (isProbPub(secretKeyA) === true)
        throw new Error("first arg must be private key");
      if (isProbPub(publicKeyB) === false)
        throw new Error("second arg must be public key");
      const s = _normFnElement(Fn2, secretKeyA);
      const b = Point.fromHex(publicKeyB);
      return b.multiply(s).toBytes(isCompressed);
    }
    const utils = {
      isValidSecretKey,
      isValidPublicKey,
      randomSecretKey,
      // TODO: remove
      isValidPrivateKey: isValidSecretKey,
      randomPrivateKey: randomSecretKey,
      normPrivateKeyToScalar: (key) => _normFnElement(Fn2, key),
      precompute(windowSize = 8, point = Point.BASE) {
        return point.precompute(windowSize, false);
      }
    };
    return Object.freeze({ getPublicKey: getPublicKey2, getSharedSecret, keygen, Point, utils, lengths });
  }
  function ecdsa(Point, hash, ecdsaOpts = {}) {
    ahash(hash);
    _validateObject(ecdsaOpts, {}, {
      hmac: "function",
      lowS: "boolean",
      randomBytes: "function",
      bits2int: "function",
      bits2int_modN: "function"
    });
    const randomBytes2 = ecdsaOpts.randomBytes || randomBytes;
    const hmac2 = ecdsaOpts.hmac || ((key, ...msgs) => hmac(hash, key, concatBytes(...msgs)));
    const { Fp: Fp2, Fn: Fn2 } = Point;
    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn2;
    const { keygen, getPublicKey: getPublicKey2, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);
    const defaultSigOpts = {
      prehash: false,
      lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : false,
      format: void 0,
      //'compact' as ECDSASigFormat,
      extraEntropy: false
    };
    const defaultSigOpts_format = "compact";
    function isBiggerThanHalfOrder(number2) {
      const HALF = CURVE_ORDER >> _1n7;
      return number2 > HALF;
    }
    function validateRS(title, num) {
      if (!Fn2.isValidNot0(num))
        throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
      return num;
    }
    function validateSigLength(bytes, format) {
      validateSigFormat(format);
      const size = lengths.signature;
      const sizer = format === "compact" ? size : format === "recovered" ? size + 1 : void 0;
      return _abytes2(bytes, sizer, `${format} signature`);
    }
    class Signature {
      constructor(r, s, recovery) {
        this.r = validateRS("r", r);
        this.s = validateRS("s", s);
        if (recovery != null)
          this.recovery = recovery;
        Object.freeze(this);
      }
      static fromBytes(bytes, format = defaultSigOpts_format) {
        validateSigLength(bytes, format);
        let recid;
        if (format === "der") {
          const { r: r2, s: s2 } = DER.toSig(_abytes2(bytes));
          return new Signature(r2, s2);
        }
        if (format === "recovered") {
          recid = bytes[0];
          format = "compact";
          bytes = bytes.subarray(1);
        }
        const L = Fn2.BYTES;
        const r = bytes.subarray(0, L);
        const s = bytes.subarray(L, L * 2);
        return new Signature(Fn2.fromBytes(r), Fn2.fromBytes(s), recid);
      }
      static fromHex(hex, format) {
        return this.fromBytes(hexToBytes(hex), format);
      }
      addRecoveryBit(recovery) {
        return new Signature(this.r, this.s, recovery);
      }
      recoverPublicKey(messageHash) {
        const FIELD_ORDER = Fp2.ORDER;
        const { r, s, recovery: rec } = this;
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const hasCofactor = CURVE_ORDER * _2n5 < FIELD_ORDER;
        if (hasCofactor && rec > 1)
          throw new Error("recovery id is ambiguous for h>1 curve");
        const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
        if (!Fp2.isValid(radj))
          throw new Error("recovery id 2 or 3 invalid");
        const x = Fp2.toBytes(radj);
        const R = Point.fromBytes(concatBytes(pprefix((rec & 1) === 0), x));
        const ir = Fn2.inv(radj);
        const h = bits2int_modN(ensureBytes("msgHash", messageHash));
        const u1 = Fn2.create(-h * ir);
        const u2 = Fn2.create(s * ir);
        const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
        if (Q.is0())
          throw new Error("point at infinify");
        Q.assertValidity();
        return Q;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      toBytes(format = defaultSigOpts_format) {
        validateSigFormat(format);
        if (format === "der")
          return hexToBytes(DER.hexFromSig(this));
        const r = Fn2.toBytes(this.r);
        const s = Fn2.toBytes(this.s);
        if (format === "recovered") {
          if (this.recovery == null)
            throw new Error("recovery bit must be present");
          return concatBytes(Uint8Array.of(this.recovery), r, s);
        }
        return concatBytes(r, s);
      }
      toHex(format) {
        return bytesToHex(this.toBytes(format));
      }
      // TODO: remove
      assertValidity() {
      }
      static fromCompact(hex) {
        return Signature.fromBytes(ensureBytes("sig", hex), "compact");
      }
      static fromDER(hex) {
        return Signature.fromBytes(ensureBytes("sig", hex), "der");
      }
      normalizeS() {
        return this.hasHighS() ? new Signature(this.r, Fn2.neg(this.s), this.recovery) : this;
      }
      toDERRawBytes() {
        return this.toBytes("der");
      }
      toDERHex() {
        return bytesToHex(this.toBytes("der"));
      }
      toCompactRawBytes() {
        return this.toBytes("compact");
      }
      toCompactHex() {
        return bytesToHex(this.toBytes("compact"));
      }
    }
    const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {
      if (bytes.length > 8192)
        throw new Error("input is too large");
      const num = bytesToNumberBE(bytes);
      const delta = bytes.length * 8 - fnBits;
      return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {
      return Fn2.create(bits2int(bytes));
    };
    const ORDER_MASK = bitMask(fnBits);
    function int2octets(num) {
      aInRange("num < 2^" + fnBits, num, _0n7, ORDER_MASK);
      return Fn2.toBytes(num);
    }
    function validateMsgAndHash(message, prehash) {
      _abytes2(message, void 0, "message");
      return prehash ? _abytes2(hash(message), void 0, "prehashed message") : message;
    }
    function prepSig(message, privateKey, opts) {
      if (["recovered", "canonical"].some((k) => k in opts))
        throw new Error("sign() legacy options not supported");
      const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
      message = validateMsgAndHash(message, prehash);
      const h1int = bits2int_modN(message);
      const d = _normFnElement(Fn2, privateKey);
      const seedArgs = [int2octets(d), int2octets(h1int)];
      if (extraEntropy != null && extraEntropy !== false) {
        const e = extraEntropy === true ? randomBytes2(lengths.secretKey) : extraEntropy;
        seedArgs.push(ensureBytes("extraEntropy", e));
      }
      const seed = concatBytes(...seedArgs);
      const m = h1int;
      function k2sig(kBytes) {
        const k = bits2int(kBytes);
        if (!Fn2.isValidNot0(k))
          return;
        const ik = Fn2.inv(k);
        const q = Point.BASE.multiply(k).toAffine();
        const r = Fn2.create(q.x);
        if (r === _0n7)
          return;
        const s = Fn2.create(ik * Fn2.create(m + r * d));
        if (s === _0n7)
          return;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n7);
        let normS = s;
        if (lowS && isBiggerThanHalfOrder(s)) {
          normS = Fn2.neg(s);
          recovery ^= 1;
        }
        return new Signature(r, normS, recovery);
      }
      return { seed, k2sig };
    }
    function sign2(message, secretKey, opts = {}) {
      message = ensureBytes("message", message);
      const { seed, k2sig } = prepSig(message, secretKey, opts);
      const drbg = createHmacDrbg(hash.outputLen, Fn2.BYTES, hmac2);
      const sig = drbg(seed, k2sig);
      return sig;
    }
    function tryParsingSig(sg) {
      let sig = void 0;
      const isHex = typeof sg === "string" || isBytes(sg);
      const isObj = !isHex && sg !== null && typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint";
      if (!isHex && !isObj)
        throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
      if (isObj) {
        sig = new Signature(sg.r, sg.s);
      } else if (isHex) {
        try {
          sig = Signature.fromBytes(ensureBytes("sig", sg), "der");
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
        }
        if (!sig) {
          try {
            sig = Signature.fromBytes(ensureBytes("sig", sg), "compact");
          } catch (error) {
            return false;
          }
        }
      }
      if (!sig)
        return false;
      return sig;
    }
    function verify2(signature, message, publicKey3, opts = {}) {
      const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
      publicKey3 = ensureBytes("publicKey", publicKey3);
      message = validateMsgAndHash(ensureBytes("message", message), prehash);
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      const sig = format === void 0 ? tryParsingSig(signature) : Signature.fromBytes(ensureBytes("sig", signature), format);
      if (sig === false)
        return false;
      try {
        const P = Point.fromBytes(publicKey3);
        if (lowS && sig.hasHighS())
          return false;
        const { r, s } = sig;
        const h = bits2int_modN(message);
        const is2 = Fn2.inv(s);
        const u1 = Fn2.create(h * is2);
        const u2 = Fn2.create(r * is2);
        const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
        if (R.is0())
          return false;
        const v = Fn2.create(R.x);
        return v === r;
      } catch (e) {
        return false;
      }
    }
    function recoverPublicKey(signature, message, opts = {}) {
      const { prehash } = validateSigOpts(opts, defaultSigOpts);
      message = validateMsgAndHash(message, prehash);
      return Signature.fromBytes(signature, "recovered").recoverPublicKey(message).toBytes();
    }
    return Object.freeze({
      keygen,
      getPublicKey: getPublicKey2,
      getSharedSecret,
      utils,
      lengths,
      Point,
      sign: sign2,
      verify: verify2,
      recoverPublicKey,
      Signature,
      hash
    });
  }
  function _weierstrass_legacy_opts_to_new(c) {
    const CURVE = {
      a: c.a,
      b: c.b,
      p: c.Fp.ORDER,
      n: c.n,
      h: c.h,
      Gx: c.Gx,
      Gy: c.Gy
    };
    const Fp2 = c.Fp;
    let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2)))) : void 0;
    const Fn2 = Field(CURVE.n, {
      BITS: c.nBitLength,
      allowedLengths,
      modFromBytes: c.wrapPrivateKey
    });
    const curveOpts = {
      Fp: Fp2,
      Fn: Fn2,
      allowInfinityPoint: c.allowInfinityPoint,
      endo: c.endo,
      isTorsionFree: c.isTorsionFree,
      clearCofactor: c.clearCofactor,
      fromBytes: c.fromBytes,
      toBytes: c.toBytes
    };
    return { CURVE, curveOpts };
  }
  function _ecdsa_legacy_opts_to_new(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const ecdsaOpts = {
      hmac: c.hmac,
      randomBytes: c.randomBytes,
      lowS: c.lowS,
      bits2int: c.bits2int,
      bits2int_modN: c.bits2int_modN
    };
    return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };
  }
  function _ecdsa_new_output_to_legacy(c, _ecdsa) {
    const Point = _ecdsa.Point;
    return Object.assign({}, _ecdsa, {
      ProjectivePoint: Point,
      CURVE: Object.assign({}, c, nLength(Point.Fn.ORDER, Point.Fn.BITS))
    });
  }
  function weierstrass(c) {
    const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
    const Point = weierstrassN(CURVE, curveOpts);
    const signs = ecdsa(Point, hash, ecdsaOpts);
    return _ecdsa_new_output_to_legacy(c, signs);
  }

  // node_modules/@noble/curves/esm/_shortw_utils.js
  function createCurve(curveDef, defHash) {
    const create2 = (hash) => weierstrass({ ...curveDef, hash });
    return { ...create2(defHash), create: create2 };
  }

  // node_modules/@noble/curves/esm/secp256k1.js
  var secp256k1_CURVE = {
    p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
    Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
  };
  var secp256k1_ENDO = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    basises: [
      [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
      [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
    ]
  };
  var _2n6 = /* @__PURE__ */ BigInt(2);
  function sqrtMod(y) {
    const P = secp256k1_CURVE.p;
    const _3n4 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P;
    const b3 = b2 * b2 * y % P;
    const b6 = pow2(b3, _3n4, P) * b3 % P;
    const b9 = pow2(b6, _3n4, P) * b3 % P;
    const b11 = pow2(b9, _2n6, P) * b2 % P;
    const b22 = pow2(b11, _11n, P) * b11 % P;
    const b44 = pow2(b22, _22n, P) * b22 % P;
    const b88 = pow2(b44, _44n, P) * b44 % P;
    const b176 = pow2(b88, _88n, P) * b88 % P;
    const b220 = pow2(b176, _44n, P) * b44 % P;
    const b223 = pow2(b220, _3n4, P) * b3 % P;
    const t1 = pow2(b223, _23n, P) * b22 % P;
    const t2 = pow2(t1, _6n, P) * b2 % P;
    const root = pow2(t2, _2n6, P);
    if (!Fpk1.eql(Fpk1.sqr(root), y))
      throw new Error("Cannot find square root");
    return root;
  }
  var Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });
  var secp256k1 = createCurve({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha256);

  // node_modules/@solana/web3.js/lib/index.browser.esm.js
  var generatePrivateKey = ed25519.utils.randomPrivateKey;
  var generateKeypair = () => {
    const privateScalar = ed25519.utils.randomPrivateKey();
    const publicKey3 = getPublicKey(privateScalar);
    const secretKey = new Uint8Array(64);
    secretKey.set(privateScalar);
    secretKey.set(publicKey3, 32);
    return {
      publicKey: publicKey3,
      secretKey
    };
  };
  var getPublicKey = ed25519.getPublicKey;
  function isOnCurve(publicKey3) {
    try {
      ed25519.ExtendedPoint.fromHex(publicKey3);
      return true;
    } catch {
      return false;
    }
  }
  var sign = (message, secretKey) => ed25519.sign(message, secretKey.slice(0, 32));
  var verify = ed25519.verify;
  var toBuffer = (arr) => {
    if (import_buffer2.Buffer.isBuffer(arr)) {
      return arr;
    } else if (arr instanceof Uint8Array) {
      return import_buffer2.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
    } else {
      return import_buffer2.Buffer.from(arr);
    }
  };
  var Struct2 = class {
    constructor(properties) {
      Object.assign(this, properties);
    }
    encode() {
      return import_buffer2.Buffer.from((0, import_borsh.serialize)(SOLANA_SCHEMA, this));
    }
    static decode(data) {
      return (0, import_borsh.deserialize)(SOLANA_SCHEMA, this, data);
    }
    static decodeUnchecked(data) {
      return (0, import_borsh.deserializeUnchecked)(SOLANA_SCHEMA, this, data);
    }
  };
  var SOLANA_SCHEMA = /* @__PURE__ */ new Map();
  var _PublicKey;
  var MAX_SEED_LENGTH = 32;
  var PUBLIC_KEY_LENGTH = 32;
  function isPublicKeyData(value) {
    return value._bn !== void 0;
  }
  var uniquePublicKeyCounter = 1;
  var PublicKey = class _PublicKey2 extends Struct2 {
    /**
     * Create a new PublicKey object
     * @param value ed25519 public key as buffer or base-58 encoded string
     */
    constructor(value) {
      super({});
      this._bn = void 0;
      if (isPublicKeyData(value)) {
        this._bn = value._bn;
      } else {
        if (typeof value === "string") {
          const decoded = import_bs58.default.decode(value);
          if (decoded.length != PUBLIC_KEY_LENGTH) {
            throw new Error(`Invalid public key input`);
          }
          this._bn = new import_bn.default(decoded);
        } else {
          this._bn = new import_bn.default(value);
        }
        if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {
          throw new Error(`Invalid public key input`);
        }
      }
    }
    /**
     * Returns a unique PublicKey for tests and benchmarks using a counter
     */
    static unique() {
      const key = new _PublicKey2(uniquePublicKeyCounter);
      uniquePublicKeyCounter += 1;
      return new _PublicKey2(key.toBuffer());
    }
    /**
     * Default public key value. The base58-encoded string representation is all ones (as seen below)
     * The underlying BN number is 32 bytes that are all zeros
     */
    /**
     * Checks if two publicKeys are equal
     */
    equals(publicKey3) {
      return this._bn.eq(publicKey3._bn);
    }
    /**
     * Return the base-58 representation of the public key
     */
    toBase58() {
      return import_bs58.default.encode(this.toBytes());
    }
    toJSON() {
      return this.toBase58();
    }
    /**
     * Return the byte array representation of the public key in big endian
     */
    toBytes() {
      const buf = this.toBuffer();
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }
    /**
     * Return the Buffer representation of the public key in big endian
     */
    toBuffer() {
      const b = this._bn.toArrayLike(import_buffer2.Buffer);
      if (b.length === PUBLIC_KEY_LENGTH) {
        return b;
      }
      const zeroPad = import_buffer2.Buffer.alloc(32);
      b.copy(zeroPad, 32 - b.length);
      return zeroPad;
    }
    get [Symbol.toStringTag]() {
      return `PublicKey(${this.toString()})`;
    }
    /**
     * Return the base-58 representation of the public key
     */
    toString() {
      return this.toBase58();
    }
    /**
     * Derive a public key from another key, a seed, and a program ID.
     * The program ID will also serve as the owner of the public key, giving
     * it permission to write data to the account.
     */
    /* eslint-disable require-await */
    static async createWithSeed(fromPublicKey, seed, programId) {
      const buffer = import_buffer2.Buffer.concat([fromPublicKey.toBuffer(), import_buffer2.Buffer.from(seed), programId.toBuffer()]);
      const publicKeyBytes = sha2562(buffer);
      return new _PublicKey2(publicKeyBytes);
    }
    /**
     * Derive a program address from seeds and a program ID.
     */
    /* eslint-disable require-await */
    static createProgramAddressSync(seeds, programId) {
      let buffer = import_buffer2.Buffer.alloc(0);
      seeds.forEach(function(seed) {
        if (seed.length > MAX_SEED_LENGTH) {
          throw new TypeError(`Max seed length exceeded`);
        }
        buffer = import_buffer2.Buffer.concat([buffer, toBuffer(seed)]);
      });
      buffer = import_buffer2.Buffer.concat([buffer, programId.toBuffer(), import_buffer2.Buffer.from("ProgramDerivedAddress")]);
      const publicKeyBytes = sha2562(buffer);
      if (isOnCurve(publicKeyBytes)) {
        throw new Error(`Invalid seeds, address must fall off the curve`);
      }
      return new _PublicKey2(publicKeyBytes);
    }
    /**
     * Async version of createProgramAddressSync
     * For backwards compatibility
     *
     * @deprecated Use {@link createProgramAddressSync} instead
     */
    /* eslint-disable require-await */
    static async createProgramAddress(seeds, programId) {
      return this.createProgramAddressSync(seeds, programId);
    }
    /**
     * Find a valid program address
     *
     * Valid program addresses must fall off the ed25519 curve.  This function
     * iterates a nonce until it finds one that when combined with the seeds
     * results in a valid program address.
     */
    static findProgramAddressSync(seeds, programId) {
      let nonce = 255;
      let address;
      while (nonce != 0) {
        try {
          const seedsWithNonce = seeds.concat(import_buffer2.Buffer.from([nonce]));
          address = this.createProgramAddressSync(seedsWithNonce, programId);
        } catch (err) {
          if (err instanceof TypeError) {
            throw err;
          }
          nonce--;
          continue;
        }
        return [address, nonce];
      }
      throw new Error(`Unable to find a viable program address nonce`);
    }
    /**
     * Async version of findProgramAddressSync
     * For backwards compatibility
     *
     * @deprecated Use {@link findProgramAddressSync} instead
     */
    static async findProgramAddress(seeds, programId) {
      return this.findProgramAddressSync(seeds, programId);
    }
    /**
     * Check that a pubkey is on the ed25519 curve.
     */
    static isOnCurve(pubkeyData) {
      const pubkey = new _PublicKey2(pubkeyData);
      return isOnCurve(pubkey.toBytes());
    }
  };
  _PublicKey = PublicKey;
  PublicKey.default = new _PublicKey("11111111111111111111111111111111");
  SOLANA_SCHEMA.set(PublicKey, {
    kind: "struct",
    fields: [["_bn", "u256"]]
  });
  var BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey("BPFLoader1111111111111111111111111111111111");
  var PACKET_DATA_SIZE = 1280 - 40 - 8;
  var VERSION_PREFIX_MASK = 127;
  var SIGNATURE_LENGTH_IN_BYTES = 64;
  var TransactionExpiredBlockheightExceededError = class extends Error {
    constructor(signature) {
      super(`Signature ${signature} has expired: block height exceeded.`);
      this.signature = void 0;
      this.signature = signature;
    }
  };
  Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", {
    value: "TransactionExpiredBlockheightExceededError"
  });
  var TransactionExpiredTimeoutError = class extends Error {
    constructor(signature, timeoutSeconds) {
      super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature} using the Solana Explorer or CLI tools.`);
      this.signature = void 0;
      this.signature = signature;
    }
  };
  Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
    value: "TransactionExpiredTimeoutError"
  });
  var TransactionExpiredNonceInvalidError = class extends Error {
    constructor(signature) {
      super(`Signature ${signature} has expired: the nonce is no longer valid.`);
      this.signature = void 0;
      this.signature = signature;
    }
  };
  Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", {
    value: "TransactionExpiredNonceInvalidError"
  });
  var MessageAccountKeys = class {
    constructor(staticAccountKeys, accountKeysFromLookups) {
      this.staticAccountKeys = void 0;
      this.accountKeysFromLookups = void 0;
      this.staticAccountKeys = staticAccountKeys;
      this.accountKeysFromLookups = accountKeysFromLookups;
    }
    keySegments() {
      const keySegments = [this.staticAccountKeys];
      if (this.accountKeysFromLookups) {
        keySegments.push(this.accountKeysFromLookups.writable);
        keySegments.push(this.accountKeysFromLookups.readonly);
      }
      return keySegments;
    }
    get(index) {
      for (const keySegment of this.keySegments()) {
        if (index < keySegment.length) {
          return keySegment[index];
        } else {
          index -= keySegment.length;
        }
      }
      return;
    }
    get length() {
      return this.keySegments().flat().length;
    }
    compileInstructions(instructions) {
      const U8_MAX = 255;
      if (this.length > U8_MAX + 1) {
        throw new Error("Account index overflow encountered during compilation");
      }
      const keyIndexMap = /* @__PURE__ */ new Map();
      this.keySegments().flat().forEach((key, index) => {
        keyIndexMap.set(key.toBase58(), index);
      });
      const findKeyIndex = (key) => {
        const keyIndex = keyIndexMap.get(key.toBase58());
        if (keyIndex === void 0) throw new Error("Encountered an unknown instruction account key during compilation");
        return keyIndex;
      };
      return instructions.map((instruction) => {
        return {
          programIdIndex: findKeyIndex(instruction.programId),
          accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
          data: instruction.data
        };
      });
    }
  };
  var publicKey = (property = "publicKey") => {
    return BufferLayout.blob(32, property);
  };
  var rustString = (property = "string") => {
    const rsl = BufferLayout.struct([BufferLayout.u32("length"), BufferLayout.u32("lengthPadding"), BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), "chars")], property);
    const _decode = rsl.decode.bind(rsl);
    const _encode = rsl.encode.bind(rsl);
    const rslShim = rsl;
    rslShim.decode = (b, offset2) => {
      const data = _decode(b, offset2);
      return data["chars"].toString();
    };
    rslShim.encode = (str, b, offset2) => {
      const data = {
        chars: import_buffer2.Buffer.from(str, "utf8")
      };
      return _encode(data, b, offset2);
    };
    rslShim.alloc = (str) => {
      return BufferLayout.u32().span + BufferLayout.u32().span + import_buffer2.Buffer.from(str, "utf8").length;
    };
    return rslShim;
  };
  var authorized = (property = "authorized") => {
    return BufferLayout.struct([publicKey("staker"), publicKey("withdrawer")], property);
  };
  var lockup = (property = "lockup") => {
    return BufferLayout.struct([BufferLayout.ns64("unixTimestamp"), BufferLayout.ns64("epoch"), publicKey("custodian")], property);
  };
  var voteInit = (property = "voteInit") => {
    return BufferLayout.struct([publicKey("nodePubkey"), publicKey("authorizedVoter"), publicKey("authorizedWithdrawer"), BufferLayout.u8("commission")], property);
  };
  var voteAuthorizeWithSeedArgs = (property = "voteAuthorizeWithSeedArgs") => {
    return BufferLayout.struct([BufferLayout.u32("voteAuthorizationType"), publicKey("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey("newAuthorized")], property);
  };
  function getAlloc(type2, fields) {
    const getItemAlloc = (item) => {
      if (item.span >= 0) {
        return item.span;
      } else if (typeof item.alloc === "function") {
        return item.alloc(fields[item.property]);
      } else if ("count" in item && "elementLayout" in item) {
        const field = fields[item.property];
        if (Array.isArray(field)) {
          return field.length * getItemAlloc(item.elementLayout);
        }
      } else if ("fields" in item) {
        return getAlloc({
          layout: item
        }, fields[item.property]);
      }
      return 0;
    };
    let alloc = 0;
    type2.layout.fields.forEach((item) => {
      alloc += getItemAlloc(item);
    });
    return alloc;
  }
  function decodeLength(bytes) {
    let len = 0;
    let size = 0;
    for (; ; ) {
      let elem = bytes.shift();
      len |= (elem & 127) << size * 7;
      size += 1;
      if ((elem & 128) === 0) {
        break;
      }
    }
    return len;
  }
  function encodeLength(bytes, len) {
    let rem_len = len;
    for (; ; ) {
      let elem = rem_len & 127;
      rem_len >>= 7;
      if (rem_len == 0) {
        bytes.push(elem);
        break;
      } else {
        elem |= 128;
        bytes.push(elem);
      }
    }
  }
  function assert2(condition, message) {
    if (!condition) {
      throw new Error(message || "Assertion failed");
    }
  }
  var CompiledKeys = class _CompiledKeys {
    constructor(payer, keyMetaMap) {
      this.payer = void 0;
      this.keyMetaMap = void 0;
      this.payer = payer;
      this.keyMetaMap = keyMetaMap;
    }
    static compile(instructions, payer) {
      const keyMetaMap = /* @__PURE__ */ new Map();
      const getOrInsertDefault = (pubkey) => {
        const address = pubkey.toBase58();
        let keyMeta = keyMetaMap.get(address);
        if (keyMeta === void 0) {
          keyMeta = {
            isSigner: false,
            isWritable: false,
            isInvoked: false
          };
          keyMetaMap.set(address, keyMeta);
        }
        return keyMeta;
      };
      const payerKeyMeta = getOrInsertDefault(payer);
      payerKeyMeta.isSigner = true;
      payerKeyMeta.isWritable = true;
      for (const ix of instructions) {
        getOrInsertDefault(ix.programId).isInvoked = true;
        for (const accountMeta of ix.keys) {
          const keyMeta = getOrInsertDefault(accountMeta.pubkey);
          keyMeta.isSigner || (keyMeta.isSigner = accountMeta.isSigner);
          keyMeta.isWritable || (keyMeta.isWritable = accountMeta.isWritable);
        }
      }
      return new _CompiledKeys(payer, keyMetaMap);
    }
    getMessageComponents() {
      const mapEntries = [...this.keyMetaMap.entries()];
      assert2(mapEntries.length <= 256, "Max static account keys length exceeded");
      const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
      const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
      const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
      const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
      const header = {
        numRequiredSignatures: writableSigners.length + readonlySigners.length,
        numReadonlySignedAccounts: readonlySigners.length,
        numReadonlyUnsignedAccounts: readonlyNonSigners.length
      };
      {
        assert2(writableSigners.length > 0, "Expected at least one writable signer key");
        const [payerAddress] = writableSigners[0];
        assert2(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
      }
      const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey(address)), ...readonlySigners.map(([address]) => new PublicKey(address)), ...writableNonSigners.map(([address]) => new PublicKey(address)), ...readonlyNonSigners.map(([address]) => new PublicKey(address))];
      return [header, staticAccountKeys];
    }
    extractTableLookup(lookupTable) {
      const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
      const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
      if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
        return;
      }
      return [{
        accountKey: lookupTable.key,
        writableIndexes,
        readonlyIndexes
      }, {
        writable: drainedWritableKeys,
        readonly: drainedReadonlyKeys
      }];
    }
    /** @internal */
    drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
      const lookupTableIndexes = new Array();
      const drainedKeys = new Array();
      for (const [address, keyMeta] of this.keyMetaMap.entries()) {
        if (keyMetaFilter(keyMeta)) {
          const key = new PublicKey(address);
          const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
          if (lookupTableIndex >= 0) {
            assert2(lookupTableIndex < 256, "Max lookup table index exceeded");
            lookupTableIndexes.push(lookupTableIndex);
            drainedKeys.push(key);
            this.keyMetaMap.delete(address);
          }
        }
      }
      return [lookupTableIndexes, drainedKeys];
    }
  };
  var END_OF_BUFFER_ERROR_MESSAGE = "Reached end of buffer unexpectedly";
  function guardedShift(byteArray) {
    if (byteArray.length === 0) {
      throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
    }
    return byteArray.shift();
  }
  function guardedSplice(byteArray, ...args) {
    const [start] = args;
    if (args.length === 2 ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {
      throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
    }
    return byteArray.splice(...args);
  }
  var Message = class _Message {
    constructor(args) {
      this.header = void 0;
      this.accountKeys = void 0;
      this.recentBlockhash = void 0;
      this.instructions = void 0;
      this.indexToProgramIds = /* @__PURE__ */ new Map();
      this.header = args.header;
      this.accountKeys = args.accountKeys.map((account) => new PublicKey(account));
      this.recentBlockhash = args.recentBlockhash;
      this.instructions = args.instructions;
      this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
    }
    get version() {
      return "legacy";
    }
    get staticAccountKeys() {
      return this.accountKeys;
    }
    get compiledInstructions() {
      return this.instructions.map((ix) => ({
        programIdIndex: ix.programIdIndex,
        accountKeyIndexes: ix.accounts,
        data: import_bs58.default.decode(ix.data)
      }));
    }
    get addressTableLookups() {
      return [];
    }
    getAccountKeys() {
      return new MessageAccountKeys(this.staticAccountKeys);
    }
    static compile(args) {
      const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
      const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
      const accountKeys = new MessageAccountKeys(staticAccountKeys);
      const instructions = accountKeys.compileInstructions(args.instructions).map((ix) => ({
        programIdIndex: ix.programIdIndex,
        accounts: ix.accountKeyIndexes,
        data: import_bs58.default.encode(ix.data)
      }));
      return new _Message({
        header,
        accountKeys: staticAccountKeys,
        recentBlockhash: args.recentBlockhash,
        instructions
      });
    }
    isAccountSigner(index) {
      return index < this.header.numRequiredSignatures;
    }
    isAccountWritable(index) {
      const numSignedAccounts = this.header.numRequiredSignatures;
      if (index >= this.header.numRequiredSignatures) {
        const unsignedAccountIndex = index - numSignedAccounts;
        const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
        const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
        return unsignedAccountIndex < numWritableUnsignedAccounts;
      } else {
        const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
        return index < numWritableSignedAccounts;
      }
    }
    isProgramId(index) {
      return this.indexToProgramIds.has(index);
    }
    programIds() {
      return [...this.indexToProgramIds.values()];
    }
    nonProgramIds() {
      return this.accountKeys.filter((_, index) => !this.isProgramId(index));
    }
    serialize() {
      const numKeys = this.accountKeys.length;
      let keyCount = [];
      encodeLength(keyCount, numKeys);
      const instructions = this.instructions.map((instruction) => {
        const {
          accounts,
          programIdIndex
        } = instruction;
        const data = Array.from(import_bs58.default.decode(instruction.data));
        let keyIndicesCount = [];
        encodeLength(keyIndicesCount, accounts.length);
        let dataCount = [];
        encodeLength(dataCount, data.length);
        return {
          programIdIndex,
          keyIndicesCount: import_buffer2.Buffer.from(keyIndicesCount),
          keyIndices: accounts,
          dataLength: import_buffer2.Buffer.from(dataCount),
          data
        };
      });
      let instructionCount = [];
      encodeLength(instructionCount, instructions.length);
      let instructionBuffer = import_buffer2.Buffer.alloc(PACKET_DATA_SIZE);
      import_buffer2.Buffer.from(instructionCount).copy(instructionBuffer);
      let instructionBufferLength = instructionCount.length;
      instructions.forEach((instruction) => {
        const instructionLayout = BufferLayout.struct([BufferLayout.u8("programIdIndex"), BufferLayout.blob(instruction.keyIndicesCount.length, "keyIndicesCount"), BufferLayout.seq(BufferLayout.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), BufferLayout.blob(instruction.dataLength.length, "dataLength"), BufferLayout.seq(BufferLayout.u8("userdatum"), instruction.data.length, "data")]);
        const length2 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
        instructionBufferLength += length2;
      });
      instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
      const signDataLayout = BufferLayout.struct([BufferLayout.blob(1, "numRequiredSignatures"), BufferLayout.blob(1, "numReadonlySignedAccounts"), BufferLayout.blob(1, "numReadonlyUnsignedAccounts"), BufferLayout.blob(keyCount.length, "keyCount"), BufferLayout.seq(publicKey("key"), numKeys, "keys"), publicKey("recentBlockhash")]);
      const transaction = {
        numRequiredSignatures: import_buffer2.Buffer.from([this.header.numRequiredSignatures]),
        numReadonlySignedAccounts: import_buffer2.Buffer.from([this.header.numReadonlySignedAccounts]),
        numReadonlyUnsignedAccounts: import_buffer2.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
        keyCount: import_buffer2.Buffer.from(keyCount),
        keys: this.accountKeys.map((key) => toBuffer(key.toBytes())),
        recentBlockhash: import_bs58.default.decode(this.recentBlockhash)
      };
      let signData = import_buffer2.Buffer.alloc(2048);
      const length = signDataLayout.encode(transaction, signData);
      instructionBuffer.copy(signData, length);
      return signData.slice(0, length + instructionBuffer.length);
    }
    /**
     * Decode a compiled message into a Message object.
     */
    static from(buffer) {
      let byteArray = [...buffer];
      const numRequiredSignatures = guardedShift(byteArray);
      if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {
        throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
      }
      const numReadonlySignedAccounts = guardedShift(byteArray);
      const numReadonlyUnsignedAccounts = guardedShift(byteArray);
      const accountCount = decodeLength(byteArray);
      let accountKeys = [];
      for (let i = 0; i < accountCount; i++) {
        const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
        accountKeys.push(new PublicKey(import_buffer2.Buffer.from(account)));
      }
      const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
      const instructionCount = decodeLength(byteArray);
      let instructions = [];
      for (let i = 0; i < instructionCount; i++) {
        const programIdIndex = guardedShift(byteArray);
        const accountCount2 = decodeLength(byteArray);
        const accounts = guardedSplice(byteArray, 0, accountCount2);
        const dataLength = decodeLength(byteArray);
        const dataSlice = guardedSplice(byteArray, 0, dataLength);
        const data = import_bs58.default.encode(import_buffer2.Buffer.from(dataSlice));
        instructions.push({
          programIdIndex,
          accounts,
          data
        });
      }
      const messageArgs = {
        header: {
          numRequiredSignatures,
          numReadonlySignedAccounts,
          numReadonlyUnsignedAccounts
        },
        recentBlockhash: import_bs58.default.encode(import_buffer2.Buffer.from(recentBlockhash)),
        accountKeys,
        instructions
      };
      return new _Message(messageArgs);
    }
  };
  var MessageV0 = class _MessageV0 {
    constructor(args) {
      this.header = void 0;
      this.staticAccountKeys = void 0;
      this.recentBlockhash = void 0;
      this.compiledInstructions = void 0;
      this.addressTableLookups = void 0;
      this.header = args.header;
      this.staticAccountKeys = args.staticAccountKeys;
      this.recentBlockhash = args.recentBlockhash;
      this.compiledInstructions = args.compiledInstructions;
      this.addressTableLookups = args.addressTableLookups;
    }
    get version() {
      return 0;
    }
    get numAccountKeysFromLookups() {
      let count = 0;
      for (const lookup of this.addressTableLookups) {
        count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;
      }
      return count;
    }
    getAccountKeys(args) {
      let accountKeysFromLookups;
      if (args && "accountKeysFromLookups" in args && args.accountKeysFromLookups) {
        if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {
          throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
        }
        accountKeysFromLookups = args.accountKeysFromLookups;
      } else if (args && "addressLookupTableAccounts" in args && args.addressLookupTableAccounts) {
        accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
      } else if (this.addressTableLookups.length > 0) {
        throw new Error("Failed to get account keys because address table lookups were not resolved");
      }
      return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);
    }
    isAccountSigner(index) {
      return index < this.header.numRequiredSignatures;
    }
    isAccountWritable(index) {
      const numSignedAccounts = this.header.numRequiredSignatures;
      const numStaticAccountKeys = this.staticAccountKeys.length;
      if (index >= numStaticAccountKeys) {
        const lookupAccountKeysIndex = index - numStaticAccountKeys;
        const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup) => count + lookup.writableIndexes.length, 0);
        return lookupAccountKeysIndex < numWritableLookupAccountKeys;
      } else if (index >= this.header.numRequiredSignatures) {
        const unsignedAccountIndex = index - numSignedAccounts;
        const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
        const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
        return unsignedAccountIndex < numWritableUnsignedAccounts;
      } else {
        const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
        return index < numWritableSignedAccounts;
      }
    }
    resolveAddressTableLookups(addressLookupTableAccounts) {
      const accountKeysFromLookups = {
        writable: [],
        readonly: []
      };
      for (const tableLookup of this.addressTableLookups) {
        const tableAccount = addressLookupTableAccounts.find((account) => account.key.equals(tableLookup.accountKey));
        if (!tableAccount) {
          throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);
        }
        for (const index of tableLookup.writableIndexes) {
          if (index < tableAccount.state.addresses.length) {
            accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);
          } else {
            throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
          }
        }
        for (const index of tableLookup.readonlyIndexes) {
          if (index < tableAccount.state.addresses.length) {
            accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);
          } else {
            throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
          }
        }
      }
      return accountKeysFromLookups;
    }
    static compile(args) {
      const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
      const addressTableLookups = new Array();
      const accountKeysFromLookups = {
        writable: new Array(),
        readonly: new Array()
      };
      const lookupTableAccounts = args.addressLookupTableAccounts || [];
      for (const lookupTable of lookupTableAccounts) {
        const extractResult = compiledKeys.extractTableLookup(lookupTable);
        if (extractResult !== void 0) {
          const [addressTableLookup, {
            writable,
            readonly
          }] = extractResult;
          addressTableLookups.push(addressTableLookup);
          accountKeysFromLookups.writable.push(...writable);
          accountKeysFromLookups.readonly.push(...readonly);
        }
      }
      const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
      const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);
      const compiledInstructions = accountKeys.compileInstructions(args.instructions);
      return new _MessageV0({
        header,
        staticAccountKeys,
        recentBlockhash: args.recentBlockhash,
        compiledInstructions,
        addressTableLookups
      });
    }
    serialize() {
      const encodedStaticAccountKeysLength = Array();
      encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
      const serializedInstructions = this.serializeInstructions();
      const encodedInstructionsLength = Array();
      encodeLength(encodedInstructionsLength, this.compiledInstructions.length);
      const serializedAddressTableLookups = this.serializeAddressTableLookups();
      const encodedAddressTableLookupsLength = Array();
      encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);
      const messageLayout = BufferLayout.struct([BufferLayout.u8("prefix"), BufferLayout.struct([BufferLayout.u8("numRequiredSignatures"), BufferLayout.u8("numReadonlySignedAccounts"), BufferLayout.u8("numReadonlyUnsignedAccounts")], "header"), BufferLayout.blob(encodedStaticAccountKeysLength.length, "staticAccountKeysLength"), BufferLayout.seq(publicKey(), this.staticAccountKeys.length, "staticAccountKeys"), publicKey("recentBlockhash"), BufferLayout.blob(encodedInstructionsLength.length, "instructionsLength"), BufferLayout.blob(serializedInstructions.length, "serializedInstructions"), BufferLayout.blob(encodedAddressTableLookupsLength.length, "addressTableLookupsLength"), BufferLayout.blob(serializedAddressTableLookups.length, "serializedAddressTableLookups")]);
      const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);
      const MESSAGE_VERSION_0_PREFIX = 1 << 7;
      const serializedMessageLength = messageLayout.encode({
        prefix: MESSAGE_VERSION_0_PREFIX,
        header: this.header,
        staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
        staticAccountKeys: this.staticAccountKeys.map((key) => key.toBytes()),
        recentBlockhash: import_bs58.default.decode(this.recentBlockhash),
        instructionsLength: new Uint8Array(encodedInstructionsLength),
        serializedInstructions,
        addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
        serializedAddressTableLookups
      }, serializedMessage);
      return serializedMessage.slice(0, serializedMessageLength);
    }
    serializeInstructions() {
      let serializedLength = 0;
      const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);
      for (const instruction of this.compiledInstructions) {
        const encodedAccountKeyIndexesLength = Array();
        encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
        const encodedDataLength = Array();
        encodeLength(encodedDataLength, instruction.data.length);
        const instructionLayout = BufferLayout.struct([BufferLayout.u8("programIdIndex"), BufferLayout.blob(encodedAccountKeyIndexesLength.length, "encodedAccountKeyIndexesLength"), BufferLayout.seq(BufferLayout.u8(), instruction.accountKeyIndexes.length, "accountKeyIndexes"), BufferLayout.blob(encodedDataLength.length, "encodedDataLength"), BufferLayout.blob(instruction.data.length, "data")]);
        serializedLength += instructionLayout.encode({
          programIdIndex: instruction.programIdIndex,
          encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
          accountKeyIndexes: instruction.accountKeyIndexes,
          encodedDataLength: new Uint8Array(encodedDataLength),
          data: instruction.data
        }, serializedInstructions, serializedLength);
      }
      return serializedInstructions.slice(0, serializedLength);
    }
    serializeAddressTableLookups() {
      let serializedLength = 0;
      const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);
      for (const lookup of this.addressTableLookups) {
        const encodedWritableIndexesLength = Array();
        encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);
        const encodedReadonlyIndexesLength = Array();
        encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);
        const addressTableLookupLayout = BufferLayout.struct([publicKey("accountKey"), BufferLayout.blob(encodedWritableIndexesLength.length, "encodedWritableIndexesLength"), BufferLayout.seq(BufferLayout.u8(), lookup.writableIndexes.length, "writableIndexes"), BufferLayout.blob(encodedReadonlyIndexesLength.length, "encodedReadonlyIndexesLength"), BufferLayout.seq(BufferLayout.u8(), lookup.readonlyIndexes.length, "readonlyIndexes")]);
        serializedLength += addressTableLookupLayout.encode({
          accountKey: lookup.accountKey.toBytes(),
          encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
          writableIndexes: lookup.writableIndexes,
          encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
          readonlyIndexes: lookup.readonlyIndexes
        }, serializedAddressTableLookups, serializedLength);
      }
      return serializedAddressTableLookups.slice(0, serializedLength);
    }
    static deserialize(serializedMessage) {
      let byteArray = [...serializedMessage];
      const prefix = guardedShift(byteArray);
      const maskedPrefix = prefix & VERSION_PREFIX_MASK;
      assert2(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);
      const version2 = maskedPrefix;
      assert2(version2 === 0, `Expected versioned message with version 0 but found version ${version2}`);
      const header = {
        numRequiredSignatures: guardedShift(byteArray),
        numReadonlySignedAccounts: guardedShift(byteArray),
        numReadonlyUnsignedAccounts: guardedShift(byteArray)
      };
      const staticAccountKeys = [];
      const staticAccountKeysLength = decodeLength(byteArray);
      for (let i = 0; i < staticAccountKeysLength; i++) {
        staticAccountKeys.push(new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)));
      }
      const recentBlockhash = import_bs58.default.encode(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
      const instructionCount = decodeLength(byteArray);
      const compiledInstructions = [];
      for (let i = 0; i < instructionCount; i++) {
        const programIdIndex = guardedShift(byteArray);
        const accountKeyIndexesLength = decodeLength(byteArray);
        const accountKeyIndexes = guardedSplice(byteArray, 0, accountKeyIndexesLength);
        const dataLength = decodeLength(byteArray);
        const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength));
        compiledInstructions.push({
          programIdIndex,
          accountKeyIndexes,
          data
        });
      }
      const addressTableLookupsCount = decodeLength(byteArray);
      const addressTableLookups = [];
      for (let i = 0; i < addressTableLookupsCount; i++) {
        const accountKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
        const writableIndexesLength = decodeLength(byteArray);
        const writableIndexes = guardedSplice(byteArray, 0, writableIndexesLength);
        const readonlyIndexesLength = decodeLength(byteArray);
        const readonlyIndexes = guardedSplice(byteArray, 0, readonlyIndexesLength);
        addressTableLookups.push({
          accountKey,
          writableIndexes,
          readonlyIndexes
        });
      }
      return new _MessageV0({
        header,
        staticAccountKeys,
        recentBlockhash,
        compiledInstructions,
        addressTableLookups
      });
    }
  };
  var TransactionStatus = /* @__PURE__ */ function(TransactionStatus2) {
    TransactionStatus2[TransactionStatus2["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
    TransactionStatus2[TransactionStatus2["PROCESSED"] = 1] = "PROCESSED";
    TransactionStatus2[TransactionStatus2["TIMED_OUT"] = 2] = "TIMED_OUT";
    TransactionStatus2[TransactionStatus2["NONCE_INVALID"] = 3] = "NONCE_INVALID";
    return TransactionStatus2;
  }({});
  var DEFAULT_SIGNATURE = import_buffer2.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
  var TransactionInstruction = class {
    constructor(opts) {
      this.keys = void 0;
      this.programId = void 0;
      this.data = import_buffer2.Buffer.alloc(0);
      this.programId = opts.programId;
      this.keys = opts.keys;
      if (opts.data) {
        this.data = opts.data;
      }
    }
    /**
     * @internal
     */
    toJSON() {
      return {
        keys: this.keys.map(({
          pubkey,
          isSigner,
          isWritable
        }) => ({
          pubkey: pubkey.toJSON(),
          isSigner,
          isWritable
        })),
        programId: this.programId.toJSON(),
        data: [...this.data]
      };
    }
  };
  var Transaction = class _Transaction {
    /**
     * The first (payer) Transaction signature
     *
     * @returns {Buffer | null} Buffer of payer's signature
     */
    get signature() {
      if (this.signatures.length > 0) {
        return this.signatures[0].signature;
      }
      return null;
    }
    /**
     * The transaction fee payer
     */
    // Construct a transaction with a blockhash and lastValidBlockHeight
    // Construct a transaction using a durable nonce
    /**
     * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.
     * Please supply a `TransactionBlockhashCtor` instead.
     */
    /**
     * Construct an empty Transaction
     */
    constructor(opts) {
      this.signatures = [];
      this.feePayer = void 0;
      this.instructions = [];
      this.recentBlockhash = void 0;
      this.lastValidBlockHeight = void 0;
      this.nonceInfo = void 0;
      this.minNonceContextSlot = void 0;
      this._message = void 0;
      this._json = void 0;
      if (!opts) {
        return;
      }
      if (opts.feePayer) {
        this.feePayer = opts.feePayer;
      }
      if (opts.signatures) {
        this.signatures = opts.signatures;
      }
      if (Object.prototype.hasOwnProperty.call(opts, "nonceInfo")) {
        const {
          minContextSlot,
          nonceInfo
        } = opts;
        this.minNonceContextSlot = minContextSlot;
        this.nonceInfo = nonceInfo;
      } else if (Object.prototype.hasOwnProperty.call(opts, "lastValidBlockHeight")) {
        const {
          blockhash,
          lastValidBlockHeight
        } = opts;
        this.recentBlockhash = blockhash;
        this.lastValidBlockHeight = lastValidBlockHeight;
      } else {
        const {
          recentBlockhash,
          nonceInfo
        } = opts;
        if (nonceInfo) {
          this.nonceInfo = nonceInfo;
        }
        this.recentBlockhash = recentBlockhash;
      }
    }
    /**
     * @internal
     */
    toJSON() {
      return {
        recentBlockhash: this.recentBlockhash || null,
        feePayer: this.feePayer ? this.feePayer.toJSON() : null,
        nonceInfo: this.nonceInfo ? {
          nonce: this.nonceInfo.nonce,
          nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
        } : null,
        instructions: this.instructions.map((instruction) => instruction.toJSON()),
        signers: this.signatures.map(({
          publicKey: publicKey3
        }) => {
          return publicKey3.toJSON();
        })
      };
    }
    /**
     * Add one or more instructions to this Transaction
     *
     * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction
     */
    add(...items) {
      if (items.length === 0) {
        throw new Error("No instructions");
      }
      items.forEach((item) => {
        if ("instructions" in item) {
          this.instructions = this.instructions.concat(item.instructions);
        } else if ("data" in item && "programId" in item && "keys" in item) {
          this.instructions.push(item);
        } else {
          this.instructions.push(new TransactionInstruction(item));
        }
      });
      return this;
    }
    /**
     * Compile transaction data
     */
    compileMessage() {
      if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
        return this._message;
      }
      let recentBlockhash;
      let instructions;
      if (this.nonceInfo) {
        recentBlockhash = this.nonceInfo.nonce;
        if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
          instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
        } else {
          instructions = this.instructions;
        }
      } else {
        recentBlockhash = this.recentBlockhash;
        instructions = this.instructions;
      }
      if (!recentBlockhash) {
        throw new Error("Transaction recentBlockhash required");
      }
      if (instructions.length < 1) {
        console.warn("No instructions provided");
      }
      let feePayer;
      if (this.feePayer) {
        feePayer = this.feePayer;
      } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
        feePayer = this.signatures[0].publicKey;
      } else {
        throw new Error("Transaction fee payer required");
      }
      for (let i = 0; i < instructions.length; i++) {
        if (instructions[i].programId === void 0) {
          throw new Error(`Transaction instruction index ${i} has undefined program id`);
        }
      }
      const programIds = [];
      const accountMetas = [];
      instructions.forEach((instruction) => {
        instruction.keys.forEach((accountMeta) => {
          accountMetas.push({
            ...accountMeta
          });
        });
        const programId = instruction.programId.toString();
        if (!programIds.includes(programId)) {
          programIds.push(programId);
        }
      });
      programIds.forEach((programId) => {
        accountMetas.push({
          pubkey: new PublicKey(programId),
          isSigner: false,
          isWritable: false
        });
      });
      const uniqueMetas = [];
      accountMetas.forEach((accountMeta) => {
        const pubkeyString = accountMeta.pubkey.toString();
        const uniqueIndex = uniqueMetas.findIndex((x) => {
          return x.pubkey.toString() === pubkeyString;
        });
        if (uniqueIndex > -1) {
          uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
          uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
        } else {
          uniqueMetas.push(accountMeta);
        }
      });
      uniqueMetas.sort(function(x, y) {
        if (x.isSigner !== y.isSigner) {
          return x.isSigner ? -1 : 1;
        }
        if (x.isWritable !== y.isWritable) {
          return x.isWritable ? -1 : 1;
        }
        const options = {
          localeMatcher: "best fit",
          usage: "sort",
          sensitivity: "variant",
          ignorePunctuation: false,
          numeric: false,
          caseFirst: "lower"
        };
        return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), "en", options);
      });
      const feePayerIndex = uniqueMetas.findIndex((x) => {
        return x.pubkey.equals(feePayer);
      });
      if (feePayerIndex > -1) {
        const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
        payerMeta.isSigner = true;
        payerMeta.isWritable = true;
        uniqueMetas.unshift(payerMeta);
      } else {
        uniqueMetas.unshift({
          pubkey: feePayer,
          isSigner: true,
          isWritable: true
        });
      }
      for (const signature of this.signatures) {
        const uniqueIndex = uniqueMetas.findIndex((x) => {
          return x.pubkey.equals(signature.publicKey);
        });
        if (uniqueIndex > -1) {
          if (!uniqueMetas[uniqueIndex].isSigner) {
            uniqueMetas[uniqueIndex].isSigner = true;
            console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.");
          }
        } else {
          throw new Error(`unknown signer: ${signature.publicKey.toString()}`);
        }
      }
      let numRequiredSignatures = 0;
      let numReadonlySignedAccounts = 0;
      let numReadonlyUnsignedAccounts = 0;
      const signedKeys = [];
      const unsignedKeys = [];
      uniqueMetas.forEach(({
        pubkey,
        isSigner,
        isWritable
      }) => {
        if (isSigner) {
          signedKeys.push(pubkey.toString());
          numRequiredSignatures += 1;
          if (!isWritable) {
            numReadonlySignedAccounts += 1;
          }
        } else {
          unsignedKeys.push(pubkey.toString());
          if (!isWritable) {
            numReadonlyUnsignedAccounts += 1;
          }
        }
      });
      const accountKeys = signedKeys.concat(unsignedKeys);
      const compiledInstructions = instructions.map((instruction) => {
        const {
          data,
          programId
        } = instruction;
        return {
          programIdIndex: accountKeys.indexOf(programId.toString()),
          accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
          data: import_bs58.default.encode(data)
        };
      });
      compiledInstructions.forEach((instruction) => {
        assert2(instruction.programIdIndex >= 0);
        instruction.accounts.forEach((keyIndex) => assert2(keyIndex >= 0));
      });
      return new Message({
        header: {
          numRequiredSignatures,
          numReadonlySignedAccounts,
          numReadonlyUnsignedAccounts
        },
        accountKeys,
        recentBlockhash,
        instructions: compiledInstructions
      });
    }
    /**
     * @internal
     */
    _compile() {
      const message = this.compileMessage();
      const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
      if (this.signatures.length === signedKeys.length) {
        const valid = this.signatures.every((pair, index) => {
          return signedKeys[index].equals(pair.publicKey);
        });
        if (valid) return message;
      }
      this.signatures = signedKeys.map((publicKey3) => ({
        signature: null,
        publicKey: publicKey3
      }));
      return message;
    }
    /**
     * Get a buffer of the Transaction data that need to be covered by signatures
     */
    serializeMessage() {
      return this._compile().serialize();
    }
    /**
     * Get the estimated fee associated with a transaction
     *
     * @param {Connection} connection Connection to RPC Endpoint.
     *
     * @returns {Promise<number | null>} The estimated fee for the transaction
     */
    async getEstimatedFee(connection) {
      return (await connection.getFeeForMessage(this.compileMessage())).value;
    }
    /**
     * Specify the public keys which will be used to sign the Transaction.
     * The first signer will be used as the transaction fee payer account.
     *
     * Signatures can be added with either `partialSign` or `addSignature`
     *
     * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
     * specified and it can be set in the Transaction constructor or with the
     * `feePayer` property.
     */
    setSigners(...signers) {
      if (signers.length === 0) {
        throw new Error("No signers");
      }
      const seen = /* @__PURE__ */ new Set();
      this.signatures = signers.filter((publicKey3) => {
        const key = publicKey3.toString();
        if (seen.has(key)) {
          return false;
        } else {
          seen.add(key);
          return true;
        }
      }).map((publicKey3) => ({
        signature: null,
        publicKey: publicKey3
      }));
    }
    /**
     * Sign the Transaction with the specified signers. Multiple signatures may
     * be applied to a Transaction. The first signature is considered "primary"
     * and is used identify and confirm transactions.
     *
     * If the Transaction `feePayer` is not set, the first signer will be used
     * as the transaction fee payer account.
     *
     * Transaction fields should not be modified after the first call to `sign`,
     * as doing so may invalidate the signature and cause the Transaction to be
     * rejected.
     *
     * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
     *
     * @param {Array<Signer>} signers Array of signers that will sign the transaction
     */
    sign(...signers) {
      if (signers.length === 0) {
        throw new Error("No signers");
      }
      const seen = /* @__PURE__ */ new Set();
      const uniqueSigners = [];
      for (const signer of signers) {
        const key = signer.publicKey.toString();
        if (seen.has(key)) {
          continue;
        } else {
          seen.add(key);
          uniqueSigners.push(signer);
        }
      }
      this.signatures = uniqueSigners.map((signer) => ({
        signature: null,
        publicKey: signer.publicKey
      }));
      const message = this._compile();
      this._partialSign(message, ...uniqueSigners);
    }
    /**
     * Partially sign a transaction with the specified accounts. All accounts must
     * correspond to either the fee payer or a signer account in the transaction
     * instructions.
     *
     * All the caveats from the `sign` method apply to `partialSign`
     *
     * @param {Array<Signer>} signers Array of signers that will sign the transaction
     */
    partialSign(...signers) {
      if (signers.length === 0) {
        throw new Error("No signers");
      }
      const seen = /* @__PURE__ */ new Set();
      const uniqueSigners = [];
      for (const signer of signers) {
        const key = signer.publicKey.toString();
        if (seen.has(key)) {
          continue;
        } else {
          seen.add(key);
          uniqueSigners.push(signer);
        }
      }
      const message = this._compile();
      this._partialSign(message, ...uniqueSigners);
    }
    /**
     * @internal
     */
    _partialSign(message, ...signers) {
      const signData = message.serialize();
      signers.forEach((signer) => {
        const signature = sign(signData, signer.secretKey);
        this._addSignature(signer.publicKey, toBuffer(signature));
      });
    }
    /**
     * Add an externally created signature to a transaction. The public key
     * must correspond to either the fee payer or a signer account in the transaction
     * instructions.
     *
     * @param {PublicKey} pubkey Public key that will be added to the transaction.
     * @param {Buffer} signature An externally created signature to add to the transaction.
     */
    addSignature(pubkey, signature) {
      this._compile();
      this._addSignature(pubkey, signature);
    }
    /**
     * @internal
     */
    _addSignature(pubkey, signature) {
      assert2(signature.length === 64);
      const index = this.signatures.findIndex((sigpair) => pubkey.equals(sigpair.publicKey));
      if (index < 0) {
        throw new Error(`unknown signer: ${pubkey.toString()}`);
      }
      this.signatures[index].signature = import_buffer2.Buffer.from(signature);
    }
    /**
     * Verify signatures of a Transaction
     * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
     * If no boolean is provided, we expect a fully signed Transaction by default.
     *
     * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction
     */
    verifySignatures(requireAllSignatures = true) {
      const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);
      return !signatureErrors;
    }
    /**
     * @internal
     */
    _getMessageSignednessErrors(message, requireAllSignatures) {
      const errors = {};
      for (const {
        signature,
        publicKey: publicKey3
      } of this.signatures) {
        if (signature === null) {
          if (requireAllSignatures) {
            (errors.missing || (errors.missing = [])).push(publicKey3);
          }
        } else {
          if (!verify(signature, message, publicKey3.toBytes())) {
            (errors.invalid || (errors.invalid = [])).push(publicKey3);
          }
        }
      }
      return errors.invalid || errors.missing ? errors : void 0;
    }
    /**
     * Serialize the Transaction in the wire format.
     *
     * @param {Buffer} [config] Config of transaction.
     *
     * @returns {Buffer} Signature of transaction in wire format.
     */
    serialize(config) {
      const {
        requireAllSignatures,
        verifySignatures
      } = Object.assign({
        requireAllSignatures: true,
        verifySignatures: true
      }, config);
      const signData = this.serializeMessage();
      if (verifySignatures) {
        const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);
        if (sigErrors) {
          let errorMessage = "Signature verification failed.";
          if (sigErrors.invalid) {
            errorMessage += `
Invalid signature for public key${sigErrors.invalid.length === 1 ? "" : "(s)"} [\`${sigErrors.invalid.map((p) => p.toBase58()).join("`, `")}\`].`;
          }
          if (sigErrors.missing) {
            errorMessage += `
Missing signature for public key${sigErrors.missing.length === 1 ? "" : "(s)"} [\`${sigErrors.missing.map((p) => p.toBase58()).join("`, `")}\`].`;
          }
          throw new Error(errorMessage);
        }
      }
      return this._serialize(signData);
    }
    /**
     * @internal
     */
    _serialize(signData) {
      const {
        signatures
      } = this;
      const signatureCount = [];
      encodeLength(signatureCount, signatures.length);
      const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
      const wireTransaction = import_buffer2.Buffer.alloc(transactionLength);
      assert2(signatures.length < 256);
      import_buffer2.Buffer.from(signatureCount).copy(wireTransaction, 0);
      signatures.forEach(({
        signature
      }, index) => {
        if (signature !== null) {
          assert2(signature.length === 64, `signature has invalid length`);
          import_buffer2.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);
        }
      });
      signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
      assert2(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
      return wireTransaction;
    }
    /**
     * Deprecated method
     * @internal
     */
    get keys() {
      assert2(this.instructions.length === 1);
      return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
    }
    /**
     * Deprecated method
     * @internal
     */
    get programId() {
      assert2(this.instructions.length === 1);
      return this.instructions[0].programId;
    }
    /**
     * Deprecated method
     * @internal
     */
    get data() {
      assert2(this.instructions.length === 1);
      return this.instructions[0].data;
    }
    /**
     * Parse a wire transaction into a Transaction object.
     *
     * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction
     *
     * @returns {Transaction} Transaction associated with the signature
     */
    static from(buffer) {
      let byteArray = [...buffer];
      const signatureCount = decodeLength(byteArray);
      let signatures = [];
      for (let i = 0; i < signatureCount; i++) {
        const signature = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);
        signatures.push(import_bs58.default.encode(import_buffer2.Buffer.from(signature)));
      }
      return _Transaction.populate(Message.from(byteArray), signatures);
    }
    /**
     * Populate Transaction object from message and signatures
     *
     * @param {Message} message Message of transaction
     * @param {Array<string>} signatures List of signatures to assign to the transaction
     *
     * @returns {Transaction} The populated Transaction
     */
    static populate(message, signatures = []) {
      const transaction = new _Transaction();
      transaction.recentBlockhash = message.recentBlockhash;
      if (message.header.numRequiredSignatures > 0) {
        transaction.feePayer = message.accountKeys[0];
      }
      signatures.forEach((signature, index) => {
        const sigPubkeyPair = {
          signature: signature == import_bs58.default.encode(DEFAULT_SIGNATURE) ? null : import_bs58.default.decode(signature),
          publicKey: message.accountKeys[index]
        };
        transaction.signatures.push(sigPubkeyPair);
      });
      message.instructions.forEach((instruction) => {
        const keys = instruction.accounts.map((account) => {
          const pubkey = message.accountKeys[account];
          return {
            pubkey,
            isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),
            isWritable: message.isAccountWritable(account)
          };
        });
        transaction.instructions.push(new TransactionInstruction({
          keys,
          programId: message.accountKeys[instruction.programIdIndex],
          data: import_bs58.default.decode(instruction.data)
        }));
      });
      transaction._message = message;
      transaction._json = transaction.toJSON();
      return transaction;
    }
  };
  var NUM_TICKS_PER_SECOND = 160;
  var DEFAULT_TICKS_PER_SLOT = 64;
  var NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;
  var MS_PER_SLOT = 1e3 / NUM_SLOTS_PER_SECOND;
  var SYSVAR_CLOCK_PUBKEY = new PublicKey("SysvarC1ock11111111111111111111111111111111");
  var SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey("SysvarEpochSchedu1e111111111111111111111111");
  var SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey("Sysvar1nstructions1111111111111111111111111");
  var SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey("SysvarRecentB1ockHashes11111111111111111111");
  var SYSVAR_RENT_PUBKEY = new PublicKey("SysvarRent111111111111111111111111111111111");
  var SYSVAR_REWARDS_PUBKEY = new PublicKey("SysvarRewards111111111111111111111111111111");
  var SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey("SysvarS1otHashes111111111111111111111111111");
  var SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey("SysvarS1otHistory11111111111111111111111111");
  var SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey("SysvarStakeHistory1111111111111111111111111");
  var SendTransactionError = class extends Error {
    constructor({
      action,
      signature,
      transactionMessage,
      logs
    }) {
      const maybeLogsOutput = logs ? `Logs: 
${JSON.stringify(logs.slice(-10), null, 2)}. ` : "";
      const guideText = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
      let message;
      switch (action) {
        case "send":
          message = `Transaction ${signature} resulted in an error. 
${transactionMessage}. ` + maybeLogsOutput + guideText;
          break;
        case "simulate":
          message = `Simulation failed. 
Message: ${transactionMessage}. 
` + maybeLogsOutput + guideText;
          break;
        default: {
          message = `Unknown action '${/* @__PURE__ */ ((a) => a)(action)}'`;
        }
      }
      super(message);
      this.signature = void 0;
      this.transactionMessage = void 0;
      this.transactionLogs = void 0;
      this.signature = signature;
      this.transactionMessage = transactionMessage;
      this.transactionLogs = logs ? logs : void 0;
    }
    get transactionError() {
      return {
        message: this.transactionMessage,
        logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0
      };
    }
    /* @deprecated Use `await getLogs()` instead */
    get logs() {
      const cachedLogs = this.transactionLogs;
      if (cachedLogs != null && typeof cachedLogs === "object" && "then" in cachedLogs) {
        return void 0;
      }
      return cachedLogs;
    }
    async getLogs(connection) {
      if (!Array.isArray(this.transactionLogs)) {
        this.transactionLogs = new Promise((resolve, reject) => {
          connection.getTransaction(this.signature).then((tx) => {
            if (tx && tx.meta && tx.meta.logMessages) {
              const logs = tx.meta.logMessages;
              this.transactionLogs = logs;
              resolve(logs);
            } else {
              reject(new Error("Log messages not found"));
            }
          }).catch(reject);
        });
      }
      return await this.transactionLogs;
    }
  };
  var SolanaJSONRPCError = class extends Error {
    constructor({
      code,
      message,
      data
    }, customMessage) {
      super(customMessage != null ? `${customMessage}: ${message}` : message);
      this.code = void 0;
      this.data = void 0;
      this.code = code;
      this.data = data;
      this.name = "SolanaJSONRPCError";
    }
  };
  async function sendAndConfirmTransaction(connection, transaction, signers, options) {
    const sendOptions = options && {
      skipPreflight: options.skipPreflight,
      preflightCommitment: options.preflightCommitment || options.commitment,
      maxRetries: options.maxRetries,
      minContextSlot: options.minContextSlot
    };
    const signature = await connection.sendTransaction(transaction, signers, sendOptions);
    let status;
    if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
      status = (await connection.confirmTransaction({
        abortSignal: options?.abortSignal,
        signature,
        blockhash: transaction.recentBlockhash,
        lastValidBlockHeight: transaction.lastValidBlockHeight
      }, options && options.commitment)).value;
    } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
      const {
        nonceInstruction
      } = transaction.nonceInfo;
      const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
      status = (await connection.confirmTransaction({
        abortSignal: options?.abortSignal,
        minContextSlot: transaction.minNonceContextSlot,
        nonceAccountPubkey,
        nonceValue: transaction.nonceInfo.nonce,
        signature
      }, options && options.commitment)).value;
    } else {
      if (options?.abortSignal != null) {
        console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");
      }
      status = (await connection.confirmTransaction(signature, options && options.commitment)).value;
    }
    if (status.err) {
      if (signature != null) {
        throw new SendTransactionError({
          action: "send",
          signature,
          transactionMessage: `Status: (${JSON.stringify(status)})`
        });
      }
      throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);
    }
    return signature;
  }
  function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  function encodeData(type2, fields) {
    const allocLength = type2.layout.span >= 0 ? type2.layout.span : getAlloc(type2, fields);
    const data = import_buffer2.Buffer.alloc(allocLength);
    const layoutFields = Object.assign({
      instruction: type2.index
    }, fields);
    type2.layout.encode(layoutFields, data);
    return data;
  }
  var FeeCalculatorLayout = BufferLayout.nu64("lamportsPerSignature");
  var NonceAccountLayout = BufferLayout.struct([BufferLayout.u32("version"), BufferLayout.u32("state"), publicKey("authorizedPubkey"), publicKey("nonce"), BufferLayout.struct([FeeCalculatorLayout], "feeCalculator")]);
  var NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
  var NonceAccount = class _NonceAccount {
    /**
     * @internal
     */
    constructor(args) {
      this.authorizedPubkey = void 0;
      this.nonce = void 0;
      this.feeCalculator = void 0;
      this.authorizedPubkey = args.authorizedPubkey;
      this.nonce = args.nonce;
      this.feeCalculator = args.feeCalculator;
    }
    /**
     * Deserialize NonceAccount from the account data.
     *
     * @param buffer account data
     * @return NonceAccount
     */
    static fromAccountData(buffer) {
      const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);
      return new _NonceAccount({
        authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),
        nonce: new PublicKey(nonceAccount.nonce).toString(),
        feeCalculator: nonceAccount.feeCalculator
      });
    }
  };
  function u64(property) {
    const layout = (0, import_buffer_layout.blob)(8, property);
    const decode = layout.decode.bind(layout);
    const encode = layout.encode.bind(layout);
    const bigIntLayout = layout;
    const codec = getU64Codec();
    bigIntLayout.decode = (buffer, offset2) => {
      const src = decode(buffer, offset2);
      return codec.decode(src);
    };
    bigIntLayout.encode = (bigInt2, buffer, offset2) => {
      const src = codec.encode(bigInt2);
      return encode(src, buffer, offset2);
    };
    return bigIntLayout;
  }
  var SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
    Create: {
      index: 0,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports"), BufferLayout.ns64("space"), publicKey("programId")])
    },
    Assign: {
      index: 1,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("programId")])
    },
    Transfer: {
      index: 2,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), u64("lamports")])
    },
    CreateWithSeed: {
      index: 3,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout.ns64("lamports"), BufferLayout.ns64("space"), publicKey("programId")])
    },
    AdvanceNonceAccount: {
      index: 4,
      layout: BufferLayout.struct([BufferLayout.u32("instruction")])
    },
    WithdrawNonceAccount: {
      index: 5,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
    },
    InitializeNonceAccount: {
      index: 6,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("authorized")])
    },
    AuthorizeNonceAccount: {
      index: 7,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("authorized")])
    },
    Allocate: {
      index: 8,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("space")])
    },
    AllocateWithSeed: {
      index: 9,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout.ns64("space"), publicKey("programId")])
    },
    AssignWithSeed: {
      index: 10,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), publicKey("programId")])
    },
    TransferWithSeed: {
      index: 11,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), u64("lamports"), rustString("seed"), publicKey("programId")])
    },
    UpgradeNonceAccount: {
      index: 12,
      layout: BufferLayout.struct([BufferLayout.u32("instruction")])
    }
  });
  var SystemProgram = class _SystemProgram {
    /**
     * @internal
     */
    constructor() {
    }
    /**
     * Public key that identifies the System program
     */
    /**
     * Generate a transaction instruction that creates a new account
     */
    static createAccount(params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Create;
      const data = encodeData(type2, {
        lamports: params.lamports,
        space: params.space,
        programId: toBuffer(params.programId.toBuffer())
      });
      return new TransactionInstruction({
        keys: [{
          pubkey: params.fromPubkey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: params.newAccountPubkey,
          isSigner: true,
          isWritable: true
        }],
        programId: this.programId,
        data
      });
    }
    /**
     * Generate a transaction instruction that transfers lamports from one account to another
     */
    static transfer(params) {
      let data;
      let keys;
      if ("basePubkey" in params) {
        const type2 = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
        data = encodeData(type2, {
          lamports: BigInt(params.lamports),
          seed: params.seed,
          programId: toBuffer(params.programId.toBuffer())
        });
        keys = [{
          pubkey: params.fromPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.basePubkey,
          isSigner: true,
          isWritable: false
        }, {
          pubkey: params.toPubkey,
          isSigner: false,
          isWritable: true
        }];
      } else {
        const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
        data = encodeData(type2, {
          lamports: BigInt(params.lamports)
        });
        keys = [{
          pubkey: params.fromPubkey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: params.toPubkey,
          isSigner: false,
          isWritable: true
        }];
      }
      return new TransactionInstruction({
        keys,
        programId: this.programId,
        data
      });
    }
    /**
     * Generate a transaction instruction that assigns an account to a program
     */
    static assign(params) {
      let data;
      let keys;
      if ("basePubkey" in params) {
        const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
        data = encodeData(type2, {
          base: toBuffer(params.basePubkey.toBuffer()),
          seed: params.seed,
          programId: toBuffer(params.programId.toBuffer())
        });
        keys = [{
          pubkey: params.accountPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.basePubkey,
          isSigner: true,
          isWritable: false
        }];
      } else {
        const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
        data = encodeData(type2, {
          programId: toBuffer(params.programId.toBuffer())
        });
        keys = [{
          pubkey: params.accountPubkey,
          isSigner: true,
          isWritable: true
        }];
      }
      return new TransactionInstruction({
        keys,
        programId: this.programId,
        data
      });
    }
    /**
     * Generate a transaction instruction that creates a new account at
     *   an address generated with `from`, a seed, and programId
     */
    static createAccountWithSeed(params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
      const data = encodeData(type2, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        lamports: params.lamports,
        space: params.space,
        programId: toBuffer(params.programId.toBuffer())
      });
      let keys = [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: false,
        isWritable: true
      }];
      if (!params.basePubkey.equals(params.fromPubkey)) {
        keys.push({
          pubkey: params.basePubkey,
          isSigner: true,
          isWritable: false
        });
      }
      return new TransactionInstruction({
        keys,
        programId: this.programId,
        data
      });
    }
    /**
     * Generate a transaction that creates a new Nonce account
     */
    static createNonceAccount(params) {
      const transaction = new Transaction();
      if ("basePubkey" in params && "seed" in params) {
        transaction.add(_SystemProgram.createAccountWithSeed({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.noncePubkey,
          basePubkey: params.basePubkey,
          seed: params.seed,
          lamports: params.lamports,
          space: NONCE_ACCOUNT_LENGTH,
          programId: this.programId
        }));
      } else {
        transaction.add(_SystemProgram.createAccount({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.noncePubkey,
          lamports: params.lamports,
          space: NONCE_ACCOUNT_LENGTH,
          programId: this.programId
        }));
      }
      const initParams = {
        noncePubkey: params.noncePubkey,
        authorizedPubkey: params.authorizedPubkey
      };
      transaction.add(this.nonceInitialize(initParams));
      return transaction;
    }
    /**
     * Generate an instruction to initialize a Nonce account
     */
    static nonceInitialize(params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
      const data = encodeData(type2, {
        authorized: toBuffer(params.authorizedPubkey.toBuffer())
      });
      const instructionData = {
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }],
        programId: this.programId,
        data
      };
      return new TransactionInstruction(instructionData);
    }
    /**
     * Generate an instruction to advance the nonce in a Nonce account
     */
    static nonceAdvance(params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
      const data = encodeData(type2);
      const instructionData = {
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: params.authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data
      };
      return new TransactionInstruction(instructionData);
    }
    /**
     * Generate a transaction instruction that withdraws lamports from a Nonce account
     */
    static nonceWithdraw(params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
      const data = encodeData(type2, {
        lamports: params.lamports
      });
      return new TransactionInstruction({
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.toPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: params.authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data
      });
    }
    /**
     * Generate a transaction instruction that authorizes a new PublicKey as the authority
     * on a Nonce account.
     */
    static nonceAuthorize(params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
      const data = encodeData(type2, {
        authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
      });
      return new TransactionInstruction({
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data
      });
    }
    /**
     * Generate a transaction instruction that allocates space in an account without funding
     */
    static allocate(params) {
      let data;
      let keys;
      if ("basePubkey" in params) {
        const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
        data = encodeData(type2, {
          base: toBuffer(params.basePubkey.toBuffer()),
          seed: params.seed,
          space: params.space,
          programId: toBuffer(params.programId.toBuffer())
        });
        keys = [{
          pubkey: params.accountPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.basePubkey,
          isSigner: true,
          isWritable: false
        }];
      } else {
        const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
        data = encodeData(type2, {
          space: params.space
        });
        keys = [{
          pubkey: params.accountPubkey,
          isSigner: true,
          isWritable: true
        }];
      }
      return new TransactionInstruction({
        keys,
        programId: this.programId,
        data
      });
    }
  };
  SystemProgram.programId = new PublicKey("11111111111111111111111111111111");
  var CHUNK_SIZE = PACKET_DATA_SIZE - 300;
  var Loader = class _Loader {
    /**
     * @internal
     */
    constructor() {
    }
    /**
     * Amount of program data placed in each load Transaction
     */
    /**
     * Minimum number of signatures required to load a program not including
     * retries
     *
     * Can be used to calculate transaction fees
     */
    static getMinNumSignatures(dataLength) {
      return 2 * // Every transaction requires two signatures (payer + program)
      (Math.ceil(dataLength / _Loader.chunkSize) + 1 + // Add one for Create transaction
      1);
    }
    /**
     * Loads a generic program
     *
     * @param connection The connection to use
     * @param payer System account that pays to load the program
     * @param program Account to load the program into
     * @param programId Public key that identifies the loader
     * @param data Program octets
     * @return true if program was loaded successfully, false if program was already loaded
     */
    static async load(connection, payer, program, programId, data) {
      {
        const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);
        const programInfo = await connection.getAccountInfo(program.publicKey, "confirmed");
        let transaction = null;
        if (programInfo !== null) {
          if (programInfo.executable) {
            console.error("Program load failed, account is already executable");
            return false;
          }
          if (programInfo.data.length !== data.length) {
            transaction = transaction || new Transaction();
            transaction.add(SystemProgram.allocate({
              accountPubkey: program.publicKey,
              space: data.length
            }));
          }
          if (!programInfo.owner.equals(programId)) {
            transaction = transaction || new Transaction();
            transaction.add(SystemProgram.assign({
              accountPubkey: program.publicKey,
              programId
            }));
          }
          if (programInfo.lamports < balanceNeeded) {
            transaction = transaction || new Transaction();
            transaction.add(SystemProgram.transfer({
              fromPubkey: payer.publicKey,
              toPubkey: program.publicKey,
              lamports: balanceNeeded - programInfo.lamports
            }));
          }
        } else {
          transaction = new Transaction().add(SystemProgram.createAccount({
            fromPubkey: payer.publicKey,
            newAccountPubkey: program.publicKey,
            lamports: balanceNeeded > 0 ? balanceNeeded : 1,
            space: data.length,
            programId
          }));
        }
        if (transaction !== null) {
          await sendAndConfirmTransaction(connection, transaction, [payer, program], {
            commitment: "confirmed"
          });
        }
      }
      const dataLayout = BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.u32("offset"), BufferLayout.u32("bytesLength"), BufferLayout.u32("bytesLengthPadding"), BufferLayout.seq(BufferLayout.u8("byte"), BufferLayout.offset(BufferLayout.u32(), -8), "bytes")]);
      const chunkSize = _Loader.chunkSize;
      let offset2 = 0;
      let array2 = data;
      let transactions = [];
      while (array2.length > 0) {
        const bytes = array2.slice(0, chunkSize);
        const data2 = import_buffer2.Buffer.alloc(chunkSize + 16);
        dataLayout.encode({
          instruction: 0,
          // Load instruction
          offset: offset2,
          bytes,
          bytesLength: 0,
          bytesLengthPadding: 0
        }, data2);
        const transaction = new Transaction().add({
          keys: [{
            pubkey: program.publicKey,
            isSigner: true,
            isWritable: true
          }],
          programId,
          data: data2
        });
        transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program], {
          commitment: "confirmed"
        }));
        if (connection._rpcEndpoint.includes("solana.com")) {
          const REQUESTS_PER_SECOND = 4;
          await sleep(1e3 / REQUESTS_PER_SECOND);
        }
        offset2 += chunkSize;
        array2 = array2.slice(chunkSize);
      }
      await Promise.all(transactions);
      {
        const dataLayout2 = BufferLayout.struct([BufferLayout.u32("instruction")]);
        const data2 = import_buffer2.Buffer.alloc(dataLayout2.span);
        dataLayout2.encode({
          instruction: 1
          // Finalize instruction
        }, data2);
        const transaction = new Transaction().add({
          keys: [{
            pubkey: program.publicKey,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }],
          programId,
          data: data2
        });
        const deployCommitment = "processed";
        const finalizeSignature = await connection.sendTransaction(transaction, [payer, program], {
          preflightCommitment: deployCommitment
        });
        const {
          context,
          value
        } = await connection.confirmTransaction({
          signature: finalizeSignature,
          lastValidBlockHeight: transaction.lastValidBlockHeight,
          blockhash: transaction.recentBlockhash
        }, deployCommitment);
        if (value.err) {
          throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);
        }
        while (true) {
          try {
            const currentSlot = await connection.getSlot({
              commitment: deployCommitment
            });
            if (currentSlot > context.slot) {
              break;
            }
          } catch {
          }
          await new Promise((resolve) => setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));
        }
      }
      return true;
    }
  };
  Loader.chunkSize = CHUNK_SIZE;
  var BPF_LOADER_PROGRAM_ID = new PublicKey("BPFLoader2111111111111111111111111111111111");
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var fastStableStringify$1;
  var hasRequiredFastStableStringify;
  function requireFastStableStringify() {
    if (hasRequiredFastStableStringify) return fastStableStringify$1;
    hasRequiredFastStableStringify = 1;
    var objToString = Object.prototype.toString;
    var objKeys = Object.keys || function(obj) {
      var keys = [];
      for (var name in obj) {
        keys.push(name);
      }
      return keys;
    };
    function stringify2(val, isArrayProp) {
      var i, max, str, keys, key, propVal, toStr;
      if (val === true) {
        return "true";
      }
      if (val === false) {
        return "false";
      }
      switch (typeof val) {
        case "object":
          if (val === null) {
            return null;
          } else if (val.toJSON && typeof val.toJSON === "function") {
            return stringify2(val.toJSON(), isArrayProp);
          } else {
            toStr = objToString.call(val);
            if (toStr === "[object Array]") {
              str = "[";
              max = val.length - 1;
              for (i = 0; i < max; i++) {
                str += stringify2(val[i], true) + ",";
              }
              if (max > -1) {
                str += stringify2(val[i], true);
              }
              return str + "]";
            } else if (toStr === "[object Object]") {
              keys = objKeys(val).sort();
              max = keys.length;
              str = "";
              i = 0;
              while (i < max) {
                key = keys[i];
                propVal = stringify2(val[key], false);
                if (propVal !== void 0) {
                  if (str) {
                    str += ",";
                  }
                  str += JSON.stringify(key) + ":" + propVal;
                }
                i++;
              }
              return "{" + str + "}";
            } else {
              return JSON.stringify(val);
            }
          }
        case "function":
        case "undefined":
          return isArrayProp ? null : void 0;
        case "string":
          return JSON.stringify(val);
        default:
          return isFinite(val) ? val : null;
      }
    }
    fastStableStringify$1 = function(val) {
      var returnVal = stringify2(val, false);
      if (returnVal !== void 0) {
        return "" + returnVal;
      }
    };
    return fastStableStringify$1;
  }
  var fastStableStringifyExports = /* @__PURE__ */ requireFastStableStringify();
  var fastStableStringify = /* @__PURE__ */ getDefaultExportFromCjs(fastStableStringifyExports);
  var MINIMUM_SLOT_PER_EPOCH = 32;
  function trailingZeros(n) {
    let trailingZeros2 = 0;
    while (n > 1) {
      n /= 2;
      trailingZeros2++;
    }
    return trailingZeros2;
  }
  function nextPowerOfTwo(n) {
    if (n === 0) return 1;
    n--;
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;
    n |= n >> 32;
    return n + 1;
  }
  var EpochSchedule = class {
    constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
      this.slotsPerEpoch = void 0;
      this.leaderScheduleSlotOffset = void 0;
      this.warmup = void 0;
      this.firstNormalEpoch = void 0;
      this.firstNormalSlot = void 0;
      this.slotsPerEpoch = slotsPerEpoch;
      this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
      this.warmup = warmup;
      this.firstNormalEpoch = firstNormalEpoch;
      this.firstNormalSlot = firstNormalSlot;
    }
    getEpoch(slot) {
      return this.getEpochAndSlotIndex(slot)[0];
    }
    getEpochAndSlotIndex(slot) {
      if (slot < this.firstNormalSlot) {
        const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
        const epochLen = this.getSlotsInEpoch(epoch);
        const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);
        return [epoch, slotIndex];
      } else {
        const normalSlotIndex = slot - this.firstNormalSlot;
        const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
        const epoch = this.firstNormalEpoch + normalEpochIndex;
        const slotIndex = normalSlotIndex % this.slotsPerEpoch;
        return [epoch, slotIndex];
      }
    }
    getFirstSlotInEpoch(epoch) {
      if (epoch <= this.firstNormalEpoch) {
        return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
      } else {
        return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
      }
    }
    getLastSlotInEpoch(epoch) {
      return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
    }
    getSlotsInEpoch(epoch) {
      if (epoch < this.firstNormalEpoch) {
        return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
      } else {
        return this.slotsPerEpoch;
      }
    }
  };
  var fetchImpl = globalThis.fetch;
  var RpcWebSocketClient = class extends CommonClient {
    constructor(address, options, generate_request_id) {
      const webSocketFactory = (url) => {
        const rpc = WebSocket(url, {
          autoconnect: true,
          max_reconnects: 5,
          reconnect: true,
          reconnect_interval: 1e3,
          ...options
        });
        if ("socket" in rpc) {
          this.underlyingSocket = rpc.socket;
        } else {
          this.underlyingSocket = rpc;
        }
        return rpc;
      };
      super(webSocketFactory, address, options, generate_request_id);
      this.underlyingSocket = void 0;
    }
    call(...args) {
      const readyState = this.underlyingSocket?.readyState;
      if (readyState === 1) {
        return super.call(...args);
      }
      return Promise.reject(new Error("Tried to call a JSON-RPC method `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
    }
    notify(...args) {
      const readyState = this.underlyingSocket?.readyState;
      if (readyState === 1) {
        return super.notify(...args);
      }
      return Promise.reject(new Error("Tried to send a JSON-RPC notification `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
    }
  };
  function decodeData(type2, data) {
    let decoded;
    try {
      decoded = type2.layout.decode(data);
    } catch (err) {
      throw new Error("invalid instruction; " + err);
    }
    if (decoded.typeIndex !== type2.index) {
      throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type2.index}`);
    }
    return decoded;
  }
  var LOOKUP_TABLE_META_SIZE = 56;
  var AddressLookupTableAccount = class {
    constructor(args) {
      this.key = void 0;
      this.state = void 0;
      this.key = args.key;
      this.state = args.state;
    }
    isActive() {
      const U64_MAX = BigInt("0xffffffffffffffff");
      return this.state.deactivationSlot === U64_MAX;
    }
    static deserialize(accountData) {
      const meta = decodeData(LookupTableMetaLayout, accountData);
      const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;
      assert2(serializedAddressesLen >= 0, "lookup table is invalid");
      assert2(serializedAddressesLen % 32 === 0, "lookup table is invalid");
      const numSerializedAddresses = serializedAddressesLen / 32;
      const {
        addresses
      } = BufferLayout.struct([BufferLayout.seq(publicKey(), numSerializedAddresses, "addresses")]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));
      return {
        deactivationSlot: meta.deactivationSlot,
        lastExtendedSlot: meta.lastExtendedSlot,
        lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
        authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : void 0,
        addresses: addresses.map((address) => new PublicKey(address))
      };
    }
  };
  var LookupTableMetaLayout = {
    index: 1,
    layout: BufferLayout.struct([
      BufferLayout.u32("typeIndex"),
      u64("deactivationSlot"),
      BufferLayout.nu64("lastExtendedSlot"),
      BufferLayout.u8("lastExtendedStartIndex"),
      BufferLayout.u8(),
      // option
      BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u8(), -1), "authority")
    ])
  };
  var URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
  function makeWebsocketUrl(endpoint) {
    const matches = endpoint.match(URL_RE);
    if (matches == null) {
      throw TypeError(`Failed to validate endpoint URL \`${endpoint}\``);
    }
    const [
      _,
      // eslint-disable-line @typescript-eslint/no-unused-vars
      hostish,
      portWithColon,
      rest
    ] = matches;
    const protocol = endpoint.startsWith("https:") ? "wss:" : "ws:";
    const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
    const websocketPort = (
      // Only shift the port by +1 as a convention for ws(s) only if given endpoint
      // is explicitly specifying the endpoint port (HTTP-based RPC), assuming
      // we're directly trying to connect to agave-validator's ws listening port.
      // When the endpoint omits the port, we're connecting to the protocol
      // default ports: http(80) or https(443) and it's assumed we're behind a reverse
      // proxy which manages WebSocket upgrade and backend port redirection.
      startPort == null ? "" : `:${startPort + 1}`
    );
    return `${protocol}//${hostish}${websocketPort}${rest}`;
  }
  var PublicKeyFromString = coerce(instance(PublicKey), string(), (value) => new PublicKey(value));
  var RawAccountDataResult = tuple([string(), literal("base64")]);
  var BufferFromRawAccountData = coerce(instance(import_buffer2.Buffer), RawAccountDataResult, (value) => import_buffer2.Buffer.from(value[0], "base64"));
  var BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1e3;
  function assertEndpointUrl(putativeUrl) {
    if (/^https?:/.test(putativeUrl) === false) {
      throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
    }
    return putativeUrl;
  }
  function extractCommitmentFromConfig(commitmentOrConfig) {
    let commitment;
    let config;
    if (typeof commitmentOrConfig === "string") {
      commitment = commitmentOrConfig;
    } else if (commitmentOrConfig) {
      const {
        commitment: specifiedCommitment,
        ...specifiedConfig
      } = commitmentOrConfig;
      commitment = specifiedCommitment;
      config = specifiedConfig;
    }
    return {
      commitment,
      config
    };
  }
  function applyDefaultMemcmpEncodingToFilters(filters) {
    return filters.map((filter) => "memcmp" in filter ? {
      ...filter,
      memcmp: {
        ...filter.memcmp,
        encoding: filter.memcmp.encoding ?? "base58"
      }
    } : filter);
  }
  function createRpcResult(result) {
    return union([type({
      jsonrpc: literal("2.0"),
      id: string(),
      result
    }), type({
      jsonrpc: literal("2.0"),
      id: string(),
      error: type({
        code: unknown(),
        message: string(),
        data: optional(any())
      })
    })]);
  }
  var UnknownRpcResult = createRpcResult(unknown());
  function jsonRpcResult(schema) {
    return coerce(createRpcResult(schema), UnknownRpcResult, (value) => {
      if ("error" in value) {
        return value;
      } else {
        return {
          ...value,
          result: create(value.result, schema)
        };
      }
    });
  }
  function jsonRpcResultAndContext(value) {
    return jsonRpcResult(type({
      context: type({
        slot: number()
      }),
      value
    }));
  }
  function notificationResultAndContext(value) {
    return type({
      context: type({
        slot: number()
      }),
      value
    });
  }
  function versionedMessageFromResponse(version2, response) {
    if (version2 === 0) {
      return new MessageV0({
        header: response.header,
        staticAccountKeys: response.accountKeys.map((accountKey) => new PublicKey(accountKey)),
        recentBlockhash: response.recentBlockhash,
        compiledInstructions: response.instructions.map((ix) => ({
          programIdIndex: ix.programIdIndex,
          accountKeyIndexes: ix.accounts,
          data: import_bs58.default.decode(ix.data)
        })),
        addressTableLookups: response.addressTableLookups
      });
    } else {
      return new Message(response);
    }
  }
  var GetInflationGovernorResult = type({
    foundation: number(),
    foundationTerm: number(),
    initial: number(),
    taper: number(),
    terminal: number()
  });
  var GetInflationRewardResult = jsonRpcResult(array(nullable(type({
    epoch: number(),
    effectiveSlot: number(),
    amount: number(),
    postBalance: number(),
    commission: optional(nullable(number()))
  }))));
  var GetRecentPrioritizationFeesResult = array(type({
    slot: number(),
    prioritizationFee: number()
  }));
  var GetInflationRateResult = type({
    total: number(),
    validator: number(),
    foundation: number(),
    epoch: number()
  });
  var GetEpochInfoResult = type({
    epoch: number(),
    slotIndex: number(),
    slotsInEpoch: number(),
    absoluteSlot: number(),
    blockHeight: optional(number()),
    transactionCount: optional(number())
  });
  var GetEpochScheduleResult = type({
    slotsPerEpoch: number(),
    leaderScheduleSlotOffset: number(),
    warmup: boolean(),
    firstNormalEpoch: number(),
    firstNormalSlot: number()
  });
  var GetLeaderScheduleResult = record(string(), array(number()));
  var TransactionErrorResult = nullable(union([type({}), string()]));
  var SignatureStatusResult = type({
    err: TransactionErrorResult
  });
  var SignatureReceivedResult = literal("receivedSignature");
  var VersionResult = type({
    "solana-core": string(),
    "feature-set": optional(number())
  });
  var ParsedInstructionStruct = type({
    program: string(),
    programId: PublicKeyFromString,
    parsed: unknown()
  });
  var PartiallyDecodedInstructionStruct = type({
    programId: PublicKeyFromString,
    accounts: array(PublicKeyFromString),
    data: string()
  });
  var SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
    err: nullable(union([type({}), string()])),
    logs: nullable(array(string())),
    accounts: optional(nullable(array(nullable(type({
      executable: boolean(),
      owner: string(),
      lamports: number(),
      data: array(string()),
      rentEpoch: optional(number())
    }))))),
    unitsConsumed: optional(number()),
    returnData: optional(nullable(type({
      programId: string(),
      data: tuple([string(), literal("base64")])
    }))),
    innerInstructions: optional(nullable(array(type({
      index: number(),
      instructions: array(union([ParsedInstructionStruct, PartiallyDecodedInstructionStruct]))
    }))))
  }));
  var BlockProductionResponseStruct = jsonRpcResultAndContext(type({
    byIdentity: record(string(), array(number())),
    range: type({
      firstSlot: number(),
      lastSlot: number()
    })
  }));
  function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {
    const fetch2 = customFetch ? customFetch : fetchImpl;
    let agent;
    {
      if (httpAgent != null) {
        console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
      }
    }
    let fetchWithMiddleware;
    if (fetchMiddleware) {
      fetchWithMiddleware = async (info, init) => {
        const modifiedFetchArgs = await new Promise((resolve, reject) => {
          try {
            fetchMiddleware(info, init, (modifiedInfo, modifiedInit) => resolve([modifiedInfo, modifiedInit]));
          } catch (error) {
            reject(error);
          }
        });
        return await fetch2(...modifiedFetchArgs);
      };
    }
    const clientBrowser = new import_browser.default(async (request, callback) => {
      const options = {
        method: "POST",
        body: request,
        agent,
        headers: Object.assign({
          "Content-Type": "application/json"
        }, httpHeaders || {}, COMMON_HTTP_HEADERS)
      };
      try {
        let too_many_requests_retries = 5;
        let res;
        let waitTime = 500;
        for (; ; ) {
          if (fetchWithMiddleware) {
            res = await fetchWithMiddleware(url, options);
          } else {
            res = await fetch2(url, options);
          }
          if (res.status !== 429) {
            break;
          }
          if (disableRetryOnRateLimit === true) {
            break;
          }
          too_many_requests_retries -= 1;
          if (too_many_requests_retries === 0) {
            break;
          }
          console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);
          await sleep(waitTime);
          waitTime *= 2;
        }
        const text = await res.text();
        if (res.ok) {
          callback(null, text);
        } else {
          callback(new Error(`${res.status} ${res.statusText}: ${text}`));
        }
      } catch (err) {
        if (err instanceof Error) callback(err);
      }
    }, {});
    return clientBrowser;
  }
  function createRpcRequest(client) {
    return (method, args) => {
      return new Promise((resolve, reject) => {
        client.request(method, args, (err, response) => {
          if (err) {
            reject(err);
            return;
          }
          resolve(response);
        });
      });
    };
  }
  function createRpcBatchRequest(client) {
    return (requests) => {
      return new Promise((resolve, reject) => {
        if (requests.length === 0) resolve([]);
        const batch = requests.map((params) => {
          return client.request(params.methodName, params.args);
        });
        client.request(batch, (err, response) => {
          if (err) {
            reject(err);
            return;
          }
          resolve(response);
        });
      });
    };
  }
  var GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);
  var GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);
  var GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);
  var GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);
  var GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);
  var GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);
  var SlotRpcResult = jsonRpcResult(number());
  var GetSupplyRpcResult = jsonRpcResultAndContext(type({
    total: number(),
    circulating: number(),
    nonCirculating: number(),
    nonCirculatingAccounts: array(PublicKeyFromString)
  }));
  var TokenAmountResult = type({
    amount: string(),
    uiAmount: nullable(number()),
    decimals: number(),
    uiAmountString: optional(string())
  });
  var GetTokenLargestAccountsResult = jsonRpcResultAndContext(array(type({
    address: PublicKeyFromString,
    amount: string(),
    uiAmount: nullable(number()),
    decimals: number(),
    uiAmountString: optional(string())
  })));
  var GetTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
    pubkey: PublicKeyFromString,
    account: type({
      executable: boolean(),
      owner: PublicKeyFromString,
      lamports: number(),
      data: BufferFromRawAccountData,
      rentEpoch: number()
    })
  })));
  var ParsedAccountDataResult = type({
    program: string(),
    parsed: unknown(),
    space: number()
  });
  var GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
    pubkey: PublicKeyFromString,
    account: type({
      executable: boolean(),
      owner: PublicKeyFromString,
      lamports: number(),
      data: ParsedAccountDataResult,
      rentEpoch: number()
    })
  })));
  var GetLargestAccountsRpcResult = jsonRpcResultAndContext(array(type({
    lamports: number(),
    address: PublicKeyFromString
  })));
  var AccountInfoResult = type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: BufferFromRawAccountData,
    rentEpoch: number()
  });
  var KeyedAccountInfoResult = type({
    pubkey: PublicKeyFromString,
    account: AccountInfoResult
  });
  var ParsedOrRawAccountData = coerce(union([instance(import_buffer2.Buffer), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), (value) => {
    if (Array.isArray(value)) {
      return create(value, BufferFromRawAccountData);
    } else {
      return value;
    }
  });
  var ParsedAccountInfoResult = type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: ParsedOrRawAccountData,
    rentEpoch: number()
  });
  var KeyedParsedAccountInfoResult = type({
    pubkey: PublicKeyFromString,
    account: ParsedAccountInfoResult
  });
  var StakeActivationResult = type({
    state: union([literal("active"), literal("inactive"), literal("activating"), literal("deactivating")]),
    active: number(),
    inactive: number()
  });
  var GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array(type({
    signature: string(),
    slot: number(),
    err: TransactionErrorResult,
    memo: nullable(string()),
    blockTime: optional(nullable(number()))
  })));
  var GetSignaturesForAddressRpcResult = jsonRpcResult(array(type({
    signature: string(),
    slot: number(),
    err: TransactionErrorResult,
    memo: nullable(string()),
    blockTime: optional(nullable(number()))
  })));
  var AccountNotificationResult = type({
    subscription: number(),
    result: notificationResultAndContext(AccountInfoResult)
  });
  var ProgramAccountInfoResult = type({
    pubkey: PublicKeyFromString,
    account: AccountInfoResult
  });
  var ProgramAccountNotificationResult = type({
    subscription: number(),
    result: notificationResultAndContext(ProgramAccountInfoResult)
  });
  var SlotInfoResult = type({
    parent: number(),
    slot: number(),
    root: number()
  });
  var SlotNotificationResult = type({
    subscription: number(),
    result: SlotInfoResult
  });
  var SlotUpdateResult = union([type({
    type: union([literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root")]),
    slot: number(),
    timestamp: number()
  }), type({
    type: literal("createdBank"),
    parent: number(),
    slot: number(),
    timestamp: number()
  }), type({
    type: literal("frozen"),
    slot: number(),
    timestamp: number(),
    stats: type({
      numTransactionEntries: number(),
      numSuccessfulTransactions: number(),
      numFailedTransactions: number(),
      maxTransactionsPerEntry: number()
    })
  }), type({
    type: literal("dead"),
    slot: number(),
    timestamp: number(),
    err: string()
  })]);
  var SlotUpdateNotificationResult = type({
    subscription: number(),
    result: SlotUpdateResult
  });
  var SignatureNotificationResult = type({
    subscription: number(),
    result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
  });
  var RootNotificationResult = type({
    subscription: number(),
    result: number()
  });
  var ContactInfoResult = type({
    pubkey: string(),
    gossip: nullable(string()),
    tpu: nullable(string()),
    rpc: nullable(string()),
    version: nullable(string())
  });
  var VoteAccountInfoResult = type({
    votePubkey: string(),
    nodePubkey: string(),
    activatedStake: number(),
    epochVoteAccount: boolean(),
    epochCredits: array(tuple([number(), number(), number()])),
    commission: number(),
    lastVote: number(),
    rootSlot: nullable(number())
  });
  var GetVoteAccounts = jsonRpcResult(type({
    current: array(VoteAccountInfoResult),
    delinquent: array(VoteAccountInfoResult)
  }));
  var ConfirmationStatus = union([literal("processed"), literal("confirmed"), literal("finalized")]);
  var SignatureStatusResponse = type({
    slot: number(),
    confirmations: nullable(number()),
    err: TransactionErrorResult,
    confirmationStatus: optional(ConfirmationStatus)
  });
  var GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array(nullable(SignatureStatusResponse)));
  var GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number());
  var AddressTableLookupStruct = type({
    accountKey: PublicKeyFromString,
    writableIndexes: array(number()),
    readonlyIndexes: array(number())
  });
  var ConfirmedTransactionResult = type({
    signatures: array(string()),
    message: type({
      accountKeys: array(string()),
      header: type({
        numRequiredSignatures: number(),
        numReadonlySignedAccounts: number(),
        numReadonlyUnsignedAccounts: number()
      }),
      instructions: array(type({
        accounts: array(number()),
        data: string(),
        programIdIndex: number()
      })),
      recentBlockhash: string(),
      addressTableLookups: optional(array(AddressTableLookupStruct))
    })
  });
  var AnnotatedAccountKey = type({
    pubkey: PublicKeyFromString,
    signer: boolean(),
    writable: boolean(),
    source: optional(union([literal("transaction"), literal("lookupTable")]))
  });
  var ConfirmedTransactionAccountsModeResult = type({
    accountKeys: array(AnnotatedAccountKey),
    signatures: array(string())
  });
  var ParsedInstructionResult = type({
    parsed: unknown(),
    program: string(),
    programId: PublicKeyFromString
  });
  var RawInstructionResult = type({
    accounts: array(PublicKeyFromString),
    data: string(),
    programId: PublicKeyFromString
  });
  var InstructionResult = union([RawInstructionResult, ParsedInstructionResult]);
  var UnknownInstructionResult = union([type({
    parsed: unknown(),
    program: string(),
    programId: string()
  }), type({
    accounts: array(string()),
    data: string(),
    programId: string()
  })]);
  var ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, (value) => {
    if ("accounts" in value) {
      return create(value, RawInstructionResult);
    } else {
      return create(value, ParsedInstructionResult);
    }
  });
  var ParsedConfirmedTransactionResult = type({
    signatures: array(string()),
    message: type({
      accountKeys: array(AnnotatedAccountKey),
      instructions: array(ParsedOrRawInstruction),
      recentBlockhash: string(),
      addressTableLookups: optional(nullable(array(AddressTableLookupStruct)))
    })
  });
  var TokenBalanceResult = type({
    accountIndex: number(),
    mint: string(),
    owner: optional(string()),
    programId: optional(string()),
    uiTokenAmount: TokenAmountResult
  });
  var LoadedAddressesResult = type({
    writable: array(PublicKeyFromString),
    readonly: array(PublicKeyFromString)
  });
  var ConfirmedTransactionMetaResult = type({
    err: TransactionErrorResult,
    fee: number(),
    innerInstructions: optional(nullable(array(type({
      index: number(),
      instructions: array(type({
        accounts: array(number()),
        data: string(),
        programIdIndex: number()
      }))
    })))),
    preBalances: array(number()),
    postBalances: array(number()),
    logMessages: optional(nullable(array(string()))),
    preTokenBalances: optional(nullable(array(TokenBalanceResult))),
    postTokenBalances: optional(nullable(array(TokenBalanceResult))),
    loadedAddresses: optional(LoadedAddressesResult),
    computeUnitsConsumed: optional(number()),
    costUnits: optional(number())
  });
  var ParsedConfirmedTransactionMetaResult = type({
    err: TransactionErrorResult,
    fee: number(),
    innerInstructions: optional(nullable(array(type({
      index: number(),
      instructions: array(ParsedOrRawInstruction)
    })))),
    preBalances: array(number()),
    postBalances: array(number()),
    logMessages: optional(nullable(array(string()))),
    preTokenBalances: optional(nullable(array(TokenBalanceResult))),
    postTokenBalances: optional(nullable(array(TokenBalanceResult))),
    loadedAddresses: optional(LoadedAddressesResult),
    computeUnitsConsumed: optional(number()),
    costUnits: optional(number())
  });
  var TransactionVersionStruct = union([literal(0), literal("legacy")]);
  var RewardsResult = type({
    pubkey: string(),
    lamports: number(),
    postBalance: nullable(number()),
    rewardType: nullable(string()),
    commission: optional(nullable(number()))
  });
  var GetBlockRpcResult = jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    transactions: array(type({
      transaction: ConfirmedTransactionResult,
      meta: nullable(ConfirmedTransactionMetaResult),
      version: optional(TransactionVersionStruct)
    })),
    rewards: optional(array(RewardsResult)),
    blockTime: nullable(number()),
    blockHeight: nullable(number())
  })));
  var GetNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    rewards: optional(array(RewardsResult)),
    blockTime: nullable(number()),
    blockHeight: nullable(number())
  })));
  var GetAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    transactions: array(type({
      transaction: ConfirmedTransactionAccountsModeResult,
      meta: nullable(ConfirmedTransactionMetaResult),
      version: optional(TransactionVersionStruct)
    })),
    rewards: optional(array(RewardsResult)),
    blockTime: nullable(number()),
    blockHeight: nullable(number())
  })));
  var GetParsedBlockRpcResult = jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    transactions: array(type({
      transaction: ParsedConfirmedTransactionResult,
      meta: nullable(ParsedConfirmedTransactionMetaResult),
      version: optional(TransactionVersionStruct)
    })),
    rewards: optional(array(RewardsResult)),
    blockTime: nullable(number()),
    blockHeight: nullable(number())
  })));
  var GetParsedAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    transactions: array(type({
      transaction: ConfirmedTransactionAccountsModeResult,
      meta: nullable(ParsedConfirmedTransactionMetaResult),
      version: optional(TransactionVersionStruct)
    })),
    rewards: optional(array(RewardsResult)),
    blockTime: nullable(number()),
    blockHeight: nullable(number())
  })));
  var GetParsedNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    rewards: optional(array(RewardsResult)),
    blockTime: nullable(number()),
    blockHeight: nullable(number())
  })));
  var GetConfirmedBlockRpcResult = jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    transactions: array(type({
      transaction: ConfirmedTransactionResult,
      meta: nullable(ConfirmedTransactionMetaResult)
    })),
    rewards: optional(array(RewardsResult)),
    blockTime: nullable(number())
  })));
  var GetBlockSignaturesRpcResult = jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    signatures: array(string()),
    blockTime: nullable(number())
  })));
  var GetTransactionRpcResult = jsonRpcResult(nullable(type({
    slot: number(),
    meta: nullable(ConfirmedTransactionMetaResult),
    blockTime: optional(nullable(number())),
    transaction: ConfirmedTransactionResult,
    version: optional(TransactionVersionStruct)
  })));
  var GetParsedTransactionRpcResult = jsonRpcResult(nullable(type({
    slot: number(),
    transaction: ParsedConfirmedTransactionResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    blockTime: optional(nullable(number())),
    version: optional(TransactionVersionStruct)
  })));
  var GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type({
    blockhash: string(),
    lastValidBlockHeight: number()
  }));
  var IsBlockhashValidRpcResult = jsonRpcResultAndContext(boolean());
  var PerfSampleResult = type({
    slot: number(),
    numTransactions: number(),
    numSlots: number(),
    samplePeriodSecs: number()
  });
  var GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array(PerfSampleResult));
  var GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable(type({
    feeCalculator: type({
      lamportsPerSignature: number()
    })
  })));
  var RequestAirdropRpcResult = jsonRpcResult(string());
  var SendTransactionRpcResult = jsonRpcResult(string());
  var LogsResult = type({
    err: TransactionErrorResult,
    logs: array(string()),
    signature: string()
  });
  var LogsNotificationResult = type({
    result: notificationResultAndContext(LogsResult),
    subscription: number()
  });
  var COMMON_HTTP_HEADERS = {
    "solana-client": `js/${"1.0.0-maintenance"}`
  };
  var Connection = class {
    /**
     * Establish a JSON RPC connection
     *
     * @param endpoint URL to the fullnode JSON RPC endpoint
     * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object
     */
    constructor(endpoint, _commitmentOrConfig) {
      this._commitment = void 0;
      this._confirmTransactionInitialTimeout = void 0;
      this._rpcEndpoint = void 0;
      this._rpcWsEndpoint = void 0;
      this._rpcClient = void 0;
      this._rpcRequest = void 0;
      this._rpcBatchRequest = void 0;
      this._rpcWebSocket = void 0;
      this._rpcWebSocketConnected = false;
      this._rpcWebSocketHeartbeat = null;
      this._rpcWebSocketIdleTimeout = null;
      this._rpcWebSocketGeneration = 0;
      this._disableBlockhashCaching = false;
      this._pollingBlockhash = false;
      this._blockhashInfo = {
        latestBlockhash: null,
        lastFetch: 0,
        transactionSignatures: [],
        simulatedSignatures: []
      };
      this._nextClientSubscriptionId = 0;
      this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
      this._subscriptionHashByClientSubscriptionId = {};
      this._subscriptionStateChangeCallbacksByHash = {};
      this._subscriptionCallbacksByServerSubscriptionId = {};
      this._subscriptionsByHash = {};
      this._subscriptionsAutoDisposedByRpc = /* @__PURE__ */ new Set();
      this.getBlockHeight = /* @__PURE__ */ (() => {
        const requestPromises = {};
        return async (commitmentOrConfig) => {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([], commitment, void 0, config);
          const requestHash = fastStableStringify(args);
          requestPromises[requestHash] = requestPromises[requestHash] ?? (async () => {
            try {
              const unsafeRes = await this._rpcRequest("getBlockHeight", args);
              const res = create(unsafeRes, jsonRpcResult(number()));
              if ("error" in res) {
                throw new SolanaJSONRPCError(res.error, "failed to get block height information");
              }
              return res.result;
            } finally {
              delete requestPromises[requestHash];
            }
          })();
          return await requestPromises[requestHash];
        };
      })();
      let wsEndpoint;
      let httpHeaders;
      let fetch2;
      let fetchMiddleware;
      let disableRetryOnRateLimit;
      let httpAgent;
      if (_commitmentOrConfig && typeof _commitmentOrConfig === "string") {
        this._commitment = _commitmentOrConfig;
      } else if (_commitmentOrConfig) {
        this._commitment = _commitmentOrConfig.commitment;
        this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;
        wsEndpoint = _commitmentOrConfig.wsEndpoint;
        httpHeaders = _commitmentOrConfig.httpHeaders;
        fetch2 = _commitmentOrConfig.fetch;
        fetchMiddleware = _commitmentOrConfig.fetchMiddleware;
        disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;
        httpAgent = _commitmentOrConfig.httpAgent;
      }
      this._rpcEndpoint = assertEndpointUrl(endpoint);
      this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);
      this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch2, fetchMiddleware, disableRetryOnRateLimit, httpAgent);
      this._rpcRequest = createRpcRequest(this._rpcClient);
      this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
      this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
        autoconnect: false,
        max_reconnects: Infinity
      });
      this._rpcWebSocket.on("open", this._wsOnOpen.bind(this));
      this._rpcWebSocket.on("error", this._wsOnError.bind(this));
      this._rpcWebSocket.on("close", this._wsOnClose.bind(this));
      this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this));
      this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this));
      this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this));
      this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this));
      this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this));
      this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this));
      this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this));
    }
    /**
     * The default commitment used for requests
     */
    get commitment() {
      return this._commitment;
    }
    /**
     * The RPC endpoint
     */
    get rpcEndpoint() {
      return this._rpcEndpoint;
    }
    /**
     * Fetch the balance for the specified public key, return with context
     */
    async getBalanceAndContext(publicKey3, commitmentOrConfig) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([publicKey3.toBase58()], commitment, void 0, config);
      const unsafeRes = await this._rpcRequest("getBalance", args);
      const res = create(unsafeRes, jsonRpcResultAndContext(number()));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey3.toBase58()}`);
      }
      return res.result;
    }
    /**
     * Fetch the balance for the specified public key
     */
    async getBalance(publicKey3, commitmentOrConfig) {
      return await this.getBalanceAndContext(publicKey3, commitmentOrConfig).then((x) => x.value).catch((e) => {
        throw new Error("failed to get balance of account " + publicKey3.toBase58() + ": " + e);
      });
    }
    /**
     * Fetch the estimated production time of a block
     */
    async getBlockTime(slot) {
      const unsafeRes = await this._rpcRequest("getBlockTime", [slot]);
      const res = create(unsafeRes, jsonRpcResult(nullable(number())));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);
      }
      return res.result;
    }
    /**
     * Fetch the lowest slot that the node has information about in its ledger.
     * This value may increase over time if the node is configured to purge older ledger data
     */
    async getMinimumLedgerSlot() {
      const unsafeRes = await this._rpcRequest("minimumLedgerSlot", []);
      const res = create(unsafeRes, jsonRpcResult(number()));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get minimum ledger slot");
      }
      return res.result;
    }
    /**
     * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
     */
    async getFirstAvailableBlock() {
      const unsafeRes = await this._rpcRequest("getFirstAvailableBlock", []);
      const res = create(unsafeRes, SlotRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get first available block");
      }
      return res.result;
    }
    /**
     * Fetch information about the current supply
     */
    async getSupply(config) {
      let configArg = {};
      if (typeof config === "string") {
        configArg = {
          commitment: config
        };
      } else if (config) {
        configArg = {
          ...config,
          commitment: config && config.commitment || this.commitment
        };
      } else {
        configArg = {
          commitment: this.commitment
        };
      }
      const unsafeRes = await this._rpcRequest("getSupply", [configArg]);
      const res = create(unsafeRes, GetSupplyRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get supply");
      }
      return res.result;
    }
    /**
     * Fetch the current supply of a token mint
     */
    async getTokenSupply(tokenMintAddress, commitment) {
      const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);
      const unsafeRes = await this._rpcRequest("getTokenSupply", args);
      const res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get token supply");
      }
      return res.result;
    }
    /**
     * Fetch the current balance of a token account
     */
    async getTokenAccountBalance(tokenAddress, commitment) {
      const args = this._buildArgs([tokenAddress.toBase58()], commitment);
      const unsafeRes = await this._rpcRequest("getTokenAccountBalance", args);
      const res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get token account balance");
      }
      return res.result;
    }
    /**
     * Fetch all the token accounts owned by the specified account
     *
     * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}
     */
    async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      let _args = [ownerAddress.toBase58()];
      if ("mint" in filter) {
        _args.push({
          mint: filter.mint.toBase58()
        });
      } else {
        _args.push({
          programId: filter.programId.toBase58()
        });
      }
      const args = this._buildArgs(_args, commitment, "base64", config);
      const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
      const res = create(unsafeRes, GetTokenAccountsByOwner);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
      }
      return res.result;
    }
    /**
     * Fetch parsed token accounts owned by the specified account
     *
     * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}
     */
    async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {
      let _args = [ownerAddress.toBase58()];
      if ("mint" in filter) {
        _args.push({
          mint: filter.mint.toBase58()
        });
      } else {
        _args.push({
          programId: filter.programId.toBase58()
        });
      }
      const args = this._buildArgs(_args, commitment, "jsonParsed");
      const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
      const res = create(unsafeRes, GetParsedTokenAccountsByOwner);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
      }
      return res.result;
    }
    /**
     * Fetch the 20 largest accounts with their current balances
     */
    async getLargestAccounts(config) {
      const arg = {
        ...config,
        commitment: config && config.commitment || this.commitment
      };
      const args = arg.filter || arg.commitment ? [arg] : [];
      const unsafeRes = await this._rpcRequest("getLargestAccounts", args);
      const res = create(unsafeRes, GetLargestAccountsRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get largest accounts");
      }
      return res.result;
    }
    /**
     * Fetch the 20 largest token accounts with their current balances
     * for a given mint.
     */
    async getTokenLargestAccounts(mintAddress, commitment) {
      const args = this._buildArgs([mintAddress.toBase58()], commitment);
      const unsafeRes = await this._rpcRequest("getTokenLargestAccounts", args);
      const res = create(unsafeRes, GetTokenLargestAccountsResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get token largest accounts");
      }
      return res.result;
    }
    /**
     * Fetch all the account info for the specified public key, return with context
     */
    async getAccountInfoAndContext(publicKey3, commitmentOrConfig) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([publicKey3.toBase58()], commitment, "base64", config);
      const unsafeRes = await this._rpcRequest("getAccountInfo", args);
      const res = create(unsafeRes, jsonRpcResultAndContext(nullable(AccountInfoResult)));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey3.toBase58()}`);
      }
      return res.result;
    }
    /**
     * Fetch parsed account info for the specified public key
     */
    async getParsedAccountInfo(publicKey3, commitmentOrConfig) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([publicKey3.toBase58()], commitment, "jsonParsed", config);
      const unsafeRes = await this._rpcRequest("getAccountInfo", args);
      const res = create(unsafeRes, jsonRpcResultAndContext(nullable(ParsedAccountInfoResult)));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey3.toBase58()}`);
      }
      return res.result;
    }
    /**
     * Fetch all the account info for the specified public key
     */
    async getAccountInfo(publicKey3, commitmentOrConfig) {
      try {
        const res = await this.getAccountInfoAndContext(publicKey3, commitmentOrConfig);
        return res.value;
      } catch (e) {
        throw new Error("failed to get info about account " + publicKey3.toBase58() + ": " + e);
      }
    }
    /**
     * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
     */
    async getMultipleParsedAccounts(publicKeys, rawConfig) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(rawConfig);
      const keys = publicKeys.map((key) => key.toBase58());
      const args = this._buildArgs([keys], commitment, "jsonParsed", config);
      const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
      const res = create(unsafeRes, jsonRpcResultAndContext(array(nullable(ParsedAccountInfoResult))));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
      }
      return res.result;
    }
    /**
     * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
     */
    async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const keys = publicKeys.map((key) => key.toBase58());
      const args = this._buildArgs([keys], commitment, "base64", config);
      const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
      const res = create(unsafeRes, jsonRpcResultAndContext(array(nullable(AccountInfoResult))));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
      }
      return res.result;
    }
    /**
     * Fetch all the account info for multiple accounts specified by an array of public keys
     */
    async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {
      const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);
      return res.value;
    }
    /**
     * Returns epoch activation information for a stake account that has been delegated
     *
     * @deprecated Deprecated since RPC v1.18; will be removed in a future version.
     */
    async getStakeActivation(publicKey3, commitmentOrConfig, epoch) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([publicKey3.toBase58()], commitment, void 0, {
        ...config,
        epoch: epoch != null ? epoch : config?.epoch
      });
      const unsafeRes = await this._rpcRequest("getStakeActivation", args);
      const res = create(unsafeRes, jsonRpcResult(StakeActivationResult));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey3.toBase58()}`);
      }
      return res.result;
    }
    /**
     * Fetch all the accounts owned by the specified program id
     *
     * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}
     */
    // eslint-disable-next-line no-dupe-class-members
    // eslint-disable-next-line no-dupe-class-members
    async getProgramAccounts(programId, configOrCommitment) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(configOrCommitment);
      const {
        encoding,
        ...configWithoutEncoding
      } = config || {};
      const args = this._buildArgs([programId.toBase58()], commitment, encoding || "base64", {
        ...configWithoutEncoding,
        ...configWithoutEncoding.filters ? {
          filters: applyDefaultMemcmpEncodingToFilters(configWithoutEncoding.filters)
        } : null
      });
      const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
      const baseSchema = array(KeyedAccountInfoResult);
      const res = configWithoutEncoding.withContext === true ? create(unsafeRes, jsonRpcResultAndContext(baseSchema)) : create(unsafeRes, jsonRpcResult(baseSchema));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
      }
      return res.result;
    }
    /**
     * Fetch and parse all the accounts owned by the specified program id
     *
     * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}
     */
    async getParsedProgramAccounts(programId, configOrCommitment) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(configOrCommitment);
      const args = this._buildArgs([programId.toBase58()], commitment, "jsonParsed", config);
      const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
      const res = create(unsafeRes, jsonRpcResult(array(KeyedParsedAccountInfoResult)));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
      }
      return res.result;
    }
    /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */
    // eslint-disable-next-line no-dupe-class-members
    // eslint-disable-next-line no-dupe-class-members
    async confirmTransaction(strategy, commitment) {
      let rawSignature;
      if (typeof strategy == "string") {
        rawSignature = strategy;
      } else {
        const config = strategy;
        if (config.abortSignal?.aborted) {
          return Promise.reject(config.abortSignal.reason);
        }
        rawSignature = config.signature;
      }
      let decodedSignature;
      try {
        decodedSignature = import_bs58.default.decode(rawSignature);
      } catch (err) {
        throw new Error("signature must be base58 encoded: " + rawSignature);
      }
      assert2(decodedSignature.length === 64, "signature has invalid length");
      if (typeof strategy === "string") {
        return await this.confirmTransactionUsingLegacyTimeoutStrategy({
          commitment: commitment || this.commitment,
          signature: rawSignature
        });
      } else if ("lastValidBlockHeight" in strategy) {
        return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
          commitment: commitment || this.commitment,
          strategy
        });
      } else {
        return await this.confirmTransactionUsingDurableNonceStrategy({
          commitment: commitment || this.commitment,
          strategy
        });
      }
    }
    getCancellationPromise(signal) {
      return new Promise((_, reject) => {
        if (signal == null) {
          return;
        }
        if (signal.aborted) {
          reject(signal.reason);
        } else {
          signal.addEventListener("abort", () => {
            reject(signal.reason);
          });
        }
      });
    }
    getTransactionConfirmationPromise({
      commitment,
      signature
    }) {
      let signatureSubscriptionId;
      let disposeSignatureSubscriptionStateChangeObserver;
      let done = false;
      const confirmationPromise = new Promise((resolve, reject) => {
        try {
          signatureSubscriptionId = this.onSignature(signature, (result, context) => {
            signatureSubscriptionId = void 0;
            const response = {
              context,
              value: result
            };
            resolve({
              __type: TransactionStatus.PROCESSED,
              response
            });
          }, commitment);
          const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup) => {
            if (signatureSubscriptionId == null) {
              resolveSubscriptionSetup();
            } else {
              disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState) => {
                if (nextState === "subscribed") {
                  resolveSubscriptionSetup();
                }
              });
            }
          });
          (async () => {
            await subscriptionSetupPromise;
            if (done) return;
            const response = await this.getSignatureStatus(signature);
            if (done) return;
            if (response == null) {
              return;
            }
            const {
              context,
              value
            } = response;
            if (value == null) {
              return;
            }
            if (value?.err) {
              reject(value.err);
            } else {
              switch (commitment) {
                case "confirmed":
                case "single":
                case "singleGossip": {
                  if (value.confirmationStatus === "processed") {
                    return;
                  }
                  break;
                }
                case "finalized":
                case "max":
                case "root": {
                  if (value.confirmationStatus === "processed" || value.confirmationStatus === "confirmed") {
                    return;
                  }
                  break;
                }
                // exhaust enums to ensure full coverage
                case "processed":
                case "recent":
              }
              done = true;
              resolve({
                __type: TransactionStatus.PROCESSED,
                response: {
                  context,
                  value
                }
              });
            }
          })();
        } catch (err) {
          reject(err);
        }
      });
      const abortConfirmation = () => {
        if (disposeSignatureSubscriptionStateChangeObserver) {
          disposeSignatureSubscriptionStateChangeObserver();
          disposeSignatureSubscriptionStateChangeObserver = void 0;
        }
        if (signatureSubscriptionId != null) {
          this.removeSignatureListener(signatureSubscriptionId);
          signatureSubscriptionId = void 0;
        }
      };
      return {
        abortConfirmation,
        confirmationPromise
      };
    }
    async confirmTransactionUsingBlockHeightExceedanceStrategy({
      commitment,
      strategy: {
        abortSignal,
        lastValidBlockHeight,
        signature
      }
    }) {
      let done = false;
      const expiryPromise = new Promise((resolve) => {
        const checkBlockHeight = async () => {
          try {
            const blockHeight = await this.getBlockHeight(commitment);
            return blockHeight;
          } catch (_e) {
            return -1;
          }
        };
        (async () => {
          let currentBlockHeight = await checkBlockHeight();
          if (done) return;
          while (currentBlockHeight <= lastValidBlockHeight) {
            await sleep(1e3);
            if (done) return;
            currentBlockHeight = await checkBlockHeight();
            if (done) return;
          }
          resolve({
            __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
          });
        })();
      });
      const {
        abortConfirmation,
        confirmationPromise
      } = this.getTransactionConfirmationPromise({
        commitment,
        signature
      });
      const cancellationPromise = this.getCancellationPromise(abortSignal);
      let result;
      try {
        const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
        if (outcome.__type === TransactionStatus.PROCESSED) {
          result = outcome.response;
        } else {
          throw new TransactionExpiredBlockheightExceededError(signature);
        }
      } finally {
        done = true;
        abortConfirmation();
      }
      return result;
    }
    async confirmTransactionUsingDurableNonceStrategy({
      commitment,
      strategy: {
        abortSignal,
        minContextSlot,
        nonceAccountPubkey,
        nonceValue,
        signature
      }
    }) {
      let done = false;
      const expiryPromise = new Promise((resolve) => {
        let currentNonceValue = nonceValue;
        let lastCheckedSlot = null;
        const getCurrentNonceValue = async () => {
          try {
            const {
              context,
              value: nonceAccount
            } = await this.getNonceAndContext(nonceAccountPubkey, {
              commitment,
              minContextSlot
            });
            lastCheckedSlot = context.slot;
            return nonceAccount?.nonce;
          } catch (e) {
            return currentNonceValue;
          }
        };
        (async () => {
          currentNonceValue = await getCurrentNonceValue();
          if (done) return;
          while (true) {
            if (nonceValue !== currentNonceValue) {
              resolve({
                __type: TransactionStatus.NONCE_INVALID,
                slotInWhichNonceDidAdvance: lastCheckedSlot
              });
              return;
            }
            await sleep(2e3);
            if (done) return;
            currentNonceValue = await getCurrentNonceValue();
            if (done) return;
          }
        })();
      });
      const {
        abortConfirmation,
        confirmationPromise
      } = this.getTransactionConfirmationPromise({
        commitment,
        signature
      });
      const cancellationPromise = this.getCancellationPromise(abortSignal);
      let result;
      try {
        const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
        if (outcome.__type === TransactionStatus.PROCESSED) {
          result = outcome.response;
        } else {
          let signatureStatus;
          while (true) {
            const status = await this.getSignatureStatus(signature);
            if (status == null) {
              break;
            }
            if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {
              await sleep(400);
              continue;
            }
            signatureStatus = status;
            break;
          }
          if (signatureStatus?.value) {
            const commitmentForStatus = commitment || "finalized";
            const {
              confirmationStatus
            } = signatureStatus.value;
            switch (commitmentForStatus) {
              case "processed":
              case "recent":
                if (confirmationStatus !== "processed" && confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                  throw new TransactionExpiredNonceInvalidError(signature);
                }
                break;
              case "confirmed":
              case "single":
              case "singleGossip":
                if (confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                  throw new TransactionExpiredNonceInvalidError(signature);
                }
                break;
              case "finalized":
              case "max":
              case "root":
                if (confirmationStatus !== "finalized") {
                  throw new TransactionExpiredNonceInvalidError(signature);
                }
                break;
              default:
                /* @__PURE__ */ ((_) => {
                })(commitmentForStatus);
            }
            result = {
              context: signatureStatus.context,
              value: {
                err: signatureStatus.value.err
              }
            };
          } else {
            throw new TransactionExpiredNonceInvalidError(signature);
          }
        }
      } finally {
        done = true;
        abortConfirmation();
      }
      return result;
    }
    async confirmTransactionUsingLegacyTimeoutStrategy({
      commitment,
      signature
    }) {
      let timeoutId;
      const expiryPromise = new Promise((resolve) => {
        let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1e3;
        switch (commitment) {
          case "processed":
          case "recent":
          case "single":
          case "confirmed":
          case "singleGossip": {
            timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1e3;
            break;
          }
        }
        timeoutId = setTimeout(() => resolve({
          __type: TransactionStatus.TIMED_OUT,
          timeoutMs
        }), timeoutMs);
      });
      const {
        abortConfirmation,
        confirmationPromise
      } = this.getTransactionConfirmationPromise({
        commitment,
        signature
      });
      let result;
      try {
        const outcome = await Promise.race([confirmationPromise, expiryPromise]);
        if (outcome.__type === TransactionStatus.PROCESSED) {
          result = outcome.response;
        } else {
          throw new TransactionExpiredTimeoutError(signature, outcome.timeoutMs / 1e3);
        }
      } finally {
        clearTimeout(timeoutId);
        abortConfirmation();
      }
      return result;
    }
    /**
     * Return the list of nodes that are currently participating in the cluster
     */
    async getClusterNodes() {
      const unsafeRes = await this._rpcRequest("getClusterNodes", []);
      const res = create(unsafeRes, jsonRpcResult(array(ContactInfoResult)));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get cluster nodes");
      }
      return res.result;
    }
    /**
     * Return the list of nodes that are currently participating in the cluster
     */
    async getVoteAccounts(commitment) {
      const args = this._buildArgs([], commitment);
      const unsafeRes = await this._rpcRequest("getVoteAccounts", args);
      const res = create(unsafeRes, GetVoteAccounts);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get vote accounts");
      }
      return res.result;
    }
    /**
     * Fetch the current slot that the node is processing
     */
    async getSlot(commitmentOrConfig) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([], commitment, void 0, config);
      const unsafeRes = await this._rpcRequest("getSlot", args);
      const res = create(unsafeRes, jsonRpcResult(number()));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get slot");
      }
      return res.result;
    }
    /**
     * Fetch the current slot leader of the cluster
     */
    async getSlotLeader(commitmentOrConfig) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([], commitment, void 0, config);
      const unsafeRes = await this._rpcRequest("getSlotLeader", args);
      const res = create(unsafeRes, jsonRpcResult(string()));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get slot leader");
      }
      return res.result;
    }
    /**
     * Fetch `limit` number of slot leaders starting from `startSlot`
     *
     * @param startSlot fetch slot leaders starting from this slot
     * @param limit number of slot leaders to return
     */
    async getSlotLeaders(startSlot, limit) {
      const args = [startSlot, limit];
      const unsafeRes = await this._rpcRequest("getSlotLeaders", args);
      const res = create(unsafeRes, jsonRpcResult(array(PublicKeyFromString)));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get slot leaders");
      }
      return res.result;
    }
    /**
     * Fetch the current status of a signature
     */
    async getSignatureStatus(signature, config) {
      const {
        context,
        value: values
      } = await this.getSignatureStatuses([signature], config);
      assert2(values.length === 1);
      const value = values[0];
      return {
        context,
        value
      };
    }
    /**
     * Fetch the current statuses of a batch of signatures
     */
    async getSignatureStatuses(signatures, config) {
      const params = [signatures];
      if (config) {
        params.push(config);
      }
      const unsafeRes = await this._rpcRequest("getSignatureStatuses", params);
      const res = create(unsafeRes, GetSignatureStatusesRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get signature status");
      }
      return res.result;
    }
    /**
     * Fetch the current transaction count of the cluster
     */
    async getTransactionCount(commitmentOrConfig) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([], commitment, void 0, config);
      const unsafeRes = await this._rpcRequest("getTransactionCount", args);
      const res = create(unsafeRes, jsonRpcResult(number()));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get transaction count");
      }
      return res.result;
    }
    /**
     * Fetch the current total currency supply of the cluster in lamports
     *
     * @deprecated Deprecated since RPC v1.2.8. Please use {@link getSupply} instead.
     */
    async getTotalSupply(commitment) {
      const result = await this.getSupply({
        commitment,
        excludeNonCirculatingAccountsList: true
      });
      return result.value.total;
    }
    /**
     * Fetch the cluster InflationGovernor parameters
     */
    async getInflationGovernor(commitment) {
      const args = this._buildArgs([], commitment);
      const unsafeRes = await this._rpcRequest("getInflationGovernor", args);
      const res = create(unsafeRes, GetInflationGovernorRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get inflation");
      }
      return res.result;
    }
    /**
     * Fetch the inflation reward for a list of addresses for an epoch
     */
    async getInflationReward(addresses, epoch, commitmentOrConfig) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([addresses.map((pubkey) => pubkey.toBase58())], commitment, void 0, {
        ...config,
        epoch: epoch != null ? epoch : config?.epoch
      });
      const unsafeRes = await this._rpcRequest("getInflationReward", args);
      const res = create(unsafeRes, GetInflationRewardResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get inflation reward");
      }
      return res.result;
    }
    /**
     * Fetch the specific inflation values for the current epoch
     */
    async getInflationRate() {
      const unsafeRes = await this._rpcRequest("getInflationRate", []);
      const res = create(unsafeRes, GetInflationRateRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get inflation rate");
      }
      return res.result;
    }
    /**
     * Fetch the Epoch Info parameters
     */
    async getEpochInfo(commitmentOrConfig) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([], commitment, void 0, config);
      const unsafeRes = await this._rpcRequest("getEpochInfo", args);
      const res = create(unsafeRes, GetEpochInfoRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get epoch info");
      }
      return res.result;
    }
    /**
     * Fetch the Epoch Schedule parameters
     */
    async getEpochSchedule() {
      const unsafeRes = await this._rpcRequest("getEpochSchedule", []);
      const res = create(unsafeRes, GetEpochScheduleRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get epoch schedule");
      }
      const epochSchedule = res.result;
      return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);
    }
    /**
     * Fetch the leader schedule for the current epoch
     * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
     */
    async getLeaderSchedule() {
      const unsafeRes = await this._rpcRequest("getLeaderSchedule", []);
      const res = create(unsafeRes, GetLeaderScheduleRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get leader schedule");
      }
      return res.result;
    }
    /**
     * Fetch the minimum balance needed to exempt an account of `dataLength`
     * size from rent
     */
    async getMinimumBalanceForRentExemption(dataLength, commitment) {
      const args = this._buildArgs([dataLength], commitment);
      const unsafeRes = await this._rpcRequest("getMinimumBalanceForRentExemption", args);
      const res = create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);
      if ("error" in res) {
        console.warn("Unable to fetch minimum balance for rent exemption");
        return 0;
      }
      return res.result;
    }
    /**
     * Fetch a recent blockhash from the cluster, return with context
     * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
     *
     * @deprecated Deprecated since RPC v1.9.0. Please use {@link getLatestBlockhash} instead.
     */
    async getRecentBlockhashAndContext(commitment) {
      const {
        context,
        value: {
          blockhash
        }
      } = await this.getLatestBlockhashAndContext(commitment);
      const feeCalculator = {
        get lamportsPerSignature() {
          throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.");
        },
        toJSON() {
          return {};
        }
      };
      return {
        context,
        value: {
          blockhash,
          feeCalculator
        }
      };
    }
    /**
     * Fetch recent performance samples
     * @return {Promise<Array<PerfSample>>}
     */
    async getRecentPerformanceSamples(limit) {
      const unsafeRes = await this._rpcRequest("getRecentPerformanceSamples", limit ? [limit] : []);
      const res = create(unsafeRes, GetRecentPerformanceSamplesRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get recent performance samples");
      }
      return res.result;
    }
    /**
     * Fetch the fee calculator for a recent blockhash from the cluster, return with context
     *
     * @deprecated Deprecated since RPC v1.9.0. Please use {@link getFeeForMessage} instead.
     */
    async getFeeCalculatorForBlockhash(blockhash, commitment) {
      const args = this._buildArgs([blockhash], commitment);
      const unsafeRes = await this._rpcRequest("getFeeCalculatorForBlockhash", args);
      const res = create(unsafeRes, GetFeeCalculatorRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get fee calculator");
      }
      const {
        context,
        value
      } = res.result;
      return {
        context,
        value: value !== null ? value.feeCalculator : null
      };
    }
    /**
     * Fetch the fee for a message from the cluster, return with context
     */
    async getFeeForMessage(message, commitment) {
      const wireMessage = toBuffer(message.serialize()).toString("base64");
      const args = this._buildArgs([wireMessage], commitment);
      const unsafeRes = await this._rpcRequest("getFeeForMessage", args);
      const res = create(unsafeRes, jsonRpcResultAndContext(nullable(number())));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get fee for message");
      }
      if (res.result === null) {
        throw new Error("invalid blockhash");
      }
      return res.result;
    }
    /**
     * Fetch a list of prioritization fees from recent blocks.
     */
    async getRecentPrioritizationFees(config) {
      const accounts = config?.lockedWritableAccounts?.map((key) => key.toBase58());
      const args = accounts?.length ? [accounts] : [];
      const unsafeRes = await this._rpcRequest("getRecentPrioritizationFees", args);
      const res = create(unsafeRes, GetRecentPrioritizationFeesRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get recent prioritization fees");
      }
      return res.result;
    }
    /**
     * Fetch a recent blockhash from the cluster
     * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
     *
     * @deprecated Deprecated since RPC v1.8.0. Please use {@link getLatestBlockhash} instead.
     */
    async getRecentBlockhash(commitment) {
      try {
        const res = await this.getRecentBlockhashAndContext(commitment);
        return res.value;
      } catch (e) {
        throw new Error("failed to get recent blockhash: " + e);
      }
    }
    /**
     * Fetch the latest blockhash from the cluster
     * @return {Promise<BlockhashWithExpiryBlockHeight>}
     */
    async getLatestBlockhash(commitmentOrConfig) {
      try {
        const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);
        return res.value;
      } catch (e) {
        throw new Error("failed to get recent blockhash: " + e);
      }
    }
    /**
     * Fetch the latest blockhash from the cluster
     * @return {Promise<BlockhashWithExpiryBlockHeight>}
     */
    async getLatestBlockhashAndContext(commitmentOrConfig) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([], commitment, void 0, config);
      const unsafeRes = await this._rpcRequest("getLatestBlockhash", args);
      const res = create(unsafeRes, GetLatestBlockhashRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get latest blockhash");
      }
      return res.result;
    }
    /**
     * Returns whether a blockhash is still valid or not
     */
    async isBlockhashValid(blockhash, rawConfig) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(rawConfig);
      const args = this._buildArgs([blockhash], commitment, void 0, config);
      const unsafeRes = await this._rpcRequest("isBlockhashValid", args);
      const res = create(unsafeRes, IsBlockhashValidRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to determine if the blockhash `" + blockhash + "`is valid");
      }
      return res.result;
    }
    /**
     * Fetch the node version
     */
    async getVersion() {
      const unsafeRes = await this._rpcRequest("getVersion", []);
      const res = create(unsafeRes, jsonRpcResult(VersionResult));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get version");
      }
      return res.result;
    }
    /**
     * Fetch the genesis hash
     */
    async getGenesisHash() {
      const unsafeRes = await this._rpcRequest("getGenesisHash", []);
      const res = create(unsafeRes, jsonRpcResult(string()));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get genesis hash");
      }
      return res.result;
    }
    /**
     * Fetch a processed block from the cluster.
     *
     * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
     * setting the `maxSupportedTransactionVersion` property.
     */
    /**
     * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
     * setting the `maxSupportedTransactionVersion` property.
     */
    // eslint-disable-next-line no-dupe-class-members
    /**
     * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
     * setting the `maxSupportedTransactionVersion` property.
     */
    // eslint-disable-next-line no-dupe-class-members
    /**
     * Fetch a processed block from the cluster.
     */
    // eslint-disable-next-line no-dupe-class-members
    // eslint-disable-next-line no-dupe-class-members
    // eslint-disable-next-line no-dupe-class-members
    /**
     * Fetch a processed block from the cluster.
     */
    // eslint-disable-next-line no-dupe-class-members
    async getBlock(slot, rawConfig) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(rawConfig);
      const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, config);
      const unsafeRes = await this._rpcRequest("getBlock", args);
      try {
        switch (config?.transactionDetails) {
          case "accounts": {
            const res = create(unsafeRes, GetAccountsModeBlockRpcResult);
            if ("error" in res) {
              throw res.error;
            }
            return res.result;
          }
          case "none": {
            const res = create(unsafeRes, GetNoneModeBlockRpcResult);
            if ("error" in res) {
              throw res.error;
            }
            return res.result;
          }
          default: {
            const res = create(unsafeRes, GetBlockRpcResult);
            if ("error" in res) {
              throw res.error;
            }
            const {
              result
            } = res;
            return result ? {
              ...result,
              transactions: result.transactions.map(({
                transaction,
                meta,
                version: version2
              }) => ({
                meta,
                transaction: {
                  ...transaction,
                  message: versionedMessageFromResponse(version2, transaction.message)
                },
                version: version2
              }))
            } : null;
          }
        }
      } catch (e) {
        throw new SolanaJSONRPCError(e, "failed to get confirmed block");
      }
    }
    /**
     * Fetch parsed transaction details for a confirmed or finalized block
     */
    // eslint-disable-next-line no-dupe-class-members
    // eslint-disable-next-line no-dupe-class-members
    // eslint-disable-next-line no-dupe-class-members
    async getParsedBlock(slot, rawConfig) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(rawConfig);
      const args = this._buildArgsAtLeastConfirmed([slot], commitment, "jsonParsed", config);
      const unsafeRes = await this._rpcRequest("getBlock", args);
      try {
        switch (config?.transactionDetails) {
          case "accounts": {
            const res = create(unsafeRes, GetParsedAccountsModeBlockRpcResult);
            if ("error" in res) {
              throw res.error;
            }
            return res.result;
          }
          case "none": {
            const res = create(unsafeRes, GetParsedNoneModeBlockRpcResult);
            if ("error" in res) {
              throw res.error;
            }
            return res.result;
          }
          default: {
            const res = create(unsafeRes, GetParsedBlockRpcResult);
            if ("error" in res) {
              throw res.error;
            }
            return res.result;
          }
        }
      } catch (e) {
        throw new SolanaJSONRPCError(e, "failed to get block");
      }
    }
    /*
     * Returns recent block production information from the current or previous epoch
     */
    async getBlockProduction(configOrCommitment) {
      let extra;
      let commitment;
      if (typeof configOrCommitment === "string") {
        commitment = configOrCommitment;
      } else if (configOrCommitment) {
        const {
          commitment: c,
          ...rest
        } = configOrCommitment;
        commitment = c;
        extra = rest;
      }
      const args = this._buildArgs([], commitment, "base64", extra);
      const unsafeRes = await this._rpcRequest("getBlockProduction", args);
      const res = create(unsafeRes, BlockProductionResponseStruct);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get block production information");
      }
      return res.result;
    }
    /**
     * Fetch a confirmed or finalized transaction from the cluster.
     *
     * @deprecated Instead, call `getTransaction` using a
     * `GetVersionedTransactionConfig` by setting the
     * `maxSupportedTransactionVersion` property.
     */
    /**
     * Fetch a confirmed or finalized transaction from the cluster.
     */
    // eslint-disable-next-line no-dupe-class-members
    /**
     * Fetch a confirmed or finalized transaction from the cluster.
     */
    // eslint-disable-next-line no-dupe-class-members
    async getTransaction(signature, rawConfig) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(rawConfig);
      const args = this._buildArgsAtLeastConfirmed([signature], commitment, void 0, config);
      const unsafeRes = await this._rpcRequest("getTransaction", args);
      const res = create(unsafeRes, GetTransactionRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get transaction");
      }
      const result = res.result;
      if (!result) return result;
      return {
        ...result,
        transaction: {
          ...result.transaction,
          message: versionedMessageFromResponse(result.version, result.transaction.message)
        }
      };
    }
    /**
     * Fetch parsed transaction details for a confirmed or finalized transaction
     */
    async getParsedTransaction(signature, commitmentOrConfig) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgsAtLeastConfirmed([signature], commitment, "jsonParsed", config);
      const unsafeRes = await this._rpcRequest("getTransaction", args);
      const res = create(unsafeRes, GetParsedTransactionRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get transaction");
      }
      return res.result;
    }
    /**
     * Fetch parsed transaction details for a batch of confirmed transactions
     */
    async getParsedTransactions(signatures, commitmentOrConfig) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const batch = signatures.map((signature) => {
        const args = this._buildArgsAtLeastConfirmed([signature], commitment, "jsonParsed", config);
        return {
          methodName: "getTransaction",
          args
        };
      });
      const unsafeRes = await this._rpcBatchRequest(batch);
      const res = unsafeRes.map((unsafeRes2) => {
        const res2 = create(unsafeRes2, GetParsedTransactionRpcResult);
        if ("error" in res2) {
          throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
        }
        return res2.result;
      });
      return res;
    }
    /**
     * Fetch transaction details for a batch of confirmed transactions.
     * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.
     *
     * @deprecated Instead, call `getTransactions` using a
     * `GetVersionedTransactionConfig` by setting the
     * `maxSupportedTransactionVersion` property.
     */
    /**
     * Fetch transaction details for a batch of confirmed transactions.
     * Similar to {@link getParsedTransactions} but returns a {@link
     * VersionedTransactionResponse}.
     */
    // eslint-disable-next-line no-dupe-class-members
    /**
     * Fetch transaction details for a batch of confirmed transactions.
     * Similar to {@link getParsedTransactions} but returns a {@link
     * VersionedTransactionResponse}.
     */
    // eslint-disable-next-line no-dupe-class-members
    async getTransactions(signatures, commitmentOrConfig) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const batch = signatures.map((signature) => {
        const args = this._buildArgsAtLeastConfirmed([signature], commitment, void 0, config);
        return {
          methodName: "getTransaction",
          args
        };
      });
      const unsafeRes = await this._rpcBatchRequest(batch);
      const res = unsafeRes.map((unsafeRes2) => {
        const res2 = create(unsafeRes2, GetTransactionRpcResult);
        if ("error" in res2) {
          throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
        }
        const result = res2.result;
        if (!result) return result;
        return {
          ...result,
          transaction: {
            ...result.transaction,
            message: versionedMessageFromResponse(result.version, result.transaction.message)
          }
        };
      });
      return res;
    }
    /**
     * Fetch a list of Transactions and transaction statuses from the cluster
     * for a confirmed block.
     *
     * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlock} instead.
     */
    async getConfirmedBlock(slot, commitment) {
      const args = this._buildArgsAtLeastConfirmed([slot], commitment);
      const unsafeRes = await this._rpcRequest("getBlock", args);
      const res = create(unsafeRes, GetConfirmedBlockRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
      }
      const result = res.result;
      if (!result) {
        throw new Error("Confirmed block " + slot + " not found");
      }
      const block = {
        ...result,
        transactions: result.transactions.map(({
          transaction,
          meta
        }) => {
          const message = new Message(transaction.message);
          return {
            meta,
            transaction: {
              ...transaction,
              message
            }
          };
        })
      };
      return {
        ...block,
        transactions: block.transactions.map(({
          transaction,
          meta
        }) => {
          return {
            meta,
            transaction: Transaction.populate(transaction.message, transaction.signatures)
          };
        })
      };
    }
    /**
     * Fetch confirmed blocks between two slots
     */
    async getBlocks(startSlot, endSlot, commitment) {
      const args = this._buildArgsAtLeastConfirmed(endSlot !== void 0 ? [startSlot, endSlot] : [startSlot], commitment);
      const unsafeRes = await this._rpcRequest("getBlocks", args);
      const res = create(unsafeRes, jsonRpcResult(array(number())));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get blocks");
      }
      return res.result;
    }
    /**
     * Fetch a list of Signatures from the cluster for a block, excluding rewards
     */
    async getBlockSignatures(slot, commitment) {
      const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
        transactionDetails: "signatures",
        rewards: false
      });
      const unsafeRes = await this._rpcRequest("getBlock", args);
      const res = create(unsafeRes, GetBlockSignaturesRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get block");
      }
      const result = res.result;
      if (!result) {
        throw new Error("Block " + slot + " not found");
      }
      return result;
    }
    /**
     * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards
     *
     * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlockSignatures} instead.
     */
    async getConfirmedBlockSignatures(slot, commitment) {
      const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
        transactionDetails: "signatures",
        rewards: false
      });
      const unsafeRes = await this._rpcRequest("getBlock", args);
      const res = create(unsafeRes, GetBlockSignaturesRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
      }
      const result = res.result;
      if (!result) {
        throw new Error("Confirmed block " + slot + " not found");
      }
      return result;
    }
    /**
     * Fetch a transaction details for a confirmed transaction
     *
     * @deprecated Deprecated since RPC v1.7.0. Please use {@link getTransaction} instead.
     */
    async getConfirmedTransaction(signature, commitment) {
      const args = this._buildArgsAtLeastConfirmed([signature], commitment);
      const unsafeRes = await this._rpcRequest("getTransaction", args);
      const res = create(unsafeRes, GetTransactionRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get transaction");
      }
      const result = res.result;
      if (!result) return result;
      const message = new Message(result.transaction.message);
      const signatures = result.transaction.signatures;
      return {
        ...result,
        transaction: Transaction.populate(message, signatures)
      };
    }
    /**
     * Fetch parsed transaction details for a confirmed transaction
     *
     * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransaction} instead.
     */
    async getParsedConfirmedTransaction(signature, commitment) {
      const args = this._buildArgsAtLeastConfirmed([signature], commitment, "jsonParsed");
      const unsafeRes = await this._rpcRequest("getTransaction", args);
      const res = create(unsafeRes, GetParsedTransactionRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get confirmed transaction");
      }
      return res.result;
    }
    /**
     * Fetch parsed transaction details for a batch of confirmed transactions
     *
     * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransactions} instead.
     */
    async getParsedConfirmedTransactions(signatures, commitment) {
      const batch = signatures.map((signature) => {
        const args = this._buildArgsAtLeastConfirmed([signature], commitment, "jsonParsed");
        return {
          methodName: "getTransaction",
          args
        };
      });
      const unsafeRes = await this._rpcBatchRequest(batch);
      const res = unsafeRes.map((unsafeRes2) => {
        const res2 = create(unsafeRes2, GetParsedTransactionRpcResult);
        if ("error" in res2) {
          throw new SolanaJSONRPCError(res2.error, "failed to get confirmed transactions");
        }
        return res2.result;
      });
      return res;
    }
    /**
     * Fetch a list of all the confirmed signatures for transactions involving an address
     * within a specified slot range. Max range allowed is 10,000 slots.
     *
     * @deprecated Deprecated since RPC v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.
     *
     * @param address queried address
     * @param startSlot start slot, inclusive
     * @param endSlot end slot, inclusive
     */
    async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {
      let options = {};
      let firstAvailableBlock = await this.getFirstAvailableBlock();
      while (!("until" in options)) {
        startSlot--;
        if (startSlot <= 0 || startSlot < firstAvailableBlock) {
          break;
        }
        try {
          const block = await this.getConfirmedBlockSignatures(startSlot, "finalized");
          if (block.signatures.length > 0) {
            options.until = block.signatures[block.signatures.length - 1].toString();
          }
        } catch (err) {
          if (err instanceof Error && err.message.includes("skipped")) {
            continue;
          } else {
            throw err;
          }
        }
      }
      let highestConfirmedRoot = await this.getSlot("finalized");
      while (!("before" in options)) {
        endSlot++;
        if (endSlot > highestConfirmedRoot) {
          break;
        }
        try {
          const block = await this.getConfirmedBlockSignatures(endSlot);
          if (block.signatures.length > 0) {
            options.before = block.signatures[block.signatures.length - 1].toString();
          }
        } catch (err) {
          if (err instanceof Error && err.message.includes("skipped")) {
            continue;
          } else {
            throw err;
          }
        }
      }
      const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);
      return confirmedSignatureInfo.map((info) => info.signature);
    }
    /**
     * Returns confirmed signatures for transactions involving an
     * address backwards in time from the provided signature or most recent confirmed block
     *
     * @deprecated Deprecated since RPC v1.7.0. Please use {@link getSignaturesForAddress} instead.
     */
    async getConfirmedSignaturesForAddress2(address, options, commitment) {
      const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
      const unsafeRes = await this._rpcRequest("getConfirmedSignaturesForAddress2", args);
      const res = create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get confirmed signatures for address");
      }
      return res.result;
    }
    /**
     * Returns confirmed signatures for transactions involving an
     * address backwards in time from the provided signature or most recent confirmed block
     *
     *
     * @param address queried address
     * @param options
     */
    async getSignaturesForAddress(address, options, commitment) {
      const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
      const unsafeRes = await this._rpcRequest("getSignaturesForAddress", args);
      const res = create(unsafeRes, GetSignaturesForAddressRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get signatures for address");
      }
      return res.result;
    }
    async getAddressLookupTable(accountKey, config) {
      const {
        context,
        value: accountInfo
      } = await this.getAccountInfoAndContext(accountKey, config);
      let value = null;
      if (accountInfo !== null) {
        value = new AddressLookupTableAccount({
          key: accountKey,
          state: AddressLookupTableAccount.deserialize(accountInfo.data)
        });
      }
      return {
        context,
        value
      };
    }
    /**
     * Fetch the contents of a Nonce account from the cluster, return with context
     */
    async getNonceAndContext(nonceAccount, commitmentOrConfig) {
      const {
        context,
        value: accountInfo
      } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);
      let value = null;
      if (accountInfo !== null) {
        value = NonceAccount.fromAccountData(accountInfo.data);
      }
      return {
        context,
        value
      };
    }
    /**
     * Fetch the contents of a Nonce account from the cluster
     */
    async getNonce(nonceAccount, commitmentOrConfig) {
      return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x) => x.value).catch((e) => {
        throw new Error("failed to get nonce for account " + nonceAccount.toBase58() + ": " + e);
      });
    }
    /**
     * Request an allocation of lamports to the specified address
     *
     * ```typescript
     * import { Connection, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
     *
     * (async () => {
     *   const connection = new Connection("https://api.testnet.solana.com", "confirmed");
     *   const myAddress = new PublicKey("2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM");
     *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);
     *   await connection.confirmTransaction(signature);
     * })();
     * ```
     */
    async requestAirdrop(to, lamports) {
      const unsafeRes = await this._rpcRequest("requestAirdrop", [to.toBase58(), lamports]);
      const res = create(unsafeRes, RequestAirdropRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);
      }
      return res.result;
    }
    /**
     * @internal
     */
    async _blockhashWithExpiryBlockHeight(disableCache) {
      if (!disableCache) {
        while (this._pollingBlockhash) {
          await sleep(100);
        }
        const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;
        const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
        if (this._blockhashInfo.latestBlockhash !== null && !expired) {
          return this._blockhashInfo.latestBlockhash;
        }
      }
      return await this._pollNewBlockhash();
    }
    /**
     * @internal
     */
    async _pollNewBlockhash() {
      this._pollingBlockhash = true;
      try {
        const startTime = Date.now();
        const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;
        const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;
        for (let i = 0; i < 50; i++) {
          const latestBlockhash = await this.getLatestBlockhash("finalized");
          if (cachedBlockhash !== latestBlockhash.blockhash) {
            this._blockhashInfo = {
              latestBlockhash,
              lastFetch: Date.now(),
              transactionSignatures: [],
              simulatedSignatures: []
            };
            return latestBlockhash;
          }
          await sleep(MS_PER_SLOT / 2);
        }
        throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);
      } finally {
        this._pollingBlockhash = false;
      }
    }
    /**
     * get the stake minimum delegation
     */
    async getStakeMinimumDelegation(config) {
      const {
        commitment,
        config: configArg
      } = extractCommitmentFromConfig(config);
      const args = this._buildArgs([], commitment, "base64", configArg);
      const unsafeRes = await this._rpcRequest("getStakeMinimumDelegation", args);
      const res = create(unsafeRes, jsonRpcResultAndContext(number()));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);
      }
      return res.result;
    }
    /**
     * Simulate a transaction
     *
     * @deprecated Instead, call {@link simulateTransaction} with {@link
     * VersionedTransaction} and {@link SimulateTransactionConfig} parameters
     */
    /**
     * Simulate a transaction
     */
    // eslint-disable-next-line no-dupe-class-members
    /**
     * Simulate a transaction
     */
    // eslint-disable-next-line no-dupe-class-members
    async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {
      if ("message" in transactionOrMessage) {
        const versionedTx = transactionOrMessage;
        const wireTransaction2 = versionedTx.serialize();
        const encodedTransaction2 = import_buffer2.Buffer.from(wireTransaction2).toString("base64");
        if (Array.isArray(configOrSigners) || includeAccounts !== void 0) {
          throw new Error("Invalid arguments");
        }
        const config2 = configOrSigners || {};
        config2.encoding = "base64";
        if (!("commitment" in config2)) {
          config2.commitment = this.commitment;
        }
        if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) {
          config2.innerInstructions = configOrSigners.innerInstructions;
        }
        const args2 = [encodedTransaction2, config2];
        const unsafeRes2 = await this._rpcRequest("simulateTransaction", args2);
        const res2 = create(unsafeRes2, SimulatedTransactionResponseStruct);
        if ("error" in res2) {
          throw new Error("failed to simulate transaction: " + res2.error.message);
        }
        return res2.result;
      }
      let transaction;
      if (transactionOrMessage instanceof Transaction) {
        let originalTx = transactionOrMessage;
        transaction = new Transaction();
        transaction.feePayer = originalTx.feePayer;
        transaction.instructions = transactionOrMessage.instructions;
        transaction.nonceInfo = originalTx.nonceInfo;
        transaction.signatures = originalTx.signatures;
      } else {
        transaction = Transaction.populate(transactionOrMessage);
        transaction._message = transaction._json = void 0;
      }
      if (configOrSigners !== void 0 && !Array.isArray(configOrSigners)) {
        throw new Error("Invalid arguments");
      }
      const signers = configOrSigners;
      if (transaction.nonceInfo && signers) {
        transaction.sign(...signers);
      } else {
        let disableCache = this._disableBlockhashCaching;
        for (; ; ) {
          const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
          transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
          transaction.recentBlockhash = latestBlockhash.blockhash;
          if (!signers) break;
          transaction.sign(...signers);
          if (!transaction.signature) {
            throw new Error("!signature");
          }
          const signature = transaction.signature.toString("base64");
          if (!this._blockhashInfo.simulatedSignatures.includes(signature) && !this._blockhashInfo.transactionSignatures.includes(signature)) {
            this._blockhashInfo.simulatedSignatures.push(signature);
            break;
          } else {
            disableCache = true;
          }
        }
      }
      const message = transaction._compile();
      const signData = message.serialize();
      const wireTransaction = transaction._serialize(signData);
      const encodedTransaction = wireTransaction.toString("base64");
      const config = {
        encoding: "base64",
        commitment: this.commitment
      };
      if (includeAccounts) {
        const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key) => key.toBase58());
        config["accounts"] = {
          encoding: "base64",
          addresses
        };
      }
      if (signers) {
        config.sigVerify = true;
      }
      if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) {
        config.innerInstructions = configOrSigners.innerInstructions;
      }
      const args = [encodedTransaction, config];
      const unsafeRes = await this._rpcRequest("simulateTransaction", args);
      const res = create(unsafeRes, SimulatedTransactionResponseStruct);
      if ("error" in res) {
        let logs;
        if ("data" in res.error) {
          logs = res.error.data.logs;
          if (logs && Array.isArray(logs)) {
            const traceIndent = "\n    ";
            const logTrace = traceIndent + logs.join(traceIndent);
            console.error(res.error.message, logTrace);
          }
        }
        throw new SendTransactionError({
          action: "simulate",
          signature: "",
          transactionMessage: res.error.message,
          logs
        });
      }
      return res.result;
    }
    /**
     * Sign and send a transaction
     *
     * @deprecated Instead, call {@link sendTransaction} with a {@link
     * VersionedTransaction}
     */
    /**
     * Send a signed transaction
     */
    // eslint-disable-next-line no-dupe-class-members
    /**
     * Sign and send a transaction
     */
    // eslint-disable-next-line no-dupe-class-members
    async sendTransaction(transaction, signersOrOptions, options) {
      if ("version" in transaction) {
        if (signersOrOptions && Array.isArray(signersOrOptions)) {
          throw new Error("Invalid arguments");
        }
        const wireTransaction2 = transaction.serialize();
        return await this.sendRawTransaction(wireTransaction2, signersOrOptions);
      }
      if (signersOrOptions === void 0 || !Array.isArray(signersOrOptions)) {
        throw new Error("Invalid arguments");
      }
      const signers = signersOrOptions;
      if (transaction.nonceInfo) {
        transaction.sign(...signers);
      } else {
        let disableCache = this._disableBlockhashCaching;
        for (; ; ) {
          const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
          transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
          transaction.recentBlockhash = latestBlockhash.blockhash;
          transaction.sign(...signers);
          if (!transaction.signature) {
            throw new Error("!signature");
          }
          const signature = transaction.signature.toString("base64");
          if (!this._blockhashInfo.transactionSignatures.includes(signature)) {
            this._blockhashInfo.transactionSignatures.push(signature);
            break;
          } else {
            disableCache = true;
          }
        }
      }
      const wireTransaction = transaction.serialize();
      return await this.sendRawTransaction(wireTransaction, options);
    }
    /**
     * Send a transaction that has already been signed and serialized into the
     * wire format
     */
    async sendRawTransaction(rawTransaction, options) {
      const encodedTransaction = toBuffer(rawTransaction).toString("base64");
      const result = await this.sendEncodedTransaction(encodedTransaction, options);
      return result;
    }
    /**
     * Send a transaction that has already been signed, serialized into the
     * wire format, and encoded as a base64 string
     */
    async sendEncodedTransaction(encodedTransaction, options) {
      const config = {
        encoding: "base64"
      };
      const skipPreflight = options && options.skipPreflight;
      const preflightCommitment = skipPreflight === true ? "processed" : options && options.preflightCommitment || this.commitment;
      if (options && options.maxRetries != null) {
        config.maxRetries = options.maxRetries;
      }
      if (options && options.minContextSlot != null) {
        config.minContextSlot = options.minContextSlot;
      }
      if (skipPreflight) {
        config.skipPreflight = skipPreflight;
      }
      if (preflightCommitment) {
        config.preflightCommitment = preflightCommitment;
      }
      const args = [encodedTransaction, config];
      const unsafeRes = await this._rpcRequest("sendTransaction", args);
      const res = create(unsafeRes, SendTransactionRpcResult);
      if ("error" in res) {
        let logs = void 0;
        if ("data" in res.error) {
          logs = res.error.data.logs;
        }
        throw new SendTransactionError({
          action: skipPreflight ? "send" : "simulate",
          signature: "",
          transactionMessage: res.error.message,
          logs
        });
      }
      return res.result;
    }
    /**
     * @internal
     */
    _wsOnOpen() {
      this._rpcWebSocketConnected = true;
      this._rpcWebSocketHeartbeat = setInterval(() => {
        (async () => {
          try {
            await this._rpcWebSocket.notify("ping");
          } catch {
          }
        })();
      }, 5e3);
      this._updateSubscriptions();
    }
    /**
     * @internal
     */
    _wsOnError(err) {
      this._rpcWebSocketConnected = false;
      console.error("ws error:", err.message);
    }
    /**
     * @internal
     */
    _wsOnClose(code) {
      this._rpcWebSocketConnected = false;
      this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;
      if (this._rpcWebSocketIdleTimeout) {
        clearTimeout(this._rpcWebSocketIdleTimeout);
        this._rpcWebSocketIdleTimeout = null;
      }
      if (this._rpcWebSocketHeartbeat) {
        clearInterval(this._rpcWebSocketHeartbeat);
        this._rpcWebSocketHeartbeat = null;
      }
      if (code === 1e3) {
        this._updateSubscriptions();
        return;
      }
      this._subscriptionCallbacksByServerSubscriptionId = {};
      Object.entries(this._subscriptionsByHash).forEach(([hash, subscription]) => {
        this._setSubscription(hash, {
          ...subscription,
          state: "pending"
        });
      });
    }
    /**
     * @internal
     */
    _setSubscription(hash, nextSubscription) {
      const prevState = this._subscriptionsByHash[hash]?.state;
      this._subscriptionsByHash[hash] = nextSubscription;
      if (prevState !== nextSubscription.state) {
        const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];
        if (stateChangeCallbacks) {
          stateChangeCallbacks.forEach((cb) => {
            try {
              cb(nextSubscription.state);
            } catch {
            }
          });
        }
      }
    }
    /**
     * @internal
     */
    _onSubscriptionStateChange(clientSubscriptionId, callback) {
      var _a;
      const hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
      if (hash == null) {
        return () => {
        };
      }
      const stateChangeCallbacks = (_a = this._subscriptionStateChangeCallbacksByHash)[hash] || (_a[hash] = /* @__PURE__ */ new Set());
      stateChangeCallbacks.add(callback);
      return () => {
        stateChangeCallbacks.delete(callback);
        if (stateChangeCallbacks.size === 0) {
          delete this._subscriptionStateChangeCallbacksByHash[hash];
        }
      };
    }
    /**
     * @internal
     */
    async _updateSubscriptions() {
      if (Object.keys(this._subscriptionsByHash).length === 0) {
        if (this._rpcWebSocketConnected) {
          this._rpcWebSocketConnected = false;
          this._rpcWebSocketIdleTimeout = setTimeout(() => {
            this._rpcWebSocketIdleTimeout = null;
            try {
              this._rpcWebSocket.close();
            } catch (err) {
              if (err instanceof Error) {
                console.log(`Error when closing socket connection: ${err.message}`);
              }
            }
          }, 500);
        }
        return;
      }
      if (this._rpcWebSocketIdleTimeout !== null) {
        clearTimeout(this._rpcWebSocketIdleTimeout);
        this._rpcWebSocketIdleTimeout = null;
        this._rpcWebSocketConnected = true;
      }
      if (!this._rpcWebSocketConnected) {
        this._rpcWebSocket.connect();
        return;
      }
      const activeWebSocketGeneration = this._rpcWebSocketGeneration;
      const isCurrentConnectionStillActive = () => {
        return activeWebSocketGeneration === this._rpcWebSocketGeneration;
      };
      await Promise.all(
        // Don't be tempted to change this to `Object.entries`. We call
        // `_updateSubscriptions` recursively when processing the state,
        // so it's important that we look up the *current* version of
        // each subscription, every time we process a hash.
        Object.keys(this._subscriptionsByHash).map(async (hash) => {
          const subscription = this._subscriptionsByHash[hash];
          if (subscription === void 0) {
            return;
          }
          switch (subscription.state) {
            case "pending":
            case "unsubscribed":
              if (subscription.callbacks.size === 0) {
                delete this._subscriptionsByHash[hash];
                if (subscription.state === "unsubscribed") {
                  delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];
                }
                await this._updateSubscriptions();
                return;
              }
              await (async () => {
                const {
                  args,
                  method
                } = subscription;
                try {
                  this._setSubscription(hash, {
                    ...subscription,
                    state: "subscribing"
                  });
                  const serverSubscriptionId = await this._rpcWebSocket.call(method, args);
                  this._setSubscription(hash, {
                    ...subscription,
                    serverSubscriptionId,
                    state: "subscribed"
                  });
                  this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;
                  await this._updateSubscriptions();
                } catch (e) {
                  console.error(`Received ${e instanceof Error ? "" : "JSON-RPC "}error calling \`${method}\``, {
                    args,
                    error: e
                  });
                  if (!isCurrentConnectionStillActive()) {
                    return;
                  }
                  this._setSubscription(hash, {
                    ...subscription,
                    state: "pending"
                  });
                  await this._updateSubscriptions();
                }
              })();
              break;
            case "subscribed":
              if (subscription.callbacks.size === 0) {
                await (async () => {
                  const {
                    serverSubscriptionId,
                    unsubscribeMethod
                  } = subscription;
                  if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {
                    this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);
                  } else {
                    this._setSubscription(hash, {
                      ...subscription,
                      state: "unsubscribing"
                    });
                    this._setSubscription(hash, {
                      ...subscription,
                      state: "unsubscribing"
                    });
                    try {
                      await this._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);
                    } catch (e) {
                      if (e instanceof Error) {
                        console.error(`${unsubscribeMethod} error:`, e.message);
                      }
                      if (!isCurrentConnectionStillActive()) {
                        return;
                      }
                      this._setSubscription(hash, {
                        ...subscription,
                        state: "subscribed"
                      });
                      await this._updateSubscriptions();
                      return;
                    }
                  }
                  this._setSubscription(hash, {
                    ...subscription,
                    state: "unsubscribed"
                  });
                  await this._updateSubscriptions();
                })();
              }
              break;
          }
        })
      );
    }
    /**
     * @internal
     */
    _handleServerNotification(serverSubscriptionId, callbackArgs) {
      const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];
      if (callbacks === void 0) {
        return;
      }
      callbacks.forEach((cb) => {
        try {
          cb(
            ...callbackArgs
          );
        } catch (e) {
          console.error(e);
        }
      });
    }
    /**
     * @internal
     */
    _wsOnAccountNotification(notification) {
      const {
        result,
        subscription
      } = create(notification, AccountNotificationResult);
      this._handleServerNotification(subscription, [result.value, result.context]);
    }
    /**
     * @internal
     */
    _makeSubscription(subscriptionConfig, args) {
      const clientSubscriptionId = this._nextClientSubscriptionId++;
      const hash = fastStableStringify([subscriptionConfig.method, args]);
      const existingSubscription = this._subscriptionsByHash[hash];
      if (existingSubscription === void 0) {
        this._subscriptionsByHash[hash] = {
          ...subscriptionConfig,
          args,
          callbacks: /* @__PURE__ */ new Set([subscriptionConfig.callback]),
          state: "pending"
        };
      } else {
        existingSubscription.callbacks.add(subscriptionConfig.callback);
      }
      this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;
      this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async () => {
        delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
        delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
        const subscription = this._subscriptionsByHash[hash];
        assert2(subscription !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${clientSubscriptionId}`);
        subscription.callbacks.delete(subscriptionConfig.callback);
        await this._updateSubscriptions();
      };
      this._updateSubscriptions();
      return clientSubscriptionId;
    }
    /**
     * Register a callback to be invoked whenever the specified account changes
     *
     * @param publicKey Public key of the account to monitor
     * @param callback Function to invoke whenever the account is changed
     * @param config
     * @return subscription id
     */
    /** @deprecated Instead, pass in an {@link AccountSubscriptionConfig} */
    // eslint-disable-next-line no-dupe-class-members
    // eslint-disable-next-line no-dupe-class-members
    onAccountChange(publicKey3, callback, commitmentOrConfig) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs(
        [publicKey3.toBase58()],
        commitment || this._commitment || "finalized",
        // Apply connection/server default.
        "base64",
        config
      );
      return this._makeSubscription({
        callback,
        method: "accountSubscribe",
        unsubscribeMethod: "accountUnsubscribe"
      }, args);
    }
    /**
     * Deregister an account notification callback
     *
     * @param clientSubscriptionId client subscription id to deregister
     */
    async removeAccountChangeListener(clientSubscriptionId) {
      await this._unsubscribeClientSubscription(clientSubscriptionId, "account change");
    }
    /**
     * @internal
     */
    _wsOnProgramAccountNotification(notification) {
      const {
        result,
        subscription
      } = create(notification, ProgramAccountNotificationResult);
      this._handleServerNotification(subscription, [{
        accountId: result.value.pubkey,
        accountInfo: result.value.account
      }, result.context]);
    }
    /**
     * Register a callback to be invoked whenever accounts owned by the
     * specified program change
     *
     * @param programId Public key of the program to monitor
     * @param callback Function to invoke whenever the account is changed
     * @param config
     * @return subscription id
     */
    /** @deprecated Instead, pass in a {@link ProgramAccountSubscriptionConfig} */
    // eslint-disable-next-line no-dupe-class-members
    // eslint-disable-next-line no-dupe-class-members
    onProgramAccountChange(programId, callback, commitmentOrConfig, maybeFilters) {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs(
        [programId.toBase58()],
        commitment || this._commitment || "finalized",
        // Apply connection/server default.
        "base64",
        config ? config : maybeFilters ? {
          filters: applyDefaultMemcmpEncodingToFilters(maybeFilters)
        } : void 0
        /* extra */
      );
      return this._makeSubscription({
        callback,
        method: "programSubscribe",
        unsubscribeMethod: "programUnsubscribe"
      }, args);
    }
    /**
     * Deregister an account notification callback
     *
     * @param clientSubscriptionId client subscription id to deregister
     */
    async removeProgramAccountChangeListener(clientSubscriptionId) {
      await this._unsubscribeClientSubscription(clientSubscriptionId, "program account change");
    }
    /**
     * Registers a callback to be invoked whenever logs are emitted.
     */
    onLogs(filter, callback, commitment) {
      const args = this._buildArgs(
        [typeof filter === "object" ? {
          mentions: [filter.toString()]
        } : filter],
        commitment || this._commitment || "finalized"
        // Apply connection/server default.
      );
      return this._makeSubscription({
        callback,
        method: "logsSubscribe",
        unsubscribeMethod: "logsUnsubscribe"
      }, args);
    }
    /**
     * Deregister a logs callback.
     *
     * @param clientSubscriptionId client subscription id to deregister.
     */
    async removeOnLogsListener(clientSubscriptionId) {
      await this._unsubscribeClientSubscription(clientSubscriptionId, "logs");
    }
    /**
     * @internal
     */
    _wsOnLogsNotification(notification) {
      const {
        result,
        subscription
      } = create(notification, LogsNotificationResult);
      this._handleServerNotification(subscription, [result.value, result.context]);
    }
    /**
     * @internal
     */
    _wsOnSlotNotification(notification) {
      const {
        result,
        subscription
      } = create(notification, SlotNotificationResult);
      this._handleServerNotification(subscription, [result]);
    }
    /**
     * Register a callback to be invoked upon slot changes
     *
     * @param callback Function to invoke whenever the slot changes
     * @return subscription id
     */
    onSlotChange(callback) {
      return this._makeSubscription(
        {
          callback,
          method: "slotSubscribe",
          unsubscribeMethod: "slotUnsubscribe"
        },
        []
        /* args */
      );
    }
    /**
     * Deregister a slot notification callback
     *
     * @param clientSubscriptionId client subscription id to deregister
     */
    async removeSlotChangeListener(clientSubscriptionId) {
      await this._unsubscribeClientSubscription(clientSubscriptionId, "slot change");
    }
    /**
     * @internal
     */
    _wsOnSlotUpdatesNotification(notification) {
      const {
        result,
        subscription
      } = create(notification, SlotUpdateNotificationResult);
      this._handleServerNotification(subscription, [result]);
    }
    /**
     * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s
     * may be useful to track live progress of a cluster.
     *
     * @param callback Function to invoke whenever the slot updates
     * @return subscription id
     */
    onSlotUpdate(callback) {
      return this._makeSubscription(
        {
          callback,
          method: "slotsUpdatesSubscribe",
          unsubscribeMethod: "slotsUpdatesUnsubscribe"
        },
        []
        /* args */
      );
    }
    /**
     * Deregister a slot update notification callback
     *
     * @param clientSubscriptionId client subscription id to deregister
     */
    async removeSlotUpdateListener(clientSubscriptionId) {
      await this._unsubscribeClientSubscription(clientSubscriptionId, "slot update");
    }
    /**
     * @internal
     */
    async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {
      const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
      if (dispose) {
        await dispose();
      } else {
        console.warn(`Ignored unsubscribe request because an active subscription with id \`${clientSubscriptionId}\` for '${subscriptionName}' events could not be found.`);
      }
    }
    _buildArgs(args, override, encoding, extra) {
      const commitment = override || this._commitment;
      if (commitment || encoding || extra) {
        let options = {};
        if (encoding) {
          options.encoding = encoding;
        }
        if (commitment) {
          options.commitment = commitment;
        }
        if (extra) {
          options = Object.assign(options, extra);
        }
        args.push(options);
      }
      return args;
    }
    /**
     * @internal
     */
    _buildArgsAtLeastConfirmed(args, override, encoding, extra) {
      const commitment = override || this._commitment;
      if (commitment && !["confirmed", "finalized"].includes(commitment)) {
        throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
      }
      return this._buildArgs(args, override, encoding, extra);
    }
    /**
     * @internal
     */
    _wsOnSignatureNotification(notification) {
      const {
        result,
        subscription
      } = create(notification, SignatureNotificationResult);
      if (result.value !== "receivedSignature") {
        this._subscriptionsAutoDisposedByRpc.add(subscription);
      }
      this._handleServerNotification(subscription, result.value === "receivedSignature" ? [{
        type: "received"
      }, result.context] : [{
        type: "status",
        result: result.value
      }, result.context]);
    }
    /**
     * Register a callback to be invoked upon signature updates
     *
     * @param signature Transaction signature string in base 58
     * @param callback Function to invoke on signature notifications
     * @param commitment Specify the commitment level signature must reach before notification
     * @return subscription id
     */
    onSignature(signature, callback, commitment) {
      const args = this._buildArgs(
        [signature],
        commitment || this._commitment || "finalized"
        // Apply connection/server default.
      );
      const clientSubscriptionId = this._makeSubscription({
        callback: (notification, context) => {
          if (notification.type === "status") {
            callback(notification.result, context);
            try {
              this.removeSignatureListener(clientSubscriptionId);
            } catch (_err) {
            }
          }
        },
        method: "signatureSubscribe",
        unsubscribeMethod: "signatureUnsubscribe"
      }, args);
      return clientSubscriptionId;
    }
    /**
     * Register a callback to be invoked when a transaction is
     * received and/or processed.
     *
     * @param signature Transaction signature string in base 58
     * @param callback Function to invoke on signature notifications
     * @param options Enable received notifications and set the commitment
     *   level that signature must reach before notification
     * @return subscription id
     */
    onSignatureWithOptions(signature, callback, options) {
      const {
        commitment,
        ...extra
      } = {
        ...options,
        commitment: options && options.commitment || this._commitment || "finalized"
        // Apply connection/server default.
      };
      const args = this._buildArgs([signature], commitment, void 0, extra);
      const clientSubscriptionId = this._makeSubscription({
        callback: (notification, context) => {
          callback(notification, context);
          try {
            this.removeSignatureListener(clientSubscriptionId);
          } catch (_err) {
          }
        },
        method: "signatureSubscribe",
        unsubscribeMethod: "signatureUnsubscribe"
      }, args);
      return clientSubscriptionId;
    }
    /**
     * Deregister a signature notification callback
     *
     * @param clientSubscriptionId client subscription id to deregister
     */
    async removeSignatureListener(clientSubscriptionId) {
      await this._unsubscribeClientSubscription(clientSubscriptionId, "signature result");
    }
    /**
     * @internal
     */
    _wsOnRootNotification(notification) {
      const {
        result,
        subscription
      } = create(notification, RootNotificationResult);
      this._handleServerNotification(subscription, [result]);
    }
    /**
     * Register a callback to be invoked upon root changes
     *
     * @param callback Function to invoke whenever the root changes
     * @return subscription id
     */
    onRootChange(callback) {
      return this._makeSubscription(
        {
          callback,
          method: "rootSubscribe",
          unsubscribeMethod: "rootUnsubscribe"
        },
        []
        /* args */
      );
    }
    /**
     * Deregister a root notification callback
     *
     * @param clientSubscriptionId client subscription id to deregister
     */
    async removeRootChangeListener(clientSubscriptionId) {
      await this._unsubscribeClientSubscription(clientSubscriptionId, "root change");
    }
  };
  var Keypair = class _Keypair {
    /**
     * Create a new keypair instance.
     * Generate random keypair if no {@link Ed25519Keypair} is provided.
     *
     * @param {Ed25519Keypair} keypair ed25519 keypair
     */
    constructor(keypair) {
      this._keypair = void 0;
      this._keypair = keypair ?? generateKeypair();
    }
    /**
     * Generate a new random keypair
     *
     * @returns {Keypair} Keypair
     */
    static generate() {
      return new _Keypair(generateKeypair());
    }
    /**
     * Create a keypair from a raw secret key byte array.
     *
     * This method should only be used to recreate a keypair from a previously
     * generated secret key. Generating keypairs from a random seed should be done
     * with the {@link Keypair.fromSeed} method.
     *
     * @throws error if the provided secret key is invalid and validation is not skipped.
     *
     * @param secretKey secret key byte array
     * @param options skip secret key validation
     *
     * @returns {Keypair} Keypair
     */
    static fromSecretKey(secretKey, options) {
      if (secretKey.byteLength !== 64) {
        throw new Error("bad secret key size");
      }
      const publicKey3 = secretKey.slice(32, 64);
      if (!options || !options.skipValidation) {
        const privateScalar = secretKey.slice(0, 32);
        const computedPublicKey = getPublicKey(privateScalar);
        for (let ii = 0; ii < 32; ii++) {
          if (publicKey3[ii] !== computedPublicKey[ii]) {
            throw new Error("provided secretKey is invalid");
          }
        }
      }
      return new _Keypair({
        publicKey: publicKey3,
        secretKey
      });
    }
    /**
     * Generate a keypair from a 32 byte seed.
     *
     * @param seed seed byte array
     *
     * @returns {Keypair} Keypair
     */
    static fromSeed(seed) {
      const publicKey3 = getPublicKey(seed);
      const secretKey = new Uint8Array(64);
      secretKey.set(seed);
      secretKey.set(publicKey3, 32);
      return new _Keypair({
        publicKey: publicKey3,
        secretKey
      });
    }
    /**
     * The public key for this keypair
     *
     * @returns {PublicKey} PublicKey
     */
    get publicKey() {
      return new PublicKey(this._keypair.publicKey);
    }
    /**
     * The raw secret key for this keypair
     * @returns {Uint8Array} Secret key in an array of Uint8 bytes
     */
    get secretKey() {
      return new Uint8Array(this._keypair.secretKey);
    }
  };
  var LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
    CreateLookupTable: {
      index: 0,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), u64("recentSlot"), BufferLayout.u8("bumpSeed")])
    },
    FreezeLookupTable: {
      index: 1,
      layout: BufferLayout.struct([BufferLayout.u32("instruction")])
    },
    ExtendLookupTable: {
      index: 2,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), u64(), BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u32(), -8), "addresses")])
    },
    DeactivateLookupTable: {
      index: 3,
      layout: BufferLayout.struct([BufferLayout.u32("instruction")])
    },
    CloseLookupTable: {
      index: 4,
      layout: BufferLayout.struct([BufferLayout.u32("instruction")])
    }
  });
  var AddressLookupTableProgram = class {
    /**
     * @internal
     */
    constructor() {
    }
    static createLookupTable(params) {
      const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([params.authority.toBuffer(), getU64Encoder().encode(params.recentSlot)], this.programId);
      const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;
      const data = encodeData(type2, {
        recentSlot: BigInt(params.recentSlot),
        bumpSeed
      });
      const keys = [{
        pubkey: lookupTableAddress,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authority,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.payer,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: SystemProgram.programId,
        isSigner: false,
        isWritable: false
      }];
      return [new TransactionInstruction({
        programId: this.programId,
        keys,
        data
      }), lookupTableAddress];
    }
    static freezeLookupTable(params) {
      const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;
      const data = encodeData(type2);
      const keys = [{
        pubkey: params.lookupTable,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authority,
        isSigner: true,
        isWritable: false
      }];
      return new TransactionInstruction({
        programId: this.programId,
        keys,
        data
      });
    }
    static extendLookupTable(params) {
      const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;
      const data = encodeData(type2, {
        addresses: params.addresses.map((addr) => addr.toBytes())
      });
      const keys = [{
        pubkey: params.lookupTable,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authority,
        isSigner: true,
        isWritable: false
      }];
      if (params.payer) {
        keys.push({
          pubkey: params.payer,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SystemProgram.programId,
          isSigner: false,
          isWritable: false
        });
      }
      return new TransactionInstruction({
        programId: this.programId,
        keys,
        data
      });
    }
    static deactivateLookupTable(params) {
      const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;
      const data = encodeData(type2);
      const keys = [{
        pubkey: params.lookupTable,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authority,
        isSigner: true,
        isWritable: false
      }];
      return new TransactionInstruction({
        programId: this.programId,
        keys,
        data
      });
    }
    static closeLookupTable(params) {
      const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;
      const data = encodeData(type2);
      const keys = [{
        pubkey: params.lookupTable,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authority,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.recipient,
        isSigner: false,
        isWritable: true
      }];
      return new TransactionInstruction({
        programId: this.programId,
        keys,
        data
      });
    }
  };
  AddressLookupTableProgram.programId = new PublicKey("AddressLookupTab1e1111111111111111111111111");
  var COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
    RequestUnits: {
      index: 0,
      layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("units"), BufferLayout.u32("additionalFee")])
    },
    RequestHeapFrame: {
      index: 1,
      layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("bytes")])
    },
    SetComputeUnitLimit: {
      index: 2,
      layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("units")])
    },
    SetComputeUnitPrice: {
      index: 3,
      layout: BufferLayout.struct([BufferLayout.u8("instruction"), u64("microLamports")])
    }
  });
  var ComputeBudgetProgram = class {
    /**
     * @internal
     */
    constructor() {
    }
    /**
     * Public key that identifies the Compute Budget program
     */
    /**
     * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}
     */
    static requestUnits(params) {
      const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;
      const data = encodeData(type2, params);
      return new TransactionInstruction({
        keys: [],
        programId: this.programId,
        data
      });
    }
    static requestHeapFrame(params) {
      const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;
      const data = encodeData(type2, params);
      return new TransactionInstruction({
        keys: [],
        programId: this.programId,
        data
      });
    }
    static setComputeUnitLimit(params) {
      const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;
      const data = encodeData(type2, params);
      return new TransactionInstruction({
        keys: [],
        programId: this.programId,
        data
      });
    }
    static setComputeUnitPrice(params) {
      const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;
      const data = encodeData(type2, {
        microLamports: BigInt(params.microLamports)
      });
      return new TransactionInstruction({
        keys: [],
        programId: this.programId,
        data
      });
    }
  };
  ComputeBudgetProgram.programId = new PublicKey("ComputeBudget111111111111111111111111111111");
  var PRIVATE_KEY_BYTES$1 = 64;
  var PUBLIC_KEY_BYTES$1 = 32;
  var SIGNATURE_BYTES = 64;
  var ED25519_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8("numSignatures"), BufferLayout.u8("padding"), BufferLayout.u16("signatureOffset"), BufferLayout.u16("signatureInstructionIndex"), BufferLayout.u16("publicKeyOffset"), BufferLayout.u16("publicKeyInstructionIndex"), BufferLayout.u16("messageDataOffset"), BufferLayout.u16("messageDataSize"), BufferLayout.u16("messageInstructionIndex")]);
  var Ed25519Program = class _Ed25519Program {
    /**
     * @internal
     */
    constructor() {
    }
    /**
     * Public key that identifies the ed25519 program
     */
    /**
     * Create an ed25519 instruction with a public key and signature. The
     * public key must be a buffer that is 32 bytes long, and the signature
     * must be a buffer of 64 bytes.
     */
    static createInstructionWithPublicKey(params) {
      const {
        publicKey: publicKey3,
        message,
        signature,
        instructionIndex
      } = params;
      assert2(publicKey3.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey3.length} bytes`);
      assert2(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);
      const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;
      const signatureOffset = publicKeyOffset + publicKey3.length;
      const messageDataOffset = signatureOffset + signature.length;
      const numSignatures = 1;
      const instructionData = import_buffer2.Buffer.alloc(messageDataOffset + message.length);
      const index = instructionIndex == null ? 65535 : instructionIndex;
      ED25519_INSTRUCTION_LAYOUT.encode({
        numSignatures,
        padding: 0,
        signatureOffset,
        signatureInstructionIndex: index,
        publicKeyOffset,
        publicKeyInstructionIndex: index,
        messageDataOffset,
        messageDataSize: message.length,
        messageInstructionIndex: index
      }, instructionData);
      instructionData.fill(publicKey3, publicKeyOffset);
      instructionData.fill(signature, signatureOffset);
      instructionData.fill(message, messageDataOffset);
      return new TransactionInstruction({
        keys: [],
        programId: _Ed25519Program.programId,
        data: instructionData
      });
    }
    /**
     * Create an ed25519 instruction with a private key. The private key
     * must be a buffer that is 64 bytes long.
     */
    static createInstructionWithPrivateKey(params) {
      const {
        privateKey,
        message,
        instructionIndex
      } = params;
      assert2(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);
      try {
        const keypair = Keypair.fromSecretKey(privateKey);
        const publicKey3 = keypair.publicKey.toBytes();
        const signature = sign(message, keypair.secretKey);
        return this.createInstructionWithPublicKey({
          publicKey: publicKey3,
          message,
          signature,
          instructionIndex
        });
      } catch (error) {
        throw new Error(`Error creating instruction; ${error}`);
      }
    }
  };
  Ed25519Program.programId = new PublicKey("Ed25519SigVerify111111111111111111111111111");
  var ecdsaSign = (msgHash, privKey) => {
    const signature = secp256k1.sign(msgHash, privKey);
    return [signature.toCompactRawBytes(), signature.recovery];
  };
  secp256k1.utils.isValidPrivateKey;
  var publicKeyCreate = secp256k1.getPublicKey;
  var PRIVATE_KEY_BYTES = 32;
  var ETHEREUM_ADDRESS_BYTES = 20;
  var PUBLIC_KEY_BYTES = 64;
  var SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;
  var SECP256K1_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8("numSignatures"), BufferLayout.u16("signatureOffset"), BufferLayout.u8("signatureInstructionIndex"), BufferLayout.u16("ethAddressOffset"), BufferLayout.u8("ethAddressInstructionIndex"), BufferLayout.u16("messageDataOffset"), BufferLayout.u16("messageDataSize"), BufferLayout.u8("messageInstructionIndex"), BufferLayout.blob(20, "ethAddress"), BufferLayout.blob(64, "signature"), BufferLayout.u8("recoveryId")]);
  var Secp256k1Program = class _Secp256k1Program {
    /**
     * @internal
     */
    constructor() {
    }
    /**
     * Public key that identifies the secp256k1 program
     */
    /**
     * Construct an Ethereum address from a secp256k1 public key buffer.
     * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer
     */
    static publicKeyToEthAddress(publicKey3) {
      assert2(publicKey3.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey3.length} bytes`);
      try {
        return import_buffer2.Buffer.from(keccak_256(toBuffer(publicKey3))).slice(-ETHEREUM_ADDRESS_BYTES);
      } catch (error) {
        throw new Error(`Error constructing Ethereum address: ${error}`);
      }
    }
    /**
     * Create an secp256k1 instruction with a public key. The public key
     * must be a buffer that is 64 bytes long.
     */
    static createInstructionWithPublicKey(params) {
      const {
        publicKey: publicKey3,
        message,
        signature,
        recoveryId,
        instructionIndex
      } = params;
      return _Secp256k1Program.createInstructionWithEthAddress({
        ethAddress: _Secp256k1Program.publicKeyToEthAddress(publicKey3),
        message,
        signature,
        recoveryId,
        instructionIndex
      });
    }
    /**
     * Create an secp256k1 instruction with an Ethereum address. The address
     * must be a hex string or a buffer that is 20 bytes long.
     */
    static createInstructionWithEthAddress(params) {
      const {
        ethAddress: rawAddress,
        message,
        signature,
        recoveryId,
        instructionIndex = 0
      } = params;
      let ethAddress;
      if (typeof rawAddress === "string") {
        if (rawAddress.startsWith("0x")) {
          ethAddress = import_buffer2.Buffer.from(rawAddress.substr(2), "hex");
        } else {
          ethAddress = import_buffer2.Buffer.from(rawAddress, "hex");
        }
      } else {
        ethAddress = rawAddress;
      }
      assert2(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);
      const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
      const ethAddressOffset = dataStart;
      const signatureOffset = dataStart + ethAddress.length;
      const messageDataOffset = signatureOffset + signature.length + 1;
      const numSignatures = 1;
      const instructionData = import_buffer2.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
      SECP256K1_INSTRUCTION_LAYOUT.encode({
        numSignatures,
        signatureOffset,
        signatureInstructionIndex: instructionIndex,
        ethAddressOffset,
        ethAddressInstructionIndex: instructionIndex,
        messageDataOffset,
        messageDataSize: message.length,
        messageInstructionIndex: instructionIndex,
        signature: toBuffer(signature),
        ethAddress: toBuffer(ethAddress),
        recoveryId
      }, instructionData);
      instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
      return new TransactionInstruction({
        keys: [],
        programId: _Secp256k1Program.programId,
        data: instructionData
      });
    }
    /**
     * Create an secp256k1 instruction with a private key. The private key
     * must be a buffer that is 32 bytes long.
     */
    static createInstructionWithPrivateKey(params) {
      const {
        privateKey: pkey,
        message,
        instructionIndex
      } = params;
      assert2(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);
      try {
        const privateKey = toBuffer(pkey);
        const publicKey3 = publicKeyCreate(
          privateKey,
          false
          /* isCompressed */
        ).slice(1);
        const messageHash = import_buffer2.Buffer.from(keccak_256(toBuffer(message)));
        const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);
        return this.createInstructionWithPublicKey({
          publicKey: publicKey3,
          message,
          signature,
          recoveryId,
          instructionIndex
        });
      } catch (error) {
        throw new Error(`Error creating instruction; ${error}`);
      }
    }
  };
  Secp256k1Program.programId = new PublicKey("KeccakSecp256k11111111111111111111111111111");
  var _Lockup;
  var STAKE_CONFIG_ID = new PublicKey("StakeConfig11111111111111111111111111111111");
  var Lockup = class {
    /**
     * Create a new Lockup object
     */
    constructor(unixTimestamp, epoch, custodian) {
      this.unixTimestamp = void 0;
      this.epoch = void 0;
      this.custodian = void 0;
      this.unixTimestamp = unixTimestamp;
      this.epoch = epoch;
      this.custodian = custodian;
    }
    /**
     * Default, inactive Lockup value
     */
  };
  _Lockup = Lockup;
  Lockup.default = new _Lockup(0, 0, PublicKey.default);
  var STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
    Initialize: {
      index: 0,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), authorized(), lockup()])
    },
    Authorize: {
      index: 1,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("stakeAuthorizationType")])
    },
    Delegate: {
      index: 2,
      layout: BufferLayout.struct([BufferLayout.u32("instruction")])
    },
    Split: {
      index: 3,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
    },
    Withdraw: {
      index: 4,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
    },
    Deactivate: {
      index: 5,
      layout: BufferLayout.struct([BufferLayout.u32("instruction")])
    },
    Merge: {
      index: 7,
      layout: BufferLayout.struct([BufferLayout.u32("instruction")])
    },
    AuthorizeWithSeed: {
      index: 8,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("stakeAuthorizationType"), rustString("authoritySeed"), publicKey("authorityOwner")])
    }
  });
  var StakeAuthorizationLayout = Object.freeze({
    Staker: {
      index: 0
    },
    Withdrawer: {
      index: 1
    }
  });
  var StakeProgram = class {
    /**
     * @internal
     */
    constructor() {
    }
    /**
     * Public key that identifies the Stake program
     */
    /**
     * Generate an Initialize instruction to add to a Stake Create transaction
     */
    static initialize(params) {
      const {
        stakePubkey,
        authorized: authorized2,
        lockup: maybeLockup
      } = params;
      const lockup2 = maybeLockup || Lockup.default;
      const type2 = STAKE_INSTRUCTION_LAYOUTS.Initialize;
      const data = encodeData(type2, {
        authorized: {
          staker: toBuffer(authorized2.staker.toBuffer()),
          withdrawer: toBuffer(authorized2.withdrawer.toBuffer())
        },
        lockup: {
          unixTimestamp: lockup2.unixTimestamp,
          epoch: lockup2.epoch,
          custodian: toBuffer(lockup2.custodian.toBuffer())
        }
      });
      const instructionData = {
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }],
        programId: this.programId,
        data
      };
      return new TransactionInstruction(instructionData);
    }
    /**
     * Generate a Transaction that creates a new Stake account at
     *   an address generated with `from`, a seed, and the Stake programId
     */
    static createAccountWithSeed(params) {
      const transaction = new Transaction();
      transaction.add(SystemProgram.createAccountWithSeed({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.stakePubkey,
        basePubkey: params.basePubkey,
        seed: params.seed,
        lamports: params.lamports,
        space: this.space,
        programId: this.programId
      }));
      const {
        stakePubkey,
        authorized: authorized2,
        lockup: lockup2
      } = params;
      return transaction.add(this.initialize({
        stakePubkey,
        authorized: authorized2,
        lockup: lockup2
      }));
    }
    /**
     * Generate a Transaction that creates a new Stake account
     */
    static createAccount(params) {
      const transaction = new Transaction();
      transaction.add(SystemProgram.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.stakePubkey,
        lamports: params.lamports,
        space: this.space,
        programId: this.programId
      }));
      const {
        stakePubkey,
        authorized: authorized2,
        lockup: lockup2
      } = params;
      return transaction.add(this.initialize({
        stakePubkey,
        authorized: authorized2,
        lockup: lockup2
      }));
    }
    /**
     * Generate a Transaction that delegates Stake tokens to a validator
     * Vote PublicKey. This transaction can also be used to redelegate Stake
     * to a new validator Vote PublicKey.
     */
    static delegate(params) {
      const {
        stakePubkey,
        authorizedPubkey,
        votePubkey
      } = params;
      const type2 = STAKE_INSTRUCTION_LAYOUTS.Delegate;
      const data = encodeData(type2);
      return new Transaction().add({
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: votePubkey,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: STAKE_CONFIG_ID,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data
      });
    }
    /**
     * Generate a Transaction that authorizes a new PublicKey as Staker
     * or Withdrawer on the Stake account.
     */
    static authorize(params) {
      const {
        stakePubkey,
        authorizedPubkey,
        newAuthorizedPubkey,
        stakeAuthorizationType,
        custodianPubkey
      } = params;
      const type2 = STAKE_INSTRUCTION_LAYOUTS.Authorize;
      const data = encodeData(type2, {
        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
        stakeAuthorizationType: stakeAuthorizationType.index
      });
      const keys = [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }];
      if (custodianPubkey) {
        keys.push({
          pubkey: custodianPubkey,
          isSigner: true,
          isWritable: false
        });
      }
      return new Transaction().add({
        keys,
        programId: this.programId,
        data
      });
    }
    /**
     * Generate a Transaction that authorizes a new PublicKey as Staker
     * or Withdrawer on the Stake account.
     */
    static authorizeWithSeed(params) {
      const {
        stakePubkey,
        authorityBase,
        authoritySeed,
        authorityOwner,
        newAuthorizedPubkey,
        stakeAuthorizationType,
        custodianPubkey
      } = params;
      const type2 = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
      const data = encodeData(type2, {
        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
        stakeAuthorizationType: stakeAuthorizationType.index,
        authoritySeed,
        authorityOwner: toBuffer(authorityOwner.toBuffer())
      });
      const keys = [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorityBase,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }];
      if (custodianPubkey) {
        keys.push({
          pubkey: custodianPubkey,
          isSigner: true,
          isWritable: false
        });
      }
      return new Transaction().add({
        keys,
        programId: this.programId,
        data
      });
    }
    /**
     * @internal
     */
    static splitInstruction(params) {
      const {
        stakePubkey,
        authorizedPubkey,
        splitStakePubkey,
        lamports
      } = params;
      const type2 = STAKE_INSTRUCTION_LAYOUTS.Split;
      const data = encodeData(type2, {
        lamports
      });
      return new TransactionInstruction({
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: splitStakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data
      });
    }
    /**
     * Generate a Transaction that splits Stake tokens into another stake account
     */
    static split(params, rentExemptReserve) {
      const transaction = new Transaction();
      transaction.add(SystemProgram.createAccount({
        fromPubkey: params.authorizedPubkey,
        newAccountPubkey: params.splitStakePubkey,
        lamports: rentExemptReserve,
        space: this.space,
        programId: this.programId
      }));
      return transaction.add(this.splitInstruction(params));
    }
    /**
     * Generate a Transaction that splits Stake tokens into another account
     * derived from a base public key and seed
     */
    static splitWithSeed(params, rentExemptReserve) {
      const {
        stakePubkey,
        authorizedPubkey,
        splitStakePubkey,
        basePubkey,
        seed,
        lamports
      } = params;
      const transaction = new Transaction();
      transaction.add(SystemProgram.allocate({
        accountPubkey: splitStakePubkey,
        basePubkey,
        seed,
        space: this.space,
        programId: this.programId
      }));
      if (rentExemptReserve && rentExemptReserve > 0) {
        transaction.add(SystemProgram.transfer({
          fromPubkey: params.authorizedPubkey,
          toPubkey: splitStakePubkey,
          lamports: rentExemptReserve
        }));
      }
      return transaction.add(this.splitInstruction({
        stakePubkey,
        authorizedPubkey,
        splitStakePubkey,
        lamports
      }));
    }
    /**
     * Generate a Transaction that merges Stake accounts.
     */
    static merge(params) {
      const {
        stakePubkey,
        sourceStakePubKey,
        authorizedPubkey
      } = params;
      const type2 = STAKE_INSTRUCTION_LAYOUTS.Merge;
      const data = encodeData(type2);
      return new Transaction().add({
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: sourceStakePubKey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data
      });
    }
    /**
     * Generate a Transaction that withdraws deactivated Stake tokens.
     */
    static withdraw(params) {
      const {
        stakePubkey,
        authorizedPubkey,
        toPubkey,
        lamports,
        custodianPubkey
      } = params;
      const type2 = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
      const data = encodeData(type2, {
        lamports
      });
      const keys = [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }];
      if (custodianPubkey) {
        keys.push({
          pubkey: custodianPubkey,
          isSigner: true,
          isWritable: false
        });
      }
      return new Transaction().add({
        keys,
        programId: this.programId,
        data
      });
    }
    /**
     * Generate a Transaction that deactivates Stake tokens.
     */
    static deactivate(params) {
      const {
        stakePubkey,
        authorizedPubkey
      } = params;
      const type2 = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
      const data = encodeData(type2);
      return new Transaction().add({
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data
      });
    }
  };
  StakeProgram.programId = new PublicKey("Stake11111111111111111111111111111111111111");
  StakeProgram.space = 200;
  var VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
    InitializeAccount: {
      index: 0,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), voteInit()])
    },
    Authorize: {
      index: 1,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("voteAuthorizationType")])
    },
    Withdraw: {
      index: 3,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
    },
    UpdateValidatorIdentity: {
      index: 4,
      layout: BufferLayout.struct([BufferLayout.u32("instruction")])
    },
    AuthorizeWithSeed: {
      index: 10,
      layout: BufferLayout.struct([BufferLayout.u32("instruction"), voteAuthorizeWithSeedArgs()])
    }
  });
  var VoteAuthorizationLayout = Object.freeze({
    Voter: {
      index: 0
    },
    Withdrawer: {
      index: 1
    }
  });
  var VoteProgram = class _VoteProgram {
    /**
     * @internal
     */
    constructor() {
    }
    /**
     * Public key that identifies the Vote program
     */
    /**
     * Generate an Initialize instruction.
     */
    static initializeAccount(params) {
      const {
        votePubkey,
        nodePubkey,
        voteInit: voteInit2
      } = params;
      const type2 = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;
      const data = encodeData(type2, {
        voteInit: {
          nodePubkey: toBuffer(voteInit2.nodePubkey.toBuffer()),
          authorizedVoter: toBuffer(voteInit2.authorizedVoter.toBuffer()),
          authorizedWithdrawer: toBuffer(voteInit2.authorizedWithdrawer.toBuffer()),
          commission: voteInit2.commission
        }
      });
      const instructionData = {
        keys: [{
          pubkey: votePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: nodePubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data
      };
      return new TransactionInstruction(instructionData);
    }
    /**
     * Generate a transaction that creates a new Vote account.
     */
    static createAccount(params) {
      const transaction = new Transaction();
      transaction.add(SystemProgram.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.votePubkey,
        lamports: params.lamports,
        space: this.space,
        programId: this.programId
      }));
      return transaction.add(this.initializeAccount({
        votePubkey: params.votePubkey,
        nodePubkey: params.voteInit.nodePubkey,
        voteInit: params.voteInit
      }));
    }
    /**
     * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.
     */
    static authorize(params) {
      const {
        votePubkey,
        authorizedPubkey,
        newAuthorizedPubkey,
        voteAuthorizationType
      } = params;
      const type2 = VOTE_INSTRUCTION_LAYOUTS.Authorize;
      const data = encodeData(type2, {
        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
        voteAuthorizationType: voteAuthorizationType.index
      });
      const keys = [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }];
      return new Transaction().add({
        keys,
        programId: this.programId,
        data
      });
    }
    /**
     * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account
     * where the current Voter or Withdrawer authority is a derived key.
     */
    static authorizeWithSeed(params) {
      const {
        currentAuthorityDerivedKeyBasePubkey,
        currentAuthorityDerivedKeyOwnerPubkey,
        currentAuthorityDerivedKeySeed,
        newAuthorizedPubkey,
        voteAuthorizationType,
        votePubkey
      } = params;
      const type2 = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
      const data = encodeData(type2, {
        voteAuthorizeWithSeedArgs: {
          currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
          currentAuthorityDerivedKeySeed,
          newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
          voteAuthorizationType: voteAuthorizationType.index
        }
      });
      const keys = [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: currentAuthorityDerivedKeyBasePubkey,
        isSigner: true,
        isWritable: false
      }];
      return new Transaction().add({
        keys,
        programId: this.programId,
        data
      });
    }
    /**
     * Generate a transaction to withdraw from a Vote account.
     */
    static withdraw(params) {
      const {
        votePubkey,
        authorizedWithdrawerPubkey,
        lamports,
        toPubkey
      } = params;
      const type2 = VOTE_INSTRUCTION_LAYOUTS.Withdraw;
      const data = encodeData(type2, {
        lamports
      });
      const keys = [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedWithdrawerPubkey,
        isSigner: true,
        isWritable: false
      }];
      return new Transaction().add({
        keys,
        programId: this.programId,
        data
      });
    }
    /**
     * Generate a transaction to withdraw safely from a Vote account.
     *
     * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`
     * checks that the withdraw amount will not exceed the specified balance while leaving enough left
     * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the
     * `withdraw` method directly.
     */
    static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
      if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
        throw new Error("Withdraw will leave vote account with insufficient funds.");
      }
      return _VoteProgram.withdraw(params);
    }
    /**
     * Generate a transaction to update the validator identity (node pubkey) of a Vote account.
     */
    static updateValidatorIdentity(params) {
      const {
        votePubkey,
        authorizedWithdrawerPubkey,
        nodePubkey
      } = params;
      const type2 = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;
      const data = encodeData(type2);
      const keys = [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: nodePubkey,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: authorizedWithdrawerPubkey,
        isSigner: true,
        isWritable: false
      }];
      return new Transaction().add({
        keys,
        programId: this.programId,
        data
      });
    }
  };
  VoteProgram.programId = new PublicKey("Vote111111111111111111111111111111111111111");
  VoteProgram.space = 3762;
  var VALIDATOR_INFO_KEY = new PublicKey("Va1idator1nfo111111111111111111111111111111");
  var InfoString = type({
    name: string(),
    website: optional(string()),
    details: optional(string()),
    iconUrl: optional(string()),
    keybaseUsername: optional(string())
  });
  var VOTE_PROGRAM_ID = new PublicKey("Vote111111111111111111111111111111111111111");
  var VoteAccountLayout = BufferLayout.struct([
    publicKey("nodePubkey"),
    publicKey("authorizedWithdrawer"),
    BufferLayout.u8("commission"),
    BufferLayout.nu64(),
    // votes.length
    BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("slot"), BufferLayout.u32("confirmationCount")]), BufferLayout.offset(BufferLayout.u32(), -8), "votes"),
    BufferLayout.u8("rootSlotValid"),
    BufferLayout.nu64("rootSlot"),
    BufferLayout.nu64(),
    // authorizedVoters.length
    BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("epoch"), publicKey("authorizedVoter")]), BufferLayout.offset(BufferLayout.u32(), -8), "authorizedVoters"),
    BufferLayout.struct([BufferLayout.seq(BufferLayout.struct([publicKey("authorizedPubkey"), BufferLayout.nu64("epochOfLastAuthorizedSwitch"), BufferLayout.nu64("targetEpoch")]), 32, "buf"), BufferLayout.nu64("idx"), BufferLayout.u8("isEmpty")], "priorVoters"),
    BufferLayout.nu64(),
    // epochCredits.length
    BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("epoch"), BufferLayout.nu64("credits"), BufferLayout.nu64("prevCredits")]), BufferLayout.offset(BufferLayout.u32(), -8), "epochCredits"),
    BufferLayout.struct([BufferLayout.nu64("slot"), BufferLayout.nu64("timestamp")], "lastTimestamp")
  ]);
  var LAMPORTS_PER_SOL = 1e9;

  // node_modules/bignumber.js/bignumber.mjs
  var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
  var mathceil = Math.ceil;
  var mathfloor = Math.floor;
  var bignumberError = "[BigNumber Error] ";
  var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
  var BASE = 1e14;
  var LOG_BASE = 14;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
  var SQRT_BASE = 1e7;
  var MAX = 1e9;
  function clone(configObject) {
    var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
      prefix: "",
      groupSize: 3,
      secondaryGroupSize: 0,
      groupSeparator: ",",
      decimalSeparator: ".",
      fractionGroupSize: 0,
      fractionGroupSeparator: "\xA0",
      // non-breaking space
      suffix: ""
    }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
    function BigNumber2(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
      if (!(x instanceof BigNumber2)) return new BigNumber2(v, b);
      if (b == null) {
        if (v && v._isBigNumber === true) {
          x.s = v.s;
          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }
          return;
        }
        if ((isNum = typeof v == "number") && v * 0 == 0) {
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++) ;
            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }
            return;
          }
          str = String(v);
        } else {
          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }
        if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
        if ((i = str.search(/e/i)) > 0) {
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {
          e = str.length;
        }
      } else {
        intCheck(b, 2, ALPHABET.length, "Base");
        if (b == 10 && alphabetHasNormalDecimalDigits) {
          x = new BigNumber2(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }
        str = String(v);
        if (isNum = typeof v == "number") {
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
          if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
            throw Error(tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }
        alphabet = ALPHABET.slice(0, b);
        e = i = 0;
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == ".") {
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {
              if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }
            return parseNumeric(x, String(v), isNum, b);
          }
        }
        isNum = false;
        str = convertBase(str, b, 10, x.s);
        if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
        else e = str.length;
      }
      for (i = 0; str.charCodeAt(i) === 48; i++) ;
      for (len = str.length; str.charCodeAt(--len) === 48; ) ;
      if (str = str.slice(i, ++len)) {
        len -= i;
        if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
          throw Error(tooManyDigits + x.s * v);
        }
        if ((e = e - i - 1) > MAX_EXP) {
          x.c = x.e = null;
        } else if (e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;
          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));
            for (len -= LOG_BASE; i < len; ) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }
            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }
          for (; i--; str += "0") ;
          x.c.push(+str);
        }
      } else {
        x.c = [x.e = 0];
      }
    }
    BigNumber2.clone = clone;
    BigNumber2.ROUND_UP = 0;
    BigNumber2.ROUND_DOWN = 1;
    BigNumber2.ROUND_CEIL = 2;
    BigNumber2.ROUND_FLOOR = 3;
    BigNumber2.ROUND_HALF_UP = 4;
    BigNumber2.ROUND_HALF_DOWN = 5;
    BigNumber2.ROUND_HALF_EVEN = 6;
    BigNumber2.ROUND_HALF_CEIL = 7;
    BigNumber2.ROUND_HALF_FLOOR = 8;
    BigNumber2.EUCLID = 9;
    BigNumber2.config = BigNumber2.set = function(obj) {
      var p, v;
      if (obj != null) {
        if (typeof obj == "object") {
          if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }
          if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }
          if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }
          if (obj.hasOwnProperty(p = "RANGE")) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error(bignumberError + p + " cannot be zero: " + v);
              }
            }
          }
          if (obj.hasOwnProperty(p = "CRYPTO")) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error(bignumberError + "crypto unavailable");
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error(bignumberError + p + " not true or false: " + v);
            }
          }
          if (obj.hasOwnProperty(p = "MODULO_MODE")) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }
          if (obj.hasOwnProperty(p = "POW_PRECISION")) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }
          if (obj.hasOwnProperty(p = "FORMAT")) {
            v = obj[p];
            if (typeof v == "object") FORMAT = v;
            else throw Error(bignumberError + p + " not an object: " + v);
          }
          if (obj.hasOwnProperty(p = "ALPHABET")) {
            v = obj[p];
            if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
              ALPHABET = v;
            } else {
              throw Error(bignumberError + p + " invalid: " + v);
            }
          }
        } else {
          throw Error(bignumberError + "Object expected: " + obj);
        }
      }
      return {
        DECIMAL_PLACES,
        ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO,
        MODULO_MODE,
        POW_PRECISION,
        FORMAT,
        ALPHABET
      };
    };
    BigNumber2.isBigNumber = function(v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber2.DEBUG) return true;
      var i, n, c = v.c, e = v.e, s = v.s;
      out: if ({}.toString.call(c) == "[object Array]") {
        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;
          if (String(c[0]).length == i) {
            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }
            if (n !== 0) return true;
          }
        }
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }
      throw Error(bignumberError + "Invalid BigNumber: " + v);
    };
    BigNumber2.maximum = BigNumber2.max = function() {
      return maxOrMin(arguments, -1);
    };
    BigNumber2.minimum = BigNumber2.min = function() {
      return maxOrMin(arguments, 1);
    };
    BigNumber2.random = function() {
      var pow2_53 = 9007199254740992;
      var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
        return mathfloor(Math.random() * pow2_53);
      } : function() {
        return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
      };
      return function(dp) {
        var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);
        k = mathceil(dp / LOG_BASE);
        if (CRYPTO) {
          if (crypto.getRandomValues) {
            a = crypto.getRandomValues(new Uint32Array(k *= 2));
            for (; i < k; ) {
              v = a[i] * 131072 + (a[i + 1] >>> 11);
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;
          } else if (crypto.randomBytes) {
            a = crypto.randomBytes(k *= 7);
            for (; i < k; ) {
              v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error(bignumberError + "crypto unavailable");
          }
        }
        if (!CRYPTO) {
          for (; i < k; ) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }
        k = c[--i];
        dp %= LOG_BASE;
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }
        for (; c[i] === 0; c.pop(), i--) ;
        if (i < 0) {
          c = [e = 0];
        } else {
          for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) ;
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++) ;
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }
        rand.e = e;
        rand.c = c;
        return rand;
      };
    }();
    BigNumber2.sum = function() {
      var i = 1, args = arguments, sum = new BigNumber2(args[0]);
      for (; i < args.length; ) sum = sum.plus(args[i++]);
      return sum;
    };
    convertBase = /* @__PURE__ */ function() {
      var decimal = "0123456789";
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j, arr = [0], arrL, i = 0, len = str.length;
        for (; i < len; ) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
          arr[0] += alphabet.indexOf(str.charAt(i++));
          for (j = 0; j < arr.length; j++) {
            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }
        return arr.reverse();
      }
      return function(str, baseIn, baseOut, sign2, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
        if (i >= 0) {
          k = POW_PRECISION;
          POW_PRECISION = 0;
          str = str.replace(".", "");
          y = new BigNumber2(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;
          y.c = toBaseOut(
            toFixedPoint(coeffToString(x.c), x.e, "0"),
            10,
            baseOut,
            decimal
          );
          y.e = y.c.length;
        }
        xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
        e = k = xc.length;
        for (; xc[--k] == 0; xc.pop()) ;
        if (!xc[0]) return alphabet.charAt(0);
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;
          x.s = sign2;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }
        d = e + dp + 1;
        i = xc[d];
        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;
        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
        if (d < 1 || !xc[0]) {
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {
          xc.length = d;
          if (r) {
            for (--baseOut; ++xc[--d] > baseOut; ) {
              xc[d] = 0;
              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }
          for (k = xc.length; !xc[--k]; ) ;
          for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++])) ;
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }
        return str;
      };
    }();
    div = /* @__PURE__ */ function() {
      function multiply(x, k, base) {
        var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
        for (x = x.slice(); i--; ) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }
        if (carry) x = [carry].concat(x);
        return x;
      }
      function compare2(a, b, aL, bL) {
        var i, cmp;
        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {
          for (i = cmp = 0; i < aL; i++) {
            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }
        return cmp;
      }
      function subtract(a, b, aL, base) {
        var i = 0;
        for (; aL--; ) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }
        for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
      }
      return function(x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
        if (!xc || !xc[0] || !yc || !yc[0]) {
          return new BigNumber2(
            // Return NaN if either NaN, or both Infinity or 0.
            !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
              // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
              xc && xc[0] == 0 || !yc ? s * 0 : s / 0
            )
          );
        }
        q = new BigNumber2(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;
        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }
        for (i = 0; yc[i] == (xc[i] || 0); i++) ;
        if (yc[i] > (xc[i] || 0)) e--;
        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;
          n = mathfloor(base / (yc[0] + 1));
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }
          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;
          for (; remL < yL; rem[remL++] = 0) ;
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          do {
            n = 0;
            cmp = compare2(yc, rem, yL, remL);
            if (cmp < 0) {
              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
              n = mathfloor(rem0 / yc0);
              if (n > 1) {
                if (n >= base) n = base - 1;
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;
                while (compare2(prod, rem, prodL, remL) == 1) {
                  n--;
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {
                if (n == 0) {
                  cmp = n = 1;
                }
                prod = yc.slice();
                prodL = prod.length;
              }
              if (prodL < remL) prod = [0].concat(prod);
              subtract(rem, prod, remL, base);
              remL = rem.length;
              if (cmp == -1) {
                while (compare2(yc, rem, yL, remL) < 1) {
                  n++;
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            }
            qc[i++] = n;
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);
          more = rem[0] != null;
          if (!qc[0]) qc.splice(0, 1);
        }
        if (base == BASE) {
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) ;
          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
        } else {
          q.e = e;
          q.r = +more;
        }
        return q;
      };
    }();
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      if (!n.c) return n.toString();
      c0 = n.c[0];
      ne = n.e;
      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
      } else {
        n = round(new BigNumber2(n), i, rm);
        e = n.e;
        str = coeffToString(n.c);
        len = str.length;
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
          for (; len < i; str += "0", len++) ;
          str = toExponential(str, e);
        } else {
          i -= ne + (id === 2 && e > ne);
          str = toFixedPoint(str, e, "0");
          if (e + 1 > len) {
            if (--i > 0) for (str += "."; i--; str += "0") ;
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += ".";
              for (; i--; str += "0") ;
            }
          }
        }
      }
      return n.s < 0 && c0 ? "-" + str : str;
    }
    function maxOrMin(args, n) {
      var k, y, i = 1, x = new BigNumber2(args[0]);
      for (; i < args.length; i++) {
        y = new BigNumber2(args[i]);
        if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
          x = y;
        }
      }
      return x;
    }
    function normalise(n, c, e) {
      var i = 1, j = c.length;
      for (; !c[--j]; c.pop()) ;
      for (j = c[0]; j >= 10; j /= 10, i++) ;
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
        n.c = n.e = null;
      } else if (e < MIN_EXP) {
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }
      return n;
    }
    parseNumeric = /* @__PURE__ */ function() {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
      return function(x, str, isNum, b) {
        var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {
            s = s.replace(basePrefix, function(m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
              return !b || b == base ? p1 : m;
            });
            if (b) {
              base = b;
              s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
            }
            if (str != s) return new BigNumber2(s, base);
          }
          if (BigNumber2.DEBUG) {
            throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
          }
          x.s = null;
        }
        x.c = x.e = null;
      };
    }();
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
      if (xc) {
        out: {
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
          i = sd - d;
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];
            rd = mathfloor(n / pows10[d - j - 1] % 10);
          } else {
            ni = mathceil((i + 1) / LOG_BASE);
            if (ni >= xc.length) {
              if (r) {
                for (; xc.length <= ni; xc.push(0)) ;
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];
              for (d = 1; k >= 10; k /= 10, d++) ;
              i %= LOG_BASE;
              j = i - LOG_BASE + d;
              rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
            }
          }
          r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
          xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
          r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
          (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
          if (sd < 1 || !xc[0]) {
            xc.length = 0;
            if (r) {
              sd -= x.e + 1;
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {
              xc[0] = x.e = 0;
            }
            return x;
          }
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }
          if (r) {
            for (; ; ) {
              if (ni == 0) {
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) ;
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++) ;
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }
                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }
          for (i = xc.length; xc[--i] === 0; xc.pop()) ;
        }
        if (x.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }
      return x;
    }
    function valueOf(n) {
      var str, e = n.e;
      if (e === null) return n.toString();
      str = coeffToString(n.c);
      str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
      return n.s < 0 ? "-" + str : str;
    }
    P.absoluteValue = P.abs = function() {
      var x = new BigNumber2(this);
      if (x.s < 0) x.s = 1;
      return x;
    };
    P.comparedTo = function(y, b) {
      return compare(this, new BigNumber2(y, b));
    };
    P.decimalPlaces = P.dp = function(dp, rm) {
      var c, n, v, x = this;
      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);
        return round(new BigNumber2(x), dp + x.e + 1, rm);
      }
      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) ;
      if (n < 0) n = 0;
      return n;
    };
    P.dividedBy = P.div = function(y, b) {
      return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };
    P.dividedToIntegerBy = P.idiv = function(y, b) {
      return div(this, new BigNumber2(y, b), 0, 1);
    };
    P.exponentiatedBy = P.pow = function(n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
      n = new BigNumber2(n);
      if (n.c && !n.isInteger()) {
        throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
      }
      if (m != null) m = new BigNumber2(m);
      nIsBig = n.e > 14;
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
        y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }
      nIsNeg = n.s < 0;
      if (m) {
        if (m.c ? !m.c[0] : !m.s) return new BigNumber2(NaN);
        isModExp = !nIsNeg && x.isInteger() && m.isInteger();
        if (isModExp) x = x.mod(m);
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
        k = x.s < 0 && isOdd(n) ? -0 : 0;
        if (x.e > -1) k = 1 / k;
        return new BigNumber2(nIsNeg ? 1 / k : k);
      } else if (POW_PRECISION) {
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }
      if (nIsBig) {
        half = new BigNumber2(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }
      y = new BigNumber2(ONE);
      for (; ; ) {
        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;
          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);
          }
        }
        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);
          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }
        x = x.times(x);
        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);
        }
      }
      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);
      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };
    P.integerValue = function(rm) {
      var n = new BigNumber2(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };
    P.isEqualTo = P.eq = function(y, b) {
      return compare(this, new BigNumber2(y, b)) === 0;
    };
    P.isFinite = function() {
      return !!this.c;
    };
    P.isGreaterThan = P.gt = function(y, b) {
      return compare(this, new BigNumber2(y, b)) > 0;
    };
    P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
      return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
    };
    P.isInteger = function() {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };
    P.isLessThan = P.lt = function(y, b) {
      return compare(this, new BigNumber2(y, b)) < 0;
    };
    P.isLessThanOrEqualTo = P.lte = function(y, b) {
      return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
    };
    P.isNaN = function() {
      return !this.s;
    };
    P.isNegative = function() {
      return this.s < 0;
    };
    P.isPositive = function() {
      return this.s > 0;
    };
    P.isZero = function() {
      return !!this.c && this.c[0] == 0;
    };
    P.minus = function(y, b) {
      var i, j, t, xLTy, x = this, a = x.s;
      y = new BigNumber2(y, b);
      b = y.s;
      if (!a || !b) return new BigNumber2(NaN);
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }
      var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
      if (!xe || !ye) {
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
        if (!xc[0] || !yc[0]) {
          return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
            // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
            ROUNDING_MODE == 3 ? -0 : 0
          ));
        }
      }
      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();
      if (a = xe - ye) {
        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }
        t.reverse();
        for (b = a; b--; t.push(0)) ;
        t.reverse();
      } else {
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
        for (a = b = 0; b < j; b++) {
          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }
      if (xLTy) {
        t = xc;
        xc = yc;
        yc = t;
        y.s = -y.s;
      }
      b = (j = yc.length) - (i = xc.length);
      if (b > 0) for (; b--; xc[i++] = 0) ;
      b = BASE - 1;
      for (; j > a; ) {
        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b) ;
          --xc[i];
          xc[j] += BASE;
        }
        xc[j] -= yc[j];
      }
      for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
      if (!xc[0]) {
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }
      return normalise(y, xc, ye);
    };
    P.modulo = P.mod = function(y, b) {
      var q, s, x = this;
      y = new BigNumber2(y, b);
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber2(NaN);
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber2(x);
      }
      if (MODULO_MODE == 9) {
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }
      y = x.minus(q.times(y));
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
      return y;
    };
    P.multipliedBy = P.times = function(y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
      if (!xc || !yc || !xc[0] || !yc[0]) {
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;
          if (!xc || !yc) {
            y.c = y.e = null;
          } else {
            y.c = [0];
            y.e = 0;
          }
        }
        return y;
      }
      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;
      if (xcL < ycL) {
        zc = xc;
        xc = yc;
        yc = zc;
        i = xcL;
        xcL = ycL;
        ycL = i;
      }
      for (i = xcL + ycL, zc = []; i--; zc.push(0)) ;
      base = BASE;
      sqrtBase = SQRT_BASE;
      for (i = ycL; --i >= 0; ) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;
        for (k = xcL, j = i + k; j > i; ) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }
        zc[j] = c;
      }
      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }
      return normalise(y, zc, e);
    };
    P.negated = function() {
      var x = new BigNumber2(this);
      x.s = -x.s || null;
      return x;
    };
    P.plus = function(y, b) {
      var t, x = this, a = x.s;
      y = new BigNumber2(y, b);
      b = y.s;
      if (!a || !b) return new BigNumber2(NaN);
      if (a != b) {
        y.s = -b;
        return x.minus(y);
      }
      var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
      if (!xe || !ye) {
        if (!xc || !yc) return new BigNumber2(a / 0);
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
      }
      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }
        t.reverse();
        for (; a--; t.push(0)) ;
        t.reverse();
      }
      a = xc.length;
      b = yc.length;
      if (a - b < 0) {
        t = yc;
        yc = xc;
        xc = t;
        b = a;
      }
      for (a = 0; b; ) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }
      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }
      return normalise(y, xc, ye);
    };
    P.precision = P.sd = function(sd, rm) {
      var c, n, v, x = this;
      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);
        return round(new BigNumber2(x), sd, rm);
      }
      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;
      if (v = c[v]) {
        for (; v % 10 == 0; v /= 10, n--) ;
        for (v = c[0]; v >= 10; v /= 10, n++) ;
      }
      if (sd && x.e + 1 > n) n = x.e + 1;
      return n;
    };
    P.shiftedBy = function(k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times("1e" + k);
    };
    P.squareRoot = P.sqrt = function() {
      var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }
      s = Math.sqrt(+valueOf(x));
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += "0";
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
        if (s == 1 / 0) {
          n = "5e" + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf("e") + 1) + e;
        }
        r = new BigNumber2(n);
      } else {
        r = new BigNumber2(s + "");
      }
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;
        for (; ; ) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));
          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);
            if (n == "9999" || !rep && n == "4999") {
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);
                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              dp += 4;
              s += 4;
              rep = 1;
            } else {
              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }
              break;
            }
          }
        }
      }
      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };
    P.toExponential = function(dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };
    P.toFixed = function(dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };
    P.toFormat = function(dp, rm, format2) {
      var str, x = this;
      if (format2 == null) {
        if (dp != null && rm && typeof rm == "object") {
          format2 = rm;
          rm = null;
        } else if (dp && typeof dp == "object") {
          format2 = dp;
          dp = rm = null;
        } else {
          format2 = FORMAT;
        }
      } else if (typeof format2 != "object") {
        throw Error(bignumberError + "Argument not an object: " + format2);
      }
      str = x.toFixed(dp, rm);
      if (x.c) {
        var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
        if (g2) {
          i = g1;
          g1 = g2;
          g2 = i;
          len -= i;
        }
        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = "-" + intPart;
        }
        str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
          new RegExp("\\d{" + g2 + "}\\B", "g"),
          "$&" + (format2.fractionGroupSeparator || "")
        ) : fractionPart) : intPart;
      }
      return (format2.prefix || "") + str + (format2.suffix || "");
    };
    P.toFraction = function(md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
      if (md != null) {
        n = new BigNumber2(md);
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
        }
      }
      if (!xc) return new BigNumber2(x);
      d = new BigNumber2(ONE);
      n1 = d0 = new BigNumber2(ONE);
      d1 = n0 = new BigNumber2(ONE);
      s = coeffToString(xc);
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber2(s);
      n0.c[0] = 0;
      for (; ; ) {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }
      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
        div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
      ) < 1 ? [n1, d1] : [n0, d0];
      MAX_EXP = exp;
      return r;
    };
    P.toNumber = function() {
      return +valueOf(this);
    };
    P.toPrecision = function(sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };
    P.toString = function(b) {
      var str, n = this, s = n.s, e = n.e;
      if (e === null) {
        if (s) {
          str = "Infinity";
          if (s < 0) str = "-" + str;
        } else {
          str = "NaN";
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
        } else if (b === 10 && alphabetHasNormalDecimalDigits) {
          n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, "0");
        } else {
          intCheck(b, 2, ALPHABET.length, "Base");
          str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
        }
        if (s < 0 && n.c[0]) str = "-" + str;
      }
      return str;
    };
    P.valueOf = P.toJSON = function() {
      return valueOf(this);
    };
    P._isBigNumber = true;
    P[Symbol.toStringTag] = "BigNumber";
    P[Symbol.for("nodejs.util.inspect.custom")] = P.valueOf;
    if (configObject != null) BigNumber2.set(configObject);
    return BigNumber2;
  }
  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }
  function coeffToString(a) {
    var s, z, i = 1, j = a.length, r = a[0] + "";
    for (; i < j; ) {
      s = a[i++] + "";
      z = LOG_BASE - s.length;
      for (; z--; s = "0" + s) ;
      r += s;
    }
    for (j = r.length; r.charCodeAt(--j) === 48; ) ;
    return r.slice(0, j + 1 || 1);
  }
  function compare(x, y) {
    var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
    if (!i || !j) return null;
    a = xc && !xc[0];
    b = yc && !yc[0];
    if (a || b) return a ? b ? 0 : -j : i;
    if (i != j) return i;
    a = i < 0;
    b = k == l;
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
    if (!b) return k > l ^ a ? 1 : -1;
    j = (k = xc.length) < (l = yc.length) ? k : l;
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
    }
  }
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }
  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
  }
  function toFixedPoint(str, e, z) {
    var len, zs;
    if (e < 0) {
      for (zs = z + "."; ++e; zs += z) ;
      str = zs + str;
    } else {
      len = str.length;
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z) ;
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + "." + str.slice(e);
      }
    }
    return str;
  }
  var BigNumber = clone();
  var bignumber_default = BigNumber;

  // node_modules/@solana/pay/lib/esm/constants.js
  var SOLANA_PROTOCOL = "solana:";
  var HTTPS_PROTOCOL = "https:";
  var MEMO_PROGRAM_ID = new PublicKey("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr");
  var SOL_DECIMALS = 9;
  var TEN = new bignumber_default(10);

  // node_modules/@solana/spl-token/lib/esm/constants.js
  var TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
  var TOKEN_2022_PROGRAM_ID = new PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
  var ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
  var NATIVE_MINT = new PublicKey("So11111111111111111111111111111111111111112");
  var NATIVE_MINT_2022 = new PublicKey("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");

  // node_modules/@solana/buffer-layout-utils/lib/esm/base.mjs
  var encodeDecode = (layout) => {
    const decode = layout.decode.bind(layout);
    const encode = layout.encode.bind(layout);
    return { decode, encode };
  };

  // node_modules/@solana/buffer-layout-utils/lib/esm/bigint.mjs
  var import_buffer_layout2 = __toESM(require_Layout(), 1);
  var import_bigint_buffer = __toESM(require_browser2(), 1);
  var bigInt = (length) => (property) => {
    const layout = (0, import_buffer_layout2.blob)(length, property);
    const { encode, decode } = encodeDecode(layout);
    const bigIntLayout = layout;
    bigIntLayout.decode = (buffer, offset2) => {
      const src = decode(buffer, offset2);
      return (0, import_bigint_buffer.toBigIntLE)(Buffer.from(src));
    };
    bigIntLayout.encode = (bigInt2, buffer, offset2) => {
      const src = (0, import_bigint_buffer.toBufferLE)(bigInt2, length);
      return encode(src, buffer, offset2);
    };
    return bigIntLayout;
  };
  var bigIntBE = (length) => (property) => {
    const layout = (0, import_buffer_layout2.blob)(length, property);
    const { encode, decode } = encodeDecode(layout);
    const bigIntLayout = layout;
    bigIntLayout.decode = (buffer, offset2) => {
      const src = decode(buffer, offset2);
      return (0, import_bigint_buffer.toBigIntBE)(Buffer.from(src));
    };
    bigIntLayout.encode = (bigInt2, buffer, offset2) => {
      const src = (0, import_bigint_buffer.toBufferBE)(bigInt2, length);
      return encode(src, buffer, offset2);
    };
    return bigIntLayout;
  };
  var u642 = bigInt(8);
  var u64be = bigIntBE(8);
  var u128 = bigInt(16);
  var u128be = bigIntBE(16);
  var u192 = bigInt(24);
  var u192be = bigIntBE(24);
  var u256 = bigInt(32);
  var u256be = bigIntBE(32);

  // node_modules/@solana/buffer-layout-utils/lib/esm/decimal.mjs
  var WAD = new bignumber_default("1e+18");

  // node_modules/@solana/buffer-layout-utils/lib/esm/native.mjs
  var import_buffer_layout3 = __toESM(require_Layout(), 1);
  var bool = (property) => {
    const layout = (0, import_buffer_layout3.u8)(property);
    const { encode, decode } = encodeDecode(layout);
    const boolLayout = layout;
    boolLayout.decode = (buffer, offset2) => {
      const src = decode(buffer, offset2);
      return !!src;
    };
    boolLayout.encode = (bool2, buffer, offset2) => {
      const src = Number(bool2);
      return encode(src, buffer, offset2);
    };
    return boolLayout;
  };

  // node_modules/@solana/buffer-layout-utils/lib/esm/web3.mjs
  var import_buffer_layout4 = __toESM(require_Layout(), 1);
  var publicKey2 = (property) => {
    const layout = (0, import_buffer_layout4.blob)(32, property);
    const { encode, decode } = encodeDecode(layout);
    const publicKeyLayout = layout;
    publicKeyLayout.decode = (buffer, offset2) => {
      const src = decode(buffer, offset2);
      return new PublicKey(src);
    };
    publicKeyLayout.encode = (publicKey3, buffer, offset2) => {
      const src = publicKey3.toBuffer();
      return encode(src, buffer, offset2);
    };
    return publicKeyLayout;
  };

  // node_modules/@solana/spl-token/lib/esm/errors.js
  var TokenError = class extends Error {
    constructor(message) {
      super(message);
    }
  };
  var TokenAccountNotFoundError = class extends TokenError {
    constructor() {
      super(...arguments);
      this.name = "TokenAccountNotFoundError";
    }
  };
  var TokenInvalidAccountError = class extends TokenError {
    constructor() {
      super(...arguments);
      this.name = "TokenInvalidAccountError";
    }
  };
  var TokenInvalidAccountOwnerError = class extends TokenError {
    constructor() {
      super(...arguments);
      this.name = "TokenInvalidAccountOwnerError";
    }
  };
  var TokenInvalidAccountSizeError = class extends TokenError {
    constructor() {
      super(...arguments);
      this.name = "TokenInvalidAccountSizeError";
    }
  };
  var TokenInvalidMintError = class extends TokenError {
    constructor() {
      super(...arguments);
      this.name = "TokenInvalidMintError";
    }
  };
  var TokenOwnerOffCurveError = class extends TokenError {
    constructor() {
      super(...arguments);
      this.name = "TokenOwnerOffCurveError";
    }
  };

  // node_modules/@solana/spl-token/lib/esm/instructions/types.js
  var TokenInstruction;
  (function(TokenInstruction2) {
    TokenInstruction2[TokenInstruction2["InitializeMint"] = 0] = "InitializeMint";
    TokenInstruction2[TokenInstruction2["InitializeAccount"] = 1] = "InitializeAccount";
    TokenInstruction2[TokenInstruction2["InitializeMultisig"] = 2] = "InitializeMultisig";
    TokenInstruction2[TokenInstruction2["Transfer"] = 3] = "Transfer";
    TokenInstruction2[TokenInstruction2["Approve"] = 4] = "Approve";
    TokenInstruction2[TokenInstruction2["Revoke"] = 5] = "Revoke";
    TokenInstruction2[TokenInstruction2["SetAuthority"] = 6] = "SetAuthority";
    TokenInstruction2[TokenInstruction2["MintTo"] = 7] = "MintTo";
    TokenInstruction2[TokenInstruction2["Burn"] = 8] = "Burn";
    TokenInstruction2[TokenInstruction2["CloseAccount"] = 9] = "CloseAccount";
    TokenInstruction2[TokenInstruction2["FreezeAccount"] = 10] = "FreezeAccount";
    TokenInstruction2[TokenInstruction2["ThawAccount"] = 11] = "ThawAccount";
    TokenInstruction2[TokenInstruction2["TransferChecked"] = 12] = "TransferChecked";
    TokenInstruction2[TokenInstruction2["ApproveChecked"] = 13] = "ApproveChecked";
    TokenInstruction2[TokenInstruction2["MintToChecked"] = 14] = "MintToChecked";
    TokenInstruction2[TokenInstruction2["BurnChecked"] = 15] = "BurnChecked";
    TokenInstruction2[TokenInstruction2["InitializeAccount2"] = 16] = "InitializeAccount2";
    TokenInstruction2[TokenInstruction2["SyncNative"] = 17] = "SyncNative";
    TokenInstruction2[TokenInstruction2["InitializeAccount3"] = 18] = "InitializeAccount3";
    TokenInstruction2[TokenInstruction2["InitializeMultisig2"] = 19] = "InitializeMultisig2";
    TokenInstruction2[TokenInstruction2["InitializeMint2"] = 20] = "InitializeMint2";
    TokenInstruction2[TokenInstruction2["GetAccountDataSize"] = 21] = "GetAccountDataSize";
    TokenInstruction2[TokenInstruction2["InitializeImmutableOwner"] = 22] = "InitializeImmutableOwner";
    TokenInstruction2[TokenInstruction2["AmountToUiAmount"] = 23] = "AmountToUiAmount";
    TokenInstruction2[TokenInstruction2["UiAmountToAmount"] = 24] = "UiAmountToAmount";
    TokenInstruction2[TokenInstruction2["InitializeMintCloseAuthority"] = 25] = "InitializeMintCloseAuthority";
    TokenInstruction2[TokenInstruction2["TransferFeeExtension"] = 26] = "TransferFeeExtension";
    TokenInstruction2[TokenInstruction2["ConfidentialTransferExtension"] = 27] = "ConfidentialTransferExtension";
    TokenInstruction2[TokenInstruction2["DefaultAccountStateExtension"] = 28] = "DefaultAccountStateExtension";
    TokenInstruction2[TokenInstruction2["Reallocate"] = 29] = "Reallocate";
    TokenInstruction2[TokenInstruction2["MemoTransferExtension"] = 30] = "MemoTransferExtension";
    TokenInstruction2[TokenInstruction2["CreateNativeMint"] = 31] = "CreateNativeMint";
    TokenInstruction2[TokenInstruction2["InitializeNonTransferableMint"] = 32] = "InitializeNonTransferableMint";
    TokenInstruction2[TokenInstruction2["InterestBearingMintExtension"] = 33] = "InterestBearingMintExtension";
    TokenInstruction2[TokenInstruction2["CpiGuardExtension"] = 34] = "CpiGuardExtension";
    TokenInstruction2[TokenInstruction2["InitializePermanentDelegate"] = 35] = "InitializePermanentDelegate";
    TokenInstruction2[TokenInstruction2["TransferHookExtension"] = 36] = "TransferHookExtension";
    TokenInstruction2[TokenInstruction2["MetadataPointerExtension"] = 39] = "MetadataPointerExtension";
    TokenInstruction2[TokenInstruction2["GroupPointerExtension"] = 40] = "GroupPointerExtension";
    TokenInstruction2[TokenInstruction2["GroupMemberPointerExtension"] = 41] = "GroupMemberPointerExtension";
    TokenInstruction2[TokenInstruction2["ScaledUiAmountExtension"] = 43] = "ScaledUiAmountExtension";
    TokenInstruction2[TokenInstruction2["PausableExtension"] = 44] = "PausableExtension";
  })(TokenInstruction || (TokenInstruction = {}));

  // node_modules/@solana/spl-token/lib/esm/state/mint.js
  var import_buffer_layout8 = __toESM(require_Layout(), 1);

  // node_modules/@solana/spl-token/lib/esm/extensions/accountType.js
  var AccountType;
  (function(AccountType2) {
    AccountType2[AccountType2["Uninitialized"] = 0] = "Uninitialized";
    AccountType2[AccountType2["Mint"] = 1] = "Mint";
    AccountType2[AccountType2["Account"] = 2] = "Account";
  })(AccountType || (AccountType = {}));
  var ACCOUNT_TYPE_SIZE = 1;

  // node_modules/@solana/spl-token/lib/esm/state/account.js
  var import_buffer_layout6 = __toESM(require_Layout(), 1);

  // node_modules/@solana/spl-token/lib/esm/state/multisig.js
  var import_buffer_layout5 = __toESM(require_Layout(), 1);
  var MultisigLayout = (0, import_buffer_layout5.struct)([
    (0, import_buffer_layout5.u8)("m"),
    (0, import_buffer_layout5.u8)("n"),
    bool("isInitialized"),
    publicKey2("signer1"),
    publicKey2("signer2"),
    publicKey2("signer3"),
    publicKey2("signer4"),
    publicKey2("signer5"),
    publicKey2("signer6"),
    publicKey2("signer7"),
    publicKey2("signer8"),
    publicKey2("signer9"),
    publicKey2("signer10"),
    publicKey2("signer11")
  ]);
  var MULTISIG_SIZE = MultisigLayout.span;

  // node_modules/@solana/spl-token/lib/esm/state/account.js
  var AccountState;
  (function(AccountState2) {
    AccountState2[AccountState2["Uninitialized"] = 0] = "Uninitialized";
    AccountState2[AccountState2["Initialized"] = 1] = "Initialized";
    AccountState2[AccountState2["Frozen"] = 2] = "Frozen";
  })(AccountState || (AccountState = {}));
  var AccountLayout = (0, import_buffer_layout6.struct)([
    publicKey2("mint"),
    publicKey2("owner"),
    u642("amount"),
    (0, import_buffer_layout6.u32)("delegateOption"),
    publicKey2("delegate"),
    (0, import_buffer_layout6.u8)("state"),
    (0, import_buffer_layout6.u32)("isNativeOption"),
    u642("isNative"),
    u642("delegatedAmount"),
    (0, import_buffer_layout6.u32)("closeAuthorityOption"),
    publicKey2("closeAuthority")
  ]);
  var ACCOUNT_SIZE = AccountLayout.span;
  async function getAccount(connection, address, commitment, programId = TOKEN_PROGRAM_ID) {
    const info = await connection.getAccountInfo(address, commitment);
    return unpackAccount(address, info, programId);
  }
  function unpackAccount(address, info, programId = TOKEN_PROGRAM_ID) {
    if (!info)
      throw new TokenAccountNotFoundError();
    if (!info.owner.equals(programId))
      throw new TokenInvalidAccountOwnerError();
    if (info.data.length < ACCOUNT_SIZE)
      throw new TokenInvalidAccountSizeError();
    const rawAccount = AccountLayout.decode(info.data.slice(0, ACCOUNT_SIZE));
    let tlvData = Buffer.alloc(0);
    if (info.data.length > ACCOUNT_SIZE) {
      if (info.data.length === MULTISIG_SIZE)
        throw new TokenInvalidAccountSizeError();
      if (info.data[ACCOUNT_SIZE] != AccountType.Account)
        throw new TokenInvalidAccountError();
      tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);
    }
    return {
      address,
      mint: rawAccount.mint,
      owner: rawAccount.owner,
      amount: rawAccount.amount,
      delegate: rawAccount.delegateOption ? rawAccount.delegate : null,
      delegatedAmount: rawAccount.delegatedAmount,
      isInitialized: rawAccount.state !== AccountState.Uninitialized,
      isFrozen: rawAccount.state === AccountState.Frozen,
      isNative: !!rawAccount.isNativeOption,
      rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,
      closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null,
      tlvData
    };
  }

  // node_modules/@solana/spl-token/lib/esm/instructions/internal.js
  function addSigners(keys, ownerOrAuthority, multiSigners) {
    if (multiSigners.length) {
      keys.push({ pubkey: ownerOrAuthority, isSigner: false, isWritable: false });
      for (const signer of multiSigners) {
        keys.push({
          pubkey: signer instanceof PublicKey ? signer : signer.publicKey,
          isSigner: true,
          isWritable: false
        });
      }
    } else {
      keys.push({ pubkey: ownerOrAuthority, isSigner: true, isWritable: false });
    }
    return keys;
  }

  // node_modules/@solana/spl-token/lib/esm/instructions/transferChecked.js
  var import_buffer_layout7 = __toESM(require_Layout(), 1);
  var transferCheckedInstructionData = (0, import_buffer_layout7.struct)([
    (0, import_buffer_layout7.u8)("instruction"),
    u642("amount"),
    (0, import_buffer_layout7.u8)("decimals")
  ]);
  function createTransferCheckedInstruction(source, mint, destination, owner, amount, decimals, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
    const keys = addSigners([
      { pubkey: source, isSigner: false, isWritable: true },
      { pubkey: mint, isSigner: false, isWritable: false },
      { pubkey: destination, isSigner: false, isWritable: true }
    ], owner, multiSigners);
    const data = Buffer.alloc(transferCheckedInstructionData.span);
    transferCheckedInstructionData.encode({
      instruction: TokenInstruction.TransferChecked,
      amount: BigInt(amount),
      decimals
    }, data);
    return new TransactionInstruction({ keys, programId, data });
  }

  // node_modules/@solana/spl-token/lib/esm/state/mint.js
  var MintLayout = (0, import_buffer_layout8.struct)([
    (0, import_buffer_layout8.u32)("mintAuthorityOption"),
    publicKey2("mintAuthority"),
    u642("supply"),
    (0, import_buffer_layout8.u8)("decimals"),
    bool("isInitialized"),
    (0, import_buffer_layout8.u32)("freezeAuthorityOption"),
    publicKey2("freezeAuthority")
  ]);
  var MINT_SIZE = MintLayout.span;
  async function getMint(connection, address, commitment, programId = TOKEN_PROGRAM_ID) {
    const info = await connection.getAccountInfo(address, commitment);
    return unpackMint(address, info, programId);
  }
  function unpackMint(address, info, programId = TOKEN_PROGRAM_ID) {
    if (!info)
      throw new TokenAccountNotFoundError();
    if (!info.owner.equals(programId))
      throw new TokenInvalidAccountOwnerError();
    if (info.data.length < MINT_SIZE)
      throw new TokenInvalidAccountSizeError();
    const rawMint = MintLayout.decode(info.data.slice(0, MINT_SIZE));
    let tlvData = Buffer.alloc(0);
    if (info.data.length > MINT_SIZE) {
      if (info.data.length <= ACCOUNT_SIZE)
        throw new TokenInvalidAccountSizeError();
      if (info.data.length === MULTISIG_SIZE)
        throw new TokenInvalidAccountSizeError();
      if (info.data[ACCOUNT_SIZE] != AccountType.Mint)
        throw new TokenInvalidMintError();
      tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);
    }
    return {
      address,
      mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,
      supply: rawMint.supply,
      decimals: rawMint.decimals,
      isInitialized: rawMint.isInitialized,
      freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,
      tlvData
    };
  }
  async function getAssociatedTokenAddress(mint, owner, allowOwnerOffCurve = false, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
    if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer()))
      throw new TokenOwnerOffCurveError();
    const [address] = await PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);
    return address;
  }

  // node_modules/@solana/pay/lib/esm/createTransfer.js
  var CreateTransferError = class extends Error {
    constructor() {
      super(...arguments);
      this.name = "CreateTransferError";
    }
  };
  async function createTransfer(connection, sender, { recipient, amount, splToken, reference, memo }, { commitment } = {}) {
    const senderInfo = await connection.getAccountInfo(sender);
    if (!senderInfo)
      throw new CreateTransferError("sender not found");
    const recipientInfo = await connection.getAccountInfo(recipient);
    if (!recipientInfo)
      throw new CreateTransferError("recipient not found");
    const instruction = splToken ? await createSPLTokenInstruction(recipient, amount, splToken, sender, connection) : await createSystemInstruction(recipient, amount, sender, connection);
    if (reference) {
      if (!Array.isArray(reference)) {
        reference = [reference];
      }
      for (const pubkey of reference) {
        instruction.keys.push({ pubkey, isWritable: false, isSigner: false });
      }
    }
    const transaction = new Transaction();
    transaction.feePayer = sender;
    transaction.recentBlockhash = (await connection.getLatestBlockhash(commitment)).blockhash;
    if (memo != null) {
      transaction.add(new TransactionInstruction({
        programId: MEMO_PROGRAM_ID,
        keys: [],
        data: Buffer.from(memo, "utf8")
      }));
    }
    transaction.add(instruction);
    return transaction;
  }
  async function createSystemInstruction(recipient, amount, sender, connection) {
    const senderInfo = await connection.getAccountInfo(sender);
    if (!senderInfo)
      throw new CreateTransferError("sender not found");
    const recipientInfo = await connection.getAccountInfo(recipient);
    if (!recipientInfo)
      throw new CreateTransferError("recipient not found");
    if (!senderInfo.owner.equals(SystemProgram.programId))
      throw new CreateTransferError("sender owner invalid");
    if (senderInfo.executable)
      throw new CreateTransferError("sender executable");
    if (!recipientInfo.owner.equals(SystemProgram.programId))
      throw new CreateTransferError("recipient owner invalid");
    if (recipientInfo.executable)
      throw new CreateTransferError("recipient executable");
    if ((amount.decimalPlaces() ?? 0) > SOL_DECIMALS)
      throw new CreateTransferError("amount decimals invalid");
    amount = amount.times(LAMPORTS_PER_SOL).integerValue(bignumber_default.ROUND_FLOOR);
    const lamports = amount.toNumber();
    if (lamports > senderInfo.lamports)
      throw new CreateTransferError("insufficient funds");
    return SystemProgram.transfer({
      fromPubkey: sender,
      toPubkey: recipient,
      lamports
    });
  }
  async function createSPLTokenInstruction(recipient, amount, splToken, sender, connection) {
    const accountInfo = await connection.getParsedAccountInfo(splToken);
    const accountOwner = accountInfo.value?.owner;
    const tokenProgram = accountOwner && accountOwner === TOKEN_2022_PROGRAM_ID ? TOKEN_2022_PROGRAM_ID : TOKEN_PROGRAM_ID;
    const mint = await getMint(connection, splToken, void 0, tokenProgram);
    if (!mint.isInitialized)
      throw new CreateTransferError("mint not initialized");
    if ((amount.decimalPlaces() ?? 0) > mint.decimals)
      throw new CreateTransferError("amount decimals invalid");
    amount = amount.times(TEN.pow(mint.decimals)).integerValue(bignumber_default.ROUND_FLOOR);
    const senderATA = await getAssociatedTokenAddress(splToken, sender, void 0, tokenProgram);
    const senderAccount = await getAccount(connection, senderATA, void 0, tokenProgram);
    if (!senderAccount.isInitialized)
      throw new CreateTransferError("sender not initialized");
    if (senderAccount.isFrozen)
      throw new CreateTransferError("sender frozen");
    const recipientATA = await getAssociatedTokenAddress(splToken, recipient, void 0, tokenProgram);
    const recipientAccount = await getAccount(connection, recipientATA, void 0, tokenProgram);
    if (!recipientAccount.isInitialized)
      throw new CreateTransferError("recipient not initialized");
    if (recipientAccount.isFrozen)
      throw new CreateTransferError("recipient frozen");
    const tokens = BigInt(String(amount));
    if (tokens > senderAccount.amount)
      throw new CreateTransferError("insufficient funds");
    return createTransferCheckedInstruction(senderATA, splToken, recipientATA, sender, tokens, mint.decimals, [], tokenProgram);
  }

  // node_modules/@solana/pay/lib/esm/parseURL.js
  var ParseURLError = class extends Error {
    constructor() {
      super(...arguments);
      this.name = "ParseURLError";
    }
  };
  function parseURL(url) {
    if (typeof url === "string") {
      if (url.length > 2048)
        throw new ParseURLError("length invalid");
      url = new URL(url);
    }
    if (url.protocol !== SOLANA_PROTOCOL)
      throw new ParseURLError("protocol invalid");
    if (!url.pathname)
      throw new ParseURLError("pathname missing");
    return /[:%]/.test(url.pathname) ? parseTransactionRequestURL(url) : parseTransferRequestURL(url);
  }
  function parseTransactionRequestURL({ pathname, searchParams }) {
    const link = new URL(decodeURIComponent(pathname));
    if (link.protocol !== HTTPS_PROTOCOL)
      throw new ParseURLError("link invalid");
    const label = searchParams.get("label") || void 0;
    const message = searchParams.get("message") || void 0;
    return {
      link,
      label,
      message
    };
  }
  function parseTransferRequestURL({ pathname, searchParams }) {
    let recipient;
    try {
      recipient = new PublicKey(pathname);
    } catch (error) {
      throw new ParseURLError("recipient invalid");
    }
    let amount;
    const amountParam = searchParams.get("amount");
    if (amountParam != null) {
      if (!/^\d+(\.\d+)?$/.test(amountParam))
        throw new ParseURLError("amount invalid");
      amount = new bignumber_default(amountParam);
      if (amount.isNaN())
        throw new ParseURLError("amount NaN");
      if (amount.isNegative())
        throw new ParseURLError("amount negative");
    }
    let splToken;
    const splTokenParam = searchParams.get("spl-token");
    if (splTokenParam != null) {
      try {
        splToken = new PublicKey(splTokenParam);
      } catch (error) {
        throw new ParseURLError("spl-token invalid");
      }
    }
    let reference;
    const referenceParams = searchParams.getAll("reference");
    if (referenceParams.length) {
      try {
        reference = referenceParams.map((reference2) => new PublicKey(reference2));
      } catch (error) {
        throw new ParseURLError("reference invalid");
      }
    }
    const label = searchParams.get("label") || void 0;
    const message = searchParams.get("message") || void 0;
    const memo = searchParams.get("memo") || void 0;
    return {
      recipient,
      amount,
      splToken,
      reference,
      label,
      message,
      memo
    };
  }

  // src/solana-payment.js
  var import_buffer3 = __toESM(require_buffer());
  if (typeof window !== "undefined" && !window.Buffer) {
    window.Buffer = import_buffer3.Buffer;
  }
  var CONFIG = null;
  function initializePayment(config) {
    CONFIG = config;
    console.log("Solana Pay initialized with config:", CONFIG);
  }
  function getWalletProvider() {
    if (window.phantom?.solana?.isPhantom) {
      return window.phantom.solana;
    }
    if (window.solflare?.isSolflare) {
      return window.solflare;
    }
    if (window.backpack?.isBackpack) {
      return window.backpack;
    }
    if (window.solana) {
      return window.solana;
    }
    return null;
  }
  function isWalletInstalled() {
    return getWalletProvider() !== null;
  }
  async function connectWallet() {
    const provider = getWalletProvider();
    if (!provider) {
      throw new Error("No Solana wallet found. Please install Phantom, Solflare, or Backpack.");
    }
    try {
      const response = await provider.connect();
      return response.publicKey;
    } catch (error) {
      if (error.code === 4001) {
        throw new Error("Wallet connection rejected by user");
      }
      throw error;
    }
  }
  async function connectWalletSilently() {
    const provider = getWalletProvider();
    if (!provider) {
      return null;
    }
    try {
      const response = await provider.connect({ onlyIfTrusted: true });
      return response.publicKey;
    } catch (error) {
      return null;
    }
  }
  async function createAndSendPayment(paymentUrl, rpcUrl = "https://api.mainnet-beta.solana.com") {
    const provider = getWalletProvider();
    if (!provider || !provider.publicKey) {
      throw new Error("Wallet not connected");
    }
    const { recipient, amount, splToken, reference, memo } = parseURL(paymentUrl);
    console.log("Payment details:", {
      recipient: recipient.toString(),
      amount: amount.toString(),
      splToken: splToken?.toString(),
      reference: reference?.map((r) => r.toString()),
      memo
    });
    const connection = new Connection(rpcUrl, "confirmed");
    const transaction = await createTransfer(connection, provider.publicKey, {
      recipient,
      amount,
      splToken,
      reference,
      memo
    });
    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash("confirmed");
    transaction.recentBlockhash = blockhash;
    transaction.feePayer = provider.publicKey;
    console.log("Transaction created, requesting signature...");
    const { signature } = await provider.signAndSendTransaction(transaction);
    console.log("Transaction sent:", signature);
    const confirmation = await connection.confirmTransaction({
      signature,
      blockhash,
      lastValidBlockHeight
    }, "confirmed");
    if (confirmation.value.err) {
      throw new Error("Transaction failed: " + JSON.stringify(confirmation.value.err));
    }
    console.log("Transaction confirmed:", signature);
    return signature;
  }
  async function verifyPaymentWithBackend(orderId, signature) {
    const response = await fetch("/api/payment-verify/", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CSRFToken": getCsrfToken()
      },
      body: JSON.stringify({
        order_id: orderId,
        signature
      })
    });
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    const data = await response.json();
    if (!data.success) {
      throw new Error(data.message || "Payment verification failed");
    }
    return data;
  }
  function getCsrfToken() {
    const name = "csrftoken";
    const cookies = document.cookie.split(";");
    for (let cookie of cookies) {
      cookie = cookie.trim();
      if (cookie.startsWith(name + "=")) {
        return cookie.substring(name.length + 1);
      }
    }
    return "";
  }
  async function processPayment(config, callbacks = {}) {
    const {
      onStatusChange = () => {
      },
      onSuccess = () => {
      },
      onError = () => {
      }
    } = callbacks;
    try {
      onStatusChange("Connecting to wallet...", "info");
      const publicKey3 = await connectWallet();
      console.log("Connected to wallet:", publicKey3.toString());
      onStatusChange("Creating payment transaction...", "info");
      const signature = await createAndSendPayment(
        config.paymentUrl,
        config.rpcUrl || "https://api.mainnet-beta.solana.com"
      );
      onStatusChange("Verifying payment...", "info");
      const result = await verifyPaymentWithBackend(config.orderId, signature);
      onStatusChange(result.message || "Payment confirmed!", "success");
      onSuccess(result, signature);
    } catch (error) {
      console.error("Payment error:", error);
      let errorMessage = error.message || "Payment failed";
      if (error.message?.includes("rejected")) {
        errorMessage = "Transaction rejected by user";
      } else if (error.message?.includes("insufficient")) {
        errorMessage = "Insufficient funds in wallet";
      } else if (error.message?.includes("No Solana wallet")) {
        errorMessage = "No Solana wallet detected. Please install Phantom, Solflare, or Backpack.";
      }
      onStatusChange(errorMessage, "error");
      onError(error);
    }
  }
  window.SolanaPayment = {
    initialize: initializePayment,
    isWalletInstalled,
    connectWallet,
    connectWalletSilently,
    processPayment,
    verifyPaymentWithBackend
  };
  console.log("Solana Payment module loaded");
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@solana/buffer-layout/lib/Layout.js:
  (**
   * Support for translating between Uint8Array instances and JavaScript
   * native types.
   *
   * {@link module:Layout~Layout|Layout} is the basis of a class
   * hierarchy that associates property names with sequences of encoded
   * bytes.
   *
   * Layouts are supported for these scalar (numeric) types:
   * * {@link module:Layout~UInt|Unsigned integers in little-endian
   *   format} with {@link module:Layout.u8|8-bit}, {@link
   *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
   *   {@link module:Layout.u32|32-bit}, {@link
   *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
   *   format} with {@link module:Layout.u16be|16-bit}, {@link
   *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
   *   {@link module:Layout.u40be|40-bit}, and {@link
   *   module:Layout.u48be|48-bit} representation ranges;
   * * {@link module:Layout~Int|Signed integers in little-endian
   *   format} with {@link module:Layout.s8|8-bit}, {@link
   *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
   *   {@link module:Layout.s32|32-bit}, {@link
   *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~IntBE|Signed integers in big-endian format}
   *   with {@link module:Layout.s16be|16-bit}, {@link
   *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
   *   {@link module:Layout.s40be|40-bit}, and {@link
   *   module:Layout.s48be|48-bit} representation ranges;
   * * 64-bit integral values that decode to an exact (if magnitude is
   *   less than 2^53) or nearby integral Number in {@link
   *   module:Layout.nu64|unsigned little-endian}, {@link
   *   module:Layout.nu64be|unsigned big-endian}, {@link
   *   module:Layout.ns64|signed little-endian}, and {@link
   *   module:Layout.ns64be|unsigned big-endian} encodings;
   * * 32-bit floating point values with {@link
   *   module:Layout.f32|little-endian} and {@link
   *   module:Layout.f32be|big-endian} representations;
   * * 64-bit floating point values with {@link
   *   module:Layout.f64|little-endian} and {@link
   *   module:Layout.f64be|big-endian} representations;
   * * {@link module:Layout.const|Constants} that take no space in the
   *   encoded expression.
   *
   * and for these aggregate types:
   * * {@link module:Layout.seq|Sequence}s of instances of a {@link
   *   module:Layout~Layout|Layout}, with JavaScript representation as
   *   an Array and constant or data-dependent {@link
   *   module:Layout~Sequence#count|length};
   * * {@link module:Layout.struct|Structure}s that aggregate a
   *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
   *   instances, with JavaScript representation as an Object;
   * * {@link module:Layout.union|Union}s that support multiple {@link
   *   module:Layout~VariantLayout|variant layouts} over a fixed
   *   (padded) or variable (not padded) span of bytes, using an
   *   unsigned integer at the start of the data or a separate {@link
   *   module:Layout.unionLayoutDiscriminator|layout element} to
   *   determine which layout to use when interpreting the buffer
   *   contents;
   * * {@link module:Layout.bits|BitStructure}s that contain a sequence
   *   of individual {@link
   *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
   *   16, 24, or 32-bit unsigned integer starting at the least- or
   *   most-significant bit;
   * * {@link module:Layout.cstr|C strings} of varying length;
   * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
   *   module:Layout~Blob#length|length} raw data.
   *
   * All {@link module:Layout~Layout|Layout} instances are immutable
   * after construction, to prevent internal state from becoming
   * inconsistent.
   *
   * @local Layout
   * @local ExternalLayout
   * @local GreedyCount
   * @local OffsetLayout
   * @local UInt
   * @local UIntBE
   * @local Int
   * @local IntBE
   * @local NearUInt64
   * @local NearUInt64BE
   * @local NearInt64
   * @local NearInt64BE
   * @local Float
   * @local FloatBE
   * @local Double
   * @local DoubleBE
   * @local Sequence
   * @local Structure
   * @local UnionDiscriminator
   * @local UnionLayoutDiscriminator
   * @local Union
   * @local VariantLayout
   * @local BitStructure
   * @local BitField
   * @local Boolean
   * @local Blob
   * @local CString
   * @local Constant
   * @local bindConstructorLayout
   * @module Layout
   * @license MIT
   * @author Peter A. Bigot
   * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/edwards.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9ibi5qcy9saWIvYm4uanMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9iczU4L2luZGV4LmpzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy90ZXh0LWVuY29kaW5nLXV0Zi04L2xpYi9lbmNvZGluZy5saWIuanMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2JvcnNoL2xpYi9pbmRleC5qcyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNvbGFuYS9idWZmZXItbGF5b3V0L3NyYy9MYXlvdXQudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9ybmcuanMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9yZWdleC5qcyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc3RyaW5naWZ5LmpzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjEuanMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9wYXJzZS5qcyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3YzNS5qcyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL21kNS5qcyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3YzLmpzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjQuanMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9zaGExLmpzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjUuanMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9uaWwuanMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92ZXJzaW9uLmpzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvaW5kZXguanMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2pheXNvbi9saWIvZ2VuZXJhdGVSZXF1ZXN0LmpzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9qYXlzb24vbGliL2NsaWVudC9icm93c2VyL2luZGV4LmpzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9iaWdpbnQtYnVmZmVyL2Rpc3QvYnJvd3Nlci5qcyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zcmMvY3J5cHRvLnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NyYy91dGlscy50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zcmMvX21kLnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NyYy9fdTY0LnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NyYy9zaGEyLnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL3NyYy91dGlscy50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9zcmMvYWJzdHJhY3QvbW9kdWxhci50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9zcmMvYWJzdHJhY3QvY3VydmUudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvc3JjL2Fic3RyYWN0L2Vkd2FyZHMudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvc3JjL2VkMjU1MTkudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc3JjL3NoYTI1Ni50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Ac29sYW5hL2Vycm9ycy9zcmMvY29kZXMudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQHNvbGFuYS9lcnJvcnMvc3JjL2NvbnRleHQudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQHNvbGFuYS9lcnJvcnMvc3JjL21lc3NhZ2VzLnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvZXJyb3JzL3NyYy9tZXNzYWdlLWZvcm1hdHRlci50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Ac29sYW5hL2Vycm9ycy9zcmMvZXJyb3IudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQHNvbGFuYS9lcnJvcnMvc3JjL3N0YWNrLXRyYWNlLnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvZXJyb3JzL3NyYy9ycGMtZW51bS1lcnJvcnMudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQHNvbGFuYS9lcnJvcnMvc3JjL2luc3RydWN0aW9uLWVycm9yLnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvZXJyb3JzL3NyYy90cmFuc2FjdGlvbi1lcnJvci50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Ac29sYW5hL2Vycm9ycy9zcmMvanNvbi1ycGMtZXJyb3IudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtY29yZS9zcmMvYnl0ZXMudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtY29yZS9zcmMvY29kZWMudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtY29yZS9zcmMvY29tYmluZS1jb2RlYy50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1jb3JlL3NyYy9hZGQtY29kZWMtc2VudGluZWwudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtY29yZS9zcmMvYXNzZXJ0aW9ucy50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1jb3JlL3NyYy9hZGQtY29kZWMtc2l6ZS1wcmVmaXgudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtY29yZS9zcmMvZml4LWNvZGVjLXNpemUudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtY29yZS9zcmMvb2Zmc2V0LWNvZGVjLnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvY29kZWNzLWNvcmUvc3JjL3Jlc2l6ZS1jb2RlYy50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1jb3JlL3NyYy9wYWQtY29kZWMudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtY29yZS9zcmMvcmV2ZXJzZS1jb2RlYy50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1jb3JlL3NyYy90cmFuc2Zvcm0tY29kZWMudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtbnVtYmVycy9zcmMvYXNzZXJ0aW9ucy50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1udW1iZXJzL3NyYy9jb21tb24udHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtbnVtYmVycy9zcmMvdXRpbHMudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtbnVtYmVycy9zcmMvZjMyLnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvY29kZWNzLW51bWJlcnMvc3JjL2Y2NC50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1udW1iZXJzL3NyYy9pMTI4LnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvY29kZWNzLW51bWJlcnMvc3JjL2kxNi50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1udW1iZXJzL3NyYy9pMzIudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtbnVtYmVycy9zcmMvaTY0LnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvY29kZWNzLW51bWJlcnMvc3JjL2k4LnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvY29kZWNzLW51bWJlcnMvc3JjL3Nob3J0LXUxNi50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1udW1iZXJzL3NyYy91MTI4LnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvY29kZWNzLW51bWJlcnMvc3JjL3UxNi50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1udW1iZXJzL3NyYy91MzIudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtbnVtYmVycy9zcmMvdTY0LnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvY29kZWNzLW51bWJlcnMvc3JjL3U4LnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9zdXBlcnN0cnVjdC9zcmMvZXJyb3IudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3N1cGVyc3RydWN0L3NyYy91dGlscy50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvc3VwZXJzdHJ1Y3Qvc3JjL3N0cnVjdC50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvc3VwZXJzdHJ1Y3Qvc3JjL3N0cnVjdHMvdXRpbGl0aWVzLnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9zdXBlcnN0cnVjdC9zcmMvc3RydWN0cy90eXBlcy50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvc3VwZXJzdHJ1Y3Qvc3JjL3N0cnVjdHMvY29lcmNpb25zLnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9zdXBlcnN0cnVjdC9zcmMvc3RydWN0cy9yZWZpbmVtZW50cy50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5tanMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3JwYy13ZWJzb2NrZXRzL3NyYy9saWIvY2xpZW50L3dlYnNvY2tldC5icm93c2VyLnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9ycGMtd2Vic29ja2V0cy9zcmMvbGliL3V0aWxzLnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9ycGMtd2Vic29ja2V0cy9zcmMvbGliL2NsaWVudC50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvc3JjL2luZGV4LmJyb3dzZXIudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc3JjL3NoYTMudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc3JjL2htYWMudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvc3JjL2Fic3RyYWN0L3dlaWVyc3RyYXNzLnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL3NyYy9fc2hvcnR3X3V0aWxzLnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL3NyYy9zZWNwMjU2azEudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIubWpzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Ac29sYW5hL3BheS9zcmMvY29uc3RhbnRzLnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Ac29sYW5hL3NwbC10b2tlbi9zcmMvY29uc3RhbnRzLnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Ac29sYW5hL2J1ZmZlci1sYXlvdXQtdXRpbHMvc3JjL2Jhc2UudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvYnVmZmVyLWxheW91dC11dGlscy9zcmMvYmlnaW50LnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Ac29sYW5hL2J1ZmZlci1sYXlvdXQtdXRpbHMvc3JjL2RlY2ltYWwudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvYnVmZmVyLWxheW91dC11dGlscy9zcmMvbmF0aXZlLnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Ac29sYW5hL2J1ZmZlci1sYXlvdXQtdXRpbHMvc3JjL3dlYjMudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvc3BsLXRva2VuL3NyYy9lcnJvcnMudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvc3BsLXRva2VuL3NyYy9pbnN0cnVjdGlvbnMvdHlwZXMudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvc3BsLXRva2VuL3NyYy9zdGF0ZS9taW50LnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9Ac29sYW5hL3NwbC10b2tlbi9zcmMvZXh0ZW5zaW9ucy9hY2NvdW50VHlwZS50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNvbGFuYS9zcGwtdG9rZW4vc3JjL3N0YXRlL2FjY291bnQudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvc3BsLXRva2VuL3NyYy9zdGF0ZS9tdWx0aXNpZy50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNvbGFuYS9zcGwtdG9rZW4vc3JjL2luc3RydWN0aW9ucy9pbnRlcm5hbC50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNvbGFuYS9zcGwtdG9rZW4vc3JjL2luc3RydWN0aW9ucy90cmFuc2ZlckNoZWNrZWQudHMiLCAiLi4vLi4vLi4vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvcGF5L3NyYy9jcmVhdGVUcmFuc2Zlci50cyIsICIuLi8uLi8uLi9mcm9udGVuZC9ub2RlX21vZHVsZXMvQHNvbGFuYS9wYXkvc3JjL3BhcnNlVVJMLnRzIiwgIi4uLy4uLy4uL2Zyb250ZW5kL3NyYy9zb2xhbmEtcGF5bWVudC5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCAiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsICIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxuY29uc3QgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuY29uc3QgY3VzdG9tSW5zcGVjdFN5bWJvbCA9XG4gICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2xbJ2ZvciddID09PSAnZnVuY3Rpb24nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgID8gU3ltYm9sWydmb3InXSgnbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIDogbnVsbFxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbmNvbnN0IEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgY29uc3QgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyLCBwcm90bylcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5Vmlldyh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICBjb25zdCB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBjb25zdCBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpXG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIGxldCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIGNvbnN0IGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5VmlldyAoYXJyYXlWaWV3KSB7XG4gIGlmIChpc0luc3RhbmNlKGFycmF5VmlldywgVWludDhBcnJheSkpIHtcbiAgICBjb25zdCBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KVxuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIoY29weS5idWZmZXIsIGNvcHkuYnl0ZU9mZnNldCwgY29weS5ieXRlTGVuZ3RoKVxuICB9XG4gIHJldHVybiBmcm9tQXJyYXlMaWtlKGFycmF5Vmlldylcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGxldCBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgY29uc3QgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgbGV0IHggPSBhLmxlbmd0aFxuICBsZXQgeSA9IGIubGVuZ3RoXG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICBsZXQgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIGxldCBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBpZiAocG9zICsgYnVmLmxlbmd0aCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICBidWYsXG4gICAgICAgICAgcG9zXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgfVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgY29uc3QgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBjb25zdCBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcmNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICBjb25zdCBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICBsZXQgc3RyID0gJydcbiAgY29uc3QgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cbmlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXIucHJvdG90eXBlLmluc3BlY3Rcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgbGV0IHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIGxldCB5ID0gZW5kIC0gc3RhcnRcbiAgY29uc3QgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICBjb25zdCB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICBjb25zdCB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgbGV0IGluZGV4U2l6ZSA9IDFcbiAgbGV0IGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgbGV0IHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGRpcikge1xuICAgIGxldCBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGxldCBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgY29uc3QgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICBjb25zdCByZXMgPSBbXVxuXG4gIGxldCBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICBsZXQgY29kZVBvaW50ID0gbnVsbFxuICAgIGxldCBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpXG4gICAgICA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpXG4gICAgICAgICAgPyAzXG4gICAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRilcbiAgICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgbGV0IHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxuY29uc3QgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIGNvbnN0IGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIGxldCBvdXQgPSAnJ1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIGxldCByZXMgPSAnJ1xuICAvLyBJZiBieXRlcy5sZW5ndGggaXMgb2RkLCB0aGUgbGFzdCA4IGJpdHMgbXVzdCBiZSBpZ25vcmVkIChzYW1lIGFzIG5vZGUuanMpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIGNvbnN0IG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgbGV0IG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBsbyA9IGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjRcblxuICBjb25zdCBoaSA9IHRoaXNbKytvZmZzZXRdICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICBsYXN0ICogMiAqKiAyNFxuXG4gIHJldHVybiBCaWdJbnQobG8pICsgKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGhpID0gZmlyc3QgKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIGNvbnN0IGxvID0gdGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0XG5cbiAgcmV0dXJuIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KGxvKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aFxuICBsZXQgbXVsID0gMVxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyA0XSArXG4gICAgdGhpc1tvZmZzZXQgKyA1XSAqIDIgKiogOCArXG4gICAgdGhpc1tvZmZzZXQgKyA2XSAqIDIgKiogMTYgK1xuICAgIChsYXN0IDw8IDI0KSAvLyBPdmVyZmxvd1xuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludChmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IChmaXJzdCA8PCAyNCkgKyAvLyBPdmVyZmxvd1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0TEUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgcmV0dXJuIG9mZnNldFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRCRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgN10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDZdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA1XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNF0gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDNdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAyXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMV0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldF0gPSBoaVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IDBcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgbGV0IGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gQ1VTVE9NIEVSUk9SU1xuLy8gPT09PT09PT09PT09PVxuXG4vLyBTaW1wbGlmaWVkIHZlcnNpb25zIGZyb20gTm9kZSwgY2hhbmdlZCBmb3IgQnVmZmVyLW9ubHkgdXNhZ2VcbmNvbnN0IGVycm9ycyA9IHt9XG5mdW5jdGlvbiBFIChzeW0sIGdldE1lc3NhZ2UsIEJhc2UpIHtcbiAgZXJyb3JzW3N5bV0gPSBjbGFzcyBOb2RlRXJyb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICBzdXBlcigpXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWVzc2FnZScsIHtcbiAgICAgICAgdmFsdWU6IGdldE1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSlcblxuICAgICAgLy8gQWRkIHRoZSBlcnJvciBjb2RlIHRvIHRoZSBuYW1lIHRvIGluY2x1ZGUgaXQgaW4gdGhlIHN0YWNrIHRyYWNlLlxuICAgICAgdGhpcy5uYW1lID0gYCR7dGhpcy5uYW1lfSBbJHtzeW19XWBcbiAgICAgIC8vIEFjY2VzcyB0aGUgc3RhY2sgdG8gZ2VuZXJhdGUgdGhlIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBlcnJvciBjb2RlXG4gICAgICAvLyBmcm9tIHRoZSBuYW1lLlxuICAgICAgdGhpcy5zdGFjayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgLy8gUmVzZXQgdGhlIG5hbWUgdG8gdGhlIGFjdHVhbCBuYW1lLlxuICAgICAgZGVsZXRlIHRoaXMubmFtZVxuICAgIH1cblxuICAgIGdldCBjb2RlICgpIHtcbiAgICAgIHJldHVybiBzeW1cbiAgICB9XG5cbiAgICBzZXQgY29kZSAodmFsdWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29kZScsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX0gWyR7c3ltfV06ICR7dGhpcy5tZXNzYWdlfWBcbiAgICB9XG4gIH1cbn1cblxuRSgnRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTJyxcbiAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuIGAke25hbWV9IGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2BcbiAgICB9XG5cbiAgICByZXR1cm4gJ0F0dGVtcHQgdG8gYWNjZXNzIG1lbW9yeSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnXG4gIH0sIFJhbmdlRXJyb3IpXG5FKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsXG4gIGZ1bmN0aW9uIChuYW1lLCBhY3R1YWwpIHtcbiAgICByZXR1cm4gYFRoZSBcIiR7bmFtZX1cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH1gXG4gIH0sIFR5cGVFcnJvcilcbkUoJ0VSUl9PVVRfT0ZfUkFOR0UnLFxuICBmdW5jdGlvbiAoc3RyLCByYW5nZSwgaW5wdXQpIHtcbiAgICBsZXQgbXNnID0gYFRoZSB2YWx1ZSBvZiBcIiR7c3RyfVwiIGlzIG91dCBvZiByYW5nZS5gXG4gICAgbGV0IHJlY2VpdmVkID0gaW5wdXRcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkgJiYgTWF0aC5hYnMoaW5wdXQpID4gMiAqKiAzMikge1xuICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IoU3RyaW5nKGlucHV0KSlcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIHJlY2VpdmVkID0gU3RyaW5nKGlucHV0KVxuICAgICAgaWYgKGlucHV0ID4gQmlnSW50KDIpICoqIEJpZ0ludCgzMikgfHwgaW5wdXQgPCAtKEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpKSkge1xuICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihyZWNlaXZlZClcbiAgICAgIH1cbiAgICAgIHJlY2VpdmVkICs9ICduJ1xuICAgIH1cbiAgICBtc2cgKz0gYCBJdCBtdXN0IGJlICR7cmFuZ2V9LiBSZWNlaXZlZCAke3JlY2VpdmVkfWBcbiAgICByZXR1cm4gbXNnXG4gIH0sIFJhbmdlRXJyb3IpXG5cbmZ1bmN0aW9uIGFkZE51bWVyaWNhbFNlcGFyYXRvciAodmFsKSB7XG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IHZhbC5sZW5ndGhcbiAgY29uc3Qgc3RhcnQgPSB2YWxbMF0gPT09ICctJyA/IDEgOiAwXG4gIGZvciAoOyBpID49IHN0YXJ0ICsgNDsgaSAtPSAzKSB7XG4gICAgcmVzID0gYF8ke3ZhbC5zbGljZShpIC0gMywgaSl9JHtyZXN9YFxuICB9XG4gIHJldHVybiBgJHt2YWwuc2xpY2UoMCwgaSl9JHtyZXN9YFxufVxuXG4vLyBDSEVDSyBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBjaGVja0JvdW5kcyAoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgaWYgKGJ1ZltvZmZzZXRdID09PSB1bmRlZmluZWQgfHwgYnVmW29mZnNldCArIGJ5dGVMZW5ndGhdID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIGJ1Zi5sZW5ndGggLSAoYnl0ZUxlbmd0aCArIDEpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50QkkgKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB7XG4gICAgY29uc3QgbiA9IHR5cGVvZiBtaW4gPT09ICdiaWdpbnQnID8gJ24nIDogJydcbiAgICBsZXQgcmFuZ2VcbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDMpIHtcbiAgICAgIGlmIChtaW4gPT09IDAgfHwgbWluID09PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gMCR7bn0gYW5kIDwgMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOH0ke259YFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gLSgyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259KSBhbmQgPCAyICoqIGAgK1xuICAgICAgICAgICAgICAgIGAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259YFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZSA9IGA+PSAke21pbn0ke259IGFuZCA8PSAke21heH0ke259YFxuICAgIH1cbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UoJ3ZhbHVlJywgcmFuZ2UsIHZhbHVlKVxuICB9XG4gIGNoZWNrQm91bmRzKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlciAodmFsdWUsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdudW1iZXInLCB2YWx1ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBib3VuZHNFcnJvciAodmFsdWUsIGxlbmd0aCwgdHlwZSkge1xuICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7XG4gICAgdmFsaWRhdGVOdW1iZXIodmFsdWUsIHR5cGUpXG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsICdhbiBpbnRlZ2VyJywgdmFsdWUpXG4gIH1cblxuICBpZiAobGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTKClcbiAgfVxuXG4gIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYD49ICR7dHlwZSA/IDEgOiAwfSBhbmQgPD0gJHtsZW5ndGh9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlKVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbmNvbnN0IElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICBsZXQgY29kZVBvaW50XG4gIGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgbGV0IGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIGNvbnN0IGJ5dGVzID0gW11cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICBsZXQgYywgaGksIGxvXG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbmNvbnN0IGhleFNsaWNlTG9va3VwVGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICBjb25zdCBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICBjb25zdCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIGNvbnN0IGkxNiA9IGkgKiAxNlxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdXG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZVxufSkoKVxuXG4vLyBSZXR1cm4gbm90IGZ1bmN0aW9uIHdpdGggRXJyb3IgaWYgQmlnSW50IG5vdCBzdXBwb3J0ZWRcbmZ1bmN0aW9uIGRlZmluZUJpZ0ludE1ldGhvZCAoZm4pIHtcbiAgcmV0dXJuIHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCA6IGZuXG59XG5cbmZ1bmN0aW9uIEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0JpZ0ludCBub3Qgc3VwcG9ydGVkJylcbn1cbiIsICIoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVXRpbHNcbiAgZnVuY3Rpb24gYXNzZXJ0ICh2YWwsIG1zZykge1xuICAgIGlmICghdmFsKSB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIH1cblxuICAvLyBDb3VsZCB1c2UgYGluaGVyaXRzYCBtb2R1bGUsIGJ1dCBkb24ndCB3YW50IHRvIG1vdmUgZnJvbSBzaW5nbGUgZmlsZVxuICAvLyBhcmNoaXRlY3R1cmUgeWV0LlxuICBmdW5jdGlvbiBpbmhlcml0cyAoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgfVxuXG4gIC8vIEJOXG5cbiAgZnVuY3Rpb24gQk4gKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKEJOLmlzQk4obnVtYmVyKSkge1xuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB0aGlzLndvcmRzID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBSZWR1Y3Rpb24gY29udGV4dFxuICAgIHRoaXMucmVkID0gbnVsbDtcblxuICAgIGlmIChudW1iZXIgIT09IG51bGwpIHtcbiAgICAgIGlmIChiYXNlID09PSAnbGUnIHx8IGJhc2UgPT09ICdiZScpIHtcbiAgICAgICAgZW5kaWFuID0gYmFzZTtcbiAgICAgICAgYmFzZSA9IDEwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbml0KG51bWJlciB8fCAwLCBiYXNlIHx8IDEwLCBlbmRpYW4gfHwgJ2JlJyk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gQk47XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CTiA9IEJOO1xuICB9XG5cbiAgQk4uQk4gPSBCTjtcbiAgQk4ud29yZFNpemUgPSAyNjtcblxuICB2YXIgQnVmZmVyO1xuICB0cnkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LkJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIEJ1ZmZlciA9IHdpbmRvdy5CdWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuXG4gIEJOLmlzQk4gPSBmdW5jdGlvbiBpc0JOIChudW0pIHtcbiAgICBpZiAobnVtIGluc3RhbmNlb2YgQk4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBudW0gIT09IG51bGwgJiYgdHlwZW9mIG51bSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG51bS5jb25zdHJ1Y3Rvci53b3JkU2l6ZSA9PT0gQk4ud29yZFNpemUgJiYgQXJyYXkuaXNBcnJheShudW0ud29yZHMpO1xuICB9O1xuXG4gIEJOLm1heCA9IGZ1bmN0aW9uIG1heCAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5jbXAocmlnaHQpID4gMCkgcmV0dXJuIGxlZnQ7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIEJOLm1pbiA9IGZ1bmN0aW9uIG1pbiAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5jbXAocmlnaHQpIDwgMCkgcmV0dXJuIGxlZnQ7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdE51bWJlcihudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdEFycmF5KG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIGJhc2UgPSAxNjtcbiAgICB9XG4gICAgYXNzZXJ0KGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpO1xuXG4gICAgbnVtYmVyID0gbnVtYmVyLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBpZiAobnVtYmVyWzBdID09PSAnLScpIHtcbiAgICAgIHN0YXJ0Kys7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPCBudW1iZXIubGVuZ3RoKSB7XG4gICAgICBpZiAoYmFzZSA9PT0gMTYpIHtcbiAgICAgICAgdGhpcy5fcGFyc2VIZXgobnVtYmVyLCBzdGFydCwgZW5kaWFuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BhcnNlQmFzZShudW1iZXIsIGJhc2UsIHN0YXJ0KTtcbiAgICAgICAgaWYgKGVuZGlhbiA9PT0gJ2xlJykge1xuICAgICAgICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXROdW1iZXIgPSBmdW5jdGlvbiBfaW5pdE51bWJlciAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICBudW1iZXIgPSAtbnVtYmVyO1xuICAgIH1cbiAgICBpZiAobnVtYmVyIDwgMHg0MDAwMDAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gW251bWJlciAmIDB4M2ZmZmZmZl07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChudW1iZXIgPCAweDEwMDAwMDAwMDAwMDAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobnVtYmVyIDwgMHgyMDAwMDAwMDAwMDAwMCk7IC8vIDIgXiA1MyAodW5zYWZlKVxuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZixcbiAgICAgICAgMVxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMztcbiAgICB9XG5cbiAgICBpZiAoZW5kaWFuICE9PSAnbGUnKSByZXR1cm47XG5cbiAgICAvLyBSZXZlcnNlIHRoZSBieXRlc1xuICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXRBcnJheSA9IGZ1bmN0aW9uIF9pbml0QXJyYXkgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgLy8gUGVyaGFwcyBhIFVpbnQ4QXJyYXlcbiAgICBhc3NlcnQodHlwZW9mIG51bWJlci5sZW5ndGggPT09ICdudW1iZXInKTtcbiAgICBpZiAobnVtYmVyLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gWzBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwobnVtYmVyLmxlbmd0aCAvIDMpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGosIHc7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuICAgICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDEsIGogPSAwOyBpID49IDA7IGkgLT0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpIC0gMV0gPDwgOCkgfCAobnVtYmVyW2kgLSAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVuZGlhbiA9PT0gJ2xlJykge1xuICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSArIDFdIDw8IDgpIHwgKG51bWJlcltpICsgMl0gPDwgMTYpO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjQ7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlSGV4NEJpdHMgKHN0cmluZywgaW5kZXgpIHtcbiAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAvLyAnMCcgLSAnOSdcbiAgICBpZiAoYyA+PSA0OCAmJiBjIDw9IDU3KSB7XG4gICAgICByZXR1cm4gYyAtIDQ4O1xuICAgIC8vICdBJyAtICdGJ1xuICAgIH0gZWxzZSBpZiAoYyA+PSA2NSAmJiBjIDw9IDcwKSB7XG4gICAgICByZXR1cm4gYyAtIDU1O1xuICAgIC8vICdhJyAtICdmJ1xuICAgIH0gZWxzZSBpZiAoYyA+PSA5NyAmJiBjIDw9IDEwMikge1xuICAgICAgcmV0dXJuIGMgLSA4NztcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGZhbHNlLCAnSW52YWxpZCBjaGFyYWN0ZXIgaW4gJyArIHN0cmluZyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIZXhCeXRlIChzdHJpbmcsIGxvd2VyQm91bmQsIGluZGV4KSB7XG4gICAgdmFyIHIgPSBwYXJzZUhleDRCaXRzKHN0cmluZywgaW5kZXgpO1xuICAgIGlmIChpbmRleCAtIDEgPj0gbG93ZXJCb3VuZCkge1xuICAgICAgciB8PSBwYXJzZUhleDRCaXRzKHN0cmluZywgaW5kZXggLSAxKSA8PCA0O1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fcGFyc2VIZXggPSBmdW5jdGlvbiBfcGFyc2VIZXggKG51bWJlciwgc3RhcnQsIGVuZGlhbikge1xuICAgIC8vIENyZWF0ZSBwb3NzaWJseSBiaWdnZXIgYXJyYXkgdG8gZW5zdXJlIHRoYXQgaXQgZml0cyB0aGUgbnVtYmVyXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwoKG51bWJlci5sZW5ndGggLSBzdGFydCkgLyA2KTtcbiAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIH1cblxuICAgIC8vIDI0LWJpdHMgY2h1bmtzXG4gICAgdmFyIG9mZiA9IDA7XG4gICAgdmFyIGogPSAwO1xuXG4gICAgdmFyIHc7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuICAgICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDE7IGkgPj0gc3RhcnQ7IGkgLT0gMikge1xuICAgICAgICB3ID0gcGFyc2VIZXhCeXRlKG51bWJlciwgc3RhcnQsIGkpIDw8IG9mZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ICYgMHgzZmZmZmZmO1xuICAgICAgICBpZiAob2ZmID49IDE4KSB7XG4gICAgICAgICAgb2ZmIC09IDE4O1xuICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgPj4+IDI2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZiArPSA4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJzZUxlbmd0aCA9IG51bWJlci5sZW5ndGggLSBzdGFydDtcbiAgICAgIGZvciAoaSA9IHBhcnNlTGVuZ3RoICUgMiA9PT0gMCA/IHN0YXJ0ICsgMSA6IHN0YXJ0OyBpIDwgbnVtYmVyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHcgPSBwYXJzZUhleEJ5dGUobnVtYmVyLCBzdGFydCwgaSkgPDwgb2ZmO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgJiAweDNmZmZmZmY7XG4gICAgICAgIGlmIChvZmYgPj0gMTgpIHtcbiAgICAgICAgICBvZmYgLT0gMTg7XG4gICAgICAgICAgaiArPSAxO1xuICAgICAgICAgIHRoaXMud29yZHNbal0gfD0gdyA+Pj4gMjY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2ZmICs9IDg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlQmFzZSAoc3RyLCBzdGFydCwgZW5kLCBtdWwpIHtcbiAgICB2YXIgciA9IDA7XG4gICAgdmFyIGIgPSAwO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cbiAgICAgIHIgKj0gbXVsO1xuXG4gICAgICAvLyAnYSdcbiAgICAgIGlmIChjID49IDQ5KSB7XG4gICAgICAgIGIgPSBjIC0gNDkgKyAweGE7XG5cbiAgICAgIC8vICdBJ1xuICAgICAgfSBlbHNlIGlmIChjID49IDE3KSB7XG4gICAgICAgIGIgPSBjIC0gMTcgKyAweGE7XG5cbiAgICAgIC8vICcwJyAtICc5J1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYiA9IGM7XG4gICAgICB9XG4gICAgICBhc3NlcnQoYyA+PSAwICYmIGIgPCBtdWwsICdJbnZhbGlkIGNoYXJhY3RlcicpO1xuICAgICAgciArPSBiO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fcGFyc2VCYXNlID0gZnVuY3Rpb24gX3BhcnNlQmFzZSAobnVtYmVyLCBiYXNlLCBzdGFydCkge1xuICAgIC8vIEluaXRpYWxpemUgYXMgemVyb1xuICAgIHRoaXMud29yZHMgPSBbMF07XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuXG4gICAgLy8gRmluZCBsZW5ndGggb2YgbGltYiBpbiBiYXNlXG4gICAgZm9yICh2YXIgbGltYkxlbiA9IDAsIGxpbWJQb3cgPSAxOyBsaW1iUG93IDw9IDB4M2ZmZmZmZjsgbGltYlBvdyAqPSBiYXNlKSB7XG4gICAgICBsaW1iTGVuKys7XG4gICAgfVxuICAgIGxpbWJMZW4tLTtcbiAgICBsaW1iUG93ID0gKGxpbWJQb3cgLyBiYXNlKSB8IDA7XG5cbiAgICB2YXIgdG90YWwgPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XG4gICAgdmFyIG1vZCA9IHRvdGFsICUgbGltYkxlbjtcbiAgICB2YXIgZW5kID0gTWF0aC5taW4odG90YWwsIHRvdGFsIC0gbW9kKSArIHN0YXJ0O1xuXG4gICAgdmFyIHdvcmQgPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBsaW1iTGVuKSB7XG4gICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgaSArIGxpbWJMZW4sIGJhc2UpO1xuXG4gICAgICB0aGlzLmltdWxuKGxpbWJQb3cpO1xuICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb2QgIT09IDApIHtcbiAgICAgIHZhciBwb3cgPSAxO1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIG51bWJlci5sZW5ndGgsIGJhc2UpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbW9kOyBpKyspIHtcbiAgICAgICAgcG93ICo9IGJhc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW11bG4ocG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoZGVzdCkge1xuICAgIGRlc3Qud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzdC53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgfVxuICAgIGRlc3QubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgZGVzdC5uZWdhdGl2ZSA9IHRoaXMubmVnYXRpdmU7XG4gICAgZGVzdC5yZWQgPSB0aGlzLnJlZDtcbiAgfTtcblxuICBmdW5jdGlvbiBtb3ZlIChkZXN0LCBzcmMpIHtcbiAgICBkZXN0LndvcmRzID0gc3JjLndvcmRzO1xuICAgIGRlc3QubGVuZ3RoID0gc3JjLmxlbmd0aDtcbiAgICBkZXN0Lm5lZ2F0aXZlID0gc3JjLm5lZ2F0aXZlO1xuICAgIGRlc3QucmVkID0gc3JjLnJlZDtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uIF9tb3ZlIChkZXN0KSB7XG4gICAgbW92ZShkZXN0LCB0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHIgPSBuZXcgQk4obnVsbCk7XG4gICAgdGhpcy5jb3B5KHIpO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZXhwYW5kID0gZnVuY3Rpb24gX2V4cGFuZCAoc2l6ZSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBSZW1vdmUgbGVhZGluZyBgMGAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLl9zdHJpcCA9IGZ1bmN0aW9uIHN0cmlwICgpIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPiAxICYmIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9ub3JtU2lnbiA9IGZ1bmN0aW9uIF9ub3JtU2lnbiAoKSB7XG4gICAgLy8gLTAgPSAwXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBDaGVjayBTeW1ib2wuZm9yIGJlY2F1c2Ugbm90IGV2ZXJ5d2hlcmUgd2hlcmUgU3ltYm9sIGRlZmluZWRcbiAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N5bWJvbCNCcm93c2VyX2NvbXBhdGliaWxpdHlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIEJOLnByb3RvdHlwZVtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSA9IGluc3BlY3Q7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgQk4ucHJvdG90eXBlLmluc3BlY3QgPSBpbnNwZWN0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBCTi5wcm90b3R5cGUuaW5zcGVjdCA9IGluc3BlY3Q7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgICByZXR1cm4gKHRoaXMucmVkID8gJzxCTi1SOiAnIDogJzxCTjogJykgKyB0aGlzLnRvU3RyaW5nKDE2KSArICc+JztcbiAgfVxuXG4gIC8qXG5cbiAgdmFyIHplcm9zID0gW107XG4gIHZhciBncm91cFNpemVzID0gW107XG4gIHZhciBncm91cEJhc2VzID0gW107XG5cbiAgdmFyIHMgPSAnJztcbiAgdmFyIGkgPSAtMTtcbiAgd2hpbGUgKCsraSA8IEJOLndvcmRTaXplKSB7XG4gICAgemVyb3NbaV0gPSBzO1xuICAgIHMgKz0gJzAnO1xuICB9XG4gIGdyb3VwU2l6ZXNbMF0gPSAwO1xuICBncm91cFNpemVzWzFdID0gMDtcbiAgZ3JvdXBCYXNlc1swXSA9IDA7XG4gIGdyb3VwQmFzZXNbMV0gPSAwO1xuICB2YXIgYmFzZSA9IDIgLSAxO1xuICB3aGlsZSAoKytiYXNlIDwgMzYgKyAxKSB7XG4gICAgdmFyIGdyb3VwU2l6ZSA9IDA7XG4gICAgdmFyIGdyb3VwQmFzZSA9IDE7XG4gICAgd2hpbGUgKGdyb3VwQmFzZSA8ICgxIDw8IEJOLndvcmRTaXplKSAvIGJhc2UpIHtcbiAgICAgIGdyb3VwQmFzZSAqPSBiYXNlO1xuICAgICAgZ3JvdXBTaXplICs9IDE7XG4gICAgfVxuICAgIGdyb3VwU2l6ZXNbYmFzZV0gPSBncm91cFNpemU7XG4gICAgZ3JvdXBCYXNlc1tiYXNlXSA9IGdyb3VwQmFzZTtcbiAgfVxuXG4gICovXG5cbiAgdmFyIHplcm9zID0gW1xuICAgICcnLFxuICAgICcwJyxcbiAgICAnMDAnLFxuICAgICcwMDAnLFxuICAgICcwMDAwJyxcbiAgICAnMDAwMDAnLFxuICAgICcwMDAwMDAnLFxuICAgICcwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICBdO1xuXG4gIHZhciBncm91cFNpemVzID0gW1xuICAgIDAsIDAsXG4gICAgMjUsIDE2LCAxMiwgMTEsIDEwLCA5LCA4LFxuICAgIDgsIDcsIDcsIDcsIDcsIDYsIDYsXG4gICAgNiwgNiwgNiwgNiwgNiwgNSwgNSxcbiAgICA1LCA1LCA1LCA1LCA1LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDVcbiAgXTtcblxuICB2YXIgZ3JvdXBCYXNlcyA9IFtcbiAgICAwLCAwLFxuICAgIDMzNTU0NDMyLCA0MzA0NjcyMSwgMTY3NzcyMTYsIDQ4ODI4MTI1LCA2MDQ2NjE3NiwgNDAzNTM2MDcsIDE2Nzc3MjE2LFxuICAgIDQzMDQ2NzIxLCAxMDAwMDAwMCwgMTk0ODcxNzEsIDM1ODMxODA4LCA2Mjc0ODUxNywgNzUyOTUzNiwgMTEzOTA2MjUsXG4gICAgMTY3NzcyMTYsIDI0MTM3NTY5LCAzNDAxMjIyNCwgNDcwNDU4ODEsIDY0MDAwMDAwLCA0MDg0MTAxLCA1MTUzNjMyLFxuICAgIDY0MzYzNDMsIDc5NjI2MjQsIDk3NjU2MjUsIDExODgxMzc2LCAxNDM0ODkwNywgMTcyMTAzNjgsIDIwNTExMTQ5LFxuICAgIDI0MzAwMDAwLCAyODYyOTE1MSwgMzM1NTQ0MzIsIDM5MTM1MzkzLCA0NTQzNTQyNCwgNTI1MjE4NzUsIDYwNDY2MTc2XG4gIF07XG5cbiAgQk4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKGJhc2UsIHBhZGRpbmcpIHtcbiAgICBiYXNlID0gYmFzZSB8fCAxMDtcbiAgICBwYWRkaW5nID0gcGFkZGluZyB8IDAgfHwgMTtcblxuICAgIHZhciBvdXQ7XG4gICAgaWYgKGJhc2UgPT09IDE2IHx8IGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBvdXQgPSAnJztcbiAgICAgIHZhciBvZmYgPSAwO1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV07XG4gICAgICAgIHZhciB3b3JkID0gKCgodyA8PCBvZmYpIHwgY2FycnkpICYgMHhmZmZmZmYpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgY2FycnkgPSAodyA+Pj4gKDI0IC0gb2ZmKSkgJiAweGZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYXJyeSAhPT0gMCB8fCBpICE9PSB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBvdXQgPSB6ZXJvc1s2IC0gd29yZC5sZW5ndGhdICsgd29yZCArIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgPSB3b3JkICsgb3V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgICAgb3V0ID0gY2FycnkudG9TdHJpbmcoMTYpICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpIHtcbiAgICAgIC8vIHZhciBncm91cFNpemUgPSBNYXRoLmZsb29yKEJOLndvcmRTaXplICogTWF0aC5MTjIgLyBNYXRoLmxvZyhiYXNlKSk7XG4gICAgICB2YXIgZ3JvdXBTaXplID0gZ3JvdXBTaXplc1tiYXNlXTtcbiAgICAgIC8vIHZhciBncm91cEJhc2UgPSBNYXRoLnBvdyhiYXNlLCBncm91cFNpemUpO1xuICAgICAgdmFyIGdyb3VwQmFzZSA9IGdyb3VwQmFzZXNbYmFzZV07XG4gICAgICBvdXQgPSAnJztcbiAgICAgIHZhciBjID0gdGhpcy5jbG9uZSgpO1xuICAgICAgYy5uZWdhdGl2ZSA9IDA7XG4gICAgICB3aGlsZSAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgdmFyIHIgPSBjLm1vZHJuKGdyb3VwQmFzZSkudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgIGMgPSBjLmlkaXZuKGdyb3VwQmFzZSk7XG5cbiAgICAgICAgaWYgKCFjLmlzWmVybygpKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbZ3JvdXBTaXplIC0gci5sZW5ndGhdICsgciArIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgPSByICsgb3V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBhc3NlcnQoZmFsc2UsICdCYXNlIHNob3VsZCBiZSBiZXR3ZWVuIDIgYW5kIDM2Jyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIgKCkge1xuICAgIHZhciByZXQgPSB0aGlzLndvcmRzWzBdO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0ICs9IHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA9PT0gMyAmJiB0aGlzLndvcmRzWzJdID09PSAweDAxKSB7XG4gICAgICAvLyBOT1RFOiBhdCB0aGlzIHN0YWdlIGl0IGlzIGtub3duIHRoYXQgdGhlIHRvcCBiaXQgaXMgc2V0XG4gICAgICByZXQgKz0gMHgxMDAwMDAwMDAwMDAwMCArICh0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gMikge1xuICAgICAgYXNzZXJ0KGZhbHNlLCAnTnVtYmVyIGNhbiBvbmx5IHNhZmVseSBzdG9yZSB1cCB0byA1MyBiaXRzJyk7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgPyAtcmV0IDogcmV0O1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKDE2LCAyKTtcbiAgfTtcblxuICBpZiAoQnVmZmVyKSB7XG4gICAgQk4ucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShCdWZmZXIsIGVuZGlhbiwgbGVuZ3RoKTtcbiAgICB9O1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5IChlbmRpYW4sIGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEFycmF5LCBlbmRpYW4sIGxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIGFsbG9jYXRlID0gZnVuY3Rpb24gYWxsb2NhdGUgKEFycmF5VHlwZSwgc2l6ZSkge1xuICAgIGlmIChBcnJheVR5cGUuYWxsb2NVbnNhZmUpIHtcbiAgICAgIHJldHVybiBBcnJheVR5cGUuYWxsb2NVbnNhZmUoc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXlUeXBlKHNpemUpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0FycmF5TGlrZSA9IGZ1bmN0aW9uIHRvQXJyYXlMaWtlIChBcnJheVR5cGUsIGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgdGhpcy5fc3RyaXAoKTtcblxuICAgIHZhciBieXRlTGVuZ3RoID0gdGhpcy5ieXRlTGVuZ3RoKCk7XG4gICAgdmFyIHJlcUxlbmd0aCA9IGxlbmd0aCB8fCBNYXRoLm1heCgxLCBieXRlTGVuZ3RoKTtcbiAgICBhc3NlcnQoYnl0ZUxlbmd0aCA8PSByZXFMZW5ndGgsICdieXRlIGFycmF5IGxvbmdlciB0aGFuIGRlc2lyZWQgbGVuZ3RoJyk7XG4gICAgYXNzZXJ0KHJlcUxlbmd0aCA+IDAsICdSZXF1ZXN0ZWQgYXJyYXkgbGVuZ3RoIDw9IDAnKTtcblxuICAgIHZhciByZXMgPSBhbGxvY2F0ZShBcnJheVR5cGUsIHJlcUxlbmd0aCk7XG4gICAgdmFyIHBvc3RmaXggPSBlbmRpYW4gPT09ICdsZScgPyAnTEUnIDogJ0JFJztcbiAgICB0aGlzWydfdG9BcnJheUxpa2UnICsgcG9zdGZpeF0ocmVzLCBieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fdG9BcnJheUxpa2VMRSA9IGZ1bmN0aW9uIF90b0FycmF5TGlrZUxFIChyZXMsIGJ5dGVMZW5ndGgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSAwO1xuICAgIHZhciBjYXJyeSA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgc2hpZnQgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdvcmQgPSAodGhpcy53b3Jkc1tpXSA8PCBzaGlmdCkgfCBjYXJyeTtcblxuICAgICAgcmVzW3Bvc2l0aW9uKytdID0gd29yZCAmIDB4ZmY7XG4gICAgICBpZiAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbisrXSA9ICh3b3JkID4+IDgpICYgMHhmZjtcbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uKytdID0gKHdvcmQgPj4gMTYpICYgMHhmZjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNoaWZ0ID09PSA2KSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXNbcG9zaXRpb24rK10gPSAod29yZCA+PiAyNCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3b3JkID4+PiAyNDtcbiAgICAgICAgc2hpZnQgKz0gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICByZXNbcG9zaXRpb24rK10gPSBjYXJyeTtcblxuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICByZXNbcG9zaXRpb24rK10gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX3RvQXJyYXlMaWtlQkUgPSBmdW5jdGlvbiBfdG9BcnJheUxpa2VCRSAocmVzLCBieXRlTGVuZ3RoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBzaGlmdCA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd29yZCA9ICh0aGlzLndvcmRzW2ldIDw8IHNoaWZ0KSB8IGNhcnJ5O1xuXG4gICAgICByZXNbcG9zaXRpb24tLV0gPSB3b3JkICYgMHhmZjtcbiAgICAgIGlmIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbi0tXSA9ICh3b3JkID4+IDgpICYgMHhmZjtcbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbi0tXSA9ICh3b3JkID4+IDE2KSAmIDB4ZmY7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaGlmdCA9PT0gNikge1xuICAgICAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgICAgIHJlc1twb3NpdGlvbi0tXSA9ICh3b3JkID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgICBzaGlmdCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXJyeSA9IHdvcmQgPj4+IDI0O1xuICAgICAgICBzaGlmdCArPSAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICByZXNbcG9zaXRpb24tLV0gPSBjYXJyeTtcblxuICAgICAgd2hpbGUgKHBvc2l0aW9uID49IDApIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaWYgKE1hdGguY2x6MzIpIHtcbiAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcbiAgICAgIHJldHVybiAzMiAtIE1hdGguY2x6MzIodyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcbiAgICAgIHZhciB0ID0gdztcbiAgICAgIHZhciByID0gMDtcbiAgICAgIGlmICh0ID49IDB4MTAwMCkge1xuICAgICAgICByICs9IDEzO1xuICAgICAgICB0ID4+Pj0gMTM7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDQwKSB7XG4gICAgICAgIHIgKz0gNztcbiAgICAgICAgdCA+Pj49IDc7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDgpIHtcbiAgICAgICAgciArPSA0O1xuICAgICAgICB0ID4+Pj0gNDtcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4MDIpIHtcbiAgICAgICAgciArPSAyO1xuICAgICAgICB0ID4+Pj0gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByICsgdDtcbiAgICB9O1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl96ZXJvQml0cyA9IGZ1bmN0aW9uIF96ZXJvQml0cyAodykge1xuICAgIC8vIFNob3J0LWN1dFxuICAgIGlmICh3ID09PSAwKSByZXR1cm4gMjY7XG5cbiAgICB2YXIgdCA9IHc7XG4gICAgdmFyIHIgPSAwO1xuICAgIGlmICgodCAmIDB4MWZmZikgPT09IDApIHtcbiAgICAgIHIgKz0gMTM7XG4gICAgICB0ID4+Pj0gMTM7XG4gICAgfVxuICAgIGlmICgodCAmIDB4N2YpID09PSAwKSB7XG4gICAgICByICs9IDc7XG4gICAgICB0ID4+Pj0gNztcbiAgICB9XG4gICAgaWYgKCh0ICYgMHhmKSA9PT0gMCkge1xuICAgICAgciArPSA0O1xuICAgICAgdCA+Pj49IDQ7XG4gICAgfVxuICAgIGlmICgodCAmIDB4MykgPT09IDApIHtcbiAgICAgIHIgKz0gMjtcbiAgICAgIHQgPj4+PSAyO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDEpID09PSAwKSB7XG4gICAgICByKys7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIC8vIFJldHVybiBudW1iZXIgb2YgdXNlZCBiaXRzIGluIGEgQk5cbiAgQk4ucHJvdG90eXBlLmJpdExlbmd0aCA9IGZ1bmN0aW9uIGJpdExlbmd0aCAoKSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGhpID0gdGhpcy5fY291bnRCaXRzKHcpO1xuICAgIHJldHVybiAodGhpcy5sZW5ndGggLSAxKSAqIDI2ICsgaGk7XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9CaXRBcnJheSAobnVtKSB7XG4gICAgdmFyIHcgPSBuZXcgQXJyYXkobnVtLmJpdExlbmd0aCgpKTtcblxuICAgIGZvciAodmFyIGJpdCA9IDA7IGJpdCA8IHcubGVuZ3RoOyBiaXQrKykge1xuICAgICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuICAgICAgd1tiaXRdID0gKG51bS53b3Jkc1tvZmZdID4+PiB3Yml0KSAmIDB4MDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHc7XG4gIH1cblxuICAvLyBOdW1iZXIgb2YgdHJhaWxpbmcgemVybyBiaXRzXG4gIEJOLnByb3RvdHlwZS56ZXJvQml0cyA9IGZ1bmN0aW9uIHplcm9CaXRzICgpIHtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIDA7XG5cbiAgICB2YXIgciA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYiA9IHRoaXMuX3plcm9CaXRzKHRoaXMud29yZHNbaV0pO1xuICAgICAgciArPSBiO1xuICAgICAgaWYgKGIgIT09IDI2KSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiBieXRlTGVuZ3RoICgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuYml0TGVuZ3RoKCkgLyA4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9Ud29zID0gZnVuY3Rpb24gdG9Ud29zICh3aWR0aCkge1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5hYnMoKS5pbm90bih3aWR0aCkuaWFkZG4oMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21Ud29zID0gZnVuY3Rpb24gZnJvbVR3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMudGVzdG4od2lkdGggLSAxKSkge1xuICAgICAgcmV0dXJuIHRoaXMubm90bih3aWR0aCkuaWFkZG4oMSkuaW5lZygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc05lZyA9IGZ1bmN0aW9uIGlzTmVnICgpIHtcbiAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMDtcbiAgfTtcblxuICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5lZygpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbmVnID0gZnVuY3Rpb24gaW5lZyAoKSB7XG4gICAgaWYgKCF0aGlzLmlzWmVybygpKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1b3IgPSBmdW5jdGlvbiBpdW9yIChudW0pIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gfCBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlvciA9IGZ1bmN0aW9uIGlvciAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVvcihudW0pO1xuICB9O1xuXG4gIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pb3IodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVvciA9IGZ1bmN0aW9uIHVvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdW9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1b3IodGhpcyk7XG4gIH07XG5cbiAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdWFuZCA9IGZ1bmN0aW9uIGl1YW5kIChudW0pIHtcbiAgICAvLyBiID0gbWluLWxlbmd0aChudW0sIHRoaXMpXG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSAmIG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGIubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlhbmQgPSBmdW5jdGlvbiBpYW5kIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdWFuZChudW0pO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFuZCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudWFuZCA9IGZ1bmN0aW9uIHVhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVhbmQodGhpcyk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXhvciA9IGZ1bmN0aW9uIGl1eG9yIChudW0pIHtcbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGE7XG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXSBeIGIud29yZHNbaV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMgIT09IGEpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLml4b3IgPSBmdW5jdGlvbiBpeG9yIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXhvcihudW0pO1xuICB9O1xuXG4gIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml4b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXhvcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXhvciA9IGZ1bmN0aW9uIHV4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXV4b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXV4b3IodGhpcyk7XG4gIH07XG5cbiAgLy8gTm90IGBgdGhpc2BgIHdpdGggYGB3aWR0aGBgIGJpdHdpZHRoXG4gIEJOLnByb3RvdHlwZS5pbm90biA9IGZ1bmN0aW9uIGlub3RuICh3aWR0aCkge1xuICAgIGFzc2VydCh0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInICYmIHdpZHRoID49IDApO1xuXG4gICAgdmFyIGJ5dGVzTmVlZGVkID0gTWF0aC5jZWlsKHdpZHRoIC8gMjYpIHwgMDtcbiAgICB2YXIgYml0c0xlZnQgPSB3aWR0aCAlIDI2O1xuXG4gICAgLy8gRXh0ZW5kIHRoZSBidWZmZXIgd2l0aCBsZWFkaW5nIHplcm9lc1xuICAgIHRoaXMuX2V4cGFuZChieXRlc05lZWRlZCk7XG5cbiAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG4gICAgICBieXRlc05lZWRlZC0tO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBjb21wbGV0ZSB3b3Jkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXNOZWVkZWQ7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB0aGUgcmVzaWR1ZVxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmICgweDNmZmZmZmYgPj4gKDI2IC0gYml0c0xlZnQpKTtcbiAgICB9XG5cbiAgICAvLyBBbmQgcmVtb3ZlIGxlYWRpbmcgemVyb2VzXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm5vdG4gPSBmdW5jdGlvbiBub3RuICh3aWR0aCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5vdG4od2lkdGgpO1xuICB9O1xuXG4gIC8vIFNldCBgYml0YCBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnNldG4gPSBmdW5jdGlvbiBzZXRuIChiaXQsIHZhbCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG5cbiAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuICAgIHRoaXMuX2V4cGFuZChvZmYgKyAxKTtcblxuICAgIGlmICh2YWwpIHtcbiAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSB8ICgxIDw8IHdiaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gJiB+KDEgPDwgd2JpdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKG51bSkge1xuICAgIHZhciByO1xuXG4gICAgLy8gbmVnYXRpdmUgKyBwb3NpdGl2ZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblxuICAgIC8vIHBvc2l0aXZlICsgbmVnYXRpdmVcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aF0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgLy8gQ29weSB0aGUgcmVzdCBvZiB0aGUgd29yZHNcbiAgICB9IGVsc2UgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG51bSkge1xuICAgIHZhciByZXM7XG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCAmJiB0aGlzLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gdGhpcy5zdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2UgaWYgKG51bS5uZWdhdGl2ZSA9PT0gMCAmJiB0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IG51bS5zdWIodGhpcyk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkKG51bSk7XG5cbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFkZCh0aGlzKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKG51bSkge1xuICAgIC8vIHRoaXMgLSAoLW51bSkgPSB0aGlzICsgbnVtXG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHZhciByID0gdGhpcy5pYWRkKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG5cbiAgICAvLyAtdGhpcyAtIG51bSA9IC0odGhpcyArIG51bSlcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZVxuICAgIHZhciBjbXAgPSB0aGlzLmNtcChudW0pO1xuXG4gICAgLy8gT3B0aW1pemF0aW9uIC0gemVyb2lmeVxuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBhID4gYlxuICAgIHZhciBhLCBiO1xuICAgIGlmIChjbXAgPiAwKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgLSAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gQ29weSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIGlmIChjYXJyeSA9PT0gMCAmJiBpIDwgYS5sZW5ndGggJiYgYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkpO1xuXG4gICAgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1YihudW0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNtYWxsTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgICB2YXIgbGVuID0gKHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aCkgfCAwO1xuICAgIG91dC5sZW5ndGggPSBsZW47XG4gICAgbGVuID0gKGxlbiAtIDEpIHwgMDtcblxuICAgIC8vIFBlZWwgb25lIGl0ZXJhdGlvbiAoY29tcGlsZXIgY2FuJ3QgZG8gaXQsIGJlY2F1c2Ugb2YgY29kZSBjb21wbGV4aXR5KVxuICAgIHZhciBhID0gc2VsZi53b3Jkc1swXSB8IDA7XG4gICAgdmFyIGIgPSBudW0ud29yZHNbMF0gfCAwO1xuICAgIHZhciByID0gYSAqIGI7XG5cbiAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgIHZhciBjYXJyeSA9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgb3V0LndvcmRzWzBdID0gbG87XG5cbiAgICBmb3IgKHZhciBrID0gMTsgayA8IGxlbjsgaysrKSB7XG4gICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgICAgdmFyIG5jYXJyeSA9IGNhcnJ5ID4+PiAyNjtcbiAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgIHZhciBpID0gKGsgLSBqKSB8IDA7XG4gICAgICAgIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICAgIHIgPSBhICogYiArIHJ3b3JkO1xuICAgICAgICBuY2FycnkgKz0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICAgICAgcndvcmQgPSByICYgMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQgfCAwO1xuICAgICAgY2FycnkgPSBuY2FycnkgfCAwO1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5IHwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuX3N0cmlwKCk7XG4gIH1cblxuICAvLyBUT0RPKGluZHV0bnkpOiBpdCBtYXkgYmUgcmVhc29uYWJsZSB0byBvbWl0IGl0IGZvciB1c2VycyB3aG8gZG9uJ3QgbmVlZFxuICAvLyB0byB3b3JrIHdpdGggMjU2LWJpdCBudW1iZXJzLCBvdGhlcndpc2UgaXQgZ2l2ZXMgMjAlIGltcHJvdmVtZW50IGZvciAyNTYtYml0XG4gIC8vIG11bHRpcGxpY2F0aW9uIChsaWtlIGVsbGlwdGljIHNlY3AyNTZrMSkuXG4gIHZhciBjb21iMTBNdWxUbyA9IGZ1bmN0aW9uIGNvbWIxME11bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIHZhciBhID0gc2VsZi53b3JkcztcbiAgICB2YXIgYiA9IG51bS53b3JkcztcbiAgICB2YXIgbyA9IG91dC53b3JkcztcbiAgICB2YXIgYyA9IDA7XG4gICAgdmFyIGxvO1xuICAgIHZhciBtaWQ7XG4gICAgdmFyIGhpO1xuICAgIHZhciBhMCA9IGFbMF0gfCAwO1xuICAgIHZhciBhbDAgPSBhMCAmIDB4MWZmZjtcbiAgICB2YXIgYWgwID0gYTAgPj4+IDEzO1xuICAgIHZhciBhMSA9IGFbMV0gfCAwO1xuICAgIHZhciBhbDEgPSBhMSAmIDB4MWZmZjtcbiAgICB2YXIgYWgxID0gYTEgPj4+IDEzO1xuICAgIHZhciBhMiA9IGFbMl0gfCAwO1xuICAgIHZhciBhbDIgPSBhMiAmIDB4MWZmZjtcbiAgICB2YXIgYWgyID0gYTIgPj4+IDEzO1xuICAgIHZhciBhMyA9IGFbM10gfCAwO1xuICAgIHZhciBhbDMgPSBhMyAmIDB4MWZmZjtcbiAgICB2YXIgYWgzID0gYTMgPj4+IDEzO1xuICAgIHZhciBhNCA9IGFbNF0gfCAwO1xuICAgIHZhciBhbDQgPSBhNCAmIDB4MWZmZjtcbiAgICB2YXIgYWg0ID0gYTQgPj4+IDEzO1xuICAgIHZhciBhNSA9IGFbNV0gfCAwO1xuICAgIHZhciBhbDUgPSBhNSAmIDB4MWZmZjtcbiAgICB2YXIgYWg1ID0gYTUgPj4+IDEzO1xuICAgIHZhciBhNiA9IGFbNl0gfCAwO1xuICAgIHZhciBhbDYgPSBhNiAmIDB4MWZmZjtcbiAgICB2YXIgYWg2ID0gYTYgPj4+IDEzO1xuICAgIHZhciBhNyA9IGFbN10gfCAwO1xuICAgIHZhciBhbDcgPSBhNyAmIDB4MWZmZjtcbiAgICB2YXIgYWg3ID0gYTcgPj4+IDEzO1xuICAgIHZhciBhOCA9IGFbOF0gfCAwO1xuICAgIHZhciBhbDggPSBhOCAmIDB4MWZmZjtcbiAgICB2YXIgYWg4ID0gYTggPj4+IDEzO1xuICAgIHZhciBhOSA9IGFbOV0gfCAwO1xuICAgIHZhciBhbDkgPSBhOSAmIDB4MWZmZjtcbiAgICB2YXIgYWg5ID0gYTkgPj4+IDEzO1xuICAgIHZhciBiMCA9IGJbMF0gfCAwO1xuICAgIHZhciBibDAgPSBiMCAmIDB4MWZmZjtcbiAgICB2YXIgYmgwID0gYjAgPj4+IDEzO1xuICAgIHZhciBiMSA9IGJbMV0gfCAwO1xuICAgIHZhciBibDEgPSBiMSAmIDB4MWZmZjtcbiAgICB2YXIgYmgxID0gYjEgPj4+IDEzO1xuICAgIHZhciBiMiA9IGJbMl0gfCAwO1xuICAgIHZhciBibDIgPSBiMiAmIDB4MWZmZjtcbiAgICB2YXIgYmgyID0gYjIgPj4+IDEzO1xuICAgIHZhciBiMyA9IGJbM10gfCAwO1xuICAgIHZhciBibDMgPSBiMyAmIDB4MWZmZjtcbiAgICB2YXIgYmgzID0gYjMgPj4+IDEzO1xuICAgIHZhciBiNCA9IGJbNF0gfCAwO1xuICAgIHZhciBibDQgPSBiNCAmIDB4MWZmZjtcbiAgICB2YXIgYmg0ID0gYjQgPj4+IDEzO1xuICAgIHZhciBiNSA9IGJbNV0gfCAwO1xuICAgIHZhciBibDUgPSBiNSAmIDB4MWZmZjtcbiAgICB2YXIgYmg1ID0gYjUgPj4+IDEzO1xuICAgIHZhciBiNiA9IGJbNl0gfCAwO1xuICAgIHZhciBibDYgPSBiNiAmIDB4MWZmZjtcbiAgICB2YXIgYmg2ID0gYjYgPj4+IDEzO1xuICAgIHZhciBiNyA9IGJbN10gfCAwO1xuICAgIHZhciBibDcgPSBiNyAmIDB4MWZmZjtcbiAgICB2YXIgYmg3ID0gYjcgPj4+IDEzO1xuICAgIHZhciBiOCA9IGJbOF0gfCAwO1xuICAgIHZhciBibDggPSBiOCAmIDB4MWZmZjtcbiAgICB2YXIgYmg4ID0gYjggPj4+IDEzO1xuICAgIHZhciBiOSA9IGJbOV0gfCAwO1xuICAgIHZhciBibDkgPSBiOSAmIDB4MWZmZjtcbiAgICB2YXIgYmg5ID0gYjkgPj4+IDEzO1xuXG4gICAgb3V0Lm5lZ2F0aXZlID0gc2VsZi5uZWdhdGl2ZSBeIG51bS5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0gMTk7XG4gICAgLyogayA9IDAgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDAsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMCwgYmgwKTtcbiAgICB2YXIgdzAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcwID4+PiAyNikpIHwgMDtcbiAgICB3MCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDEsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDEpKSB8IDA7XG4gICAgdmFyIHcxID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MSA+Pj4gMjYpKSB8IDA7XG4gICAgdzEgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwyLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDIsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDIsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMikpIHwgMDtcbiAgICB2YXIgdzIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcyID4+PiAyNikpIHwgMDtcbiAgICB3MiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDMgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDMsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMywgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMykpIHwgMDtcbiAgICB2YXIgdzMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHczID4+PiAyNikpIHwgMDtcbiAgICB3MyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDQgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDQsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNCwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDQpKSB8IDA7XG4gICAgdmFyIHc0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NCA+Pj4gMjYpKSB8IDA7XG4gICAgdzQgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw1LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDUsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDUsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNSkpIHwgMDtcbiAgICB2YXIgdzUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc1ID4+PiAyNikpIHwgMDtcbiAgICB3NSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDYgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDYsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNiwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNikpIHwgMDtcbiAgICB2YXIgdzYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc2ID4+PiAyNikpIHwgMDtcbiAgICB3NiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDcgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDcsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNywgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNywgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDcpKSB8IDA7XG4gICAgdmFyIHc3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NyA+Pj4gMjYpKSB8IDA7XG4gICAgdzcgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw4LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDgsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDgsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOCkpIHwgMDtcbiAgICB2YXIgdzggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc4ID4+PiAyNikpIHwgMDtcbiAgICB3OCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDkgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzkgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc5ID4+PiAyNikpIHwgMDtcbiAgICB3OSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDEpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMSk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTAgPj4+IDI2KSkgfCAwO1xuICAgIHcxMCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDExICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDIpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMSA+Pj4gMjYpKSB8IDA7XG4gICAgdzExICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTIgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMyk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgzKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwzKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgzKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTIgPj4+IDI2KSkgfCAwO1xuICAgIHcxMiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDQpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEzID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTMgPj4+IDI2KSkgfCAwO1xuICAgIHcxMyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDUpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNSk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNCA+Pj4gMjYpKSB8IDA7XG4gICAgdzE0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTUgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNik7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg2KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw2KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg2KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTUgPj4+IDI2KSkgfCAwO1xuICAgIHcxNSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDcpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTYgPj4+IDI2KSkgfCAwO1xuICAgIHcxNiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDgpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNyA+Pj4gMjYpKSB8IDA7XG4gICAgdzE3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTggKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg5KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw5KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg5KTtcbiAgICB2YXIgdzE4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTggPj4+IDI2KSkgfCAwO1xuICAgIHcxOCAmPSAweDNmZmZmZmY7XG4gICAgb1swXSA9IHcwO1xuICAgIG9bMV0gPSB3MTtcbiAgICBvWzJdID0gdzI7XG4gICAgb1szXSA9IHczO1xuICAgIG9bNF0gPSB3NDtcbiAgICBvWzVdID0gdzU7XG4gICAgb1s2XSA9IHc2O1xuICAgIG9bN10gPSB3NztcbiAgICBvWzhdID0gdzg7XG4gICAgb1s5XSA9IHc5O1xuICAgIG9bMTBdID0gdzEwO1xuICAgIG9bMTFdID0gdzExO1xuICAgIG9bMTJdID0gdzEyO1xuICAgIG9bMTNdID0gdzEzO1xuICAgIG9bMTRdID0gdzE0O1xuICAgIG9bMTVdID0gdzE1O1xuICAgIG9bMTZdID0gdzE2O1xuICAgIG9bMTddID0gdzE3O1xuICAgIG9bMThdID0gdzE4O1xuICAgIGlmIChjICE9PSAwKSB7XG4gICAgICBvWzE5XSA9IGM7XG4gICAgICBvdXQubGVuZ3RoKys7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH07XG5cbiAgLy8gUG9seWZpbGwgY29tYlxuICBpZiAoIU1hdGguaW11bCkge1xuICAgIGNvbWIxME11bFRvID0gc21hbGxNdWxUbztcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpZ011bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aDtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgdmFyIGhuY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3V0Lmxlbmd0aCAtIDE7IGsrKykge1xuICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICAgIHZhciBuY2FycnkgPSBobmNhcnJ5O1xuICAgICAgaG5jYXJyeSA9IDA7XG4gICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgICB2YXIgaSA9IGsgLSBqO1xuICAgICAgICB2YXIgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICB2YXIgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICAgIHZhciByID0gYSAqIGI7XG5cbiAgICAgICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArICgociAvIDB4NDAwMDAwMCkgfCAwKSkgfCAwO1xuICAgICAgICBsbyA9IChsbyArIHJ3b3JkKSB8IDA7XG4gICAgICAgIHJ3b3JkID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAobG8gPj4+IDI2KSkgfCAwO1xuXG4gICAgICAgIGhuY2FycnkgKz0gbmNhcnJ5ID4+PiAyNjtcbiAgICAgICAgbmNhcnJ5ICY9IDB4M2ZmZmZmZjtcbiAgICAgIH1cbiAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkO1xuICAgICAgY2FycnkgPSBuY2Fycnk7XG4gICAgICBuY2FycnkgPSBobmNhcnJ5O1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5fc3RyaXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGp1bWJvTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgLy8gVGVtcG9yYXJ5IGRpc2FibGUsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy9pc3N1ZXMvMjExXG4gICAgLy8gdmFyIGZmdG0gPSBuZXcgRkZUTSgpO1xuICAgIC8vIHJldHVybiBmZnRtLm11bHAoc2VsZiwgbnVtLCBvdXQpO1xuICAgIHJldHVybiBiaWdNdWxUbyhzZWxmLCBudW0sIG91dCk7XG4gIH1cblxuICBCTi5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbiBtdWxUbyAobnVtLCBvdXQpIHtcbiAgICB2YXIgcmVzO1xuICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aCArIG51bS5sZW5ndGg7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxMCAmJiBudW0ubGVuZ3RoID09PSAxMCkge1xuICAgICAgcmVzID0gY29tYjEwTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSBpZiAobGVuIDwgNjMpIHtcbiAgICAgIHJlcyA9IHNtYWxsTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSBpZiAobGVuIDwgMTAyNCkge1xuICAgICAgcmVzID0gYmlnTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvb2xleS1UdWtleSBhbGdvcml0aG0gZm9yIEZGVFxuICAvLyBzbGlnaHRseSByZXZpc2l0ZWQgdG8gcmVseSBvbiBsb29waW5nIGluc3RlYWQgb2YgcmVjdXJzaW9uXG5cbiAgZnVuY3Rpb24gRkZUTSAoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuXG4gIEZGVE0ucHJvdG90eXBlLm1ha2VSQlQgPSBmdW5jdGlvbiBtYWtlUkJUIChOKSB7XG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGwgPSBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyhOKSAtIDE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHRbaV0gPSB0aGlzLnJldkJpbihpLCBsLCBOKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGJpbmFyeS1yZXZlcnNlZCByZXByZXNlbnRhdGlvbiBvZiBgeGBcbiAgRkZUTS5wcm90b3R5cGUucmV2QmluID0gZnVuY3Rpb24gcmV2QmluICh4LCBsLCBOKSB7XG4gICAgaWYgKHggPT09IDAgfHwgeCA9PT0gTiAtIDEpIHJldHVybiB4O1xuXG4gICAgdmFyIHJiID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgcmIgfD0gKHggJiAxKSA8PCAobCAtIGkgLSAxKTtcbiAgICAgIHggPj49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJiO1xuICB9O1xuXG4gIC8vIFBlcmZvcm1zIFwidHdlZWRsaW5nXCIgcGhhc2UsIHRoZXJlZm9yZSAnZW11bGF0aW5nJ1xuICAvLyBiZWhhdmlvdXIgb2YgdGhlIHJlY3Vyc2l2ZSBhbGdvcml0aG1cbiAgRkZUTS5wcm90b3R5cGUucGVybXV0ZSA9IGZ1bmN0aW9uIHBlcm11dGUgKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgcnR3c1tpXSA9IHJ3c1tyYnRbaV1dO1xuICAgICAgaXR3c1tpXSA9IGl3c1tyYnRbaV1dO1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0gKHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOLCByYnQpIHtcbiAgICB0aGlzLnBlcm11dGUocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTik7XG5cbiAgICBmb3IgKHZhciBzID0gMTsgcyA8IE47IHMgPDw9IDEpIHtcbiAgICAgIHZhciBsID0gcyA8PCAxO1xuXG4gICAgICB2YXIgcnR3ZGYgPSBNYXRoLmNvcygyICogTWF0aC5QSSAvIGwpO1xuICAgICAgdmFyIGl0d2RmID0gTWF0aC5zaW4oMiAqIE1hdGguUEkgLyBsKTtcblxuICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBOOyBwICs9IGwpIHtcbiAgICAgICAgdmFyIHJ0d2RmXyA9IHJ0d2RmO1xuICAgICAgICB2YXIgaXR3ZGZfID0gaXR3ZGY7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzOyBqKyspIHtcbiAgICAgICAgICB2YXIgcmUgPSBydHdzW3AgKyBqXTtcbiAgICAgICAgICB2YXIgaWUgPSBpdHdzW3AgKyBqXTtcblxuICAgICAgICAgIHZhciBybyA9IHJ0d3NbcCArIGogKyBzXTtcbiAgICAgICAgICB2YXIgaW8gPSBpdHdzW3AgKyBqICsgc107XG5cbiAgICAgICAgICB2YXIgcnggPSBydHdkZl8gKiBybyAtIGl0d2RmXyAqIGlvO1xuXG4gICAgICAgICAgaW8gPSBydHdkZl8gKiBpbyArIGl0d2RmXyAqIHJvO1xuICAgICAgICAgIHJvID0gcng7XG5cbiAgICAgICAgICBydHdzW3AgKyBqXSA9IHJlICsgcm87XG4gICAgICAgICAgaXR3c1twICsgal0gPSBpZSArIGlvO1xuXG4gICAgICAgICAgcnR3c1twICsgaiArIHNdID0gcmUgLSBybztcbiAgICAgICAgICBpdHdzW3AgKyBqICsgc10gPSBpZSAtIGlvO1xuXG4gICAgICAgICAgLyoganNoaW50IG1heGRlcHRoIDogZmFsc2UgKi9cbiAgICAgICAgICBpZiAoaiAhPT0gbCkge1xuICAgICAgICAgICAgcnggPSBydHdkZiAqIHJ0d2RmXyAtIGl0d2RmICogaXR3ZGZfO1xuXG4gICAgICAgICAgICBpdHdkZl8gPSBydHdkZiAqIGl0d2RmXyArIGl0d2RmICogcnR3ZGZfO1xuICAgICAgICAgICAgcnR3ZGZfID0gcng7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmd1ZXNzTGVuMTNiID0gZnVuY3Rpb24gZ3Vlc3NMZW4xM2IgKG4sIG0pIHtcbiAgICB2YXIgTiA9IE1hdGgubWF4KG0sIG4pIHwgMTtcbiAgICB2YXIgb2RkID0gTiAmIDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoTiA9IE4gLyAyIHwgMDsgTjsgTiA9IE4gPj4+IDEpIHtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gMSA8PCBpICsgMSArIG9kZDtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5jb25qdWdhdGUgPSBmdW5jdGlvbiBjb25qdWdhdGUgKHJ3cywgaXdzLCBOKSB7XG4gICAgaWYgKE4gPD0gMSkgcmV0dXJuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgICB2YXIgdCA9IHJ3c1tpXTtcblxuICAgICAgcndzW2ldID0gcndzW04gLSBpIC0gMV07XG4gICAgICByd3NbTiAtIGkgLSAxXSA9IHQ7XG5cbiAgICAgIHQgPSBpd3NbaV07XG5cbiAgICAgIGl3c1tpXSA9IC1pd3NbTiAtIGkgLSAxXTtcbiAgICAgIGl3c1tOIC0gaSAtIDFdID0gLXQ7XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLm5vcm1hbGl6ZTEzYiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZTEzYiAod3MsIE4pIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHcgPSBNYXRoLnJvdW5kKHdzWzIgKiBpICsgMV0gLyBOKSAqIDB4MjAwMCArXG4gICAgICAgIE1hdGgucm91bmQod3NbMiAqIGldIC8gTikgK1xuICAgICAgICBjYXJyeTtcblxuICAgICAgd3NbaV0gPSB3ICYgMHgzZmZmZmZmO1xuXG4gICAgICBpZiAodyA8IDB4NDAwMDAwMCkge1xuICAgICAgICBjYXJyeSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXJyeSA9IHcgLyAweDQwMDAwMDAgfCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3cztcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5jb252ZXJ0MTNiID0gZnVuY3Rpb24gY29udmVydDEzYiAod3MsIGxlbiwgcndzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYXJyeSA9IGNhcnJ5ICsgKHdzW2ldIHwgMCk7XG5cbiAgICAgIHJ3c1syICogaV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgICByd3NbMiAqIGkgKyAxXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICB9XG5cbiAgICAvLyBQYWQgd2l0aCB6ZXJvZXNcbiAgICBmb3IgKGkgPSAyICogbGVuOyBpIDwgTjsgKytpKSB7XG4gICAgICByd3NbaV0gPSAwO1xuICAgIH1cblxuICAgIGFzc2VydChjYXJyeSA9PT0gMCk7XG4gICAgYXNzZXJ0KChjYXJyeSAmIH4weDFmZmYpID09PSAwKTtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5zdHViID0gZnVuY3Rpb24gc3R1YiAoTikge1xuICAgIHZhciBwaCA9IG5ldyBBcnJheShOKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgcGhbaV0gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBwaDtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5tdWxwID0gZnVuY3Rpb24gbXVscCAoeCwgeSwgb3V0KSB7XG4gICAgdmFyIE4gPSAyICogdGhpcy5ndWVzc0xlbjEzYih4Lmxlbmd0aCwgeS5sZW5ndGgpO1xuXG4gICAgdmFyIHJidCA9IHRoaXMubWFrZVJCVChOKTtcblxuICAgIHZhciBfID0gdGhpcy5zdHViKE4pO1xuXG4gICAgdmFyIHJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgcndzdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgaXdzdCA9IG5ldyBBcnJheShOKTtcblxuICAgIHZhciBucndzID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBucndzdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbml3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgcm13cyA9IG91dC53b3JkcztcbiAgICBybXdzLmxlbmd0aCA9IE47XG5cbiAgICB0aGlzLmNvbnZlcnQxM2IoeC53b3JkcywgeC5sZW5ndGgsIHJ3cywgTik7XG4gICAgdGhpcy5jb252ZXJ0MTNiKHkud29yZHMsIHkubGVuZ3RoLCBucndzLCBOKTtcblxuICAgIHRoaXMudHJhbnNmb3JtKHJ3cywgXywgcndzdCwgaXdzdCwgTiwgcmJ0KTtcbiAgICB0aGlzLnRyYW5zZm9ybShucndzLCBfLCBucndzdCwgbml3c3QsIE4sIHJidCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdmFyIHJ4ID0gcndzdFtpXSAqIG5yd3N0W2ldIC0gaXdzdFtpXSAqIG5pd3N0W2ldO1xuICAgICAgaXdzdFtpXSA9IHJ3c3RbaV0gKiBuaXdzdFtpXSArIGl3c3RbaV0gKiBucndzdFtpXTtcbiAgICAgIHJ3c3RbaV0gPSByeDtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmp1Z2F0ZShyd3N0LCBpd3N0LCBOKTtcbiAgICB0aGlzLnRyYW5zZm9ybShyd3N0LCBpd3N0LCBybXdzLCBfLCBOLCByYnQpO1xuICAgIHRoaXMuY29uanVnYXRlKHJtd3MsIF8sIE4pO1xuICAgIHRoaXMubm9ybWFsaXplMTNiKHJtd3MsIE4pO1xuXG4gICAgb3V0Lm5lZ2F0aXZlID0geC5uZWdhdGl2ZSBeIHkubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IHgubGVuZ3RoICsgeS5sZW5ndGg7XG4gICAgcmV0dXJuIG91dC5fc3RyaXAoKTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBgdGhpc2AgYnkgYG51bWBcbiAgQk4ucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5tdWxUbyhudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgZW1wbG95aW5nIEZGVFxuICBCTi5wcm90b3R5cGUubXVsZiA9IGZ1bmN0aW9uIG11bGYgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIEluLXBsYWNlIE11bHRpcGxpY2F0aW9uXG4gIEJOLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5tdWxUbyhudW0sIHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbXVsbiA9IGZ1bmN0aW9uIGltdWxuIChudW0pIHtcbiAgICB2YXIgaXNOZWdOdW0gPSBudW0gPCAwO1xuICAgIGlmIChpc05lZ051bSkgbnVtID0gLW51bTtcblxuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG5cbiAgICAvLyBDYXJyeVxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKiBudW07XG4gICAgICB2YXIgbG8gPSAodyAmIDB4M2ZmZmZmZikgKyAoY2FycnkgJiAweDNmZmZmZmYpO1xuICAgICAgY2FycnkgPj49IDI2O1xuICAgICAgY2FycnkgKz0gKHcgLyAweDQwMDAwMDApIHwgMDtcbiAgICAgIC8vIE5PVEU6IGxvIGlzIDI3Yml0IG1heGltdW1cbiAgICAgIGNhcnJ5ICs9IGxvID4+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gbnVtID09PSAwID8gMSA6IHRoaXMubGVuZ3RoO1xuXG4gICAgcmV0dXJuIGlzTmVnTnVtID8gdGhpcy5pbmVnKCkgOiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tdWxuID0gZnVuY3Rpb24gbXVsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbXVsbihudW0pO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwodGhpcyk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bCh0aGlzLmNsb25lKCkpO1xuICB9O1xuXG4gIC8vIE1hdGgucG93KGB0aGlzYCwgYG51bWApXG4gIEJOLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKG51bSkge1xuICAgIHZhciB3ID0gdG9CaXRBcnJheShudW0pO1xuICAgIGlmICh3Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5ldyBCTigxKTtcblxuICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXNcbiAgICB2YXIgcmVzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcubGVuZ3RoOyBpKyssIHJlcyA9IHJlcy5zcXIoKSkge1xuICAgICAgaWYgKHdbaV0gIT09IDApIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICgrK2kgPCB3Lmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgcSA9IHJlcy5zcXIoKTsgaSA8IHcubGVuZ3RoOyBpKyssIHEgPSBxLnNxcigpKSB7XG4gICAgICAgIGlmICh3W2ldID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSByZXMubXVsKHEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVzaGxuID0gZnVuY3Rpb24gaXVzaGxuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuICAgIHZhciBjYXJyeU1hc2sgPSAoMHgzZmZmZmZmID4+PiAoMjYgLSByKSkgPDwgKDI2IC0gcik7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5ld0NhcnJ5ID0gdGhpcy53b3Jkc1tpXSAmIGNhcnJ5TWFzaztcbiAgICAgICAgdmFyIGMgPSAoKHRoaXMud29yZHNbaV0gfCAwKSAtIG5ld0NhcnJ5KSA8PCByO1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYyB8IGNhcnJ5O1xuICAgICAgICBjYXJyeSA9IG5ld0NhcnJ5ID4+PiAoMjYgLSByKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhcnJ5KSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocyAhPT0gMCkge1xuICAgICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyBzXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoICs9IHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzaGxuID0gZnVuY3Rpb24gaXNobG4gKGJpdHMpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaGxuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LXJpZ2h0IGluLXBsYWNlXG4gIC8vIE5PVEU6IGBoaW50YCBpcyBhIGxvd2VzdCBiaXQgYmVmb3JlIHRyYWlsaW5nIHplcm9lc1xuICAvLyBOT1RFOiBpZiBgZXh0ZW5kZWRgIGlzIHByZXNlbnQgLSBpdCB3aWxsIGJlIGZpbGxlZCB3aXRoIGRlc3Ryb3llZCBiaXRzXG4gIEJOLnByb3RvdHlwZS5pdXNocm4gPSBmdW5jdGlvbiBpdXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciBoO1xuICAgIGlmIChoaW50KSB7XG4gICAgICBoID0gKGhpbnQgLSAoaGludCAlIDI2KSkgLyAyNjtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSBNYXRoLm1pbigoYml0cyAtIHIpIC8gMjYsIHRoaXMubGVuZ3RoKTtcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICB2YXIgbWFza2VkV29yZHMgPSBleHRlbmRlZDtcblxuICAgIGggLT0gcztcbiAgICBoID0gTWF0aC5tYXgoMCwgaCk7XG5cbiAgICAvLyBFeHRlbmRlZCBtb2RlLCBjb3B5IG1hc2tlZCBwYXJ0XG4gICAgaWYgKG1hc2tlZFdvcmRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICBtYXNrZWRXb3Jkcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG4gICAgICBtYXNrZWRXb3Jkcy5sZW5ndGggPSBzO1xuICAgIH1cblxuICAgIGlmIChzID09PSAwKSB7XG4gICAgICAvLyBOby1vcCwgd2Ugc2hvdWxkIG5vdCBtb3ZlIGFueXRoaW5nIGF0IGFsbFxuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiBzKSB7XG4gICAgICB0aGlzLmxlbmd0aCAtPSBzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaSArIHNdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwICYmIChjYXJyeSAhPT0gMCB8fCBpID49IGgpOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB0aGlzLndvcmRzW2ldID0gKGNhcnJ5IDw8ICgyNiAtIHIpKSB8ICh3b3JkID4+PiByKTtcbiAgICAgIGNhcnJ5ID0gd29yZCAmIG1hc2s7XG4gICAgfVxuXG4gICAgLy8gUHVzaCBjYXJyaWVkIGJpdHMgYXMgYSBtYXNrXG4gICAgaWYgKG1hc2tlZFdvcmRzICYmIGNhcnJ5ICE9PSAwKSB7XG4gICAgICBtYXNrZWRXb3Jkcy53b3Jkc1ttYXNrZWRXb3Jkcy5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc2hybiA9IGZ1bmN0aW9uIGlzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNocm4oYml0cywgaGludCwgZXh0ZW5kZWQpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LWxlZnRcbiAgQk4ucHJvdG90eXBlLnNobG4gPSBmdW5jdGlvbiBzaGxuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hsbihiaXRzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXNobG4gPSBmdW5jdGlvbiB1c2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaGxuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LXJpZ2h0XG4gIEJOLnByb3RvdHlwZS5zaHJuID0gZnVuY3Rpb24gc2hybiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNocm4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaHJuID0gZnVuY3Rpb24gdXNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hybihiaXRzKTtcbiAgfTtcblxuICAvLyBUZXN0IGlmIG4gYml0IGlzIHNldFxuICBCTi5wcm90b3R5cGUudGVzdG4gPSBmdW5jdGlvbiB0ZXN0biAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBiaXQgYW5kIHJldHVyblxuICAgIHZhciB3ID0gdGhpcy53b3Jkc1tzXTtcblxuICAgIHJldHVybiAhISh3ICYgcSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyIChpbi1wbGFjZSlcbiAgQk4ucHJvdG90eXBlLmltYXNrbiA9IGZ1bmN0aW9uIGltYXNrbiAoYml0cykge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcblxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAnaW1hc2tuIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZSBudW1iZXJzJyk7XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHMrKztcbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1pbihzLCB0aGlzLmxlbmd0aCk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gJj0gbWFzaztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXJcbiAgQk4ucHJvdG90eXBlLm1hc2tuID0gZnVuY3Rpb24gbWFza24gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltYXNrbihiaXRzKTtcbiAgfTtcblxuICAvLyBBZGQgcGxhaW4gbnVtYmVyIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaWFkZG4gPSBmdW5jdGlvbiBpYWRkbiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaXN1Ym4oLW51bSk7XG5cbiAgICAvLyBQb3NzaWJsZSBzaWduIGNoYW5nZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgKHRoaXMud29yZHNbMF0gfCAwKSA8PSBudW0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSA9IG51bSAtICh0aGlzLndvcmRzWzBdIHwgMCk7XG4gICAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlzdWJuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRob3V0IGNoZWNrc1xuICAgIHJldHVybiB0aGlzLl9pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faWFkZG4gPSBmdW5jdGlvbiBfaWFkZG4gKG51bSkge1xuICAgIHRoaXMud29yZHNbMF0gKz0gbnVtO1xuXG4gICAgLy8gQ2FycnlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPj0gMHg0MDAwMDAwOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gLT0gMHg0MDAwMDAwO1xuICAgICAgaWYgKGkgPT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSsrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpICsgMSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBwbGFpbiBudW1iZXIgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlzdWJuID0gZnVuY3Rpb24gaXN1Ym4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlhZGRuKC1udW0pO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkbihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLndvcmRzWzBdIC09IG51bTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdIDwgMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IC10aGlzLndvcmRzWzBdO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhcnJ5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPCAwOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSArPSAweDQwMDAwMDA7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdIC09IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmFkZG4gPSBmdW5jdGlvbiBhZGRuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnN1Ym4gPSBmdW5jdGlvbiBzdWJuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWJuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlhYnMgPSBmdW5jdGlvbiBpYWJzICgpIHtcbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiBhYnMgKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFicygpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faXNobG5zdWJtdWwgPSBmdW5jdGlvbiBfaXNobG5zdWJtdWwgKG51bSwgbXVsLCBzaGlmdCkge1xuICAgIHZhciBsZW4gPSBudW0ubGVuZ3RoICsgc2hpZnQ7XG4gICAgdmFyIGk7XG5cbiAgICB0aGlzLl9leHBhbmQobGVuKTtcblxuICAgIHZhciB3O1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgdmFyIHJpZ2h0ID0gKG51bS53b3Jkc1tpXSB8IDApICogbXVsO1xuICAgICAgdyAtPSByaWdodCAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gKHcgPj4gMjYpIC0gKChyaWdodCAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIGZvciAoOyBpIDwgdGhpcy5sZW5ndGggLSBzaGlmdDsgaSsrKSB7XG4gICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIGlmIChjYXJyeSA9PT0gMCkgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG5cbiAgICAvLyBTdWJ0cmFjdGlvbiBvdmVyZmxvd1xuICAgIGFzc2VydChjYXJyeSA9PT0gLTEpO1xuICAgIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdyA9IC0odGhpcy53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX3dvcmREaXYgPSBmdW5jdGlvbiBfd29yZERpdiAobnVtLCBtb2RlKSB7XG4gICAgdmFyIHNoaWZ0ID0gdGhpcy5sZW5ndGggLSBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW07XG5cbiAgICAvLyBOb3JtYWxpemVcbiAgICB2YXIgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB2YXIgYmhpQml0cyA9IHRoaXMuX2NvdW50Qml0cyhiaGkpO1xuICAgIHNoaWZ0ID0gMjYgLSBiaGlCaXRzO1xuICAgIGlmIChzaGlmdCAhPT0gMCkge1xuICAgICAgYiA9IGIudXNobG4oc2hpZnQpO1xuICAgICAgYS5pdXNobG4oc2hpZnQpO1xuICAgICAgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHF1b3RpZW50XG4gICAgdmFyIG0gPSBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICAgIHZhciBxO1xuXG4gICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICBxID0gbmV3IEJOKG51bGwpO1xuICAgICAgcS5sZW5ndGggPSBtICsgMTtcbiAgICAgIHEud29yZHMgPSBuZXcgQXJyYXkocS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHEud29yZHNbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkaWZmID0gYS5jbG9uZSgpLl9pc2hsbnN1Ym11bChiLCAxLCBtKTtcbiAgICBpZiAoZGlmZi5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgYSA9IGRpZmY7XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW21dID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gbSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICB2YXIgcWogPSAoYS53b3Jkc1tiLmxlbmd0aCArIGpdIHwgMCkgKiAweDQwMDAwMDAgK1xuICAgICAgICAoYS53b3Jkc1tiLmxlbmd0aCArIGogLSAxXSB8IDApO1xuXG4gICAgICAvLyBOT1RFOiAocWogLyBiaGkpIGlzICgweDNmZmZmZmYgKiAweDQwMDAwMDAgKyAweDNmZmZmZmYpIC8gMHgyMDAwMDAwIG1heFxuICAgICAgLy8gKDB4N2ZmZmZmZilcbiAgICAgIHFqID0gTWF0aC5taW4oKHFqIC8gYmhpKSB8IDAsIDB4M2ZmZmZmZik7XG5cbiAgICAgIGEuX2lzaGxuc3VibXVsKGIsIHFqLCBqKTtcbiAgICAgIHdoaWxlIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIHFqLS07XG4gICAgICAgIGEubmVnYXRpdmUgPSAwO1xuICAgICAgICBhLl9pc2hsbnN1Ym11bChiLCAxLCBqKTtcbiAgICAgICAgaWYgKCFhLmlzWmVybygpKSB7XG4gICAgICAgICAgYS5uZWdhdGl2ZSBePSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW2pdID0gcWo7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxKSB7XG4gICAgICBxLl9zdHJpcCgpO1xuICAgIH1cbiAgICBhLl9zdHJpcCgpO1xuXG4gICAgLy8gRGVub3JtYWxpemVcbiAgICBpZiAobW9kZSAhPT0gJ2RpdicgJiYgc2hpZnQgIT09IDApIHtcbiAgICAgIGEuaXVzaHJuKHNoaWZ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGl2OiBxIHx8IG51bGwsXG4gICAgICBtb2Q6IGFcbiAgICB9O1xuICB9O1xuXG4gIC8vIE5PVEU6IDEpIGBtb2RlYCBjYW4gYmUgc2V0IHRvIGBtb2RgIHRvIHJlcXVlc3QgbW9kIG9ubHksXG4gIC8vICAgICAgIHRvIGBkaXZgIHRvIHJlcXVlc3QgZGl2IG9ubHksIG9yIGJlIGFic2VudCB0b1xuICAvLyAgICAgICByZXF1ZXN0IGJvdGggZGl2ICYgbW9kXG4gIC8vICAgICAgIDIpIGBwb3NpdGl2ZWAgaXMgdHJ1ZSBpZiB1bnNpZ25lZCBtb2QgaXMgcmVxdWVzdGVkXG4gIEJOLnByb3RvdHlwZS5kaXZtb2QgPSBmdW5jdGlvbiBkaXZtb2QgKG51bSwgbW9kZSwgcG9zaXRpdmUpIHtcbiAgICBhc3NlcnQoIW51bS5pc1plcm8oKSk7XG5cbiAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogbmV3IEJOKDApXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkaXYsIG1vZCwgcmVzO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlhZGQobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogcmVzLm1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoKHRoaXMubmVnYXRpdmUgJiBudW0ubmVnYXRpdmUpICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pc3ViKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiByZXMuZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCb3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlIGF0IHRoaXMgcG9pbnRcblxuICAgIC8vIFN0cmlwIGJvdGggbnVtYmVycyB0byBhcHByb3hpbWF0ZSBzaGlmdCB2YWx1ZVxuICAgIGlmIChudW0ubGVuZ3RoID4gdGhpcy5sZW5ndGggfHwgdGhpcy5jbXAobnVtKSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IHRoaXNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVmVyeSBzaG9ydCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKG1vZGUgPT09ICdkaXYnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgICBtb2Q6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgPT09ICdtb2QnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiBudWxsLFxuICAgICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kcm4obnVtLndvcmRzWzBdKSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RybihudW0ud29yZHNbMF0pKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd29yZERpdihudW0sIG1vZGUpO1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgIC8gYG51bWBcbiAgQk4ucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIGRpdiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ2RpdicsIGZhbHNlKS5kaXY7XG4gIH07XG5cbiAgLy8gRmluZCBgdGhpc2AgJSBgbnVtYFxuICBCTi5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gbW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgZmFsc2UpLm1vZDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudW1vZCA9IGZ1bmN0aW9uIHVtb2QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCB0cnVlKS5tb2Q7XG4gIH07XG5cbiAgLy8gRmluZCBSb3VuZChgdGhpc2AgLyBgbnVtYClcbiAgQk4ucHJvdG90eXBlLmRpdlJvdW5kID0gZnVuY3Rpb24gZGl2Um91bmQgKG51bSkge1xuICAgIHZhciBkbSA9IHRoaXMuZGl2bW9kKG51bSk7XG5cbiAgICAvLyBGYXN0IGNhc2UgLSBleGFjdCBkaXZpc2lvblxuICAgIGlmIChkbS5tb2QuaXNaZXJvKCkpIHJldHVybiBkbS5kaXY7XG5cbiAgICB2YXIgbW9kID0gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0ubW9kLmlzdWIobnVtKSA6IGRtLm1vZDtcblxuICAgIHZhciBoYWxmID0gbnVtLnVzaHJuKDEpO1xuICAgIHZhciByMiA9IG51bS5hbmRsbigxKTtcbiAgICB2YXIgY21wID0gbW9kLmNtcChoYWxmKTtcblxuICAgIC8vIFJvdW5kIGRvd25cbiAgICBpZiAoY21wIDwgMCB8fCAocjIgPT09IDEgJiYgY21wID09PSAwKSkgcmV0dXJuIGRtLmRpdjtcblxuICAgIC8vIFJvdW5kIHVwXG4gICAgcmV0dXJuIGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLmRpdi5pc3VibigxKSA6IGRtLmRpdi5pYWRkbigxKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubW9kcm4gPSBmdW5jdGlvbiBtb2RybiAobnVtKSB7XG4gICAgdmFyIGlzTmVnTnVtID0gbnVtIDwgMDtcbiAgICBpZiAoaXNOZWdOdW0pIG51bSA9IC1udW07XG5cbiAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG4gICAgdmFyIHAgPSAoMSA8PCAyNikgJSBudW07XG5cbiAgICB2YXIgYWNjID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgYWNjID0gKHAgKiBhY2MgKyAodGhpcy53b3Jkc1tpXSB8IDApKSAlIG51bTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNOZWdOdW0gPyAtYWNjIDogYWNjO1xuICB9O1xuXG4gIC8vIFdBUk5JTkc6IERFUFJFQ0FURURcbiAgQk4ucHJvdG90eXBlLm1vZG4gPSBmdW5jdGlvbiBtb2RuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5tb2RybihudW0pO1xuICB9O1xuXG4gIC8vIEluLXBsYWNlIGRpdmlzaW9uIGJ5IG51bWJlclxuICBCTi5wcm90b3R5cGUuaWRpdm4gPSBmdW5jdGlvbiBpZGl2biAobnVtKSB7XG4gICAgdmFyIGlzTmVnTnVtID0gbnVtIDwgMDtcbiAgICBpZiAoaXNOZWdOdW0pIG51bSA9IC1udW07XG5cbiAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeSAqIDB4NDAwMDAwMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAodyAvIG51bSkgfCAwO1xuICAgICAgY2FycnkgPSB3ICUgbnVtO1xuICAgIH1cblxuICAgIHRoaXMuX3N0cmlwKCk7XG4gICAgcmV0dXJuIGlzTmVnTnVtID8gdGhpcy5pbmVnKCkgOiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5kaXZuID0gZnVuY3Rpb24gZGl2biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pZGl2bihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lZ2NkID0gZnVuY3Rpb24gZWdjZCAocCkge1xuICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcbiAgICBhc3NlcnQoIXAuaXNaZXJvKCkpO1xuXG4gICAgdmFyIHggPSB0aGlzO1xuICAgIHZhciB5ID0gcC5jbG9uZSgpO1xuXG4gICAgaWYgKHgubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHggPSB4LnVtb2QocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4LmNsb25lKCk7XG4gICAgfVxuXG4gICAgLy8gQSAqIHggKyBCICogeSA9IHhcbiAgICB2YXIgQSA9IG5ldyBCTigxKTtcbiAgICB2YXIgQiA9IG5ldyBCTigwKTtcblxuICAgIC8vIEMgKiB4ICsgRCAqIHkgPSB5XG4gICAgdmFyIEMgPSBuZXcgQk4oMCk7XG4gICAgdmFyIEQgPSBuZXcgQk4oMSk7XG5cbiAgICB2YXIgZyA9IDA7XG5cbiAgICB3aGlsZSAoeC5pc0V2ZW4oKSAmJiB5LmlzRXZlbigpKSB7XG4gICAgICB4Lml1c2hybigxKTtcbiAgICAgIHkuaXVzaHJuKDEpO1xuICAgICAgKytnO1xuICAgIH1cblxuICAgIHZhciB5cCA9IHkuY2xvbmUoKTtcbiAgICB2YXIgeHAgPSB4LmNsb25lKCk7XG5cbiAgICB3aGlsZSAoIXguaXNaZXJvKCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbSA9IDE7ICh4LndvcmRzWzBdICYgaW0pID09PSAwICYmIGkgPCAyNjsgKytpLCBpbSA8PD0gMSk7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgeC5pdXNocm4oaSk7XG4gICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKEEuaXNPZGQoKSB8fCBCLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIEEuaWFkZCh5cCk7XG4gICAgICAgICAgICBCLmlzdWIoeHApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEEuaXVzaHJuKDEpO1xuICAgICAgICAgIEIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7ICh5LndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG4gICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgeS5pdXNocm4oaik7XG4gICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKEMuaXNPZGQoKSB8fCBELmlzT2RkKCkpIHtcbiAgICAgICAgICAgIEMuaWFkZCh5cCk7XG4gICAgICAgICAgICBELmlzdWIoeHApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEMuaXVzaHJuKDEpO1xuICAgICAgICAgIEQuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh4LmNtcCh5KSA+PSAwKSB7XG4gICAgICAgIHguaXN1Yih5KTtcbiAgICAgICAgQS5pc3ViKEMpO1xuICAgICAgICBCLmlzdWIoRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5LmlzdWIoeCk7XG4gICAgICAgIEMuaXN1YihBKTtcbiAgICAgICAgRC5pc3ViKEIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhOiBDLFxuICAgICAgYjogRCxcbiAgICAgIGdjZDogeS5pdXNobG4oZylcbiAgICB9O1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgcmVkdWNlZCBpbmNhcm5hdGlvbiBvZiB0aGUgYmluYXJ5IEVFQVxuICAvLyBhYm92ZSwgZGVzaWduYXRlZCB0byBpbnZlcnQgbWVtYmVycyBvZiB0aGVcbiAgLy8gX3ByaW1lXyBmaWVsZHMgRihwKSBhdCBhIG1heGltYWwgc3BlZWRcbiAgQk4ucHJvdG90eXBlLl9pbnZtcCA9IGZ1bmN0aW9uIF9pbnZtcCAocCkge1xuICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcbiAgICBhc3NlcnQoIXAuaXNaZXJvKCkpO1xuXG4gICAgdmFyIGEgPSB0aGlzO1xuICAgIHZhciBiID0gcC5jbG9uZSgpO1xuXG4gICAgaWYgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGEgPSBhLnVtb2QocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBhLmNsb25lKCk7XG4gICAgfVxuXG4gICAgdmFyIHgxID0gbmV3IEJOKDEpO1xuICAgIHZhciB4MiA9IG5ldyBCTigwKTtcblxuICAgIHZhciBkZWx0YSA9IGIuY2xvbmUoKTtcblxuICAgIHdoaWxlIChhLmNtcG4oMSkgPiAwICYmIGIuY21wbigxKSA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbSA9IDE7IChhLndvcmRzWzBdICYgaW0pID09PSAwICYmIGkgPCAyNjsgKytpLCBpbSA8PD0gMSk7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgYS5pdXNocm4oaSk7XG4gICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKHgxLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIHgxLmlhZGQoZGVsdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgxLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoYi53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIGIuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmICh4Mi5pc09kZCgpKSB7XG4gICAgICAgICAgICB4Mi5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4Mi5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGEuY21wKGIpID49IDApIHtcbiAgICAgICAgYS5pc3ViKGIpO1xuICAgICAgICB4MS5pc3ViKHgyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGIuaXN1YihhKTtcbiAgICAgICAgeDIuaXN1Yih4MSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlcztcbiAgICBpZiAoYS5jbXBuKDEpID09PSAwKSB7XG4gICAgICByZXMgPSB4MTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0geDI7XG4gICAgfVxuXG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQocCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ2NkID0gZnVuY3Rpb24gZ2NkIChudW0pIHtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIG51bS5hYnMoKTtcbiAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gdGhpcy5hYnMoKTtcblxuICAgIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICAgIHZhciBiID0gbnVtLmNsb25lKCk7XG4gICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgYi5uZWdhdGl2ZSA9IDA7XG5cbiAgICAvLyBSZW1vdmUgY29tbW9uIGZhY3RvciBvZiB0d29cbiAgICBmb3IgKHZhciBzaGlmdCA9IDA7IGEuaXNFdmVuKCkgJiYgYi5pc0V2ZW4oKTsgc2hpZnQrKykge1xuICAgICAgYS5pdXNocm4oMSk7XG4gICAgICBiLml1c2hybigxKTtcbiAgICB9XG5cbiAgICBkbyB7XG4gICAgICB3aGlsZSAoYS5pc0V2ZW4oKSkge1xuICAgICAgICBhLml1c2hybigxKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChiLmlzRXZlbigpKSB7XG4gICAgICAgIGIuaXVzaHJuKDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgciA9IGEuY21wKGIpO1xuICAgICAgaWYgKHIgPCAwKSB7XG4gICAgICAgIC8vIFN3YXAgYGFgIGFuZCBgYmAgdG8gbWFrZSBgYWAgYWx3YXlzIGJpZ2dlciB0aGFuIGBiYFxuICAgICAgICB2YXIgdCA9IGE7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBiID0gdDtcbiAgICAgIH0gZWxzZSBpZiAociA9PT0gMCB8fCBiLmNtcG4oMSkgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGEuaXN1YihiKTtcbiAgICB9IHdoaWxlICh0cnVlKTtcblxuICAgIHJldHVybiBiLml1c2hsbihzaGlmdCk7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IG51bWJlciBpbiB0aGUgZmllbGQgRihudW0pXG4gIEJOLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZWdjZChudW0pLmEudW1vZChudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4gKCkge1xuICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMTtcbiAgfTtcblxuICAvLyBBbmQgZmlyc3Qgd29yZCBhbmQgbnVtXG4gIEJOLnByb3RvdHlwZS5hbmRsbiA9IGZ1bmN0aW9uIGFuZGxuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy53b3Jkc1swXSAmIG51bTtcbiAgfTtcblxuICAvLyBJbmNyZW1lbnQgYXQgdGhlIGJpdCBwb3NpdGlvbiBpbi1saW5lXG4gIEJOLnByb3RvdHlwZS5iaW5jbiA9IGZ1bmN0aW9uIGJpbmNuIChiaXQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicpO1xuICAgIHZhciByID0gYml0ICUgMjY7XG4gICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgICB2YXIgcSA9IDEgPDwgcjtcblxuICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHRoaXMuX2V4cGFuZChzICsgMSk7XG4gICAgICB0aGlzLndvcmRzW3NdIHw9IHE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgYml0IGFuZCBwcm9wYWdhdGUsIGlmIG5lZWRlZFxuICAgIHZhciBjYXJyeSA9IHE7XG4gICAgZm9yICh2YXIgaSA9IHM7IGNhcnJ5ICE9PSAwICYmIGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdyArPSBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+Pj4gMjY7XG4gICAgICB3ICY9IDB4M2ZmZmZmZjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB3O1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8gKCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jbXBuID0gZnVuY3Rpb24gY21wbiAobnVtKSB7XG4gICAgdmFyIG5lZ2F0aXZlID0gbnVtIDwgMDtcblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmICFuZWdhdGl2ZSkgcmV0dXJuIC0xO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG5lZ2F0aXZlKSByZXR1cm4gMTtcblxuICAgIHRoaXMuX3N0cmlwKCk7XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICBudW0gPSAtbnVtO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZiwgJ051bWJlciBpcyB0b28gYmlnJyk7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1swXSB8IDA7XG4gICAgICByZXMgPSB3ID09PSBudW0gPyAwIDogdyA8IG51bSA/IC0xIDogMTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvbXBhcmUgdHdvIG51bWJlcnMgYW5kIHJldHVybjpcbiAgLy8gMSAtIGlmIGB0aGlzYCA+IGBudW1gXG4gIC8vIDAgLSBpZiBgdGhpc2AgPT0gYG51bWBcbiAgLy8gLTEgLSBpZiBgdGhpc2AgPCBgbnVtYFxuICBCTi5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24gY21wIChudW0pIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHJldHVybiAxO1xuXG4gICAgdmFyIHJlcyA9IHRoaXMudWNtcChudW0pO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBVbnNpZ25lZCBjb21wYXJpc29uXG4gIEJOLnByb3RvdHlwZS51Y21wID0gZnVuY3Rpb24gdWNtcCAobnVtKSB7XG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgaGF2ZSB0aGUgc2FtZSBzaWduXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIDE7XG4gICAgaWYgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkgcmV0dXJuIC0xO1xuXG4gICAgdmFyIHJlcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB2YXIgYiA9IG51bS53b3Jkc1tpXSB8IDA7XG5cbiAgICAgIGlmIChhID09PSBiKSBjb250aW51ZTtcbiAgICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXMgPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmVzID0gMTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndG4gPSBmdW5jdGlvbiBndG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiBndCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZW4gPSBmdW5jdGlvbiBndGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlID0gZnVuY3Rpb24gZ3RlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdG4gPSBmdW5jdGlvbiBsdG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gbHQgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlbiA9IGZ1bmN0aW9uIGx0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGUgPSBmdW5jdGlvbiBsdGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxbiA9IGZ1bmN0aW9uIGVxbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMDtcbiAgfTtcblxuICAvL1xuICAvLyBBIHJlZHVjZSBjb250ZXh0LCBjb3VsZCBiZSB1c2luZyBtb250Z29tZXJ5IG9yIHNvbWV0aGluZyBiZXR0ZXIsIGRlcGVuZGluZ1xuICAvLyBvbiB0aGUgYG1gIGl0c2VsZi5cbiAgLy9cbiAgQk4ucmVkID0gZnVuY3Rpb24gcmVkIChudW0pIHtcbiAgICByZXR1cm4gbmV3IFJlZChudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1JlZCA9IGZ1bmN0aW9uIHRvUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICByZXR1cm4gY3R4LmNvbnZlcnRUbyh0aGlzKS5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVJlZCA9IGZ1bmN0aW9uIGZyb21SZWQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ2Zyb21SZWQgd29ya3Mgb25seSB3aXRoIG51bWJlcnMgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuY29udmVydEZyb20odGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9mb3JjZVJlZCA9IGZ1bmN0aW9uIF9mb3JjZVJlZCAoY3R4KSB7XG4gICAgdGhpcy5yZWQgPSBjdHg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZvcmNlUmVkID0gZnVuY3Rpb24gZm9yY2VSZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEFkZCA9IGZ1bmN0aW9uIHJlZEFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5hZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSUFkZCA9IGZ1bmN0aW9uIHJlZElBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlhZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3ViID0gZnVuY3Rpb24gcmVkU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3ViID0gZnVuY3Rpb24gcmVkSVN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTaGwgPSBmdW5jdGlvbiByZWRTaGwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNobCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc2hsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZE11bCA9IGZ1bmN0aW9uIHJlZE11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJTXVsID0gZnVuY3Rpb24gcmVkSU11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmltdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3FyID0gZnVuY3Rpb24gcmVkU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVNxciA9IGZ1bmN0aW9uIHJlZElTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzcXIodGhpcyk7XG4gIH07XG5cbiAgLy8gU3F1YXJlIHJvb3Qgb3ZlciBwXG4gIEJOLnByb3RvdHlwZS5yZWRTcXJ0ID0gZnVuY3Rpb24gcmVkU3FydCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FydCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FydCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSW52bSA9IGZ1bmN0aW9uIHJlZEludm0gKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEludm0gd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmludm0odGhpcyk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYCAlIGByZWQgbW9kdWxvYFxuICBCTi5wcm90b3R5cGUucmVkTmVnID0gZnVuY3Rpb24gcmVkTmVnICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm5lZyh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkUG93ID0gZnVuY3Rpb24gcmVkUG93IChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQgJiYgIW51bS5yZWQsICdyZWRQb3cobm9ybWFsTnVtKScpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5wb3codGhpcywgbnVtKTtcbiAgfTtcblxuICAvLyBQcmltZSBudW1iZXJzIHdpdGggZWZmaWNpZW50IHJlZHVjdGlvblxuICB2YXIgcHJpbWVzID0ge1xuICAgIGsyNTY6IG51bGwsXG4gICAgcDIyNDogbnVsbCxcbiAgICBwMTkyOiBudWxsLFxuICAgIHAyNTUxOTogbnVsbFxuICB9O1xuXG4gIC8vIFBzZXVkby1NZXJzZW5uZSBwcmltZVxuICBmdW5jdGlvbiBNUHJpbWUgKG5hbWUsIHApIHtcbiAgICAvLyBQID0gMiBeIE4gLSBLXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnAgPSBuZXcgQk4ocCwgMTYpO1xuICAgIHRoaXMubiA9IHRoaXMucC5iaXRMZW5ndGgoKTtcbiAgICB0aGlzLmsgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMubikuaXN1Yih0aGlzLnApO1xuXG4gICAgdGhpcy50bXAgPSB0aGlzLl90bXAoKTtcbiAgfVxuXG4gIE1QcmltZS5wcm90b3R5cGUuX3RtcCA9IGZ1bmN0aW9uIF90bXAgKCkge1xuICAgIHZhciB0bXAgPSBuZXcgQk4obnVsbCk7XG4gICAgdG1wLndvcmRzID0gbmV3IEFycmF5KE1hdGguY2VpbCh0aGlzLm4gLyAxMykpO1xuICAgIHJldHVybiB0bXA7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pcmVkdWNlID0gZnVuY3Rpb24gaXJlZHVjZSAobnVtKSB7XG4gICAgLy8gQXNzdW1lcyB0aGF0IGBudW1gIGlzIGxlc3MgdGhhbiBgUF4yYFxuICAgIC8vIG51bSA9IEhJICogKDIgXiBOIC0gSykgKyBISSAqIEsgKyBMTyA9IEhJICogSyArIExPIChtb2QgUClcbiAgICB2YXIgciA9IG51bTtcbiAgICB2YXIgcmxlbjtcblxuICAgIGRvIHtcbiAgICAgIHRoaXMuc3BsaXQociwgdGhpcy50bXApO1xuICAgICAgciA9IHRoaXMuaW11bEsocik7XG4gICAgICByID0gci5pYWRkKHRoaXMudG1wKTtcbiAgICAgIHJsZW4gPSByLmJpdExlbmd0aCgpO1xuICAgIH0gd2hpbGUgKHJsZW4gPiB0aGlzLm4pO1xuXG4gICAgdmFyIGNtcCA9IHJsZW4gPCB0aGlzLm4gPyAtMSA6IHIudWNtcCh0aGlzLnApO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHIud29yZHNbMF0gPSAwO1xuICAgICAgci5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgci5pc3ViKHRoaXMucCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyLnN0cmlwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gciBpcyBhIEJOIHY0IGluc3RhbmNlXG4gICAgICAgIHIuc3RyaXAoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHIgaXMgYSBCTiB2NSBpbnN0YW5jZVxuICAgICAgICByLl9zdHJpcCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dCkge1xuICAgIGlucHV0Lml1c2hybih0aGlzLm4sIDAsIG91dCk7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICByZXR1cm4gbnVtLmltdWwodGhpcy5rKTtcbiAgfTtcblxuICBmdW5jdGlvbiBLMjU2ICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAnazI1NicsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnKTtcbiAgfVxuICBpbmhlcml0cyhLMjU2LCBNUHJpbWUpO1xuXG4gIEsyNTYucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXRwdXQpIHtcbiAgICAvLyAyNTYgPSA5ICogMjYgKyAyMlxuICAgIHZhciBtYXNrID0gMHgzZmZmZmY7XG5cbiAgICB2YXIgb3V0TGVuID0gTWF0aC5taW4oaW5wdXQubGVuZ3RoLCA5KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dExlbjsgaSsrKSB7XG4gICAgICBvdXRwdXQud29yZHNbaV0gPSBpbnB1dC53b3Jkc1tpXTtcbiAgICB9XG4gICAgb3V0cHV0Lmxlbmd0aCA9IG91dExlbjtcblxuICAgIGlmIChpbnB1dC5sZW5ndGggPD0gOSkge1xuICAgICAgaW5wdXQud29yZHNbMF0gPSAwO1xuICAgICAgaW5wdXQubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTaGlmdCBieSA5IGxpbWJzXG4gICAgdmFyIHByZXYgPSBpbnB1dC53b3Jkc1s5XTtcbiAgICBvdXRwdXQud29yZHNbb3V0cHV0Lmxlbmd0aCsrXSA9IHByZXYgJiBtYXNrO1xuXG4gICAgZm9yIChpID0gMTA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5leHQgPSBpbnB1dC53b3Jkc1tpXSB8IDA7XG4gICAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gKChuZXh0ICYgbWFzaykgPDwgNCkgfCAocHJldiA+Pj4gMjIpO1xuICAgICAgcHJldiA9IG5leHQ7XG4gICAgfVxuICAgIHByZXYgPj4+PSAyMjtcbiAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gcHJldjtcbiAgICBpZiAocHJldiA9PT0gMCAmJiBpbnB1dC5sZW5ndGggPiAxMCkge1xuICAgICAgaW5wdXQubGVuZ3RoIC09IDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gOTtcbiAgICB9XG4gIH07XG5cbiAgSzI1Ni5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgLy8gSyA9IDB4MTAwMDAwM2QxID0gWyAweDQwLCAweDNkMSBdXG4gICAgbnVtLndvcmRzW251bS5sZW5ndGhdID0gMDtcbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aCArIDFdID0gMDtcbiAgICBudW0ubGVuZ3RoICs9IDI7XG5cbiAgICAvLyBib3VuZGVkIGF0OiAweDQwICogMHgzZmZmZmZmICsgMHgzZDAgPSAweDEwMDAwMDM5MFxuICAgIHZhciBsbyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gbnVtLndvcmRzW2ldIHwgMDtcbiAgICAgIGxvICs9IHcgKiAweDNkMTtcbiAgICAgIG51bS53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgbG8gPSB3ICogMHg0MCArICgobG8gLyAweDQwMDAwMDApIHwgMCk7XG4gICAgfVxuXG4gICAgLy8gRmFzdCBsZW5ndGggcmVkdWN0aW9uXG4gICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgIG51bS5sZW5ndGgtLTtcbiAgICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICAgIG51bS5sZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICBmdW5jdGlvbiBQMjI0ICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncDIyNCcsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDEnKTtcbiAgfVxuICBpbmhlcml0cyhQMjI0LCBNUHJpbWUpO1xuXG4gIGZ1bmN0aW9uIFAxOTIgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMTkyJyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZicpO1xuICB9XG4gIGluaGVyaXRzKFAxOTIsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDI1NTE5ICgpIHtcbiAgICAvLyAyIF4gMjU1IC0gMTlcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAnMjU1MTknLFxuICAgICAgJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnKTtcbiAgfVxuICBpbmhlcml0cyhQMjU1MTksIE1QcmltZSk7XG5cbiAgUDI1NTE5LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxM1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoaSA9IChudW0ud29yZHNbaV0gfCAwKSAqIDB4MTMgKyBjYXJyeTtcbiAgICAgIHZhciBsbyA9IGhpICYgMHgzZmZmZmZmO1xuICAgICAgaGkgPj4+PSAyNjtcblxuICAgICAgbnVtLndvcmRzW2ldID0gbG87XG4gICAgICBjYXJyeSA9IGhpO1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoKytdID0gY2Fycnk7XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgLy8gRXhwb3J0ZWQgbW9zdGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB1c2UgcGxhaW4gbmFtZSBpbnN0ZWFkXG4gIEJOLl9wcmltZSA9IGZ1bmN0aW9uIHByaW1lIChuYW1lKSB7XG4gICAgLy8gQ2FjaGVkIHZlcnNpb24gb2YgcHJpbWVcbiAgICBpZiAocHJpbWVzW25hbWVdKSByZXR1cm4gcHJpbWVzW25hbWVdO1xuXG4gICAgdmFyIHByaW1lO1xuICAgIGlmIChuYW1lID09PSAnazI1NicpIHtcbiAgICAgIHByaW1lID0gbmV3IEsyNTYoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjI0Jykge1xuICAgICAgcHJpbWUgPSBuZXcgUDIyNCgpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AxOTInKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMTkyKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDI1NTE5Jykge1xuICAgICAgcHJpbWUgPSBuZXcgUDI1NTE5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwcmltZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHByaW1lc1tuYW1lXSA9IHByaW1lO1xuXG4gICAgcmV0dXJuIHByaW1lO1xuICB9O1xuXG4gIC8vXG4gIC8vIEJhc2UgcmVkdWN0aW9uIGVuZ2luZVxuICAvL1xuICBmdW5jdGlvbiBSZWQgKG0pIHtcbiAgICBpZiAodHlwZW9mIG0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgcHJpbWUgPSBCTi5fcHJpbWUobSk7XG4gICAgICB0aGlzLm0gPSBwcmltZS5wO1xuICAgICAgdGhpcy5wcmltZSA9IHByaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobS5ndG4oMSksICdtb2R1bHVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIDEnKTtcbiAgICAgIHRoaXMubSA9IG07XG4gICAgICB0aGlzLnByaW1lID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBSZWQucHJvdG90eXBlLl92ZXJpZnkxID0gZnVuY3Rpb24gX3ZlcmlmeTEgKGEpIHtcbiAgICBhc3NlcnQoYS5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgYXNzZXJ0KGEucmVkLCAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTIgPSBmdW5jdGlvbiBfdmVyaWZ5MiAoYSwgYikge1xuICAgIGFzc2VydCgoYS5uZWdhdGl2ZSB8IGIubmVnYXRpdmUpID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQgJiYgYS5yZWQgPT09IGIucmVkLFxuICAgICAgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmltb2QgPSBmdW5jdGlvbiBpbW9kIChhKSB7XG4gICAgaWYgKHRoaXMucHJpbWUpIHJldHVybiB0aGlzLnByaW1lLmlyZWR1Y2UoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuXG4gICAgbW92ZShhLCBhLnVtb2QodGhpcy5tKS5fZm9yY2VSZWQodGhpcykpO1xuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnIChhKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiBhLmNsb25lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubS5zdWIoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmFkZChiKTtcbiAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuaWFkZChiKTtcbiAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuc3ViKGIpO1xuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuaXN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc2hsID0gZnVuY3Rpb24gc2hsIChhLCBudW0pIHtcbiAgICB0aGlzLl92ZXJpZnkxKGEpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS51c2hsbihudW0pKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEuaW11bChiKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS5tdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKGEpIHtcbiAgICByZXR1cm4gdGhpcy5pbXVsKGEsIGEuY2xvbmUoKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKGEpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwoYSwgYSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gc3FydCAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIG1vZDMgPSB0aGlzLm0uYW5kbG4oMyk7XG4gICAgYXNzZXJ0KG1vZDMgJSAyID09PSAxKTtcblxuICAgIC8vIEZhc3QgY2FzZVxuICAgIGlmIChtb2QzID09PSAzKSB7XG4gICAgICB2YXIgcG93ID0gdGhpcy5tLmFkZChuZXcgQk4oMSkpLml1c2hybigyKTtcbiAgICAgIHJldHVybiB0aGlzLnBvdyhhLCBwb3cpO1xuICAgIH1cblxuICAgIC8vIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobSAoVG90YWxseSB1bm9wdGltaXplZCBhbmQgc2xvdylcbiAgICAvL1xuICAgIC8vIEZpbmQgUSBhbmQgUywgdGhhdCBRICogMiBeIFMgPSAoUCAtIDEpXG4gICAgdmFyIHEgPSB0aGlzLm0uc3VibigxKTtcbiAgICB2YXIgcyA9IDA7XG4gICAgd2hpbGUgKCFxLmlzWmVybygpICYmIHEuYW5kbG4oMSkgPT09IDApIHtcbiAgICAgIHMrKztcbiAgICAgIHEuaXVzaHJuKDEpO1xuICAgIH1cbiAgICBhc3NlcnQoIXEuaXNaZXJvKCkpO1xuXG4gICAgdmFyIG9uZSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICB2YXIgbk9uZSA9IG9uZS5yZWROZWcoKTtcblxuICAgIC8vIEZpbmQgcXVhZHJhdGljIG5vbi1yZXNpZHVlXG4gICAgLy8gTk9URTogTWF4IGlzIHN1Y2ggYmVjYXVzZSBvZiBnZW5lcmFsaXplZCBSaWVtYW5uIGh5cG90aGVzaXMuXG4gICAgdmFyIGxwb3cgPSB0aGlzLm0uc3VibigxKS5pdXNocm4oMSk7XG4gICAgdmFyIHogPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgeiA9IG5ldyBCTigyICogeiAqIHopLnRvUmVkKHRoaXMpO1xuXG4gICAgd2hpbGUgKHRoaXMucG93KHosIGxwb3cpLmNtcChuT25lKSAhPT0gMCkge1xuICAgICAgei5yZWRJQWRkKG5PbmUpO1xuICAgIH1cblxuICAgIHZhciBjID0gdGhpcy5wb3coeiwgcSk7XG4gICAgdmFyIHIgPSB0aGlzLnBvdyhhLCBxLmFkZG4oMSkuaXVzaHJuKDEpKTtcbiAgICB2YXIgdCA9IHRoaXMucG93KGEsIHEpO1xuICAgIHZhciBtID0gcztcbiAgICB3aGlsZSAodC5jbXAob25lKSAhPT0gMCkge1xuICAgICAgdmFyIHRtcCA9IHQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgdG1wLmNtcChvbmUpICE9PSAwOyBpKyspIHtcbiAgICAgICAgdG1wID0gdG1wLnJlZFNxcigpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KGkgPCBtKTtcbiAgICAgIHZhciBiID0gdGhpcy5wb3coYywgbmV3IEJOKDEpLml1c2hsbihtIC0gaSAtIDEpKTtcblxuICAgICAgciA9IHIucmVkTXVsKGIpO1xuICAgICAgYyA9IGIucmVkU3FyKCk7XG4gICAgICB0ID0gdC5yZWRNdWwoYyk7XG4gICAgICBtID0gaTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgdmFyIGludiA9IGEuX2ludm1wKHRoaXMubSk7XG4gICAgaWYgKGludi5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaW52Lm5lZ2F0aXZlID0gMDtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KS5yZWROZWcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpO1xuICAgIH1cbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAoYSwgbnVtKSB7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICBpZiAobnVtLmNtcG4oMSkgPT09IDApIHJldHVybiBhLmNsb25lKCk7XG5cbiAgICB2YXIgd2luZG93U2l6ZSA9IDQ7XG4gICAgdmFyIHduZCA9IG5ldyBBcnJheSgxIDw8IHdpbmRvd1NpemUpO1xuICAgIHduZFswXSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICB3bmRbMV0gPSBhO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgd25kLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3bmRbaV0gPSB0aGlzLm11bCh3bmRbaSAtIDFdLCBhKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0gd25kWzBdO1xuICAgIHZhciBjdXJyZW50ID0gMDtcbiAgICB2YXIgY3VycmVudExlbiA9IDA7XG4gICAgdmFyIHN0YXJ0ID0gbnVtLmJpdExlbmd0aCgpICUgMjY7XG4gICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICBzdGFydCA9IDI2O1xuICAgIH1cblxuICAgIGZvciAoaSA9IG51bS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSBudW0ud29yZHNbaV07XG4gICAgICBmb3IgKHZhciBqID0gc3RhcnQgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICB2YXIgYml0ID0gKHdvcmQgPj4gaikgJiAxO1xuICAgICAgICBpZiAocmVzICE9PSB3bmRbMF0pIHtcbiAgICAgICAgICByZXMgPSB0aGlzLnNxcihyZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJpdCA9PT0gMCAmJiBjdXJyZW50ID09PSAwKSB7XG4gICAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50IDw8PSAxO1xuICAgICAgICBjdXJyZW50IHw9IGJpdDtcbiAgICAgICAgY3VycmVudExlbisrO1xuICAgICAgICBpZiAoY3VycmVudExlbiAhPT0gd2luZG93U2l6ZSAmJiAoaSAhPT0gMCB8fCBqICE9PSAwKSkgY29udGludWU7XG5cbiAgICAgICAgcmVzID0gdGhpcy5tdWwocmVzLCB3bmRbY3VycmVudF0pO1xuICAgICAgICBjdXJyZW50TGVuID0gMDtcbiAgICAgICAgY3VycmVudCA9IDA7XG4gICAgICB9XG4gICAgICBzdGFydCA9IDI2O1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHZhciByID0gbnVtLnVtb2QodGhpcy5tKTtcblxuICAgIHJldHVybiByID09PSBudW0gPyByLmNsb25lKCkgOiByO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG4gICAgdmFyIHJlcyA9IG51bS5jbG9uZSgpO1xuICAgIHJlcy5yZWQgPSBudWxsO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy9cbiAgLy8gTW9udGdvbWVyeSBtZXRob2QgZW5naW5lXG4gIC8vXG5cbiAgQk4ubW9udCA9IGZ1bmN0aW9uIG1vbnQgKG51bSkge1xuICAgIHJldHVybiBuZXcgTW9udChudW0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIE1vbnQgKG0pIHtcbiAgICBSZWQuY2FsbCh0aGlzLCBtKTtcblxuICAgIHRoaXMuc2hpZnQgPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgaWYgKHRoaXMuc2hpZnQgJSAyNiAhPT0gMCkge1xuICAgICAgdGhpcy5zaGlmdCArPSAyNiAtICh0aGlzLnNoaWZ0ICUgMjYpO1xuICAgIH1cblxuICAgIHRoaXMuciA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5zaGlmdCk7XG4gICAgdGhpcy5yMiA9IHRoaXMuaW1vZCh0aGlzLnIuc3FyKCkpO1xuICAgIHRoaXMucmludiA9IHRoaXMuci5faW52bXAodGhpcy5tKTtcblxuICAgIHRoaXMubWludiA9IHRoaXMucmludi5tdWwodGhpcy5yKS5pc3VibigxKS5kaXYodGhpcy5tKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLm1pbnYudW1vZCh0aGlzLnIpO1xuICAgIHRoaXMubWludiA9IHRoaXMuci5zdWIodGhpcy5taW52KTtcbiAgfVxuICBpbmhlcml0cyhNb250LCBSZWQpO1xuXG4gIE1vbnQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChudW0udXNobG4odGhpcy5zaGlmdCkpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByID0gdGhpcy5pbW9kKG51bS5tdWwodGhpcy5yaW52KSk7XG4gICAgci5yZWQgPSBudWxsO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkge1xuICAgICAgYS53b3Jkc1swXSA9IDA7XG4gICAgICBhLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IGEuaW11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcblxuICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigwKS5fZm9yY2VSZWQodGhpcyk7XG5cbiAgICB2YXIgdCA9IGEubXVsKGIpO1xuICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICAgIHZhciByZXMgPSB1O1xuICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcbiAgICAvLyAoQVIpXi0xICogUl4yID0gKEFeLTEgKiBSXi0xKSAqIFJeMiA9IEFeLTEgKiBSXG4gICAgdmFyIHJlcyA9IHRoaXMuaW1vZChhLl9pbnZtcCh0aGlzLm0pLm11bCh0aGlzLnIyKSk7XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG59KSh0eXBlb2YgbW9kdWxlID09PSAndW5kZWZpbmVkJyB8fCBtb2R1bGUsIHRoaXMpO1xuIiwgIi8qISBzYWZlLWJ1ZmZlci4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSlcblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCAiJ3VzZSBzdHJpY3QnXG4vLyBiYXNlLXggZW5jb2RpbmcgLyBkZWNvZGluZ1xuLy8gQ29weXJpZ2h0IChjKSAyMDE4IGJhc2UteCBjb250cmlidXRvcnNcbi8vIENvcHlyaWdodCAoYykgMjAxNC0yMDE4IFRoZSBCaXRjb2luIENvcmUgZGV2ZWxvcGVycyAoYmFzZTU4LmNwcClcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgTElDRU5TRSBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbi8vIEB0cy1pZ25vcmVcbnZhciBfQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbmZ1bmN0aW9uIGJhc2UgKEFMUEhBQkVUKSB7XG4gIGlmIChBTFBIQUJFVC5sZW5ndGggPj0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscGhhYmV0IHRvbyBsb25nJykgfVxuICB2YXIgQkFTRV9NQVAgPSBuZXcgVWludDhBcnJheSgyNTYpXG4gIGZvciAodmFyIGogPSAwOyBqIDwgQkFTRV9NQVAubGVuZ3RoOyBqKyspIHtcbiAgICBCQVNFX01BUFtqXSA9IDI1NVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgeCA9IEFMUEhBQkVULmNoYXJBdChpKVxuICAgIHZhciB4YyA9IHguY2hhckNvZGVBdCgwKVxuICAgIGlmIChCQVNFX01BUFt4Y10gIT09IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIGFtYmlndW91cycpIH1cbiAgICBCQVNFX01BUFt4Y10gPSBpXG4gIH1cbiAgdmFyIEJBU0UgPSBBTFBIQUJFVC5sZW5ndGhcbiAgdmFyIExFQURFUiA9IEFMUEhBQkVULmNoYXJBdCgwKVxuICB2YXIgRkFDVE9SID0gTWF0aC5sb2coQkFTRSkgLyBNYXRoLmxvZygyNTYpIC8vIGxvZyhCQVNFKSAvIGxvZygyNTYpLCByb3VuZGVkIHVwXG4gIHZhciBpRkFDVE9SID0gTWF0aC5sb2coMjU2KSAvIE1hdGgubG9nKEJBU0UpIC8vIGxvZygyNTYpIC8gbG9nKEJBU0UpLCByb3VuZGVkIHVwXG4gIGZ1bmN0aW9uIGVuY29kZSAoc291cmNlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSB8fCBzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7IHNvdXJjZSA9IF9CdWZmZXIuZnJvbShzb3VyY2UpIH1cbiAgICBpZiAoIV9CdWZmZXIuaXNCdWZmZXIoc291cmNlKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBCdWZmZXInKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnIH1cbiAgICAgICAgLy8gU2tpcCAmIGNvdW50IGxlYWRpbmcgemVyb2VzLlxuICAgIHZhciB6ZXJvZXMgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB2YXIgcGJlZ2luID0gMFxuICAgIHZhciBwZW5kID0gc291cmNlLmxlbmd0aFxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQgJiYgc291cmNlW3BiZWdpbl0gPT09IDApIHtcbiAgICAgIHBiZWdpbisrXG4gICAgICB6ZXJvZXMrK1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTU4IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKChwZW5kIC0gcGJlZ2luKSAqIGlGQUNUT1IgKyAxKSA+Pj4gMFxuICAgIHZhciBiNTggPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBieXRlcy5cbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kKSB7XG4gICAgICB2YXIgY2FycnkgPSBzb3VyY2VbcGJlZ2luXVxuICAgICAgICAgICAgLy8gQXBwbHkgXCJiNTggPSBiNTggKiAyNTYgKyBjaFwiLlxuICAgICAgdmFyIGkgPSAwXG4gICAgICBmb3IgKHZhciBpdDEgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDEgIT09IC0xKTsgaXQxLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAoMjU2ICogYjU4W2l0MV0pID4+PiAwXG4gICAgICAgIGI1OFtpdDFdID0gKGNhcnJ5ICUgQkFTRSkgPj4+IDBcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBCQVNFKSA+Pj4gMFxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpXG4gICAgICBwYmVnaW4rK1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiYXNlNTggcmVzdWx0LlxuICAgIHZhciBpdDIgPSBzaXplIC0gbGVuZ3RoXG4gICAgd2hpbGUgKGl0MiAhPT0gc2l6ZSAmJiBiNThbaXQyXSA9PT0gMCkge1xuICAgICAgaXQyKytcbiAgICB9XG4gICAgICAgIC8vIFRyYW5zbGF0ZSB0aGUgcmVzdWx0IGludG8gYSBzdHJpbmcuXG4gICAgdmFyIHN0ciA9IExFQURFUi5yZXBlYXQoemVyb2VzKVxuICAgIGZvciAoOyBpdDIgPCBzaXplOyArK2l0MikgeyBzdHIgKz0gQUxQSEFCRVQuY2hhckF0KGI1OFtpdDJdKSB9XG4gICAgcmV0dXJuIHN0clxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZVVuc2FmZSAoc291cmNlKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFN0cmluZycpIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gX0J1ZmZlci5hbGxvYygwKSB9XG4gICAgdmFyIHBzeiA9IDBcbiAgICAgICAgLy8gU2tpcCBhbmQgY291bnQgbGVhZGluZyAnMSdzLlxuICAgIHZhciB6ZXJvZXMgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB3aGlsZSAoc291cmNlW3Bzel0gPT09IExFQURFUikge1xuICAgICAgemVyb2VzKytcbiAgICAgIHBzeisrXG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlMjU2IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKCgoc291cmNlLmxlbmd0aCAtIHBzeikgKiBGQUNUT1IpICsgMSkgPj4+IDAgLy8gbG9nKDU4KSAvIGxvZygyNTYpLCByb3VuZGVkIHVwLlxuICAgIHZhciBiMjU2ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgY2hhcmFjdGVycy5cbiAgICB3aGlsZSAocHN6IDwgc291cmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gRmluZCBjb2RlIG9mIG5leHQgY2hhcmFjdGVyXG4gICAgICB2YXIgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwc3opXG4gICAgICAgICAgICAvLyBCYXNlIG1hcCBjYW4gbm90IGJlIGluZGV4ZWQgdXNpbmcgY2hhciBjb2RlXG4gICAgICBpZiAoY2hhckNvZGUgPiAyNTUpIHsgcmV0dXJuIH1cbiAgICAgICAgICAgIC8vIERlY29kZSBjaGFyYWN0ZXJcbiAgICAgIHZhciBjYXJyeSA9IEJBU0VfTUFQW2NoYXJDb2RlXVxuICAgICAgICAgICAgLy8gSW52YWxpZCBjaGFyYWN0ZXJcbiAgICAgIGlmIChjYXJyeSA9PT0gMjU1KSB7IHJldHVybiB9XG4gICAgICB2YXIgaSA9IDBcbiAgICAgIGZvciAodmFyIGl0MyA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MyAhPT0gLTEpOyBpdDMtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IChCQVNFICogYjI1NltpdDNdKSA+Pj4gMFxuICAgICAgICBiMjU2W2l0M10gPSAoY2FycnkgJSAyNTYpID4+PiAwXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gMjU2KSA+Pj4gMFxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpXG4gICAgICBwc3orK1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiMjU2LlxuICAgIHZhciBpdDQgPSBzaXplIC0gbGVuZ3RoXG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSAmJiBiMjU2W2l0NF0gPT09IDApIHtcbiAgICAgIGl0NCsrXG4gICAgfVxuICAgIHZhciB2Y2ggPSBfQnVmZmVyLmFsbG9jVW5zYWZlKHplcm9lcyArIChzaXplIC0gaXQ0KSlcbiAgICB2Y2guZmlsbCgweDAwLCAwLCB6ZXJvZXMpXG4gICAgdmFyIGogPSB6ZXJvZXNcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplKSB7XG4gICAgICB2Y2hbaisrXSA9IGIyNTZbaXQ0KytdXG4gICAgfVxuICAgIHJldHVybiB2Y2hcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUgKHN0cmluZykge1xuICAgIHZhciBidWZmZXIgPSBkZWNvZGVVbnNhZmUoc3RyaW5nKVxuICAgIGlmIChidWZmZXIpIHsgcmV0dXJuIGJ1ZmZlciB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24tYmFzZScgKyBCQVNFICsgJyBjaGFyYWN0ZXInKVxuICB9XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZGVjb2RlVW5zYWZlOiBkZWNvZGVVbnNhZmUsXG4gICAgZGVjb2RlOiBkZWNvZGVcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBiYXNlXG4iLCAidmFyIGJhc2V4ID0gcmVxdWlyZSgnYmFzZS14JylcbnZhciBBTFBIQUJFVCA9ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2V4KEFMUEhBQkVUKVxuIiwgIid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyBpcyBmcmVlIGFuZCB1bmVuY3VtYmVyZWQgc29mdHdhcmUgcmVsZWFzZWQgaW50byB0aGUgcHVibGljIGRvbWFpbi5cbi8vIFNlZSBMSUNFTlNFLm1kIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4vL1xuLy8gVXRpbGl0aWVzXG4vL1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBudW1iZXIgdG8gdGVzdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLCBpbmNsdXNpdmUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHZhbHVlIGluIHRoZSByYW5nZSwgaW5jbHVzaXZlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhID49IG1pbiBhbmQgYSA8PSBtYXguXG4gKi9cbmZ1bmN0aW9uIGluUmFuZ2UoYSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIG1pbiA8PSBhICYmIGEgPD0gbWF4O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBUb0RpY3Rpb25hcnkobykge1xuICBpZiAobyA9PT0gdW5kZWZpbmVkKSByZXR1cm4ge307XG4gIGlmIChvID09PSBPYmplY3QobykpIHJldHVybiBvO1xuICB0aHJvdyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGFyZ3VtZW50IHRvIGRpY3Rpb25hcnknKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIElucHV0IHN0cmluZyBvZiBVVEYtMTYgY29kZSB1bml0cy5cbiAqIEByZXR1cm4geyFBcnJheS48bnVtYmVyPn0gQ29kZSBwb2ludHMuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQ29kZVBvaW50cyhzdHJpbmcpIHtcbiAgLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jZGZuLW9idGFpbi11bmljb2RlXG5cbiAgLy8gMS4gTGV0IFMgYmUgdGhlIERPTVN0cmluZyB2YWx1ZS5cbiAgdmFyIHMgPSBTdHJpbmcoc3RyaW5nKTtcblxuICAvLyAyLiBMZXQgbiBiZSB0aGUgbGVuZ3RoIG9mIFMuXG4gIHZhciBuID0gcy5sZW5ndGg7XG5cbiAgLy8gMy4gSW5pdGlhbGl6ZSBpIHRvIDAuXG4gIHZhciBpID0gMDtcblxuICAvLyA0LiBJbml0aWFsaXplIFUgdG8gYmUgYW4gZW1wdHkgc2VxdWVuY2Ugb2YgVW5pY29kZSBjaGFyYWN0ZXJzLlxuICB2YXIgdSA9IFtdO1xuXG4gIC8vIDUuIFdoaWxlIGkgPCBuOlxuICB3aGlsZSAoaSA8IG4pIHtcblxuICAgIC8vIDEuIExldCBjIGJlIHRoZSBjb2RlIHVuaXQgaW4gUyBhdCBpbmRleCBpLlxuICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgLy8gMi4gRGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiBjOlxuXG4gICAgLy8gYyA8IDB4RDgwMCBvciBjID4gMHhERkZGXG4gICAgaWYgKGMgPCAweEQ4MDAgfHwgYyA+IDB4REZGRikge1xuICAgICAgLy8gQXBwZW5kIHRvIFUgdGhlIFVuaWNvZGUgY2hhcmFjdGVyIHdpdGggY29kZSBwb2ludCBjLlxuICAgICAgdS5wdXNoKGMpO1xuICAgIH1cblxuICAgIC8vIDB4REMwMCBcdTIyNjQgYyBcdTIyNjQgMHhERkZGXG4gICAgZWxzZSBpZiAoMHhEQzAwIDw9IGMgJiYgYyA8PSAweERGRkYpIHtcbiAgICAgIC8vIEFwcGVuZCB0byBVIGEgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUi5cbiAgICAgIHUucHVzaCgweEZGRkQpO1xuICAgIH1cblxuICAgIC8vIDB4RDgwMCBcdTIyNjQgYyBcdTIyNjQgMHhEQkZGXG4gICAgZWxzZSBpZiAoMHhEODAwIDw9IGMgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgIC8vIDEuIElmIGkgPSBuXHUyMjEyMSwgdGhlbiBhcHBlbmQgdG8gVSBhIFUrRkZGRCBSRVBMQUNFTUVOVFxuICAgICAgLy8gQ0hBUkFDVEVSLlxuICAgICAgaWYgKGkgPT09IG4gLSAxKSB7XG4gICAgICAgIHUucHVzaCgweEZGRkQpO1xuICAgICAgfVxuICAgICAgLy8gMi4gT3RoZXJ3aXNlLCBpIDwgblx1MjIxMjE6XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gMS4gTGV0IGQgYmUgdGhlIGNvZGUgdW5pdCBpbiBTIGF0IGluZGV4IGkrMS5cbiAgICAgICAgdmFyIGQgPSBzdHJpbmcuY2hhckNvZGVBdChpICsgMSk7XG5cbiAgICAgICAgLy8gMi4gSWYgMHhEQzAwIFx1MjI2NCBkIFx1MjI2NCAweERGRkYsIHRoZW46XG4gICAgICAgIGlmICgweERDMDAgPD0gZCAmJiBkIDw9IDB4REZGRikge1xuICAgICAgICAgIC8vIDEuIExldCBhIGJlIGMgJiAweDNGRi5cbiAgICAgICAgICB2YXIgYSA9IGMgJiAweDNGRjtcblxuICAgICAgICAgIC8vIDIuIExldCBiIGJlIGQgJiAweDNGRi5cbiAgICAgICAgICB2YXIgYiA9IGQgJiAweDNGRjtcblxuICAgICAgICAgIC8vIDMuIEFwcGVuZCB0byBVIHRoZSBVbmljb2RlIGNoYXJhY3RlciB3aXRoIGNvZGUgcG9pbnRcbiAgICAgICAgICAvLyAyXjE2KzJeMTAqYStiLlxuICAgICAgICAgIHUucHVzaCgweDEwMDAwICsgKGEgPDwgMTApICsgYik7XG5cbiAgICAgICAgICAvLyA0LiBTZXQgaSB0byBpKzEuXG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gT3RoZXJ3aXNlLCBkIDwgMHhEQzAwIG9yIGQgPiAweERGRkYuIEFwcGVuZCB0byBVIGFcbiAgICAgICAgLy8gVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUi5cbiAgICAgICAgZWxzZSAge1xuICAgICAgICAgIHUucHVzaCgweEZGRkQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMy4gU2V0IGkgdG8gaSsxLlxuICAgIGkgKz0gMTtcbiAgfVxuXG4gIC8vIDYuIFJldHVybiBVLlxuICByZXR1cm4gdTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gY29kZV9wb2ludHMgQXJyYXkgb2YgY29kZSBwb2ludHMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyBTdHJpbmcgb2YgVVRGLTE2IGNvZGUgdW5pdHMuXG4gKi9cbmZ1bmN0aW9uIGNvZGVQb2ludHNUb1N0cmluZyhjb2RlX3BvaW50cykge1xuICB2YXIgcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZGVfcG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNwID0gY29kZV9wb2ludHNbaV07XG4gICAgaWYgKGNwIDw9IDB4RkZGRikge1xuICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3AgLT0gMHgxMDAwMDtcbiAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoY3AgPj4gMTApICsgMHhEODAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjcCAmIDB4M0ZGKSArIDB4REMwMCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzO1xufVxuXG5cbi8vXG4vLyBJbXBsZW1lbnRhdGlvbiBvZiBFbmNvZGluZyBzcGVjaWZpY2F0aW9uXG4vLyBodHRwczovL2VuY29kaW5nLnNwZWMud2hhdHdnLm9yZy9cbi8vXG5cbi8vXG4vLyAzLiBUZXJtaW5vbG9neVxuLy9cblxuLyoqXG4gKiBFbmQtb2Ytc3RyZWFtIGlzIGEgc3BlY2lhbCB0b2tlbiB0aGF0IHNpZ25pZmllcyBubyBtb3JlIHRva2Vuc1xuICogYXJlIGluIHRoZSBzdHJlYW0uXG4gKiBAY29uc3RcbiAqLyB2YXIgZW5kX29mX3N0cmVhbSA9IC0xO1xuXG4vKipcbiAqIEEgc3RyZWFtIHJlcHJlc2VudHMgYW4gb3JkZXJlZCBzZXF1ZW5jZSBvZiB0b2tlbnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0geyEoQXJyYXkuPG51bWJlcj58VWludDhBcnJheSl9IHRva2VucyBBcnJheSBvZiB0b2tlbnMgdGhhdCBwcm92aWRlIHRoZVxuICogc3RyZWFtLlxuICovXG5mdW5jdGlvbiBTdHJlYW0odG9rZW5zKSB7XG4gIC8qKiBAdHlwZSB7IUFycmF5LjxudW1iZXI+fSAqL1xuICB0aGlzLnRva2VucyA9IFtdLnNsaWNlLmNhbGwodG9rZW5zKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgZW5kLW9mLXN0cmVhbSBoYXMgYmVlbiBoaXQuXG4gICAqL1xuICBlbmRPZlN0cmVhbTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLnRva2Vucy5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZW4gYSB0b2tlbiBpcyByZWFkIGZyb20gYSBzdHJlYW0sIHRoZSBmaXJzdCB0b2tlbiBpbiB0aGVcbiAgICogc3RyZWFtIG11c3QgYmUgcmV0dXJuZWQgYW5kIHN1YnNlcXVlbnRseSByZW1vdmVkLCBhbmRcbiAgICogZW5kLW9mLXN0cmVhbSBtdXN0IGJlIHJldHVybmVkIG90aGVyd2lzZS5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSBHZXQgdGhlIG5leHQgdG9rZW4gZnJvbSB0aGUgc3RyZWFtLCBvclxuICAgKiBlbmRfb2Zfc3RyZWFtLlxuICAgKi9cbiAgIHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy50b2tlbnMubGVuZ3RoKVxuICAgICAgcmV0dXJuIGVuZF9vZl9zdHJlYW07XG4gICAgIHJldHVybiB0aGlzLnRva2Vucy5zaGlmdCgpO1xuICAgfSxcblxuICAvKipcbiAgICogV2hlbiBvbmUgb3IgbW9yZSB0b2tlbnMgYXJlIHByZXBlbmRlZCB0byBhIHN0cmVhbSwgdGhvc2UgdG9rZW5zXG4gICAqIG11c3QgYmUgaW5zZXJ0ZWQsIGluIGdpdmVuIG9yZGVyLCBiZWZvcmUgdGhlIGZpcnN0IHRva2VuIGluIHRoZVxuICAgKiBzdHJlYW0uXG4gICAqXG4gICAqIEBwYXJhbSB7KG51bWJlcnwhQXJyYXkuPG51bWJlcj4pfSB0b2tlbiBUaGUgdG9rZW4ocykgdG8gcHJlcGVuZCB0byB0aGUgc3RyZWFtLlxuICAgKi9cbiAgcHJlcGVuZDogZnVuY3Rpb24odG9rZW4pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0b2tlbikpIHtcbiAgICAgIHZhciB0b2tlbnMgPSAvKipAdHlwZSB7IUFycmF5LjxudW1iZXI+fSovKHRva2VuKTtcbiAgICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoKVxuICAgICAgICB0aGlzLnRva2Vucy51bnNoaWZ0KHRva2Vucy5wb3AoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudG9rZW5zLnVuc2hpZnQodG9rZW4pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogV2hlbiBvbmUgb3IgbW9yZSB0b2tlbnMgYXJlIHB1c2hlZCB0byBhIHN0cmVhbSwgdGhvc2UgdG9rZW5zXG4gICAqIG11c3QgYmUgaW5zZXJ0ZWQsIGluIGdpdmVuIG9yZGVyLCBhZnRlciB0aGUgbGFzdCB0b2tlbiBpbiB0aGVcbiAgICogc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0geyhudW1iZXJ8IUFycmF5LjxudW1iZXI+KX0gdG9rZW4gVGhlIHRva2VucyhzKSB0byBwcmVwZW5kIHRvIHRoZSBzdHJlYW0uXG4gICAqL1xuICBwdXNoOiBmdW5jdGlvbih0b2tlbikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRva2VuKSkge1xuICAgICAgdmFyIHRva2VucyA9IC8qKkB0eXBlIHshQXJyYXkuPG51bWJlcj59Ki8odG9rZW4pO1xuICAgICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpXG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2godG9rZW5zLnNoaWZ0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vXG4vLyA0LiBFbmNvZGluZ3Ncbi8vXG5cbi8vIDQuMSBFbmNvZGVycyBhbmQgZGVjb2RlcnNcblxuLyoqIEBjb25zdCAqL1xudmFyIGZpbmlzaGVkID0gLTE7XG5cbi8qKlxuICogQHBhcmFtIHtib29sZWFufSBmYXRhbCBJZiB0cnVlLCBkZWNvZGluZyBlcnJvcnMgcmFpc2UgYW4gZXhjZXB0aW9uLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfY29kZV9wb2ludCBPdmVycmlkZSB0aGUgc3RhbmRhcmQgZmFsbGJhY2sgY29kZSBwb2ludC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGNvZGUgcG9pbnQgdG8gaW5zZXJ0IG9uIGEgZGVjb2RpbmcgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZXJFcnJvcihmYXRhbCwgb3B0X2NvZGVfcG9pbnQpIHtcbiAgaWYgKGZhdGFsKVxuICAgIHRocm93IFR5cGVFcnJvcignRGVjb2RlciBlcnJvcicpO1xuICByZXR1cm4gb3B0X2NvZGVfcG9pbnQgfHwgMHhGRkZEO1xufVxuXG4vL1xuLy8gNy4gQVBJXG4vL1xuXG4vKiogQGNvbnN0ICovIHZhciBERUZBVUxUX0VOQ09ESU5HID0gJ3V0Zi04JztcblxuLy8gNy4xIEludGVyZmFjZSBUZXh0RGVjb2RlclxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmc9fSBlbmNvZGluZyBUaGUgbGFiZWwgb2YgdGhlIGVuY29kaW5nO1xuICogICAgIGRlZmF1bHRzIHRvICd1dGYtOCcuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gVGV4dERlY29kZXIoZW5jb2RpbmcsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRleHREZWNvZGVyKSkge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcsIG9wdGlvbnMpO1xuICB9XG4gIGVuY29kaW5nID0gZW5jb2RpbmcgIT09IHVuZGVmaW5lZCA/IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSA6IERFRkFVTFRfRU5DT0RJTkc7XG4gIGlmIChlbmNvZGluZyAhPT0gREVGQVVMVF9FTkNPRElORykge1xuICAgIHRocm93IG5ldyBFcnJvcignRW5jb2Rpbmcgbm90IHN1cHBvcnRlZC4gT25seSB1dGYtOCBpcyBzdXBwb3J0ZWQnKTtcbiAgfVxuICBvcHRpb25zID0gVG9EaWN0aW9uYXJ5KG9wdGlvbnMpO1xuXG4gIC8qKiBAcHJpdmF0ZSBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgdGhpcy5fc3RyZWFtaW5nID0gZmFsc2U7XG4gIC8qKiBAcHJpdmF0ZSBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgdGhpcy5fQk9Nc2VlbiA9IGZhbHNlO1xuICAvKiogQHByaXZhdGUgQHR5cGUgez9EZWNvZGVyfSAqL1xuICB0aGlzLl9kZWNvZGVyID0gbnVsbDtcbiAgLyoqIEBwcml2YXRlIEB0eXBlIHtib29sZWFufSAqL1xuICB0aGlzLl9mYXRhbCA9IEJvb2xlYW4ob3B0aW9uc1snZmF0YWwnXSk7XG4gIC8qKiBAcHJpdmF0ZSBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgdGhpcy5faWdub3JlQk9NID0gQm9vbGVhbihvcHRpb25zWydpZ25vcmVCT00nXSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdlbmNvZGluZycsIHt2YWx1ZTogJ3V0Zi04J30pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2ZhdGFsJywge3ZhbHVlOiB0aGlzLl9mYXRhbH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lnbm9yZUJPTScsIHt2YWx1ZTogdGhpcy5faWdub3JlQk9NfSk7XG59XG5cblRleHREZWNvZGVyLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3PX0gaW5wdXQgVGhlIGJ1ZmZlciBvZiBieXRlcyB0byBkZWNvZGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBkZWNvZGVkIHN0cmluZy5cbiAgICovXG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgdmFyIGJ5dGVzO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiAnYnVmZmVyJyBpbiBpbnB1dCAmJlxuICAgICAgICAgICAgICAgaW5wdXQuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQuYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5ieXRlTGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gVG9EaWN0aW9uYXJ5KG9wdGlvbnMpO1xuXG4gICAgaWYgKCF0aGlzLl9zdHJlYW1pbmcpIHtcbiAgICAgIHRoaXMuX2RlY29kZXIgPSBuZXcgVVRGOERlY29kZXIoe2ZhdGFsOiB0aGlzLl9mYXRhbH0pO1xuICAgICAgdGhpcy5fQk9Nc2VlbiA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9zdHJlYW1pbmcgPSBCb29sZWFuKG9wdGlvbnNbJ3N0cmVhbSddKTtcblxuICAgIHZhciBpbnB1dF9zdHJlYW0gPSBuZXcgU3RyZWFtKGJ5dGVzKTtcblxuICAgIHZhciBjb2RlX3BvaW50cyA9IFtdO1xuXG4gICAgLyoqIEB0eXBlIHs/KG51bWJlcnwhQXJyYXkuPG51bWJlcj4pfSAqL1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICB3aGlsZSAoIWlucHV0X3N0cmVhbS5lbmRPZlN0cmVhbSgpKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLl9kZWNvZGVyLmhhbmRsZXIoaW5wdXRfc3RyZWFtLCBpbnB1dF9zdHJlYW0ucmVhZCgpKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IGZpbmlzaGVkKVxuICAgICAgICBicmVhaztcbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSlcbiAgICAgICAgY29kZV9wb2ludHMucHVzaC5hcHBseShjb2RlX3BvaW50cywgLyoqQHR5cGUgeyFBcnJheS48bnVtYmVyPn0qLyhyZXN1bHQpKTtcbiAgICAgIGVsc2VcbiAgICAgICAgY29kZV9wb2ludHMucHVzaChyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3N0cmVhbWluZykge1xuICAgICAgZG8ge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9kZWNvZGVyLmhhbmRsZXIoaW5wdXRfc3RyZWFtLCBpbnB1dF9zdHJlYW0ucmVhZCgpKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmluaXNoZWQpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpXG4gICAgICAgICAgY29kZV9wb2ludHMucHVzaC5hcHBseShjb2RlX3BvaW50cywgLyoqQHR5cGUgeyFBcnJheS48bnVtYmVyPn0qLyhyZXN1bHQpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGNvZGVfcG9pbnRzLnB1c2gocmVzdWx0KTtcbiAgICAgIH0gd2hpbGUgKCFpbnB1dF9zdHJlYW0uZW5kT2ZTdHJlYW0oKSk7XG4gICAgICB0aGlzLl9kZWNvZGVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY29kZV9wb2ludHMubGVuZ3RoKSB7XG4gICAgICAvLyBJZiBlbmNvZGluZyBpcyBvbmUgb2YgdXRmLTgsIHV0Zi0xNmJlLCBhbmQgdXRmLTE2bGUsIGFuZFxuICAgICAgLy8gaWdub3JlIEJPTSBmbGFnIGFuZCBCT00gc2VlbiBmbGFnIGFyZSB1bnNldCwgcnVuIHRoZXNlXG4gICAgICAvLyBzdWJzdWJzdGVwczpcbiAgICAgIGlmIChbJ3V0Zi04J10uaW5kZXhPZih0aGlzLmVuY29kaW5nKSAhPT0gLTEgJiZcbiAgICAgICAgICAhdGhpcy5faWdub3JlQk9NICYmICF0aGlzLl9CT01zZWVuKSB7XG4gICAgICAgIC8vIElmIHRva2VuIGlzIFUrRkVGRiwgc2V0IEJPTSBzZWVuIGZsYWcuXG4gICAgICAgIGlmIChjb2RlX3BvaW50c1swXSA9PT0gMHhGRUZGKSB7XG4gICAgICAgICAgdGhpcy5fQk9Nc2VlbiA9IHRydWU7XG4gICAgICAgICAgY29kZV9wb2ludHMuc2hpZnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UsIGlmIHRva2VuIGlzIG5vdCBlbmQtb2Ytc3RyZWFtLCBzZXQgQk9NIHNlZW5cbiAgICAgICAgICAvLyBmbGFnIGFuZCBhcHBlbmQgdG9rZW4gdG8gb3V0cHV0LlxuICAgICAgICAgIHRoaXMuX0JPTXNlZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvZGVQb2ludHNUb1N0cmluZyhjb2RlX3BvaW50cyk7XG4gIH1cbn07XG5cbi8vIDcuMiBJbnRlcmZhY2UgVGV4dEVuY29kZXJcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nPX0gZW5jb2RpbmcgVGhlIGxhYmVsIG9mIHRoZSBlbmNvZGluZztcbiAqICAgICBkZWZhdWx0cyB0byAndXRmLTgnLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFRleHRFbmNvZGVyKGVuY29kaW5nLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUZXh0RW5jb2RlcikpXG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcihlbmNvZGluZywgb3B0aW9ucyk7XG4gIGVuY29kaW5nID0gZW5jb2RpbmcgIT09IHVuZGVmaW5lZCA/IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSA6IERFRkFVTFRfRU5DT0RJTkc7XG4gIGlmIChlbmNvZGluZyAhPT0gREVGQVVMVF9FTkNPRElORykge1xuICAgIHRocm93IG5ldyBFcnJvcignRW5jb2Rpbmcgbm90IHN1cHBvcnRlZC4gT25seSB1dGYtOCBpcyBzdXBwb3J0ZWQnKTtcbiAgfVxuICBvcHRpb25zID0gVG9EaWN0aW9uYXJ5KG9wdGlvbnMpO1xuXG4gIC8qKiBAcHJpdmF0ZSBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgdGhpcy5fc3RyZWFtaW5nID0gZmFsc2U7XG4gIC8qKiBAcHJpdmF0ZSBAdHlwZSB7P0VuY29kZXJ9ICovXG4gIHRoaXMuX2VuY29kZXIgPSBudWxsO1xuICAvKiogQHByaXZhdGUgQHR5cGUge3tmYXRhbDogYm9vbGVhbn19ICovXG4gIHRoaXMuX29wdGlvbnMgPSB7ZmF0YWw6IEJvb2xlYW4ob3B0aW9uc1snZmF0YWwnXSl9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZW5jb2RpbmcnLCB7dmFsdWU6ICd1dGYtOCd9KTtcbn1cblxuVGV4dEVuY29kZXIucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfc3RyaW5nIFRoZSBzdHJpbmcgdG8gZW5jb2RlLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAgICogQHJldHVybiB7VWludDhBcnJheX0gRW5jb2RlZCBieXRlcywgYXMgYSBVaW50OEFycmF5LlxuICAgKi9cbiAgZW5jb2RlOiBmdW5jdGlvbiBlbmNvZGUob3B0X3N0cmluZywgb3B0aW9ucykge1xuICAgIG9wdF9zdHJpbmcgPSBvcHRfc3RyaW5nID8gU3RyaW5nKG9wdF9zdHJpbmcpIDogJyc7XG4gICAgb3B0aW9ucyA9IFRvRGljdGlvbmFyeShvcHRpb25zKTtcblxuICAgIC8vIE5PVEU6IFRoaXMgb3B0aW9uIGlzIG5vbnN0YW5kYXJkLiBOb25lIG9mIHRoZSBlbmNvZGluZ3NcbiAgICAvLyBwZXJtaXR0ZWQgZm9yIGVuY29kaW5nIChpLmUuIFVURi04LCBVVEYtMTYpIGFyZSBzdGF0ZWZ1bCxcbiAgICAvLyBzbyBzdHJlYW1pbmcgaXMgbm90IG5lY2Vzc2FyeS5cbiAgICBpZiAoIXRoaXMuX3N0cmVhbWluZylcbiAgICAgIHRoaXMuX2VuY29kZXIgPSBuZXcgVVRGOEVuY29kZXIodGhpcy5fb3B0aW9ucyk7XG4gICAgdGhpcy5fc3RyZWFtaW5nID0gQm9vbGVhbihvcHRpb25zWydzdHJlYW0nXSk7XG5cbiAgICB2YXIgYnl0ZXMgPSBbXTtcbiAgICB2YXIgaW5wdXRfc3RyZWFtID0gbmV3IFN0cmVhbShzdHJpbmdUb0NvZGVQb2ludHMob3B0X3N0cmluZykpO1xuICAgIC8qKiBAdHlwZSB7PyhudW1iZXJ8IUFycmF5LjxudW1iZXI+KX0gKi9cbiAgICB2YXIgcmVzdWx0O1xuICAgIHdoaWxlICghaW5wdXRfc3RyZWFtLmVuZE9mU3RyZWFtKCkpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2VuY29kZXIuaGFuZGxlcihpbnB1dF9zdHJlYW0sIGlucHV0X3N0cmVhbS5yZWFkKCkpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gZmluaXNoZWQpXG4gICAgICAgIGJyZWFrO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSlcbiAgICAgICAgYnl0ZXMucHVzaC5hcHBseShieXRlcywgLyoqQHR5cGUgeyFBcnJheS48bnVtYmVyPn0qLyhyZXN1bHQpKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYnl0ZXMucHVzaChyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3N0cmVhbWluZykge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fZW5jb2Rlci5oYW5kbGVyKGlucHV0X3N0cmVhbSwgaW5wdXRfc3RyZWFtLnJlYWQoKSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZpbmlzaGVkKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKVxuICAgICAgICAgIGJ5dGVzLnB1c2guYXBwbHkoYnl0ZXMsIC8qKkB0eXBlIHshQXJyYXkuPG51bWJlcj59Ki8ocmVzdWx0KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBieXRlcy5wdXNoKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9lbmNvZGVyID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgfVxufTtcblxuLy9cbi8vIDguIFRoZSBlbmNvZGluZ1xuLy9cblxuLy8gOC4xIHV0Zi04XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7RGVjb2Rlcn1cbiAqIEBwYXJhbSB7e2ZhdGFsOiBib29sZWFufX0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBVVEY4RGVjb2RlcihvcHRpb25zKSB7XG4gIHZhciBmYXRhbCA9IG9wdGlvbnMuZmF0YWw7XG5cbiAgLy8gdXRmLTgncyBkZWNvZGVyJ3MgaGFzIGFuIGFzc29jaWF0ZWQgdXRmLTggY29kZSBwb2ludCwgdXRmLThcbiAgLy8gYnl0ZXMgc2VlbiwgYW5kIHV0Zi04IGJ5dGVzIG5lZWRlZCAoYWxsIGluaXRpYWxseSAwKSwgYSB1dGYtOFxuICAvLyBsb3dlciBib3VuZGFyeSAoaW5pdGlhbGx5IDB4ODApLCBhbmQgYSB1dGYtOCB1cHBlciBib3VuZGFyeVxuICAvLyAoaW5pdGlhbGx5IDB4QkYpLlxuICB2YXIgLyoqIEB0eXBlIHtudW1iZXJ9ICovIHV0ZjhfY29kZV9wb2ludCA9IDAsXG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gdXRmOF9ieXRlc19zZWVuID0gMCxcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyB1dGY4X2J5dGVzX25lZWRlZCA9IDAsXG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gdXRmOF9sb3dlcl9ib3VuZGFyeSA9IDB4ODAsXG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gdXRmOF91cHBlcl9ib3VuZGFyeSA9IDB4QkY7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gVGhlIHN0cmVhbSBvZiBieXRlcyBiZWluZyBkZWNvZGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYml0ZSBUaGUgbmV4dCBieXRlIHJlYWQgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBAcmV0dXJuIHs/KG51bWJlcnwhQXJyYXkuPG51bWJlcj4pfSBUaGUgbmV4dCBjb2RlIHBvaW50KHMpXG4gICAqICAgICBkZWNvZGVkLCBvciBudWxsIGlmIG5vdCBlbm91Z2ggZGF0YSBleGlzdHMgaW4gdGhlIGlucHV0XG4gICAqICAgICBzdHJlYW0gdG8gZGVjb2RlIGEgY29tcGxldGUgY29kZSBwb2ludC5cbiAgICovXG4gIHRoaXMuaGFuZGxlciA9IGZ1bmN0aW9uKHN0cmVhbSwgYml0ZSkge1xuICAgIC8vIDEuIElmIGJ5dGUgaXMgZW5kLW9mLXN0cmVhbSBhbmQgdXRmLTggYnl0ZXMgbmVlZGVkIGlzIG5vdCAwLFxuICAgIC8vIHNldCB1dGYtOCBieXRlcyBuZWVkZWQgdG8gMCBhbmQgcmV0dXJuIGVycm9yLlxuICAgIGlmIChiaXRlID09PSBlbmRfb2Zfc3RyZWFtICYmIHV0ZjhfYnl0ZXNfbmVlZGVkICE9PSAwKSB7XG4gICAgICB1dGY4X2J5dGVzX25lZWRlZCA9IDA7XG4gICAgICByZXR1cm4gZGVjb2RlckVycm9yKGZhdGFsKTtcbiAgICB9XG5cbiAgICAvLyAyLiBJZiBieXRlIGlzIGVuZC1vZi1zdHJlYW0sIHJldHVybiBmaW5pc2hlZC5cbiAgICBpZiAoYml0ZSA9PT0gZW5kX29mX3N0cmVhbSlcbiAgICAgIHJldHVybiBmaW5pc2hlZDtcblxuICAgIC8vIDMuIElmIHV0Zi04IGJ5dGVzIG5lZWRlZCBpcyAwLCBiYXNlZCBvbiBieXRlOlxuICAgIGlmICh1dGY4X2J5dGVzX25lZWRlZCA9PT0gMCkge1xuXG4gICAgICAvLyAweDAwIHRvIDB4N0ZcbiAgICAgIGlmIChpblJhbmdlKGJpdGUsIDB4MDAsIDB4N0YpKSB7XG4gICAgICAgIC8vIFJldHVybiBhIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgaXMgYnl0ZS5cbiAgICAgICAgcmV0dXJuIGJpdGU7XG4gICAgICB9XG5cbiAgICAgIC8vIDB4QzIgdG8gMHhERlxuICAgICAgaWYgKGluUmFuZ2UoYml0ZSwgMHhDMiwgMHhERikpIHtcbiAgICAgICAgLy8gU2V0IHV0Zi04IGJ5dGVzIG5lZWRlZCB0byAxIGFuZCB1dGYtOCBjb2RlIHBvaW50IHRvIGJ5dGVcbiAgICAgICAgLy8gXHUyMjEyIDB4QzAuXG4gICAgICAgIHV0ZjhfYnl0ZXNfbmVlZGVkID0gMTtcbiAgICAgICAgdXRmOF9jb2RlX3BvaW50ID0gYml0ZSAtIDB4QzA7XG4gICAgICB9XG5cbiAgICAgIC8vIDB4RTAgdG8gMHhFRlxuICAgICAgZWxzZSBpZiAoaW5SYW5nZShiaXRlLCAweEUwLCAweEVGKSkge1xuICAgICAgICAvLyAxLiBJZiBieXRlIGlzIDB4RTAsIHNldCB1dGYtOCBsb3dlciBib3VuZGFyeSB0byAweEEwLlxuICAgICAgICBpZiAoYml0ZSA9PT0gMHhFMClcbiAgICAgICAgICB1dGY4X2xvd2VyX2JvdW5kYXJ5ID0gMHhBMDtcbiAgICAgICAgLy8gMi4gSWYgYnl0ZSBpcyAweEVELCBzZXQgdXRmLTggdXBwZXIgYm91bmRhcnkgdG8gMHg5Ri5cbiAgICAgICAgaWYgKGJpdGUgPT09IDB4RUQpXG4gICAgICAgICAgdXRmOF91cHBlcl9ib3VuZGFyeSA9IDB4OUY7XG4gICAgICAgIC8vIDMuIFNldCB1dGYtOCBieXRlcyBuZWVkZWQgdG8gMiBhbmQgdXRmLTggY29kZSBwb2ludCB0b1xuICAgICAgICAvLyBieXRlIFx1MjIxMiAweEUwLlxuICAgICAgICB1dGY4X2J5dGVzX25lZWRlZCA9IDI7XG4gICAgICAgIHV0ZjhfY29kZV9wb2ludCA9IGJpdGUgLSAweEUwO1xuICAgICAgfVxuXG4gICAgICAvLyAweEYwIHRvIDB4RjRcbiAgICAgIGVsc2UgaWYgKGluUmFuZ2UoYml0ZSwgMHhGMCwgMHhGNCkpIHtcbiAgICAgICAgLy8gMS4gSWYgYnl0ZSBpcyAweEYwLCBzZXQgdXRmLTggbG93ZXIgYm91bmRhcnkgdG8gMHg5MC5cbiAgICAgICAgaWYgKGJpdGUgPT09IDB4RjApXG4gICAgICAgICAgdXRmOF9sb3dlcl9ib3VuZGFyeSA9IDB4OTA7XG4gICAgICAgIC8vIDIuIElmIGJ5dGUgaXMgMHhGNCwgc2V0IHV0Zi04IHVwcGVyIGJvdW5kYXJ5IHRvIDB4OEYuXG4gICAgICAgIGlmIChiaXRlID09PSAweEY0KVxuICAgICAgICAgIHV0ZjhfdXBwZXJfYm91bmRhcnkgPSAweDhGO1xuICAgICAgICAvLyAzLiBTZXQgdXRmLTggYnl0ZXMgbmVlZGVkIHRvIDMgYW5kIHV0Zi04IGNvZGUgcG9pbnQgdG9cbiAgICAgICAgLy8gYnl0ZSBcdTIyMTIgMHhGMC5cbiAgICAgICAgdXRmOF9ieXRlc19uZWVkZWQgPSAzO1xuICAgICAgICB1dGY4X2NvZGVfcG9pbnQgPSBiaXRlIC0gMHhGMDtcbiAgICAgIH1cblxuICAgICAgLy8gT3RoZXJ3aXNlXG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gUmV0dXJuIGVycm9yLlxuICAgICAgICByZXR1cm4gZGVjb2RlckVycm9yKGZhdGFsKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlbiAoYnl0ZSBpcyBpbiB0aGUgcmFuZ2UgMHhDMiB0byAweEY0KSBzZXQgdXRmLTggY29kZVxuICAgICAgLy8gcG9pbnQgdG8gdXRmLTggY29kZSBwb2ludCA8PCAoNiBcdTAwRDcgdXRmLTggYnl0ZXMgbmVlZGVkKSBhbmRcbiAgICAgIC8vIHJldHVybiBjb250aW51ZS5cbiAgICAgIHV0ZjhfY29kZV9wb2ludCA9IHV0ZjhfY29kZV9wb2ludCA8PCAoNiAqIHV0ZjhfYnl0ZXNfbmVlZGVkKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIDQuIElmIGJ5dGUgaXMgbm90IGluIHRoZSByYW5nZSB1dGYtOCBsb3dlciBib3VuZGFyeSB0byB1dGYtOFxuICAgIC8vIHVwcGVyIGJvdW5kYXJ5LCBydW4gdGhlc2Ugc3Vic3RlcHM6XG4gICAgaWYgKCFpblJhbmdlKGJpdGUsIHV0ZjhfbG93ZXJfYm91bmRhcnksIHV0ZjhfdXBwZXJfYm91bmRhcnkpKSB7XG5cbiAgICAgIC8vIDEuIFNldCB1dGYtOCBjb2RlIHBvaW50LCB1dGYtOCBieXRlcyBuZWVkZWQsIGFuZCB1dGYtOFxuICAgICAgLy8gYnl0ZXMgc2VlbiB0byAwLCBzZXQgdXRmLTggbG93ZXIgYm91bmRhcnkgdG8gMHg4MCwgYW5kIHNldFxuICAgICAgLy8gdXRmLTggdXBwZXIgYm91bmRhcnkgdG8gMHhCRi5cbiAgICAgIHV0ZjhfY29kZV9wb2ludCA9IHV0ZjhfYnl0ZXNfbmVlZGVkID0gdXRmOF9ieXRlc19zZWVuID0gMDtcbiAgICAgIHV0ZjhfbG93ZXJfYm91bmRhcnkgPSAweDgwO1xuICAgICAgdXRmOF91cHBlcl9ib3VuZGFyeSA9IDB4QkY7XG5cbiAgICAgIC8vIDIuIFByZXBlbmQgYnl0ZSB0byBzdHJlYW0uXG4gICAgICBzdHJlYW0ucHJlcGVuZChiaXRlKTtcblxuICAgICAgLy8gMy4gUmV0dXJuIGVycm9yLlxuICAgICAgcmV0dXJuIGRlY29kZXJFcnJvcihmYXRhbCk7XG4gICAgfVxuXG4gICAgLy8gNS4gU2V0IHV0Zi04IGxvd2VyIGJvdW5kYXJ5IHRvIDB4ODAgYW5kIHV0Zi04IHVwcGVyIGJvdW5kYXJ5XG4gICAgLy8gdG8gMHhCRi5cbiAgICB1dGY4X2xvd2VyX2JvdW5kYXJ5ID0gMHg4MDtcbiAgICB1dGY4X3VwcGVyX2JvdW5kYXJ5ID0gMHhCRjtcblxuICAgIC8vIDYuIEluY3JlYXNlIHV0Zi04IGJ5dGVzIHNlZW4gYnkgb25lIGFuZCBzZXQgdXRmLTggY29kZSBwb2ludFxuICAgIC8vIHRvIHV0Zi04IGNvZGUgcG9pbnQgKyAoYnl0ZSBcdTIyMTIgMHg4MCkgPDwgKDYgXHUwMEQ3ICh1dGYtOCBieXRlc1xuICAgIC8vIG5lZWRlZCBcdTIyMTIgdXRmLTggYnl0ZXMgc2VlbikpLlxuICAgIHV0ZjhfYnl0ZXNfc2VlbiArPSAxO1xuICAgIHV0ZjhfY29kZV9wb2ludCArPSAoYml0ZSAtIDB4ODApIDw8ICg2ICogKHV0ZjhfYnl0ZXNfbmVlZGVkIC0gdXRmOF9ieXRlc19zZWVuKSk7XG5cbiAgICAvLyA3LiBJZiB1dGYtOCBieXRlcyBzZWVuIGlzIG5vdCBlcXVhbCB0byB1dGYtOCBieXRlcyBuZWVkZWQsXG4gICAgLy8gY29udGludWUuXG4gICAgaWYgKHV0ZjhfYnl0ZXNfc2VlbiAhPT0gdXRmOF9ieXRlc19uZWVkZWQpXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIC8vIDguIExldCBjb2RlIHBvaW50IGJlIHV0Zi04IGNvZGUgcG9pbnQuXG4gICAgdmFyIGNvZGVfcG9pbnQgPSB1dGY4X2NvZGVfcG9pbnQ7XG5cbiAgICAvLyA5LiBTZXQgdXRmLTggY29kZSBwb2ludCwgdXRmLTggYnl0ZXMgbmVlZGVkLCBhbmQgdXRmLTggYnl0ZXNcbiAgICAvLyBzZWVuIHRvIDAuXG4gICAgdXRmOF9jb2RlX3BvaW50ID0gdXRmOF9ieXRlc19uZWVkZWQgPSB1dGY4X2J5dGVzX3NlZW4gPSAwO1xuXG4gICAgLy8gMTAuIFJldHVybiBhIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgaXMgY29kZSBwb2ludC5cbiAgICByZXR1cm4gY29kZV9wb2ludDtcbiAgfTtcbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtFbmNvZGVyfVxuICogQHBhcmFtIHt7ZmF0YWw6IGJvb2xlYW59fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFVURjhFbmNvZGVyKG9wdGlvbnMpIHtcbiAgdmFyIGZhdGFsID0gb3B0aW9ucy5mYXRhbDtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gSW5wdXQgc3RyZWFtLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY29kZV9wb2ludCBOZXh0IGNvZGUgcG9pbnQgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIEByZXR1cm4geyhudW1iZXJ8IUFycmF5LjxudW1iZXI+KX0gQnl0ZShzKSB0byBlbWl0LlxuICAgKi9cbiAgdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24oc3RyZWFtLCBjb2RlX3BvaW50KSB7XG4gICAgLy8gMS4gSWYgY29kZSBwb2ludCBpcyBlbmQtb2Ytc3RyZWFtLCByZXR1cm4gZmluaXNoZWQuXG4gICAgaWYgKGNvZGVfcG9pbnQgPT09IGVuZF9vZl9zdHJlYW0pXG4gICAgICByZXR1cm4gZmluaXNoZWQ7XG5cbiAgICAvLyAyLiBJZiBjb2RlIHBvaW50IGlzIGluIHRoZSByYW5nZSBVKzAwMDAgdG8gVSswMDdGLCByZXR1cm4gYVxuICAgIC8vIGJ5dGUgd2hvc2UgdmFsdWUgaXMgY29kZSBwb2ludC5cbiAgICBpZiAoaW5SYW5nZShjb2RlX3BvaW50LCAweDAwMDAsIDB4MDA3ZikpXG4gICAgICByZXR1cm4gY29kZV9wb2ludDtcblxuICAgIC8vIDMuIFNldCBjb3VudCBhbmQgb2Zmc2V0IGJhc2VkIG9uIHRoZSByYW5nZSBjb2RlIHBvaW50IGlzIGluOlxuICAgIHZhciBjb3VudCwgb2Zmc2V0O1xuICAgIC8vIFUrMDA4MCB0byBVKzA3RkY6ICAgIDEgYW5kIDB4QzBcbiAgICBpZiAoaW5SYW5nZShjb2RlX3BvaW50LCAweDAwODAsIDB4MDdGRikpIHtcbiAgICAgIGNvdW50ID0gMTtcbiAgICAgIG9mZnNldCA9IDB4QzA7XG4gICAgfVxuICAgIC8vIFUrMDgwMCB0byBVK0ZGRkY6ICAgIDIgYW5kIDB4RTBcbiAgICBlbHNlIGlmIChpblJhbmdlKGNvZGVfcG9pbnQsIDB4MDgwMCwgMHhGRkZGKSkge1xuICAgICAgY291bnQgPSAyO1xuICAgICAgb2Zmc2V0ID0gMHhFMDtcbiAgICB9XG4gICAgLy8gVSsxMDAwMCB0byBVKzEwRkZGRjogMyBhbmQgMHhGMFxuICAgIGVsc2UgaWYgKGluUmFuZ2UoY29kZV9wb2ludCwgMHgxMDAwMCwgMHgxMEZGRkYpKSB7XG4gICAgICBjb3VudCA9IDM7XG4gICAgICBvZmZzZXQgPSAweEYwO1xuICAgIH1cblxuICAgIC8vIDQuTGV0IGJ5dGVzIGJlIGEgYnl0ZSBzZXF1ZW5jZSB3aG9zZSBmaXJzdCBieXRlIGlzIChjb2RlXG4gICAgLy8gcG9pbnQgPj4gKDYgXHUwMEQ3IGNvdW50KSkgKyBvZmZzZXQuXG4gICAgdmFyIGJ5dGVzID0gWyhjb2RlX3BvaW50ID4+ICg2ICogY291bnQpKSArIG9mZnNldF07XG5cbiAgICAvLyA1LiBSdW4gdGhlc2Ugc3Vic3RlcHMgd2hpbGUgY291bnQgaXMgZ3JlYXRlciB0aGFuIDA6XG4gICAgd2hpbGUgKGNvdW50ID4gMCkge1xuXG4gICAgICAvLyAxLiBTZXQgdGVtcCB0byBjb2RlIHBvaW50ID4+ICg2IFx1MDBENyAoY291bnQgXHUyMjEyIDEpKS5cbiAgICAgIHZhciB0ZW1wID0gY29kZV9wb2ludCA+PiAoNiAqIChjb3VudCAtIDEpKTtcblxuICAgICAgLy8gMi4gQXBwZW5kIHRvIGJ5dGVzIDB4ODAgfCAodGVtcCAmIDB4M0YpLlxuICAgICAgYnl0ZXMucHVzaCgweDgwIHwgKHRlbXAgJiAweDNGKSk7XG5cbiAgICAgIC8vIDMuIERlY3JlYXNlIGNvdW50IGJ5IG9uZS5cbiAgICAgIGNvdW50IC09IDE7XG4gICAgfVxuXG4gICAgLy8gNi4gUmV0dXJuIGJ5dGVzIGJ5dGVzLCBpbiBvcmRlci5cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG59XG5cbmV4cG9ydHMuVGV4dEVuY29kZXIgPSBUZXh0RW5jb2RlcjtcbmV4cG9ydHMuVGV4dERlY29kZXIgPSBUZXh0RGVjb2RlcjsiLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZXNlcmlhbGl6ZVVuY2hlY2tlZCA9IGV4cG9ydHMuZGVzZXJpYWxpemUgPSBleHBvcnRzLnNlcmlhbGl6ZSA9IGV4cG9ydHMuQmluYXJ5UmVhZGVyID0gZXhwb3J0cy5CaW5hcnlXcml0ZXIgPSBleHBvcnRzLkJvcnNoRXJyb3IgPSBleHBvcnRzLmJhc2VEZWNvZGUgPSBleHBvcnRzLmJhc2VFbmNvZGUgPSB2b2lkIDA7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG5jb25zdCBiczU4XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJzNThcIikpO1xuLy8gVE9ETzogTWFrZSBzdXJlIHRoaXMgcG9seWZpbGwgbm90IGluY2x1ZGVkIHdoZW4gbm90IHJlcXVpcmVkXG5jb25zdCBlbmNvZGluZyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwidGV4dC1lbmNvZGluZy11dGYtOFwiKSk7XG5jb25zdCBSZXNvbHZlZFRleHREZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyICE9PSBcImZ1bmN0aW9uXCIgPyBlbmNvZGluZy5UZXh0RGVjb2RlciA6IFRleHREZWNvZGVyO1xuY29uc3QgdGV4dERlY29kZXIgPSBuZXcgUmVzb2x2ZWRUZXh0RGVjb2RlcihcInV0Zi04XCIsIHsgZmF0YWw6IHRydWUgfSk7XG5mdW5jdGlvbiBiYXNlRW5jb2RlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLCBcInV0ZjhcIik7XG4gICAgfVxuICAgIHJldHVybiBiczU4XzEuZGVmYXVsdC5lbmNvZGUoQnVmZmVyLmZyb20odmFsdWUpKTtcbn1cbmV4cG9ydHMuYmFzZUVuY29kZSA9IGJhc2VFbmNvZGU7XG5mdW5jdGlvbiBiYXNlRGVjb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJzNThfMS5kZWZhdWx0LmRlY29kZSh2YWx1ZSkpO1xufVxuZXhwb3J0cy5iYXNlRGVjb2RlID0gYmFzZURlY29kZTtcbmNvbnN0IElOSVRJQUxfTEVOR1RIID0gMTAyNDtcbmNsYXNzIEJvcnNoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5maWVsZFBhdGggPSBbXTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbE1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbiAgICBhZGRUb0ZpZWxkUGF0aChmaWVsZE5hbWUpIHtcbiAgICAgICAgdGhpcy5maWVsZFBhdGguc3BsaWNlKDAsIDAsIGZpZWxkTmFtZSk7XG4gICAgICAgIC8vIE5PVEU6IE1vZGlmeWluZyBtZXNzYWdlIGRpcmVjdGx5IGFzIGplc3QgZG9lc24ndCB1c2UgLnRvU3RyaW5nKClcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5vcmlnaW5hbE1lc3NhZ2UgKyBcIjogXCIgKyB0aGlzLmZpZWxkUGF0aC5qb2luKFwiLlwiKTtcbiAgICB9XG59XG5leHBvcnRzLkJvcnNoRXJyb3IgPSBCb3JzaEVycm9yO1xuLy8vIEJpbmFyeSBlbmNvZGVyLlxuY2xhc3MgQmluYXJ5V3JpdGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5idWYgPSBCdWZmZXIuYWxsb2MoSU5JVElBTF9MRU5HVEgpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIG1heWJlUmVzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5idWYubGVuZ3RoIDwgMTYgKyB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5idWYgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmJ1ZiwgQnVmZmVyLmFsbG9jKElOSVRJQUxfTEVOR1RIKV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdyaXRlVTgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZVVJbnQ4KHZhbHVlLCB0aGlzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IDE7XG4gICAgfVxuICAgIHdyaXRlVTE2KHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWF5YmVSZXNpemUoKTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVVSW50MTZMRSh2YWx1ZSwgdGhpcy5sZW5ndGgpO1xuICAgICAgICB0aGlzLmxlbmd0aCArPSAyO1xuICAgIH1cbiAgICB3cml0ZVUzMih2YWx1ZSkge1xuICAgICAgICB0aGlzLm1heWJlUmVzaXplKCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlVUludDMyTEUodmFsdWUsIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gNDtcbiAgICB9XG4gICAgd3JpdGVVNjQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyKEJ1ZmZlci5mcm9tKG5ldyBibl9qc18xLmRlZmF1bHQodmFsdWUpLnRvQXJyYXkoXCJsZVwiLCA4KSkpO1xuICAgIH1cbiAgICB3cml0ZVUxMjgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyKEJ1ZmZlci5mcm9tKG5ldyBibl9qc18xLmRlZmF1bHQodmFsdWUpLnRvQXJyYXkoXCJsZVwiLCAxNikpKTtcbiAgICB9XG4gICAgd3JpdGVVMjU2KHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWF5YmVSZXNpemUoKTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcihCdWZmZXIuZnJvbShuZXcgYm5fanNfMS5kZWZhdWx0KHZhbHVlKS50b0FycmF5KFwibGVcIiwgMzIpKSk7XG4gICAgfVxuICAgIHdyaXRlVTUxMih2YWx1ZSkge1xuICAgICAgICB0aGlzLm1heWJlUmVzaXplKCk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIoQnVmZmVyLmZyb20obmV3IGJuX2pzXzEuZGVmYXVsdCh2YWx1ZSkudG9BcnJheShcImxlXCIsIDY0KSkpO1xuICAgIH1cbiAgICB3cml0ZUJ1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgLy8gQnVmZmVyLmZyb20gaXMgbmVlZGVkIGFzIHRoaXMuYnVmLnN1YmFycmF5IGNhbiByZXR1cm4gcGxhaW4gVWludDhBcnJheSBpbiBicm93c2VyXG4gICAgICAgIHRoaXMuYnVmID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICBCdWZmZXIuZnJvbSh0aGlzLmJ1Zi5zdWJhcnJheSgwLCB0aGlzLmxlbmd0aCkpLFxuICAgICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgICAgQnVmZmVyLmFsbG9jKElOSVRJQUxfTEVOR1RIKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIHdyaXRlU3RyaW5nKHN0cikge1xuICAgICAgICB0aGlzLm1heWJlUmVzaXplKCk7XG4gICAgICAgIGNvbnN0IGIgPSBCdWZmZXIuZnJvbShzdHIsIFwidXRmOFwiKTtcbiAgICAgICAgdGhpcy53cml0ZVUzMihiLmxlbmd0aCk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIoYik7XG4gICAgfVxuICAgIHdyaXRlRml4ZWRBcnJheShhcnJheSkge1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyKEJ1ZmZlci5mcm9tKGFycmF5KSk7XG4gICAgfVxuICAgIHdyaXRlQXJyYXkoYXJyYXksIGZuKSB7XG4gICAgICAgIHRoaXMubWF5YmVSZXNpemUoKTtcbiAgICAgICAgdGhpcy53cml0ZVUzMihhcnJheS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW0gb2YgYXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMubWF5YmVSZXNpemUoKTtcbiAgICAgICAgICAgIGZuKGVsZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvQXJyYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zdWJhcnJheSgwLCB0aGlzLmxlbmd0aCk7XG4gICAgfVxufVxuZXhwb3J0cy5CaW5hcnlXcml0ZXIgPSBCaW5hcnlXcml0ZXI7XG5mdW5jdGlvbiBoYW5kbGluZ1JhbmdlRXJyb3IodGFyZ2V0LCBwcm9wZXJ0eUtleSwgcHJvcGVydHlEZXNjcmlwdG9yKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxNZXRob2QgPSBwcm9wZXJ0eURlc2NyaXB0b3IudmFsdWU7XG4gICAgcHJvcGVydHlEZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBSYW5nZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGUuY29kZTtcbiAgICAgICAgICAgICAgICBpZiAoW1wiRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTXCIsIFwiRVJSX09VVF9PRl9SQU5HRVwiXS5pbmRleE9mKGNvZGUpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoXCJSZWFjaGVkIHRoZSBlbmQgb2YgYnVmZmVyIHdoZW4gZGVzZXJpYWxpemluZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmNsYXNzIEJpbmFyeVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IoYnVmKSB7XG4gICAgICAgIHRoaXMuYnVmID0gYnVmO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgfVxuICAgIHJlYWRVOCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmJ1Zi5yZWFkVUludDgodGhpcy5vZmZzZXQpO1xuICAgICAgICB0aGlzLm9mZnNldCArPSAxO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJlYWRVMTYoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5idWYucmVhZFVJbnQxNkxFKHRoaXMub2Zmc2V0KTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZWFkVTMyKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLm9mZnNldCk7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmVhZFU2NCgpIHtcbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5yZWFkQnVmZmVyKDgpO1xuICAgICAgICByZXR1cm4gbmV3IGJuX2pzXzEuZGVmYXVsdChidWYsIFwibGVcIik7XG4gICAgfVxuICAgIHJlYWRVMTI4KCkge1xuICAgICAgICBjb25zdCBidWYgPSB0aGlzLnJlYWRCdWZmZXIoMTYpO1xuICAgICAgICByZXR1cm4gbmV3IGJuX2pzXzEuZGVmYXVsdChidWYsIFwibGVcIik7XG4gICAgfVxuICAgIHJlYWRVMjU2KCkge1xuICAgICAgICBjb25zdCBidWYgPSB0aGlzLnJlYWRCdWZmZXIoMzIpO1xuICAgICAgICByZXR1cm4gbmV3IGJuX2pzXzEuZGVmYXVsdChidWYsIFwibGVcIik7XG4gICAgfVxuICAgIHJlYWRVNTEyKCkge1xuICAgICAgICBjb25zdCBidWYgPSB0aGlzLnJlYWRCdWZmZXIoNjQpO1xuICAgICAgICByZXR1cm4gbmV3IGJuX2pzXzEuZGVmYXVsdChidWYsIFwibGVcIik7XG4gICAgfVxuICAgIHJlYWRCdWZmZXIobGVuKSB7XG4gICAgICAgIGlmICh0aGlzLm9mZnNldCArIGxlbiA+IHRoaXMuYnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoYEV4cGVjdGVkIGJ1ZmZlciBsZW5ndGggJHtsZW59IGlzbid0IHdpdGhpbiBib3VuZHNgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmJ1Zi5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyBsZW4pO1xuICAgICAgICB0aGlzLm9mZnNldCArPSBsZW47XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlYWRTdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMucmVhZFUzMigpO1xuICAgICAgICBjb25zdCBidWYgPSB0aGlzLnJlYWRCdWZmZXIobGVuKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5PVEU6IFVzaW5nIFRleHREZWNvZGVyIHRvIGZhaWwgb24gaW52YWxpZCBVVEYtOFxuICAgICAgICAgICAgcmV0dXJuIHRleHREZWNvZGVyLmRlY29kZShidWYpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihgRXJyb3IgZGVjb2RpbmcgVVRGLTggc3RyaW5nOiAke2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZEZpeGVkQXJyYXkobGVuKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLnJlYWRCdWZmZXIobGVuKSk7XG4gICAgfVxuICAgIHJlYWRBcnJheShmbikge1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLnJlYWRVMzIoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gQXJyYXkoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZm4oKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZFU4XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgaGFuZGxpbmdSYW5nZUVycm9yXG5dLCBCaW5hcnlSZWFkZXIucHJvdG90eXBlLCBcInJlYWRVMTZcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZFUzMlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGhhbmRsaW5nUmFuZ2VFcnJvclxuXSwgQmluYXJ5UmVhZGVyLnByb3RvdHlwZSwgXCJyZWFkVTY0XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgaGFuZGxpbmdSYW5nZUVycm9yXG5dLCBCaW5hcnlSZWFkZXIucHJvdG90eXBlLCBcInJlYWRVMTI4XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgaGFuZGxpbmdSYW5nZUVycm9yXG5dLCBCaW5hcnlSZWFkZXIucHJvdG90eXBlLCBcInJlYWRVMjU2XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgaGFuZGxpbmdSYW5nZUVycm9yXG5dLCBCaW5hcnlSZWFkZXIucHJvdG90eXBlLCBcInJlYWRVNTEyXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgaGFuZGxpbmdSYW5nZUVycm9yXG5dLCBCaW5hcnlSZWFkZXIucHJvdG90eXBlLCBcInJlYWRTdHJpbmdcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZEZpeGVkQXJyYXlcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZEFycmF5XCIsIG51bGwpO1xuZXhwb3J0cy5CaW5hcnlSZWFkZXIgPSBCaW5hcnlSZWFkZXI7XG5mdW5jdGlvbiBjYXBpdGFsaXplRmlyc3RMZXR0ZXIoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCB2YWx1ZSwgZmllbGRUeXBlLCB3cml0ZXIpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBUT0RPOiBIYW5kbGUgbWlzc2luZyB2YWx1ZXMgcHJvcGVybHkgKG1ha2Ugc3VyZSB0aGV5IG5ldmVyIHJlc3VsdCBpbiBqdXN0IHNraXBwZWQgd3JpdGUpXG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB3cml0ZXJbYHdyaXRlJHtjYXBpdGFsaXplRmlyc3RMZXR0ZXIoZmllbGRUeXBlKX1gXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGRUeXBlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmllbGRUeXBlWzBdID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gZmllbGRUeXBlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBFeHBlY3RpbmcgYnl0ZSBhcnJheSBvZiBsZW5ndGggJHtmaWVsZFR5cGVbMF19LCBidXQgZ290ICR7dmFsdWUubGVuZ3RofSBieXRlc2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVGaXhlZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkVHlwZS5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGZpZWxkVHlwZVsxXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IGZpZWxkVHlwZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihgRXhwZWN0aW5nIGJ5dGUgYXJyYXkgb2YgbGVuZ3RoICR7ZmllbGRUeXBlWzFdfSwgYnV0IGdvdCAke3ZhbHVlLmxlbmd0aH0gYnl0ZXNgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZFR5cGVbMV07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVGaWVsZChzY2hlbWEsIG51bGwsIHZhbHVlW2ldLCBmaWVsZFR5cGVbMF0sIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlQXJyYXkodmFsdWUsIChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCBpdGVtLCBmaWVsZFR5cGVbMF0sIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGRUeXBlLmtpbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZFR5cGUua2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJvcHRpb25cIjoge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlVTgoMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVVOCgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCB2YWx1ZSwgZmllbGRUeXBlLnR5cGUsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBcIjoge1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVVMzIodmFsdWUuc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKHZhbCwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwga2V5LCBmaWVsZFR5cGUua2V5LCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIHZhbCwgZmllbGRUeXBlLnZhbHVlLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBGaWVsZFR5cGUgJHtmaWVsZFR5cGV9IHVucmVjb2duaXplZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VyaWFsaXplU3RydWN0KHNjaGVtYSwgdmFsdWUsIHdyaXRlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJvcnNoRXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yLmFkZFRvRmllbGRQYXRoKGZpZWxkTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VyaWFsaXplU3RydWN0KHNjaGVtYSwgb2JqLCB3cml0ZXIpIHtcbiAgICBpZiAodHlwZW9mIG9iai5ib3JzaFNlcmlhbGl6ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9iai5ib3JzaFNlcmlhbGl6ZSh3cml0ZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0cnVjdFNjaGVtYSA9IHNjaGVtYS5nZXQob2JqLmNvbnN0cnVjdG9yKTtcbiAgICBpZiAoIXN0cnVjdFNjaGVtYSkge1xuICAgICAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihgQ2xhc3MgJHtvYmouY29uc3RydWN0b3IubmFtZX0gaXMgbWlzc2luZyBpbiBzY2hlbWFgKTtcbiAgICB9XG4gICAgaWYgKHN0cnVjdFNjaGVtYS5raW5kID09PSBcInN0cnVjdFwiKSB7XG4gICAgICAgIHN0cnVjdFNjaGVtYS5maWVsZHMubWFwKChbZmllbGROYW1lLCBmaWVsZFR5cGVdKSA9PiB7XG4gICAgICAgICAgICBzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgb2JqW2ZpZWxkTmFtZV0sIGZpZWxkVHlwZSwgd3JpdGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0cnVjdFNjaGVtYS5raW5kID09PSBcImVudW1cIikge1xuICAgICAgICBjb25zdCBuYW1lID0gb2JqW3N0cnVjdFNjaGVtYS5maWVsZF07XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHN0cnVjdFNjaGVtYS52YWx1ZXMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRUeXBlXSA9IHN0cnVjdFNjaGVtYS52YWx1ZXNbaWR4XTtcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVVOChpZHgpO1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCBvYmpbZmllbGROYW1lXSwgZmllbGRUeXBlLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihgVW5leHBlY3RlZCBzY2hlbWEga2luZDogJHtzdHJ1Y3RTY2hlbWEua2luZH0gZm9yICR7b2JqLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgfVxufVxuLy8vIFNlcmlhbGl6ZSBnaXZlbiBvYmplY3QgdXNpbmcgc2NoZW1hIG9mIHRoZSBmb3JtOlxuLy8vIHsgY2xhc3NfbmFtZSAtPiBbIFtmaWVsZF9uYW1lLCBmaWVsZF90eXBlXSwgLi4gXSwgLi4gfVxuZnVuY3Rpb24gc2VyaWFsaXplKHNjaGVtYSwgb2JqLCBXcml0ZXIgPSBCaW5hcnlXcml0ZXIpIHtcbiAgICBjb25zdCB3cml0ZXIgPSBuZXcgV3JpdGVyKCk7XG4gICAgc2VyaWFsaXplU3RydWN0KHNjaGVtYSwgb2JqLCB3cml0ZXIpO1xuICAgIHJldHVybiB3cml0ZXIudG9BcnJheSgpO1xufVxuZXhwb3J0cy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCBmaWVsZFR5cGUsIHJlYWRlcikge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyW2ByZWFkJHtjYXBpdGFsaXplRmlyc3RMZXR0ZXIoZmllbGRUeXBlKX1gXSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZFR5cGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZFR5cGVbMF0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRGaXhlZEFycmF5KGZpZWxkVHlwZVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZmllbGRUeXBlWzFdID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZFR5cGVbMV07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChkZXNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgbnVsbCwgZmllbGRUeXBlWzBdLCByZWFkZXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZEFycmF5KCgpID0+IGRlc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIGZpZWxkVHlwZVswXSwgcmVhZGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkVHlwZS5raW5kID09PSBcIm9wdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb24gPSByZWFkZXIucmVhZFU4KCk7XG4gICAgICAgICAgICBpZiAob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIGZpZWxkVHlwZS50eXBlLCByZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGRUeXBlLmtpbmQgPT09IFwibWFwXCIpIHtcbiAgICAgICAgICAgIGxldCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSByZWFkZXIucmVhZFUzMigpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGRlc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIGZpZWxkVHlwZS5rZXksIHJlYWRlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gZGVzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgZmllbGRUeXBlLnZhbHVlLCByZWFkZXIpO1xuICAgICAgICAgICAgICAgIG1hcC5zZXQoa2V5LCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVTdHJ1Y3Qoc2NoZW1hLCBmaWVsZFR5cGUsIHJlYWRlcik7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCb3JzaEVycm9yKSB7XG4gICAgICAgICAgICBlcnJvci5hZGRUb0ZpZWxkUGF0aChmaWVsZE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplU3RydWN0KHNjaGVtYSwgY2xhc3NUeXBlLCByZWFkZXIpIHtcbiAgICBpZiAodHlwZW9mIGNsYXNzVHlwZS5ib3JzaERlc2VyaWFsaXplID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGNsYXNzVHlwZS5ib3JzaERlc2VyaWFsaXplKHJlYWRlcik7XG4gICAgfVxuICAgIGNvbnN0IHN0cnVjdFNjaGVtYSA9IHNjaGVtYS5nZXQoY2xhc3NUeXBlKTtcbiAgICBpZiAoIXN0cnVjdFNjaGVtYSkge1xuICAgICAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihgQ2xhc3MgJHtjbGFzc1R5cGUubmFtZX0gaXMgbWlzc2luZyBpbiBzY2hlbWFgKTtcbiAgICB9XG4gICAgaWYgKHN0cnVjdFNjaGVtYS5raW5kID09PSBcInN0cnVjdFwiKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVHlwZV0gb2Ygc2NoZW1hLmdldChjbGFzc1R5cGUpLmZpZWxkcykge1xuICAgICAgICAgICAgcmVzdWx0W2ZpZWxkTmFtZV0gPSBkZXNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCBmaWVsZFR5cGUsIHJlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBjbGFzc1R5cGUocmVzdWx0KTtcbiAgICB9XG4gICAgaWYgKHN0cnVjdFNjaGVtYS5raW5kID09PSBcImVudW1cIikge1xuICAgICAgICBjb25zdCBpZHggPSByZWFkZXIucmVhZFU4KCk7XG4gICAgICAgIGlmIChpZHggPj0gc3RydWN0U2NoZW1hLnZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBFbnVtIGluZGV4OiAke2lkeH0gaXMgb3V0IG9mIHJhbmdlYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRUeXBlXSA9IHN0cnVjdFNjaGVtYS52YWx1ZXNbaWR4XTtcbiAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IGRlc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIGZpZWxkVHlwZSwgcmVhZGVyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBjbGFzc1R5cGUoeyBbZmllbGROYW1lXTogZmllbGRWYWx1ZSB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoYFVuZXhwZWN0ZWQgc2NoZW1hIGtpbmQ6ICR7c3RydWN0U2NoZW1hLmtpbmR9IGZvciAke2NsYXNzVHlwZS5jb25zdHJ1Y3Rvci5uYW1lfWApO1xufVxuLy8vIERlc2VyaWFsaXplcyBvYmplY3QgZnJvbSBieXRlcyB1c2luZyBzY2hlbWEuXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShzY2hlbWEsIGNsYXNzVHlwZSwgYnVmZmVyLCBSZWFkZXIgPSBCaW5hcnlSZWFkZXIpIHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUmVhZGVyKGJ1ZmZlcik7XG4gICAgY29uc3QgcmVzdWx0ID0gZGVzZXJpYWxpemVTdHJ1Y3Qoc2NoZW1hLCBjbGFzc1R5cGUsIHJlYWRlcik7XG4gICAgaWYgKHJlYWRlci5vZmZzZXQgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBVbmV4cGVjdGVkICR7YnVmZmVyLmxlbmd0aCAtIHJlYWRlci5vZmZzZXR9IGJ5dGVzIGFmdGVyIGRlc2VyaWFsaXplZCBkYXRhYCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemU7XG4vLy8gRGVzZXJpYWxpemVzIG9iamVjdCBmcm9tIGJ5dGVzIHVzaW5nIHNjaGVtYSwgd2l0aG91dCBjaGVja2luZyB0aGUgbGVuZ3RoIHJlYWRcbmZ1bmN0aW9uIGRlc2VyaWFsaXplVW5jaGVja2VkKHNjaGVtYSwgY2xhc3NUeXBlLCBidWZmZXIsIFJlYWRlciA9IEJpbmFyeVJlYWRlcikge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICByZXR1cm4gZGVzZXJpYWxpemVTdHJ1Y3Qoc2NoZW1hLCBjbGFzc1R5cGUsIHJlYWRlcik7XG59XG5leHBvcnRzLmRlc2VyaWFsaXplVW5jaGVja2VkID0gZGVzZXJpYWxpemVVbmNoZWNrZWQ7XG4iLCBudWxsLCAiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gSW4gdGhlIGJyb3dzZXIgd2UgdGhlcmVmb3JlXG4vLyByZXF1aXJlIHRoZSBjcnlwdG8gQVBJIGFuZCBkbyBub3Qgc3VwcG9ydCBidWlsdC1pbiBmYWxsYmFjayB0byBsb3dlciBxdWFsaXR5IHJhbmRvbSBudW1iZXJcbi8vIGdlbmVyYXRvcnMgKGxpa2UgTWF0aC5yYW5kb20oKSkuXG52YXIgZ2V0UmFuZG9tVmFsdWVzO1xudmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICAvLyBsYXp5IGxvYWQgc28gdGhhdCBlbnZpcm9ubWVudHMgdGhhdCBuZWVkIHRvIHBvbHlmaWxsIGhhdmUgYSBjaGFuY2UgdG8gZG8gc29cbiAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG8gaW1wbGVtZW50YXRpb24uIEFsc28sXG4gICAgLy8gZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIChtc0NyeXB0bykgb24gSUUxMS5cbiAgICBnZXRSYW5kb21WYWx1ZXMgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pIHx8IHR5cGVvZiBtc0NyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0byk7XG5cbiAgICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgbm90IHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCNnZXRyYW5kb212YWx1ZXMtbm90LXN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xufSIsICJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7IiwgImltcG9ydCBSRUdFWCBmcm9tICcuL3JlZ2V4LmpzJztcblxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyIsICJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cblxudmFyIGJ5dGVUb0hleCA9IFtdO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyKSB7XG4gIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICB2YXIgdXVpZCA9IChieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXSkudG9Mb3dlckNhc2UoKTsgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxuICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgLy8gLSBJbnZhbGlkIGlucHV0IHZhbHVlcyBmb3IgdGhlIFJGQyBgdmVyc2lvbmAgb3IgYHZhcmlhbnRgIGZpZWxkc1xuXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ2lmeTsiLCAiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJzsgLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuLy9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4vLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxuXG52YXIgX25vZGVJZDtcblxudmFyIF9jbG9ja3NlcTsgLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG5cblxudmFyIF9sYXN0TVNlY3MgPSAwO1xudmFyIF9sYXN0TlNlY3MgPSAwOyAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkIGZvciBBUEkgZGV0YWlsc1xuXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgdmFyIGIgPSBidWYgfHwgbmV3IEFycmF5KDE2KTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7IC8vIG5vZGUgYW5kIGNsb2Nrc2VxIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gcmFuZG9tIHZhbHVlcyBpZiB0aGV5J3JlIG5vdFxuICAvLyBzcGVjaWZpZWQuICBXZSBkbyB0aGlzIGxhemlseSB0byBtaW5pbWl6ZSBpc3N1ZXMgcmVsYXRlZCB0byBpbnN1ZmZpY2llbnRcbiAgLy8gc3lzdGVtIGVudHJvcHkuICBTZWUgIzE4OVxuXG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgIHZhciBzZWVkQnl0ZXMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtzZWVkQnl0ZXNbMF0gfCAweDAxLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG4gICAgfVxuXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9IC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuXG5cbiAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7IC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcblxuICB2YXIgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7IC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcblxuICB2YXIgZHQgPSBtc2VjcyAtIF9sYXN0TVNlY3MgKyAobnNlY3MgLSBfbGFzdE5TZWNzKSAvIDEwMDAwOyAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG5cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfSAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG5cblxuICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG5zZWNzID0gMDtcbiAgfSAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG5cblxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1dWlkLnYxKCk6IENhbid0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlY1wiKTtcbiAgfVxuXG4gIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTsgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG5cbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7IC8vIGB0aW1lX2xvd2BcblxuICB2YXIgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdGwgJiAweGZmOyAvLyBgdGltZV9taWRgXG5cbiAgdmFyIHRtaCA9IG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjsgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcblxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG5cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7IC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDsgLy8gYGNsb2NrX3NlcV9sb3dgXG5cbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmOyAvLyBgbm9kZWBcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgfHwgc3RyaW5naWZ5KGIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2MTsiLCAiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuXG5mdW5jdGlvbiBwYXJzZSh1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgdmFyIHY7XG4gIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxNik7IC8vIFBhcnNlICMjIyMjIyMjLS4uLi4tLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFyclswXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgwLCA4KSwgMTYpKSA+Pj4gMjQ7XG4gIGFyclsxXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzJdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclszXSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0jIyMjLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbNF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoOSwgMTMpLCAxNikpID4+PiA4O1xuICBhcnJbNV0gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0jIyMjLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzZdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxOCksIDE2KSkgPj4+IDg7XG4gIGFycls3XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tIyMjIy0uLi4uLi4uLi4uLi5cblxuICBhcnJbOF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTksIDIzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzldID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0uLi4uLSMjIyMjIyMjIyMjI1xuICAvLyAoVXNlIFwiL1wiIHRvIGF2b2lkIDMyLWJpdCB0cnVuY2F0aW9uIHdoZW4gYml0LXNoaWZ0aW5nIGhpZ2gtb3JkZXIgYnl0ZXMpXG5cbiAgYXJyWzEwXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgyNCwgMzYpLCAxNikpIC8gMHgxMDAwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMV0gPSB2IC8gMHgxMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTJdID0gdiA+Pj4gMjQgJiAweGZmO1xuICBhcnJbMTNdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMTRdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclsxNV0gPSB2ICYgMHhmZjtcbiAgcmV0dXJuIGFycjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGFyc2U7IiwgImltcG9ydCBzdHJpbmdpZnkgZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHBhcnNlIGZyb20gJy4vcGFyc2UuanMnO1xuXG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICBzdHIgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgdmFyIGJ5dGVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBieXRlcy5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn1cblxuZXhwb3J0IHZhciBETlMgPSAnNmJhN2I4MTAtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcbmV4cG9ydCB2YXIgVVJMID0gJzZiYTdiODExLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAobmFtZSwgdmVyc2lvbiwgaGFzaGZ1bmMpIHtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKHZhbHVlLCBuYW1lc3BhY2UsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lc3BhY2UgPSBwYXJzZShuYW1lc3BhY2UpO1xuICAgIH1cblxuICAgIGlmIChuYW1lc3BhY2UubGVuZ3RoICE9PSAxNikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdOYW1lc3BhY2UgbXVzdCBiZSBhcnJheS1saWtlICgxNiBpdGVyYWJsZSBpbnRlZ2VyIHZhbHVlcywgMC0yNTUpJyk7XG4gICAgfSAvLyBDb21wdXRlIGhhc2ggb2YgbmFtZXNwYWNlIGFuZCB2YWx1ZSwgUGVyIDQuM1xuICAgIC8vIEZ1dHVyZTogVXNlIHNwcmVhZCBzeW50YXggd2hlbiBzdXBwb3J0ZWQgb24gYWxsIHBsYXRmb3JtcywgZS5nLiBgYnl0ZXMgPVxuICAgIC8vIGhhc2hmdW5jKFsuLi5uYW1lc3BhY2UsIC4uLiB2YWx1ZV0pYFxuXG5cbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNiArIHZhbHVlLmxlbmd0aCk7XG4gICAgYnl0ZXMuc2V0KG5hbWVzcGFjZSk7XG4gICAgYnl0ZXMuc2V0KHZhbHVlLCBuYW1lc3BhY2UubGVuZ3RoKTtcbiAgICBieXRlcyA9IGhhc2hmdW5jKGJ5dGVzKTtcbiAgICBieXRlc1s2XSA9IGJ5dGVzWzZdICYgMHgwZiB8IHZlcnNpb247XG4gICAgYnl0ZXNbOF0gPSBieXRlc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gICAgaWYgKGJ1Zikge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5KGJ5dGVzKTtcbiAgfSAvLyBGdW5jdGlvbiNuYW1lIGlzIG5vdCBzZXR0YWJsZSBvbiBzb21lIHBsYXRmb3JtcyAoIzI3MClcblxuXG4gIHRyeSB7XG4gICAgZ2VuZXJhdGVVVUlELm5hbWUgPSBuYW1lOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgfSBjYXRjaCAoZXJyKSB7fSAvLyBGb3IgQ29tbW9uSlMgZGVmYXVsdCBleHBvcnQgc3VwcG9ydFxuXG5cbiAgZ2VuZXJhdGVVVUlELkROUyA9IEROUztcbiAgZ2VuZXJhdGVVVUlELlVSTCA9IFVSTDtcbiAgcmV0dXJuIGdlbmVyYXRlVVVJRDtcbn0iLCAiLypcbiAqIEJyb3dzZXItY29tcGF0aWJsZSBKYXZhU2NyaXB0IE1ENVxuICpcbiAqIE1vZGlmaWNhdGlvbiBvZiBKYXZhU2NyaXB0IE1ENVxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1NRDVcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSwgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKlxuICogQmFzZWQgb25cbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXG4gKiBWZXJzaW9uIDIuMiBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDlcbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cbiAqL1xuZnVuY3Rpb24gbWQ1KGJ5dGVzKSB7XG4gIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG1zZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChieXRlcykpOyAvLyBVVEY4IGVzY2FwZVxuXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShtc2cubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgKytpKSB7XG4gICAgICBieXRlc1tpXSA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZDVUb0hleEVuY29kZWRBcnJheSh3b3Jkc1RvTWQ1KGJ5dGVzVG9Xb3JkcyhieXRlcyksIGJ5dGVzLmxlbmd0aCAqIDgpKTtcbn1cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMgdG8gYW4gYXJyYXkgb2YgYnl0ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIG1kNVRvSGV4RW5jb2RlZEFycmF5KGlucHV0KSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgdmFyIGxlbmd0aDMyID0gaW5wdXQubGVuZ3RoICogMzI7XG4gIHZhciBoZXhUYWIgPSAnMDEyMzQ1Njc4OWFiY2RlZic7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgzMjsgaSArPSA4KSB7XG4gICAgdmFyIHggPSBpbnB1dFtpID4+IDVdID4+PiBpICUgMzIgJiAweGZmO1xuICAgIHZhciBoZXggPSBwYXJzZUludChoZXhUYWIuY2hhckF0KHggPj4+IDQgJiAweDBmKSArIGhleFRhYi5jaGFyQXQoeCAmIDB4MGYpLCAxNik7XG4gICAgb3V0cHV0LnB1c2goaGV4KTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBvdXRwdXQgbGVuZ3RoIHdpdGggcGFkZGluZyBhbmQgYml0IGxlbmd0aFxuICovXG5cblxuZnVuY3Rpb24gZ2V0T3V0cHV0TGVuZ3RoKGlucHV0TGVuZ3RoOCkge1xuICByZXR1cm4gKGlucHV0TGVuZ3RoOCArIDY0ID4+PiA5IDw8IDQpICsgMTQgKyAxO1xufVxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGguXG4gKi9cblxuXG5mdW5jdGlvbiB3b3Jkc1RvTWQ1KHgsIGxlbikge1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8IGxlbiAlIDMyO1xuICB4W2dldE91dHB1dExlbmd0aChsZW4pIC0gMV0gPSBsZW47XG4gIHZhciBhID0gMTczMjU4NDE5MztcbiAgdmFyIGIgPSAtMjcxNzMzODc5O1xuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xuICB2YXIgZCA9IDI3MTczMzg3ODtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgdmFyIG9sZGEgPSBhO1xuICAgIHZhciBvbGRiID0gYjtcbiAgICB2YXIgb2xkYyA9IGM7XG4gICAgdmFyIG9sZGQgPSBkO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2ldLCA3LCAtNjgwODc2OTM2KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMV0sIDEyLCAtMzg5NTY0NTg2KTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE3LCA2MDYxMDU4MTkpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgNF0sIDcsIC0xNzY0MTg4OTcpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyA1XSwgMTIsIDEyMDAwODA0MjYpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyA2XSwgMTcsIC0xNDczMjMxMzQxKTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgN10sIDIyLCAtNDU3MDU5ODMpO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA4XSwgNywgMTc3MDAzNTQxNik7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAxMF0sIDE3LCAtNDIwNjMpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDEyXSwgNywgMTgwNDYwMzY4Mik7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDEzXSwgMTIsIC00MDM0MTEwMSk7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgMTVdLCAyMiwgMTIzNjUzNTMyOSk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDFdLCA1LCAtMTY1Nzk2NTEwKTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgNl0sIDksIC0xMDY5NTAxNjMyKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNCwgNjQzNzE3NzEzKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpXSwgMjAsIC0zNzM4OTczMDIpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNSwgLTcwMTU1ODY5MSk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDEwXSwgOSwgMzgwMTYwODMpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAxNV0sIDE0LCAtNjYwNDc4MzM1KTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgOV0sIDUsIDU2ODQ0NjQzOCk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDE0XSwgOSwgLTEwMTk4MDM2OTApO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAzXSwgMTQsIC0xODczNjM5NjEpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA4XSwgMjAsIDExNjM1MzE1MDEpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyAxM10sIDUsIC0xNDQ0NjgxNDY3KTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMl0sIDksIC01MTQwMzc4NCk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDddLCAxNCwgMTczNTMyODQ3Myk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgNV0sIDQsIC0zNzg1NTgpO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNiwgMTgzOTAzMDU2Mik7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDE0XSwgMjMsIC0zNTMwOTU1Nik7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDFdLCA0LCAtMTUzMDk5MjA2MCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDRdLCAxMSwgMTI3Mjg5MzM1Myk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDddLCAxNiwgLTE1NTQ5NzYzMik7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMTNdLCA0LCA2ODEyNzkxNzQpO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2ldLCAxMSwgLTM1ODUzNzIyMik7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNiwgLTcyMjUyMTk3OSk7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDZdLCAyMywgNzYwMjkxODkpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNCwgLTY0MDM2NDQ4Nyk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDEyXSwgMTEsIC00MjE4MTU4MzUpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxNV0sIDE2LCA1MzA3NDI1MjApO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2ldLCA2LCAtMTk4NjMwODQ0KTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgN10sIDEwLCAxMTI2ODkxNDE1KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA1XSwgMjEsIC01NzQzNDA1NSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDEyXSwgNiwgMTcwMDQ4NTU3MSk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAxMF0sIDE1LCAtMTA1MTUyMyk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA4XSwgNiwgMTg3MzMxMzM1OSk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDE1XSwgMTAsIC0zMDYxMTc0NCk7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNSwgLTE1NjAxOTgzODApO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyAxM10sIDIxLCAxMzA5MTUxNjQ5KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgNF0sIDYsIC0xNDU1MjMwNzApO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDJdLCAxNSwgNzE4Nzg3MjU5KTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgOV0sIDIxLCAtMzQzNDg1NTUxKTtcbiAgICBhID0gc2FmZUFkZChhLCBvbGRhKTtcbiAgICBiID0gc2FmZUFkZChiLCBvbGRiKTtcbiAgICBjID0gc2FmZUFkZChjLCBvbGRjKTtcbiAgICBkID0gc2FmZUFkZChkLCBvbGRkKTtcbiAgfVxuXG4gIHJldHVybiBbYSwgYiwgYywgZF07XG59XG4vKlxuICogQ29udmVydCBhbiBhcnJheSBieXRlcyB0byBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzXG4gKiBDaGFyYWN0ZXJzID4yNTUgaGF2ZSB0aGVpciBoaWdoLWJ5dGUgc2lsZW50bHkgaWdub3JlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJ5dGVzVG9Xb3JkcyhpbnB1dCkge1xuICBpZiAoaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIGxlbmd0aDggPSBpbnB1dC5sZW5ndGggKiA4O1xuICB2YXIgb3V0cHV0ID0gbmV3IFVpbnQzMkFycmF5KGdldE91dHB1dExlbmd0aChsZW5ndGg4KSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg4OyBpICs9IDgpIHtcbiAgICBvdXRwdXRbaSA+PiA1XSB8PSAoaW5wdXRbaSAvIDhdICYgMHhmZikgPDwgaSAlIDMyO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5cblxuZnVuY3Rpb24gc2FmZUFkZCh4LCB5KSB7XG4gIHZhciBsc3cgPSAoeCAmIDB4ZmZmZikgKyAoeSAmIDB4ZmZmZik7XG4gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgcmV0dXJuIG1zdyA8PCAxNiB8IGxzdyAmIDB4ZmZmZjtcbn1cbi8qXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gKi9cblxuXG5mdW5jdGlvbiBiaXRSb3RhdGVMZWZ0KG51bSwgY250KSB7XG4gIHJldHVybiBudW0gPDwgY250IHwgbnVtID4+PiAzMiAtIGNudDtcbn1cbi8qXG4gKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IHRoZSBmb3VyIGJhc2ljIG9wZXJhdGlvbnMgdGhlIGFsZ29yaXRobSB1c2VzLlxuICovXG5cblxuZnVuY3Rpb24gbWQ1Y21uKHEsIGEsIGIsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIHNhZmVBZGQoYml0Um90YXRlTGVmdChzYWZlQWRkKHNhZmVBZGQoYSwgcSksIHNhZmVBZGQoeCwgdCkpLCBzKSwgYik7XG59XG5cbmZ1bmN0aW9uIG1kNWZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihiICYgYyB8IH5iICYgZCwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmZ1bmN0aW9uIG1kNWdnKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihiICYgZCB8IGMgJiB+ZCwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmZ1bmN0aW9uIG1kNWhoKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVpaShhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYyBeIChiIHwgfmQpLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWQ1OyIsICJpbXBvcnQgdjM1IGZyb20gJy4vdjM1LmpzJztcbmltcG9ydCBtZDUgZnJvbSAnLi9tZDUuanMnO1xudmFyIHYzID0gdjM1KCd2MycsIDB4MzAsIG1kNSk7XG5leHBvcnQgZGVmYXVsdCB2MzsiLCAiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZ2lmeShybmRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjQ7IiwgIi8vIEFkYXB0ZWQgZnJvbSBDaHJpcyBWZW5lc3MnIFNIQTEgY29kZSBhdFxuLy8gaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9zaGExLmh0bWxcbmZ1bmN0aW9uIGYocywgeCwgeSwgeikge1xuICBzd2l0Y2ggKHMpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4geCAmIHkgXiB+eCAmIHo7XG5cbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4geCBeIHkgXiB6O1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHggJiB5IF4geCAmIHogXiB5ICYgejtcblxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XG4gIH1cbn1cblxuZnVuY3Rpb24gUk9UTCh4LCBuKSB7XG4gIHJldHVybiB4IDw8IG4gfCB4ID4+PiAzMiAtIG47XG59XG5cbmZ1bmN0aW9uIHNoYTEoYnl0ZXMpIHtcbiAgdmFyIEsgPSBbMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhjYTYyYzFkNl07XG4gIHZhciBIID0gWzB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjBdO1xuXG4gIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG1zZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChieXRlcykpOyAvLyBVVEY4IGVzY2FwZVxuXG4gICAgYnl0ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgKytpKSB7XG4gICAgICBieXRlcy5wdXNoKG1zZy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoYnl0ZXMpKSB7XG4gICAgLy8gQ29udmVydCBBcnJheS1saWtlIHRvIEFycmF5XG4gICAgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChieXRlcyk7XG4gIH1cblxuICBieXRlcy5wdXNoKDB4ODApO1xuICB2YXIgbCA9IGJ5dGVzLmxlbmd0aCAvIDQgKyAyO1xuICB2YXIgTiA9IE1hdGguY2VpbChsIC8gMTYpO1xuICB2YXIgTSA9IG5ldyBBcnJheShOKTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgTjsgKytfaSkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDMyQXJyYXkoMTYpO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICBhcnJbal0gPSBieXRlc1tfaSAqIDY0ICsgaiAqIDRdIDw8IDI0IHwgYnl0ZXNbX2kgKiA2NCArIGogKiA0ICsgMV0gPDwgMTYgfCBieXRlc1tfaSAqIDY0ICsgaiAqIDQgKyAyXSA8PCA4IHwgYnl0ZXNbX2kgKiA2NCArIGogKiA0ICsgM107XG4gICAgfVxuXG4gICAgTVtfaV0gPSBhcnI7XG4gIH1cblxuICBNW04gLSAxXVsxNF0gPSAoYnl0ZXMubGVuZ3RoIC0gMSkgKiA4IC8gTWF0aC5wb3coMiwgMzIpO1xuICBNW04gLSAxXVsxNF0gPSBNYXRoLmZsb29yKE1bTiAtIDFdWzE0XSk7XG4gIE1bTiAtIDFdWzE1XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggJiAweGZmZmZmZmZmO1xuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IE47ICsrX2kyKSB7XG4gICAgdmFyIFcgPSBuZXcgVWludDMyQXJyYXkoODApO1xuXG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCAxNjsgKyt0KSB7XG4gICAgICBXW3RdID0gTVtfaTJdW3RdO1xuICAgIH1cblxuICAgIGZvciAodmFyIF90ID0gMTY7IF90IDwgODA7ICsrX3QpIHtcbiAgICAgIFdbX3RdID0gUk9UTChXW190IC0gM10gXiBXW190IC0gOF0gXiBXW190IC0gMTRdIF4gV1tfdCAtIDE2XSwgMSk7XG4gICAgfVxuXG4gICAgdmFyIGEgPSBIWzBdO1xuICAgIHZhciBiID0gSFsxXTtcbiAgICB2YXIgYyA9IEhbMl07XG4gICAgdmFyIGQgPSBIWzNdO1xuICAgIHZhciBlID0gSFs0XTtcblxuICAgIGZvciAodmFyIF90MiA9IDA7IF90MiA8IDgwOyArK190Mikge1xuICAgICAgdmFyIHMgPSBNYXRoLmZsb29yKF90MiAvIDIwKTtcbiAgICAgIHZhciBUID0gUk9UTChhLCA1KSArIGYocywgYiwgYywgZCkgKyBlICsgS1tzXSArIFdbX3QyXSA+Pj4gMDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gUk9UTChiLCAzMCkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSBUO1xuICAgIH1cblxuICAgIEhbMF0gPSBIWzBdICsgYSA+Pj4gMDtcbiAgICBIWzFdID0gSFsxXSArIGIgPj4+IDA7XG4gICAgSFsyXSA9IEhbMl0gKyBjID4+PiAwO1xuICAgIEhbM10gPSBIWzNdICsgZCA+Pj4gMDtcbiAgICBIWzRdID0gSFs0XSArIGUgPj4+IDA7XG4gIH1cblxuICByZXR1cm4gW0hbMF0gPj4gMjQgJiAweGZmLCBIWzBdID4+IDE2ICYgMHhmZiwgSFswXSA+PiA4ICYgMHhmZiwgSFswXSAmIDB4ZmYsIEhbMV0gPj4gMjQgJiAweGZmLCBIWzFdID4+IDE2ICYgMHhmZiwgSFsxXSA+PiA4ICYgMHhmZiwgSFsxXSAmIDB4ZmYsIEhbMl0gPj4gMjQgJiAweGZmLCBIWzJdID4+IDE2ICYgMHhmZiwgSFsyXSA+PiA4ICYgMHhmZiwgSFsyXSAmIDB4ZmYsIEhbM10gPj4gMjQgJiAweGZmLCBIWzNdID4+IDE2ICYgMHhmZiwgSFszXSA+PiA4ICYgMHhmZiwgSFszXSAmIDB4ZmYsIEhbNF0gPj4gMjQgJiAweGZmLCBIWzRdID4+IDE2ICYgMHhmZiwgSFs0XSA+PiA4ICYgMHhmZiwgSFs0XSAmIDB4ZmZdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaGExOyIsICJpbXBvcnQgdjM1IGZyb20gJy4vdjM1LmpzJztcbmltcG9ydCBzaGExIGZyb20gJy4vc2hhMS5qcyc7XG52YXIgdjUgPSB2MzUoJ3Y1JywgMHg1MCwgc2hhMSk7XG5leHBvcnQgZGVmYXVsdCB2NTsiLCAiZXhwb3J0IGRlZmF1bHQgJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCc7IiwgImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuZnVuY3Rpb24gdmVyc2lvbih1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlSW50KHV1aWQuc3Vic3RyKDE0LCAxKSwgMTYpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2ZXJzaW9uOyIsICJleHBvcnQgeyBkZWZhdWx0IGFzIHYxIH0gZnJvbSAnLi92MS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHYzIH0gZnJvbSAnLi92My5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY0IH0gZnJvbSAnLi92NC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY1IH0gZnJvbSAnLi92NS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5JTCB9IGZyb20gJy4vbmlsLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZhbGlkYXRlIH0gZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFyc2UgfSBmcm9tICcuL3BhcnNlLmpzJzsiLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dWlkID0gcmVxdWlyZSgndXVpZCcpLnY0O1xuXG4vKipcbiAqICBHZW5lcmF0ZXMgYSBKU09OLVJQQyAxLjAgb3IgMi4wIHJlcXVlc3RcbiAqICBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE5hbWUgb2YgbWV0aG9kIHRvIGNhbGxcbiAqICBAcGFyYW0ge0FycmF5fE9iamVjdH0gcGFyYW1zIEFycmF5IG9mIHBhcmFtZXRlcnMgcGFzc2VkIHRvIHRoZSBtZXRob2QgYXMgc3BlY2lmaWVkLCBvciBhbiBvYmplY3Qgb2YgcGFyYW1ldGVyIG5hbWVzIGFuZCBjb3JyZXNwb25kaW5nIHZhbHVlXG4gKiAgQHBhcmFtIHtTdHJpbmd8TnVtYmVyfG51bGx9IFtpZF0gUmVxdWVzdCBJRCBjYW4gYmUgYSBzdHJpbmcsIG51bWJlciwgbnVsbCBmb3IgZXhwbGljaXQgbm90aWZpY2F0aW9uIG9yIGxlZnQgb3V0IGZvciBhdXRvbWF0aWMgZ2VuZXJhdGlvblxuICogIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmVyc2lvbj0yXSBKU09OLVJQQyB2ZXJzaW9uIHRvIHVzZSAoMSBvciAyKVxuICogIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubm90aWZpY2F0aW9uSWROdWxsPWZhbHNlXSBXaGVuIHRydWUsIHZlcnNpb24gMiByZXF1ZXN0cyB3aWxsIHNldCBpZCB0byBudWxsIGluc3RlYWQgb2Ygb21pdHRpbmcgaXRcbiAqICBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0b3JdIFBhc3NlZCB0aGUgcmVxdWVzdCwgYW5kIHRoZSBvcHRpb25zIG9iamVjdCBhbmQgaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGEgcmVxdWVzdCBJRFxuICogIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYW55IG9mIHRoZSBwYXJhbWV0ZXJzIGFyZSBpbnZhbGlkXG4gKiAgQHJldHVybiB7T2JqZWN0fSBBIEpTT04tUlBDIDEuMCBvciAyLjAgcmVxdWVzdFxuICogIEBtZW1iZXJPZiBVdGlsc1xuICovXG5jb25zdCBnZW5lcmF0ZVJlcXVlc3QgPSBmdW5jdGlvbihtZXRob2QsIHBhcmFtcywgaWQsIG9wdGlvbnMpIHtcbiAgaWYodHlwZW9mIG1ldGhvZCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG1ldGhvZCArICcgbXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gY2hlY2sgdmFsaWQgdmVyc2lvbiBwcm92aWRlZFxuICBjb25zdCB2ZXJzaW9uID0gdHlwZW9mIG9wdGlvbnMudmVyc2lvbiA9PT0gJ251bWJlcicgPyBvcHRpb25zLnZlcnNpb24gOiAyO1xuICBpZiAodmVyc2lvbiAhPT0gMSAmJiB2ZXJzaW9uICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcih2ZXJzaW9uICsgJyBtdXN0IGJlIDEgb3IgMicpO1xuICB9XG5cbiAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICBtZXRob2Q6IG1ldGhvZFxuICB9O1xuXG4gIGlmKHZlcnNpb24gPT09IDIpIHtcbiAgICByZXF1ZXN0Lmpzb25ycGMgPSAnMi4wJztcbiAgfVxuXG4gIGlmKHBhcmFtcykge1xuICAgIC8vIHBhcmFtcyBnaXZlbiwgYnV0IGludmFsaWQ/XG4gICAgaWYodHlwZW9mIHBhcmFtcyAhPT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihwYXJhbXMgKyAnIG11c3QgYmUgYW4gb2JqZWN0LCBhcnJheSBvciBvbWl0dGVkJyk7XG4gICAgfVxuICAgIHJlcXVlc3QucGFyYW1zID0gcGFyYW1zO1xuICB9XG5cbiAgLy8gaWYgaWQgd2FzIGxlZnQgb3V0LCBnZW5lcmF0ZSBvbmUgKG51bGwgbWVhbnMgZXhwbGljaXQgbm90aWZpY2F0aW9uKVxuICBpZih0eXBlb2YoaWQpID09PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IGdlbmVyYXRvciA9IHR5cGVvZiBvcHRpb25zLmdlbmVyYXRvciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZ2VuZXJhdG9yIDogZnVuY3Rpb24oKSB7IHJldHVybiB1dWlkKCk7IH07XG4gICAgcmVxdWVzdC5pZCA9IGdlbmVyYXRvcihyZXF1ZXN0LCBvcHRpb25zKTtcbiAgfSBlbHNlIGlmICh2ZXJzaW9uID09PSAyICYmIGlkID09PSBudWxsKSB7XG4gICAgLy8gd2UgaGF2ZSBhIHZlcnNpb24gMiBub3RpZmljYXRpb25cbiAgICBpZiAob3B0aW9ucy5ub3RpZmljYXRpb25JZE51bGwpIHtcbiAgICAgIHJlcXVlc3QuaWQgPSBudWxsOyAvLyBpZCB3aWxsIG5vdCBiZSBzZXQgYXQgYWxsIHVubGVzcyBvcHRpb24gcHJvdmlkZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVxdWVzdC5pZCA9IGlkO1xuICB9XG5cbiAgcmV0dXJuIHJlcXVlc3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlUmVxdWVzdDtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV1aWQgPSByZXF1aXJlKCd1dWlkJykudjQ7XG5jb25zdCBnZW5lcmF0ZVJlcXVlc3QgPSByZXF1aXJlKCcuLi8uLi9nZW5lcmF0ZVJlcXVlc3QnKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciBmb3IgYSBKYXlzb24gQnJvd3NlciBDbGllbnQgdGhhdCBkb2VzIG5vdCBkZXBlbmQgYW55IG5vZGUuanMgY29yZSBsaWJyYXJpZXNcbiAqIEBjbGFzcyBDbGllbnRCcm93c2VyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsU2VydmVyIE1ldGhvZCB0aGF0IGNhbGxzIHRoZSBzZXJ2ZXIsIHJlY2VpdmVzIHRoZSBzdHJpbmdpZmllZCByZXF1ZXN0IGFuZCBhIHJlZ3VsYXIgbm9kZS1zdHlsZSBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMucmV2aXZlcl0gUmV2aXZlciBmdW5jdGlvbiBmb3IgSlNPTlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMucmVwbGFjZXJdIFJlcGxhY2VyIGZ1bmN0aW9uIGZvciBKU09OXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmVyc2lvbj0yXSBKU09OLVJQQyB2ZXJzaW9uIHRvIHVzZSAoMXwyKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdG9yXSBGdW5jdGlvbiB0byB1c2UgZm9yIGdlbmVyYXRpbmcgcmVxdWVzdCBJRHNcbiAqICBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm5vdGlmaWNhdGlvbklkTnVsbD1mYWxzZV0gV2hlbiB0cnVlLCB2ZXJzaW9uIDIgcmVxdWVzdHMgd2lsbCBzZXQgaWQgdG8gbnVsbCBpbnN0ZWFkIG9mIG9taXR0aW5nIGl0XG4gKiBAcmV0dXJuIHtDbGllbnRCcm93c2VyfVxuICovXG5jb25zdCBDbGllbnRCcm93c2VyID0gZnVuY3Rpb24oY2FsbFNlcnZlciwgb3B0aW9ucykge1xuICBpZighKHRoaXMgaW5zdGFuY2VvZiBDbGllbnRCcm93c2VyKSkge1xuICAgIHJldHVybiBuZXcgQ2xpZW50QnJvd3NlcihjYWxsU2VydmVyLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHRoaXMub3B0aW9ucyA9IHtcbiAgICByZXZpdmVyOiB0eXBlb2Ygb3B0aW9ucy5yZXZpdmVyICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMucmV2aXZlciA6IG51bGwsXG4gICAgcmVwbGFjZXI6IHR5cGVvZiBvcHRpb25zLnJlcGxhY2VyICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMucmVwbGFjZXIgOiBudWxsLFxuICAgIGdlbmVyYXRvcjogdHlwZW9mIG9wdGlvbnMuZ2VuZXJhdG9yICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuZ2VuZXJhdG9yIDogZnVuY3Rpb24oKSB7IHJldHVybiB1dWlkKCk7IH0sXG4gICAgdmVyc2lvbjogdHlwZW9mIG9wdGlvbnMudmVyc2lvbiAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnZlcnNpb24gOiAyLFxuICAgIG5vdGlmaWNhdGlvbklkTnVsbDogdHlwZW9mIG9wdGlvbnMubm90aWZpY2F0aW9uSWROdWxsID09PSAnYm9vbGVhbicgPyBvcHRpb25zLm5vdGlmaWNhdGlvbklkTnVsbCA6IGZhbHNlLFxuICB9O1xuXG4gIHRoaXMuY2FsbFNlcnZlciA9IGNhbGxTZXJ2ZXI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsaWVudEJyb3dzZXI7XG5cbi8qKlxuICogIENyZWF0ZXMgYSByZXF1ZXN0IGFuZCBkaXNwYXRjaGVzIGl0IGlmIGdpdmVuIGEgY2FsbGJhY2suXG4gKiAgQHBhcmFtIHtTdHJpbmd8QXJyYXl9IG1ldGhvZCBBIGJhdGNoIHJlcXVlc3QgaWYgcGFzc2VkIGFuIEFycmF5LCBvciBhIG1ldGhvZCBuYW1lIGlmIHBhc3NlZCBhIFN0cmluZ1xuICogIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBbcGFyYW1zXSBQYXJhbWV0ZXJzIGZvciB0aGUgbWV0aG9kXG4gKiAgQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbaWRdIE9wdGlvbmFsIGlkLiBJZiB1bmRlZmluZWQgYW4gaWQgd2lsbCBiZSBnZW5lcmF0ZWQuIElmIG51bGwgaXQgY3JlYXRlcyBhIG5vdGlmaWNhdGlvbiByZXF1ZXN0XG4gKiAgQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBSZXF1ZXN0IGNhbGxiYWNrLiBJZiBzcGVjaWZpZWQsIGV4ZWN1dGVzIHRoZSByZXF1ZXN0IHJhdGhlciB0aGFuIG9ubHkgcmV0dXJuaW5nIGl0LlxuICogIEB0aHJvd3Mge1R5cGVFcnJvcn0gSW52YWxpZCBwYXJhbWV0ZXJzXG4gKiAgQHJldHVybiB7T2JqZWN0fSBKU09OLVJQQyAxLjAgb3IgMi4wIGNvbXBhdGlibGUgcmVxdWVzdFxuICovXG5DbGllbnRCcm93c2VyLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24obWV0aG9kLCBwYXJhbXMsIGlkLCBjYWxsYmFjaykge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgbGV0IHJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIGlzIHRoaXMgYSBiYXRjaCByZXF1ZXN0P1xuICBjb25zdCBpc0JhdGNoID0gQXJyYXkuaXNBcnJheShtZXRob2QpICYmIHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbic7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy52ZXJzaW9uID09PSAxICYmIGlzQmF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdKU09OLVJQQyAxLjAgZG9lcyBub3Qgc3VwcG9ydCBiYXRjaGluZycpO1xuICB9XG5cbiAgLy8gaXMgdGhpcyBhIHJhdyByZXF1ZXN0P1xuICBjb25zdCBpc1JhdyA9ICFpc0JhdGNoICYmIG1ldGhvZCAmJiB0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nO1xuXG4gIGlmKGlzQmF0Y2ggfHwgaXNSYXcpIHtcbiAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICByZXF1ZXN0ID0gbWV0aG9kO1xuICB9IGVsc2Uge1xuICAgIGlmKHR5cGVvZiBpZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBpZDtcbiAgICAgIC8vIHNwZWNpZmljYWxseSB1bmRlZmluZWQgYmVjYXVzZSBcIm51bGxcIiBpcyBhIG5vdGlmaWNhdGlvbiByZXF1ZXN0XG4gICAgICBpZCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBoYXNDYWxsYmFjayA9IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJztcblxuICAgIHRyeSB7XG4gICAgICByZXF1ZXN0ID0gZ2VuZXJhdGVSZXF1ZXN0KG1ldGhvZCwgcGFyYW1zLCBpZCwge1xuICAgICAgICBnZW5lcmF0b3I6IHRoaXMub3B0aW9ucy5nZW5lcmF0b3IsXG4gICAgICAgIHZlcnNpb246IHRoaXMub3B0aW9ucy52ZXJzaW9uLFxuICAgICAgICBub3RpZmljYXRpb25JZE51bGw6IHRoaXMub3B0aW9ucy5ub3RpZmljYXRpb25JZE51bGwsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgaWYoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgLy8gbm8gY2FsbGJhY2sgbWVhbnMgd2Ugc2hvdWxkIGp1c3QgcmV0dXJuIGEgcmF3IHJlcXVlc3RcbiAgICBpZighaGFzQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cblxuICB9XG5cbiAgbGV0IG1lc3NhZ2U7XG4gIHRyeSB7XG4gICAgbWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QsIHRoaXMub3B0aW9ucy5yZXBsYWNlcik7XG4gIH0gY2F0Y2goZXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gIH1cblxuICB0aGlzLmNhbGxTZXJ2ZXIobWVzc2FnZSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZSkge1xuICAgIHNlbGYuX3BhcnNlUmVzcG9uc2UoZXJyLCByZXNwb25zZSwgY2FsbGJhY2spO1xuICB9KTtcblxuICAvLyBhbHdheXMgcmV0dXJuIHRoZSByYXcgcmVxdWVzdFxuICByZXR1cm4gcmVxdWVzdDtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgcmVzcG9uc2UgZnJvbSBhIHNlcnZlclxuICogQHBhcmFtIHtPYmplY3R9IGVyciBFcnJvciB0byBwYXNzIG9uIHRoYXQgaXMgdW5yZWxhdGVkIHRvIHRoZSBhY3R1YWwgcmVzcG9uc2VcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXNwb25zZVRleHQgSlNPTi1SUEMgMS4wIG9yIDIuMCByZXNwb25zZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdGhhdCB3aWxsIHJlY2VpdmUgZGlmZmVyZW50IGFyZ3VtZW50cyBkZXBlbmRpbmcgb24gdGhlIGFtb3VudCBvZiBwYXJhbWV0ZXJzXG4gKiBAcHJpdmF0ZVxuICovXG5DbGllbnRCcm93c2VyLnByb3RvdHlwZS5fcGFyc2VSZXNwb25zZSA9IGZ1bmN0aW9uKGVyciwgcmVzcG9uc2VUZXh0LCBjYWxsYmFjaykge1xuICBpZihlcnIpIHtcbiAgICBjYWxsYmFjayhlcnIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmKCFyZXNwb25zZVRleHQpIHtcbiAgICAvLyBlbXB0eSByZXNwb25zZSB0ZXh0LCBhc3N1bWUgdGhhdCBpcyBjb3JyZWN0IGJlY2F1c2UgaXQgY291bGQgYmUgYVxuICAgIC8vIG5vdGlmaWNhdGlvbiB3aGljaCBqYXlzb24gZG9lcyBub3QgZ2l2ZSBhbnkgYm9keSBmb3JcbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfVxuXG4gIGxldCByZXNwb25zZTtcbiAgdHJ5IHtcbiAgICByZXNwb25zZSA9IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0LCB0aGlzLm9wdGlvbnMucmV2aXZlcik7XG4gIH0gY2F0Y2goZXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gIH1cblxuICBpZihjYWxsYmFjay5sZW5ndGggPT09IDMpIHtcbiAgICAvLyBpZiBjYWxsYmFjayBsZW5ndGggaXMgMywgd2Ugc3BsaXQgY2FsbGJhY2sgYXJndW1lbnRzIG9uIGVycm9yIGFuZCByZXNwb25zZVxuXG4gICAgLy8gaXMgYmF0Y2ggcmVzcG9uc2U/XG4gICAgaWYoQXJyYXkuaXNBcnJheShyZXNwb25zZSkpIHtcblxuICAgICAgLy8gbmVjY2VzYXJ5IHRvIHNwbGl0IHN0cmljdGx5IG9uIHZhbGlkaXR5IGFjY29yZGluZyB0byBzcGVjIGhlcmVcbiAgICAgIGNvbnN0IGlzRXJyb3IgPSBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZXMuZXJyb3IgIT09ICd1bmRlZmluZWQnO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgaXNOb3RFcnJvciA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgcmV0dXJuICFpc0Vycm9yKHJlcyk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UuZmlsdGVyKGlzRXJyb3IpLCByZXNwb25zZS5maWx0ZXIoaXNOb3RFcnJvcikpO1xuICAgIFxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIHNwbGl0IHJlZ2FyZGxlc3Mgb2YgdmFsaWRpdHlcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXNwb25zZS5lcnJvciwgcmVzcG9uc2UucmVzdWx0KTtcbiAgICBcbiAgICB9XG4gIFxuICB9XG5cbiAgY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UpO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW2VtaXR0ZXIuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbi8qKlxuICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIGVsc2UgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiAwO1xuICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm4gJiZcbiAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcbiAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fFxuICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG4gICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5sZXQgY29udmVydGVyO1xuLyoqXG4gKiBDb252ZXJ0IGEgbGl0dGxlLWVuZGlhbiBidWZmZXIgaW50byBhIEJpZ0ludC5cbiAqIEBwYXJhbSBidWYgVGhlIGxpdHRsZS1lbmRpYW4gYnVmZmVyIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIEEgQmlnSW50IHdpdGggdGhlIGxpdHRsZS1lbmRpYW4gcmVwcmVzZW50YXRpb24gb2YgYnVmLlxuICovXG5mdW5jdGlvbiB0b0JpZ0ludExFKGJ1Zikge1xuICAgIHtcbiAgICAgICAgY29uc3QgcmV2ZXJzZWQgPSBCdWZmZXIuZnJvbShidWYpO1xuICAgICAgICByZXZlcnNlZC5yZXZlcnNlKCk7XG4gICAgICAgIGNvbnN0IGhleCA9IHJldmVyc2VkLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQoMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZ0ludChgMHgke2hleH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRlci50b0JpZ0ludChidWYsIGZhbHNlKTtcbn1cbmV4cG9ydHMudG9CaWdJbnRMRSA9IHRvQmlnSW50TEU7XG4vKipcbiAqIENvbnZlcnQgYSBiaWctZW5kaWFuIGJ1ZmZlciBpbnRvIGEgQmlnSW50XG4gKiBAcGFyYW0gYnVmIFRoZSBiaWctZW5kaWFuIGJ1ZmZlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQSBCaWdJbnQgd2l0aCB0aGUgYmlnLWVuZGlhbiByZXByZXNlbnRhdGlvbiBvZiBidWYuXG4gKi9cbmZ1bmN0aW9uIHRvQmlnSW50QkUoYnVmKSB7XG4gICAge1xuICAgICAgICBjb25zdCBoZXggPSBidWYudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnSW50KGAweCR7aGV4fWApO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydGVyLnRvQmlnSW50KGJ1ZiwgdHJ1ZSk7XG59XG5leHBvcnRzLnRvQmlnSW50QkUgPSB0b0JpZ0ludEJFO1xuLyoqXG4gKiBDb252ZXJ0IGEgQmlnSW50IHRvIGEgbGl0dGxlLWVuZGlhbiBidWZmZXIuXG4gKiBAcGFyYW0gbnVtICAgVGhlIEJpZ0ludCB0byBjb252ZXJ0LlxuICogQHBhcmFtIHdpZHRoIFRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCB0aGUgcmVzdWx0aW5nIGJ1ZmZlciBzaG91bGQgYmUuXG4gKiBAcmV0dXJucyBBIGxpdHRsZS1lbmRpYW4gYnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIG51bS5cbiAqL1xuZnVuY3Rpb24gdG9CdWZmZXJMRShudW0sIHdpZHRoKSB7XG4gICAge1xuICAgICAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShoZXgucGFkU3RhcnQod2lkdGggKiAyLCAnMCcpLnNsaWNlKDAsIHdpZHRoICogMiksICdoZXgnKTtcbiAgICAgICAgYnVmZmVyLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gICAgLy8gQWxsb2NhdGlvbiBpcyBkb25lIGhlcmUsIHNpbmNlIGl0IGlzIHNsb3dlciB1c2luZyBuYXBpIGluIENcbiAgICByZXR1cm4gY29udmVydGVyLmZyb21CaWdJbnQobnVtLCBCdWZmZXIuYWxsb2NVbnNhZmUod2lkdGgpLCBmYWxzZSk7XG59XG5leHBvcnRzLnRvQnVmZmVyTEUgPSB0b0J1ZmZlckxFO1xuLyoqXG4gKiBDb252ZXJ0IGEgQmlnSW50IHRvIGEgYmlnLWVuZGlhbiBidWZmZXIuXG4gKiBAcGFyYW0gbnVtICAgVGhlIEJpZ0ludCB0byBjb252ZXJ0LlxuICogQHBhcmFtIHdpZHRoIFRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCB0aGUgcmVzdWx0aW5nIGJ1ZmZlciBzaG91bGQgYmUuXG4gKiBAcmV0dXJucyBBIGJpZy1lbmRpYW4gYnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIG51bS5cbiAqL1xuZnVuY3Rpb24gdG9CdWZmZXJCRShudW0sIHdpZHRoKSB7XG4gICAge1xuICAgICAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oaGV4LnBhZFN0YXJ0KHdpZHRoICogMiwgJzAnKS5zbGljZSgwLCB3aWR0aCAqIDIpLCAnaGV4Jyk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0ZXIuZnJvbUJpZ0ludChudW0sIEJ1ZmZlci5hbGxvY1Vuc2FmZSh3aWR0aCksIHRydWUpO1xufVxuZXhwb3J0cy50b0J1ZmZlckJFID0gdG9CdWZmZXJCRTtcbiIsICIvKipcbiAqIEludGVybmFsIHdlYmNyeXB0byBhbGlhcy5cbiAqIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuICogU2VlIHV0aWxzLnRzIGZvciBkZXRhaWxzLlxuICogQG1vZHVsZVxuICovXG5kZWNsYXJlIGNvbnN0IGdsb2JhbFRoaXM6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQ7XG5leHBvcnQgY29uc3QgY3J5cHRvOiBhbnkgPVxuICB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdW5kZWZpbmVkO1xuIiwgIi8qKlxuICogVXRpbGl0aWVzIGZvciBoZXgsIGJ5dGVzLCBDU1BSTkcuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cblxuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkICgyMDI1LTA0LTMwKSwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuaW1wb3J0IHsgY3J5cHRvIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9jcnlwdG8nO1xuXG4vKiogQ2hlY2tzIGlmIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiBCZSBjYXJlZnVsOiBub2RlanMgQnVmZmVyIHdpbGwgcmV0dXJuIHRydWUuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyhhOiB1bmtub3duKTogYSBpcyBVaW50OEFycmF5IHtcbiAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xufVxuXG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgcG9zaXRpdmUgaW50ZWdlci4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbnVtYmVyKG46IG51bWJlcik6IHZvaWQge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKSB0aHJvdyBuZXcgRXJyb3IoJ3Bvc2l0aXZlIGludGVnZXIgZXhwZWN0ZWQsIGdvdCAnICsgbik7XG59XG5cbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFieXRlcyhiOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkLCAuLi5sZW5ndGhzOiBudW1iZXJbXSk6IHZvaWQge1xuICBpZiAoIWlzQnl0ZXMoYikpIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQgb2YgbGVuZ3RoICcgKyBsZW5ndGhzICsgJywgZ290IGxlbmd0aD0nICsgYi5sZW5ndGgpO1xufVxuXG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgaGFzaCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFoYXNoKGg6IElIYXNoKTogdm9pZCB7XG4gIGlmICh0eXBlb2YgaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLmNyZWF0ZUhhc2hlcicpO1xuICBhbnVtYmVyKGgub3V0cHV0TGVuKTtcbiAgYW51bWJlcihoLmJsb2NrTGVuKTtcbn1cblxuLyoqIEFzc2VydHMgYSBoYXNoIGluc3RhbmNlIGhhcyBub3QgYmVlbiBkZXN0cm95ZWQgLyBmaW5pc2hlZCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFleGlzdHMoaW5zdGFuY2U6IGFueSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpOiB2b2lkIHtcbiAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZCkgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5cbi8qKiBBc3NlcnRzIG91dHB1dCBpcyBwcm9wZXJseS1zaXplZCBieXRlIGFycmF5ICovXG5leHBvcnQgZnVuY3Rpb24gYW91dHB1dChvdXQ6IGFueSwgaW5zdGFuY2U6IGFueSk6IHZvaWQge1xuICBhYnl0ZXMob3V0KTtcbiAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJyArIG1pbik7XG4gIH1cbn1cblxuLyoqIEdlbmVyaWMgdHlwZSBlbmNvbXBhc3NpbmcgOC8xNi8zMi1ieXRlIGFycmF5cyAtIGJ1dCBub3QgNjQtYnl0ZS4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IHR5cGUgVHlwZWRBcnJheSA9IEludDhBcnJheSB8IFVpbnQ4Q2xhbXBlZEFycmF5IHwgVWludDhBcnJheSB8XG4gIFVpbnQxNkFycmF5IHwgSW50MTZBcnJheSB8IFVpbnQzMkFycmF5IHwgSW50MzJBcnJheTtcblxuLyoqIENhc3QgdTggLyB1MTYgLyB1MzIgdG8gdTguICovXG5leHBvcnQgZnVuY3Rpb24gdTgoYXJyOiBUeXBlZEFycmF5KTogVWludDhBcnJheSB7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xufVxuXG4vKiogQ2FzdCB1OCAvIHUxNiAvIHUzMiB0byB1MzIuICovXG5leHBvcnQgZnVuY3Rpb24gdTMyKGFycjogVHlwZWRBcnJheSk6IFVpbnQzMkFycmF5IHtcbiAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbn1cblxuLyoqIFplcm9pemUgYSBieXRlIGFycmF5LiBXYXJuaW5nOiBKUyBwcm92aWRlcyBubyBndWFyYW50ZWVzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuKC4uLmFycmF5czogVHlwZWRBcnJheVtdKTogdm9pZCB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXlzW2ldLmZpbGwoMCk7XG4gIH1cbn1cblxuLyoqIENyZWF0ZSBEYXRhVmlldyBvZiBhbiBhcnJheSBmb3IgZWFzeSBieXRlLWxldmVsIG1hbmlwdWxhdGlvbi4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWaWV3KGFycjogVHlwZWRBcnJheSk6IERhdGFWaWV3IHtcbiAgcmV0dXJuIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xufVxuXG4vKiogVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyICovXG5leHBvcnQgZnVuY3Rpb24gcm90cih3b3JkOiBudW1iZXIsIHNoaWZ0OiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG59XG5cbi8qKiBUaGUgcm90YXRlIGxlZnQgKGNpcmN1bGFyIGxlZnQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyICovXG5leHBvcnQgZnVuY3Rpb24gcm90bCh3b3JkOiBudW1iZXIsIHNoaWZ0OiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gKHdvcmQgPDwgc2hpZnQpIHwgKCh3b3JkID4+PiAoMzIgLSBzaGlmdCkpID4+PiAwKTtcbn1cblxuLyoqIElzIGN1cnJlbnQgcGxhdGZvcm0gbGl0dGxlLWVuZGlhbj8gTW9zdCBhcmUuIEJpZy1FbmRpYW4gcGxhdGZvcm06IElCTSAqL1xuZXhwb3J0IGNvbnN0IGlzTEU6IGJvb2xlYW4gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+XG4gIG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQpKCk7XG5cbi8qKiBUaGUgYnl0ZSBzd2FwIG9wZXJhdGlvbiBmb3IgdWludDMyICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZVN3YXAod29yZDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIChcbiAgICAoKHdvcmQgPDwgMjQpICYgMHhmZjAwMDAwMCkgfFxuICAgICgod29yZCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgKCh3b3JkID4+PiA4KSAmIDB4ZmYwMCkgfFxuICAgICgod29yZCA+Pj4gMjQpICYgMHhmZilcbiAgKTtcbn1cbi8qKiBDb25kaXRpb25hbGx5IGJ5dGUgc3dhcCBpZiBvbiBhIGJpZy1lbmRpYW4gcGxhdGZvcm0gKi9cbmV4cG9ydCBjb25zdCBzd2FwOElmQkU6IChuOiBudW1iZXIpID0+IG51bWJlciA9IGlzTEVcbiAgPyAobjogbnVtYmVyKSA9PiBuXG4gIDogKG46IG51bWJlcikgPT4gYnl0ZVN3YXAobik7XG5cbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGNvbnN0IGJ5dGVTd2FwSWZCRTogdHlwZW9mIHN3YXA4SWZCRSA9IHN3YXA4SWZCRTtcbi8qKiBJbiBwbGFjZSBieXRlIHN3YXAgZm9yIFVpbnQzMkFycmF5ICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZVN3YXAzMihhcnI6IFVpbnQzMkFycmF5KTogVWludDMyQXJyYXkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGFycltpXSA9IGJ5dGVTd2FwKGFycltpXSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuZXhwb3J0IGNvbnN0IHN3YXAzMklmQkU6ICh1OiBVaW50MzJBcnJheSkgPT4gVWludDMyQXJyYXkgPSBpc0xFXG4gID8gKHU6IFVpbnQzMkFycmF5KSA9PiB1XG4gIDogYnl0ZVN3YXAzMjtcblxuLy8gQnVpbHQtaW4gaGV4IGNvbnZlcnNpb24gaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc191aW50OGFycmF5X2Zyb21oZXhcbmNvbnN0IGhhc0hleEJ1aWx0aW46IGJvb2xlYW4gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+XG4gIC8vIEB0cy1pZ25vcmVcbiAgdHlwZW9mIFVpbnQ4QXJyYXkuZnJvbShbXSkudG9IZXggPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFVpbnQ4QXJyYXkuZnJvbUhleCA9PT0gJ2Z1bmN0aW9uJykoKTtcblxuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT5cbiAgaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKVxuKTtcblxuLyoqXG4gKiBDb252ZXJ0IGJ5dGUgYXJyYXkgdG8gaGV4IHN0cmluZy4gVXNlcyBidWlsdC1pbiBmdW5jdGlvbiwgd2hlbiBhdmFpbGFibGUuXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgYWJ5dGVzKGJ5dGVzKTtcbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAoaGFzSGV4QnVpbHRpbikgcmV0dXJuIGJ5dGVzLnRvSGV4KCk7XG4gIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICBsZXQgaGV4ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICB9XG4gIHJldHVybiBoZXg7XG59XG5cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBBOiA2NSwgRjogNzAsIGE6IDk3LCBmOiAxMDIgfSBhcyBjb25zdDtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2g6IG51bWJlcik6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gIGlmIChjaCA+PSBhc2NpaXMuXzAgJiYgY2ggPD0gYXNjaWlzLl85KSByZXR1cm4gY2ggLSBhc2NpaXMuXzA7IC8vICcyJyA9PiA1MC00OFxuICBpZiAoY2ggPj0gYXNjaWlzLkEgJiYgY2ggPD0gYXNjaWlzLkYpIHJldHVybiBjaCAtIChhc2NpaXMuQSAtIDEwKTsgLy8gJ0InID0+IDY2LSg2NS0xMClcbiAgaWYgKGNoID49IGFzY2lpcy5hICYmIGNoIDw9IGFzY2lpcy5mKSByZXR1cm4gY2ggLSAoYXNjaWlzLmEgLSAxMCk7IC8vICdiJyA9PiA5OC0oOTctMTApXG4gIHJldHVybjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheS4gVXNlcyBidWlsdC1pbiBmdW5jdGlvbiwgd2hlbiBhdmFpbGFibGUuXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleDogc3RyaW5nKTogVWludDhBcnJheSB7XG4gIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAvLyBAdHMtaWdub3JlXG4gIGlmIChoYXNIZXhCdWlsdGluKSByZXR1cm4gVWludDhBcnJheS5mcm9tSGV4KGhleCk7XG4gIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgY29uc3QgYWwgPSBobCAvIDI7XG4gIGlmIChobCAlIDIpIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgfVxuICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjsgLy8gbXVsdGlwbHkgZmlyc3Qgb2N0ZXQsIGUuZy4gJ2EzJyA9PiAxMCoxNiszID0+IDE2MCArIDMgPT4gMTYzXG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4gKiBDYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbiAqIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge307XG5cbi8qKiBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nLiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChcbiAgaXRlcnM6IG51bWJlcixcbiAgdGljazogbnVtYmVyLFxuICBjYjogKGk6IG51bWJlcikgPT4gdm9pZFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGxldCB0cyA9IERhdGUubm93KCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgIGNiKGkpO1xuICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKSBjb250aW51ZTtcbiAgICBhd2FpdCBuZXh0VGljaygpO1xuICAgIHRzICs9IGRpZmY7XG4gIH1cbn1cblxuLy8gR2xvYmFsIHN5bWJvbHMsIGJ1dCB0cyBkb2Vzbid0IHNlZSB0aGVtOiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzMxNTM1XG5kZWNsYXJlIGNvbnN0IFRleHRFbmNvZGVyOiBhbnk7XG5kZWNsYXJlIGNvbnN0IFRleHREZWNvZGVyOiBhbnk7XG5cbi8qKlxuICogQ29udmVydHMgc3RyaW5nIHRvIGJ5dGVzIHVzaW5nIFVURjggZW5jb2RpbmcuXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gVWludDhBcnJheS5mcm9tKFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cjogc3RyaW5nKTogVWludDhBcnJheSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGJ5dGVzIHRvIHN0cmluZyB1c2luZyBVVEY4IGVuY29kaW5nLlxuICogQGV4YW1wbGUgYnl0ZXNUb1V0ZjgoVWludDhBcnJheS5mcm9tKFs5NywgOTgsIDk5XSkpIC8vICdhYmMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvVXRmOChieXRlczogVWludDhBcnJheSk6IHN0cmluZyB7XG4gIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xufVxuXG4vKiogQWNjZXB0ZWQgaW5wdXQgb2YgaGFzaCBmdW5jdGlvbnMuIFN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byBieXRlIGFycmF5cy4gKi9cbmV4cG9ydCB0eXBlIElucHV0ID0gc3RyaW5nIHwgVWludDhBcnJheTtcbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhOiBJbnB1dCk6IFVpbnQ4QXJyYXkge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gIGFieXRlcyhkYXRhKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKiBLREZzIGNhbiBhY2NlcHQgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgZm9yIHVzZXIgY29udmVuaWVuY2UuICovXG5leHBvcnQgdHlwZSBLREZJbnB1dCA9IHN0cmluZyB8IFVpbnQ4QXJyYXk7XG4vKipcbiAqIEhlbHBlciBmb3IgS0RGczogY29uc3VtZXMgdWludDhhcnJheSBvciBzdHJpbmcuXG4gKiBXaGVuIHN0cmluZyBpcyBwYXNzZWQsIGRvZXMgdXRmOCBkZWNvZGluZywgdXNpbmcgVGV4dERlY29kZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBrZGZJbnB1dFRvQnl0ZXMoZGF0YTogS0RGSW5wdXQpOiBVaW50OEFycmF5IHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICBhYnl0ZXMoZGF0YSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKiogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzOiBVaW50OEFycmF5W10pOiBVaW50OEFycmF5IHtcbiAgbGV0IHN1bSA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICBhYnl0ZXMoYSk7XG4gICAgc3VtICs9IGEubGVuZ3RoO1xuICB9XG4gIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgcGFkICs9IGEubGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnR5cGUgRW1wdHlPYmogPSB7fTtcbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHM8VDEgZXh0ZW5kcyBFbXB0eU9iaiwgVDIgZXh0ZW5kcyBFbXB0eU9iaj4oXG4gIGRlZmF1bHRzOiBUMSxcbiAgb3B0cz86IFQyXG4pOiBUMSAmIFQyIHtcbiAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiB7fS50b1N0cmluZy5jYWxsKG9wdHMpICE9PSAnW29iamVjdCBPYmplY3RdJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gIHJldHVybiBtZXJnZWQgYXMgVDEgJiBUMjtcbn1cblxuLyoqIEhhc2ggaW50ZXJmYWNlLiAqL1xuZXhwb3J0IHR5cGUgSUhhc2ggPSB7XG4gIChkYXRhOiBVaW50OEFycmF5KTogVWludDhBcnJheTtcbiAgYmxvY2tMZW46IG51bWJlcjtcbiAgb3V0cHV0TGVuOiBudW1iZXI7XG4gIGNyZWF0ZTogYW55O1xufTtcblxuLyoqIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSGFzaDxUIGV4dGVuZHMgSGFzaDxUPj4ge1xuICBhYnN0cmFjdCBibG9ja0xlbjogbnVtYmVyOyAvLyBCeXRlcyBwZXIgYmxvY2tcbiAgYWJzdHJhY3Qgb3V0cHV0TGVuOiBudW1iZXI7IC8vIEJ5dGVzIGluIG91dHB1dFxuICBhYnN0cmFjdCB1cGRhdGUoYnVmOiBJbnB1dCk6IHRoaXM7XG4gIC8vIFdyaXRlcyBkaWdlc3QgaW50byBidWZcbiAgYWJzdHJhY3QgZGlnZXN0SW50byhidWY6IFVpbnQ4QXJyYXkpOiB2b2lkO1xuICBhYnN0cmFjdCBkaWdlc3QoKTogVWludDhBcnJheTtcbiAgLyoqXG4gICAqIFJlc2V0cyBpbnRlcm5hbCBzdGF0ZS4gTWFrZXMgSGFzaCBpbnN0YW5jZSB1bnVzYWJsZS5cbiAgICogUmVzZXQgaXMgaW1wb3NzaWJsZSBmb3Iga2V5ZWQgaGFzaGVzIGlmIGtleSBpcyBjb25zdW1lZCBpbnRvIHN0YXRlLiBJZiBkaWdlc3QgaXMgbm90IGNvbnN1bWVkXG4gICAqIGJ5IHVzZXIsIHRoZXkgd2lsbCBuZWVkIHRvIG1hbnVhbGx5IGNhbGwgYGRlc3Ryb3koKWAgd2hlbiB6ZXJvaW5nIGlzIG5lY2Vzc2FyeS5cbiAgICovXG4gIGFic3RyYWN0IGRlc3Ryb3koKTogdm9pZDtcbiAgLyoqXG4gICAqIENsb25lcyBoYXNoIGluc3RhbmNlLiBVbnNhZmU6IGRvZXNuJ3QgY2hlY2sgd2hldGhlciBgdG9gIGlzIHZhbGlkLiBDYW4gYmUgdXNlZCBhcyBgY2xvbmUoKWBcbiAgICogd2hlbiBubyBvcHRpb25zIGFyZSBwYXNzZWQuXG4gICAqIFJlYXNvbnMgdG8gdXNlIGBfY2xvbmVJbnRvYCBpbnN0ZWFkIG9mIGNsb25lOiAxKSBwZXJmb3JtYW5jZSAyKSByZXVzZSBpbnN0YW5jZSA9PiBhbGwgaW50ZXJuYWxcbiAgICogYnVmZmVycyBhcmUgb3ZlcndyaXR0ZW4gPT4gY2F1c2VzIGJ1ZmZlciBvdmVyd3JpdGUgd2hpY2ggaXMgdXNlZCBmb3IgZGlnZXN0IGluIHNvbWUgY2FzZXMuXG4gICAqIFRoZXJlIGFyZSBubyBndWFyYW50ZWVzIGZvciBjbGVhbi11cCBiZWNhdXNlIGl0J3MgaW1wb3NzaWJsZSBpbiBKUy5cbiAgICovXG4gIGFic3RyYWN0IF9jbG9uZUludG8odG8/OiBUKTogVDtcbiAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gIGFic3RyYWN0IGNsb25lKCk6IFQ7XG59XG5cbi8qKlxuICogWE9GOiBzdHJlYW1pbmcgQVBJIHRvIHJlYWQgZGlnZXN0IGluIGNodW5rcy5cbiAqIFNhbWUgYXMgJ3NxdWVlemUnIGluIGtlY2Nhay9rMTIgYW5kICdzZWVrJyBpbiBibGFrZTMsIGJ1dCBtb3JlIGdlbmVyaWMgbmFtZS5cbiAqIFdoZW4gaGFzaCB1c2VkIGluIFhPRiBtb2RlIGl0IGlzIHVwIHRvIHVzZXIgdG8gY2FsbCAnLmRlc3Ryb3knIGFmdGVyd2FyZHMsIHNpbmNlIHdlIGNhbm5vdFxuICogZGVzdHJveSBzdGF0ZSwgbmV4dCBjYWxsIGNhbiByZXF1aXJlIG1vcmUgYnl0ZXMuXG4gKi9cbmV4cG9ydCB0eXBlIEhhc2hYT0Y8VCBleHRlbmRzIEhhc2g8VD4+ID0gSGFzaDxUPiAmIHtcbiAgeG9mKGJ5dGVzOiBudW1iZXIpOiBVaW50OEFycmF5OyAvLyBSZWFkICdieXRlcycgYnl0ZXMgZnJvbSBkaWdlc3Qgc3RyZWFtXG4gIHhvZkludG8oYnVmOiBVaW50OEFycmF5KTogVWludDhBcnJheTsgLy8gcmVhZCBidWYubGVuZ3RoIGJ5dGVzIGZyb20gZGlnZXN0IHN0cmVhbSBpbnRvIGJ1ZlxufTtcblxuLyoqIEhhc2ggZnVuY3Rpb24gKi9cbmV4cG9ydCB0eXBlIENIYXNoID0gUmV0dXJuVHlwZTx0eXBlb2YgY3JlYXRlSGFzaGVyPjtcbi8qKiBIYXNoIGZ1bmN0aW9uIHdpdGggb3V0cHV0ICovXG5leHBvcnQgdHlwZSBDSGFzaE8gPSBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVPcHRIYXNoZXI+O1xuLyoqIFhPRiB3aXRoIG91dHB1dCAqL1xuZXhwb3J0IHR5cGUgQ0hhc2hYTyA9IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZVhPRmVyPjtcblxuLyoqIFdyYXBzIGhhc2ggZnVuY3Rpb24sIGNyZWF0aW5nIGFuIGludGVyZmFjZSBvbiB0b3Agb2YgaXQgKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIYXNoZXI8VCBleHRlbmRzIEhhc2g8VD4+KFxuICBoYXNoQ29uczogKCkgPT4gSGFzaDxUPlxuKToge1xuICAobXNnOiBJbnB1dCk6IFVpbnQ4QXJyYXk7XG4gIG91dHB1dExlbjogbnVtYmVyO1xuICBibG9ja0xlbjogbnVtYmVyO1xuICBjcmVhdGUoKTogSGFzaDxUPjtcbn0ge1xuICBjb25zdCBoYXNoQyA9IChtc2c6IElucHV0KTogVWludDhBcnJheSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgcmV0dXJuIGhhc2hDO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3B0SGFzaGVyPEggZXh0ZW5kcyBIYXNoPEg+LCBUIGV4dGVuZHMgT2JqZWN0PihcbiAgaGFzaENvbnM6IChvcHRzPzogVCkgPT4gSGFzaDxIPlxuKToge1xuICAobXNnOiBJbnB1dCwgb3B0cz86IFQpOiBVaW50OEFycmF5O1xuICBvdXRwdXRMZW46IG51bWJlcjtcbiAgYmxvY2tMZW46IG51bWJlcjtcbiAgY3JlYXRlKG9wdHM/OiBUKTogSGFzaDxIPjtcbn0ge1xuICBjb25zdCBoYXNoQyA9IChtc2c6IElucHV0LCBvcHRzPzogVCk6IFVpbnQ4QXJyYXkgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9IGFzIFQpO1xuICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgaGFzaEMuY3JlYXRlID0gKG9wdHM/OiBUKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgcmV0dXJuIGhhc2hDO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlWE9GZXI8SCBleHRlbmRzIEhhc2hYT0Y8SD4sIFQgZXh0ZW5kcyBPYmplY3Q+KFxuICBoYXNoQ29uczogKG9wdHM/OiBUKSA9PiBIYXNoWE9GPEg+XG4pOiB7XG4gIChtc2c6IElucHV0LCBvcHRzPzogVCk6IFVpbnQ4QXJyYXk7XG4gIG91dHB1dExlbjogbnVtYmVyO1xuICBibG9ja0xlbjogbnVtYmVyO1xuICBjcmVhdGUob3B0cz86IFQpOiBIYXNoWE9GPEg+O1xufSB7XG4gIGNvbnN0IGhhc2hDID0gKG1zZzogSW5wdXQsIG9wdHM/OiBUKTogVWludDhBcnJheSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgY29uc3QgdG1wID0gaGFzaENvbnMoe30gYXMgVCk7XG4gIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICBoYXNoQy5jcmVhdGUgPSAob3B0cz86IFQpID0+IGhhc2hDb25zKG9wdHMpO1xuICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgY29uc3Qgd3JhcENvbnN0cnVjdG9yOiB0eXBlb2YgY3JlYXRlSGFzaGVyID0gY3JlYXRlSGFzaGVyO1xuZXhwb3J0IGNvbnN0IHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzOiB0eXBlb2YgY3JlYXRlT3B0SGFzaGVyID0gY3JlYXRlT3B0SGFzaGVyO1xuZXhwb3J0IGNvbnN0IHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzOiB0eXBlb2YgY3JlYXRlWE9GZXIgPSBjcmVhdGVYT0ZlcjtcblxuLyoqIENyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBQUk5HLiBVc2VzIGludGVybmFsIE9TLWxldmVsIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYC4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKTogVWludDhBcnJheSB7XG4gIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICB9XG4gIC8vIExlZ2FjeSBOb2RlLmpzIGNvbXBhdGliaWxpdHlcbiAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLnJhbmRvbUJ5dGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjcnlwdG8ucmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGgpKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG4iLCAiLyoqXG4gKiBJbnRlcm5hbCBNZXJrbGUtRGFtZ2FyZCBoYXNoIHV0aWxzLlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyB0eXBlIElucHV0LCBIYXNoLCBhYnl0ZXMsIGFleGlzdHMsIGFvdXRwdXQsIGNsZWFuLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy50cyc7XG5cbi8qKiBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0LiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX2RhdGF2aWV3X3NldGJpZ3VpbnQ2NCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEJpZ1VpbnQ2NChcbiAgdmlldzogRGF0YVZpZXcsXG4gIGJ5dGVPZmZzZXQ6IG51bWJlcixcbiAgdmFsdWU6IGJpZ2ludCxcbiAgaXNMRTogYm9vbGVhblxuKTogdm9pZCB7XG4gIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cblxuLyoqIENob2ljZTogYSA/IGIgOiBjICovXG5leHBvcnQgZnVuY3Rpb24gQ2hpKGE6IG51bWJlciwgYjogbnVtYmVyLCBjOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gKGEgJiBiKSBeICh+YSAmIGMpO1xufVxuXG4vKiogTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1dHMgaXMgdHJ1ZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNYWooYTogbnVtYmVyLCBiOiBudW1iZXIsIGM6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG59XG5cbi8qKlxuICogTWVya2xlLURhbWdhcmQgaGFzaCBjb25zdHJ1Y3Rpb24gYmFzZSBjbGFzcy5cbiAqIENvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIE1ENSwgUklQRU1ELCBTSEExLCBTSEEyLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSGFzaE1EPFQgZXh0ZW5kcyBIYXNoTUQ8VD4+IGV4dGVuZHMgSGFzaDxUPiB7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBwcm9jZXNzKGJ1ZjogRGF0YVZpZXcsIG9mZnNldDogbnVtYmVyKTogdm9pZDtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldCgpOiBudW1iZXJbXTtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IHNldCguLi5hcmdzOiBudW1iZXJbXSk6IHZvaWQ7XG4gIGFic3RyYWN0IGRlc3Ryb3koKTogdm9pZDtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IHJvdW5kQ2xlYW4oKTogdm9pZDtcblxuICByZWFkb25seSBibG9ja0xlbjogbnVtYmVyO1xuICByZWFkb25seSBvdXRwdXRMZW46IG51bWJlcjtcbiAgcmVhZG9ubHkgcGFkT2Zmc2V0OiBudW1iZXI7XG4gIHJlYWRvbmx5IGlzTEU6IGJvb2xlYW47XG5cbiAgLy8gRm9yIHBhcnRpYWwgdXBkYXRlcyBsZXNzIHRoYW4gYmxvY2sgc2l6ZVxuICBwcm90ZWN0ZWQgYnVmZmVyOiBVaW50OEFycmF5O1xuICBwcm90ZWN0ZWQgdmlldzogRGF0YVZpZXc7XG4gIHByb3RlY3RlZCBmaW5pc2hlZCA9IGZhbHNlO1xuICBwcm90ZWN0ZWQgbGVuZ3RoID0gMDtcbiAgcHJvdGVjdGVkIHBvcyA9IDA7XG4gIHByb3RlY3RlZCBkZXN0cm95ZWQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihibG9ja0xlbjogbnVtYmVyLCBvdXRwdXRMZW46IG51bWJlciwgcGFkT2Zmc2V0OiBudW1iZXIsIGlzTEU6IGJvb2xlYW4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICB9XG4gIHVwZGF0ZShkYXRhOiBJbnB1dCk6IHRoaXMge1xuICAgIGFleGlzdHModGhpcyk7XG4gICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgYWJ5dGVzKGRhdGEpO1xuICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47ICkge1xuICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbikgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgcG9zICs9IHRha2U7XG4gICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkaWdlc3RJbnRvKG91dDogVWludDhBcnJheSk6IHZvaWQge1xuICAgIGFleGlzdHModGhpcyk7XG4gICAgYW91dHB1dChvdXQsIHRoaXMpO1xuICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgIC8vIFBhZGRpbmdcbiAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgIGNsZWFuKHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykpO1xuICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW5cbiAgICAvLyBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICBwb3MgPSAwO1xuICAgIH1cbiAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKykgYnVmZmVyW2ldID0gMDtcbiAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgIGlmIChsZW4gJSA0KSB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKSBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgfVxuICBkaWdlc3QoKTogVWludDhBcnJheSB7XG4gICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIF9jbG9uZUludG8odG8/OiBUKTogVCB7XG4gICAgdG8gfHw9IG5ldyAodGhpcy5jb25zdHJ1Y3RvciBhcyBhbnkpKCkgYXMgVDtcbiAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgdG8ucG9zID0gcG9zO1xuICAgIGlmIChsZW5ndGggJSBibG9ja0xlbikgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgIHJldHVybiB0bztcbiAgfVxuICBjbG9uZSgpOiBUIHtcbiAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsIFNIQS0yIHN0YXRlOiBmcmFjdGlvbmFsIHBhcnRzIG9mIHNxdWFyZSByb290cyBvZiBmaXJzdCAxNiBwcmltZXMgMi4uNTMuXG4gKiBDaGVjayBvdXQgYHRlc3QvbWlzYy9zaGEyLWdlbi1pdi5qc2AgZm9yIHJlY29tcHV0YXRpb24gZ3VpZGUuXG4gKi9cblxuLyoqIEluaXRpYWwgU0hBMjU2IHN0YXRlLiBCaXRzIDAuLjMyIG9mIGZyYWMgcGFydCBvZiBzcXJ0IG9mIHByaW1lcyAyLi4xOSAqL1xuZXhwb3J0IGNvbnN0IFNIQTI1Nl9JVjogVWludDMyQXJyYXkgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTksXG5dKTtcblxuLyoqIEluaXRpYWwgU0hBMjI0IHN0YXRlLiBCaXRzIDMyLi42NCBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMjMuLjUzICovXG5leHBvcnQgY29uc3QgU0hBMjI0X0lWOiBVaW50MzJBcnJheSA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgMHhjMTA1OWVkOCwgMHgzNjdjZDUwNywgMHgzMDcwZGQxNywgMHhmNzBlNTkzOSwgMHhmZmMwMGIzMSwgMHg2ODU4MTUxMSwgMHg2NGY5OGZhNywgMHhiZWZhNGZhNCxcbl0pO1xuXG4vKiogSW5pdGlhbCBTSEEzODQgc3RhdGUuIEJpdHMgMC4uNjQgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIzLi41MyAqL1xuZXhwb3J0IGNvbnN0IFNIQTM4NF9JVjogVWludDMyQXJyYXkgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gIDB4Y2JiYjlkNWQsIDB4YzEwNTllZDgsIDB4NjI5YTI5MmEsIDB4MzY3Y2Q1MDcsIDB4OTE1OTAxNWEsIDB4MzA3MGRkMTcsIDB4MTUyZmVjZDgsIDB4ZjcwZTU5MzksXG4gIDB4NjczMzI2NjcsIDB4ZmZjMDBiMzEsIDB4OGViNDRhODcsIDB4Njg1ODE1MTEsIDB4ZGIwYzJlMGQsIDB4NjRmOThmYTcsIDB4NDdiNTQ4MWQsIDB4YmVmYTRmYTQsXG5dKTtcblxuLyoqIEluaXRpYWwgU0hBNTEyIHN0YXRlLiBCaXRzIDAuLjY0IG9mIGZyYWMgcGFydCBvZiBzcXJ0IG9mIHByaW1lcyAyLi4xOSAqL1xuZXhwb3J0IGNvbnN0IFNIQTUxMl9JVjogVWludDMyQXJyYXkgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gIDB4NmEwOWU2NjcsIDB4ZjNiY2M5MDgsIDB4YmI2N2FlODUsIDB4ODRjYWE3M2IsIDB4M2M2ZWYzNzIsIDB4ZmU5NGY4MmIsIDB4YTU0ZmY1M2EsIDB4NWYxZDM2ZjEsXG4gIDB4NTEwZTUyN2YsIDB4YWRlNjgyZDEsIDB4OWIwNTY4OGMsIDB4MmIzZTZjMWYsIDB4MWY4M2Q5YWIsIDB4ZmI0MWJkNmIsIDB4NWJlMGNkMTksIDB4MTM3ZTIxNzksXG5dKTtcbiIsICIvKipcbiAqIEludGVybmFsIGhlbHBlcnMgZm9yIHU2NC4gQmlnVWludDY0QXJyYXkgaXMgdG9vIHNsb3cgYXMgcGVyIDIwMjUsIHNvIHdlIGltcGxlbWVudCBpdCB1c2luZyBVaW50MzJBcnJheS5cbiAqIEB0b2RvIHJlLWNoZWNrIGh0dHBzOi8vaXNzdWVzLmNocm9taXVtLm9yZy9pc3N1ZXMvNDIyMTI1ODhcbiAqIEBtb2R1bGVcbiAqL1xuY29uc3QgVTMyX01BU0s2NCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMzIpO1xuXG5mdW5jdGlvbiBmcm9tQmlnKFxuICBuOiBiaWdpbnQsXG4gIGxlID0gZmFsc2Vcbik6IHtcbiAgaDogbnVtYmVyO1xuICBsOiBudW1iZXI7XG59IHtcbiAgaWYgKGxlKSByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5cbmZ1bmN0aW9uIHNwbGl0KGxzdDogYmlnaW50W10sIGxlID0gZmFsc2UpOiBVaW50MzJBcnJheVtdIHtcbiAgY29uc3QgbGVuID0gbHN0Lmxlbmd0aDtcbiAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxlbik7XG4gIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsZW4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICB9XG4gIHJldHVybiBbQWgsIEFsXTtcbn1cblxuY29uc3QgdG9CaWcgPSAoaDogbnVtYmVyLCBsOiBudW1iZXIpOiBiaWdpbnQgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoOiBudW1iZXIsIF9sOiBudW1iZXIsIHM6IG51bWJlcik6IG51bWJlciA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaDogbnVtYmVyLCBsOiBudW1iZXIsIHM6IG51bWJlcik6IG51bWJlciA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdHJTSCA9IChoOiBudW1iZXIsIGw6IG51bWJlciwgczogbnVtYmVyKTogbnVtYmVyID0+IChoID4+PiBzKSB8IChsIDw8ICgzMiAtIHMpKTtcbmNvbnN0IHJvdHJTTCA9IChoOiBudW1iZXIsIGw6IG51bWJlciwgczogbnVtYmVyKTogbnVtYmVyID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoOiBudW1iZXIsIGw6IG51bWJlciwgczogbnVtYmVyKTogbnVtYmVyID0+IChoIDw8ICg2NCAtIHMpKSB8IChsID4+PiAocyAtIDMyKSk7XG5jb25zdCByb3RyQkwgPSAoaDogbnVtYmVyLCBsOiBudW1iZXIsIHM6IG51bWJlcik6IG51bWJlciA9PiAoaCA+Pj4gKHMgLSAzMikpIHwgKGwgPDwgKDY0IC0gcykpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoX2g6IG51bWJlciwgbDogbnVtYmVyKTogbnVtYmVyID0+IGw7XG5jb25zdCByb3RyMzJMID0gKGg6IG51bWJlciwgX2w6IG51bWJlcik6IG51bWJlciA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoOiBudW1iZXIsIGw6IG51bWJlciwgczogbnVtYmVyKTogbnVtYmVyID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoOiBudW1iZXIsIGw6IG51bWJlciwgczogbnVtYmVyKTogbnVtYmVyID0+IChsIDw8IHMpIHwgKGggPj4+ICgzMiAtIHMpKTtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90bEJIID0gKGg6IG51bWJlciwgbDogbnVtYmVyLCBzOiBudW1iZXIpOiBudW1iZXIgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoOiBudW1iZXIsIGw6IG51bWJlciwgczogbnVtYmVyKTogbnVtYmVyID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG5cbi8vIEpTIHVzZXMgMzItYml0IHNpZ25lZCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zIHdoaWNoIG1lYW5zIHdlIGNhbm5vdFxuLy8gc2ltcGxlIHRha2UgY2Fycnkgb3V0IG9mIGxvdyBiaXQgc3VtIGJ5IHNoaWZ0LCB3ZSBuZWVkIHRvIHVzZSBkaXZpc2lvbi5cbmZ1bmN0aW9uIGFkZChcbiAgQWg6IG51bWJlcixcbiAgQWw6IG51bWJlcixcbiAgQmg6IG51bWJlcixcbiAgQmw6IG51bWJlclxuKToge1xuICBoOiBudW1iZXI7XG4gIGw6IG51bWJlcjtcbn0ge1xuICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWw6IG51bWJlciwgQmw6IG51bWJlciwgQ2w6IG51bWJlcik6IG51bWJlciA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3c6IG51bWJlciwgQWg6IG51bWJlciwgQmg6IG51bWJlciwgQ2g6IG51bWJlcik6IG51bWJlciA9PlxuICAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ0TCA9IChBbDogbnVtYmVyLCBCbDogbnVtYmVyLCBDbDogbnVtYmVyLCBEbDogbnVtYmVyKTogbnVtYmVyID0+XG4gIChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5jb25zdCBhZGQ0SCA9IChsb3c6IG51bWJlciwgQWg6IG51bWJlciwgQmg6IG51bWJlciwgQ2g6IG51bWJlciwgRGg6IG51bWJlcik6IG51bWJlciA9PlxuICAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDVMID0gKEFsOiBudW1iZXIsIEJsOiBudW1iZXIsIENsOiBudW1iZXIsIERsOiBudW1iZXIsIEVsOiBudW1iZXIpOiBudW1iZXIgPT5cbiAgKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5jb25zdCBhZGQ1SCA9IChsb3c6IG51bWJlciwgQWg6IG51bWJlciwgQmg6IG51bWJlciwgQ2g6IG51bWJlciwgRGg6IG51bWJlciwgRWg6IG51bWJlcik6IG51bWJlciA9PlxuICAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuXG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB7XG4gIGFkZCwgYWRkM0gsIGFkZDNMLCBhZGQ0SCwgYWRkNEwsIGFkZDVILCBhZGQ1TCwgZnJvbUJpZywgcm90bEJILCByb3RsQkwsIHJvdGxTSCwgcm90bFNMLCByb3RyMzJILCByb3RyMzJMLCByb3RyQkgsIHJvdHJCTCwgcm90clNILCByb3RyU0wsIHNoclNILCBzaHJTTCwgc3BsaXQsIHRvQmlnXG59O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQ6IHsgZnJvbUJpZzogdHlwZW9mIGZyb21CaWc7IHNwbGl0OiB0eXBlb2Ygc3BsaXQ7IHRvQmlnOiAoaDogbnVtYmVyLCBsOiBudW1iZXIpID0+IGJpZ2ludDsgc2hyU0g6IChoOiBudW1iZXIsIF9sOiBudW1iZXIsIHM6IG51bWJlcikgPT4gbnVtYmVyOyBzaHJTTDogKGg6IG51bWJlciwgbDogbnVtYmVyLCBzOiBudW1iZXIpID0+IG51bWJlcjsgcm90clNIOiAoaDogbnVtYmVyLCBsOiBudW1iZXIsIHM6IG51bWJlcikgPT4gbnVtYmVyOyByb3RyU0w6IChoOiBudW1iZXIsIGw6IG51bWJlciwgczogbnVtYmVyKSA9PiBudW1iZXI7IHJvdHJCSDogKGg6IG51bWJlciwgbDogbnVtYmVyLCBzOiBudW1iZXIpID0+IG51bWJlcjsgcm90ckJMOiAoaDogbnVtYmVyLCBsOiBudW1iZXIsIHM6IG51bWJlcikgPT4gbnVtYmVyOyByb3RyMzJIOiAoX2g6IG51bWJlciwgbDogbnVtYmVyKSA9PiBudW1iZXI7IHJvdHIzMkw6IChoOiBudW1iZXIsIF9sOiBudW1iZXIpID0+IG51bWJlcjsgcm90bFNIOiAoaDogbnVtYmVyLCBsOiBudW1iZXIsIHM6IG51bWJlcikgPT4gbnVtYmVyOyByb3RsU0w6IChoOiBudW1iZXIsIGw6IG51bWJlciwgczogbnVtYmVyKSA9PiBudW1iZXI7IHJvdGxCSDogKGg6IG51bWJlciwgbDogbnVtYmVyLCBzOiBudW1iZXIpID0+IG51bWJlcjsgcm90bEJMOiAoaDogbnVtYmVyLCBsOiBudW1iZXIsIHM6IG51bWJlcikgPT4gbnVtYmVyOyBhZGQ6IHR5cGVvZiBhZGQ7IGFkZDNMOiAoQWw6IG51bWJlciwgQmw6IG51bWJlciwgQ2w6IG51bWJlcikgPT4gbnVtYmVyOyBhZGQzSDogKGxvdzogbnVtYmVyLCBBaDogbnVtYmVyLCBCaDogbnVtYmVyLCBDaDogbnVtYmVyKSA9PiBudW1iZXI7IGFkZDRMOiAoQWw6IG51bWJlciwgQmw6IG51bWJlciwgQ2w6IG51bWJlciwgRGw6IG51bWJlcikgPT4gbnVtYmVyOyBhZGQ0SDogKGxvdzogbnVtYmVyLCBBaDogbnVtYmVyLCBCaDogbnVtYmVyLCBDaDogbnVtYmVyLCBEaDogbnVtYmVyKSA9PiBudW1iZXI7IGFkZDVIOiAobG93OiBudW1iZXIsIEFoOiBudW1iZXIsIEJoOiBudW1iZXIsIENoOiBudW1iZXIsIERoOiBudW1iZXIsIEVoOiBudW1iZXIpID0+IG51bWJlcjsgYWRkNUw6IChBbDogbnVtYmVyLCBCbDogbnVtYmVyLCBDbDogbnVtYmVyLCBEbDogbnVtYmVyLCBFbDogbnVtYmVyKSA9PiBudW1iZXI7IH0gPSB7XG4gIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgc2hyU0gsIHNoclNMLFxuICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gIHJvdHIzMkgsIHJvdHIzMkwsXG4gIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCxcbiAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydCBkZWZhdWx0IHU2NDtcbiIsICIvKipcbiAqIFNIQTIgaGFzaCBmdW5jdGlvbi4gQS5rLmEuIHNoYTI1Niwgc2hhMzg0LCBzaGE1MTIsIHNoYTUxMl8yMjQsIHNoYTUxMl8yNTYuXG4gKiBTSEEyNTYgaXMgdGhlIGZhc3Rlc3QgaGFzaCBpbXBsZW1lbnRhYmxlIGluIEpTLCBldmVuIGZhc3RlciB0aGFuIEJsYWtlMy5cbiAqIENoZWNrIG91dCBbUkZDIDQ2MzRdKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNDYzNCkgYW5kXG4gKiBbRklQUyAxODAtNF0oaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZikuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IENoaSwgSGFzaE1ELCBNYWosIFNIQTIyNF9JViwgU0hBMjU2X0lWLCBTSEEzODRfSVYsIFNIQTUxMl9JViB9IGZyb20gJy4vX21kLnRzJztcbmltcG9ydCAqIGFzIHU2NCBmcm9tICcuL191NjQudHMnO1xuaW1wb3J0IHsgdHlwZSBDSGFzaCwgY2xlYW4sIGNyZWF0ZUhhc2hlciwgcm90ciB9IGZyb20gJy4vdXRpbHMudHMnO1xuXG4vKipcbiAqIFJvdW5kIGNvbnN0YW50czpcbiAqIEZpcnN0IDMyIGJpdHMgb2YgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG5cbi8qKiBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyLiBcIldcIiBjb21lcyBzdHJhaWdodCBmcm9tIHNwZWMuICovXG5jb25zdCBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuZXhwb3J0IGNsYXNzIFNIQTI1NiBleHRlbmRzIEhhc2hNRDxTSEEyNTY+IHtcbiAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gIHByb3RlY3RlZCBBOiBudW1iZXIgPSBTSEEyNTZfSVZbMF0gfCAwO1xuICBwcm90ZWN0ZWQgQjogbnVtYmVyID0gU0hBMjU2X0lWWzFdIHwgMDtcbiAgcHJvdGVjdGVkIEM6IG51bWJlciA9IFNIQTI1Nl9JVlsyXSB8IDA7XG4gIHByb3RlY3RlZCBEOiBudW1iZXIgPSBTSEEyNTZfSVZbM10gfCAwO1xuICBwcm90ZWN0ZWQgRTogbnVtYmVyID0gU0hBMjU2X0lWWzRdIHwgMDtcbiAgcHJvdGVjdGVkIEY6IG51bWJlciA9IFNIQTI1Nl9JVls1XSB8IDA7XG4gIHByb3RlY3RlZCBHOiBudW1iZXIgPSBTSEEyNTZfSVZbNl0gfCAwO1xuICBwcm90ZWN0ZWQgSDogbnVtYmVyID0gU0hBMjU2X0lWWzddIHwgMDtcblxuICBjb25zdHJ1Y3RvcihvdXRwdXRMZW46IG51bWJlciA9IDMyKSB7XG4gICAgc3VwZXIoNjQsIG91dHB1dExlbiwgOCwgZmFsc2UpO1xuICB9XG4gIHByb3RlY3RlZCBnZXQoKTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XG4gICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gIH1cbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHByb3RlY3RlZCBzZXQoXG4gICAgQTogbnVtYmVyLCBCOiBudW1iZXIsIEM6IG51bWJlciwgRDogbnVtYmVyLCBFOiBudW1iZXIsIEY6IG51bWJlciwgRzogbnVtYmVyLCBIOiBudW1iZXJcbiAgKTogdm9pZCB7XG4gICAgdGhpcy5BID0gQSB8IDA7XG4gICAgdGhpcy5CID0gQiB8IDA7XG4gICAgdGhpcy5DID0gQyB8IDA7XG4gICAgdGhpcy5EID0gRCB8IDA7XG4gICAgdGhpcy5FID0gRSB8IDA7XG4gICAgdGhpcy5GID0gRiB8IDA7XG4gICAgdGhpcy5HID0gRyB8IDA7XG4gICAgdGhpcy5IID0gSCB8IDA7XG4gIH1cbiAgcHJvdGVjdGVkIHByb2Nlc3ModmlldzogRGF0YVZpZXcsIG9mZnNldDogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNCkgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgIH1cbiAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICBjb25zdCBzaWdtYTEgPSByb3RyKEUsIDYpIF4gcm90cihFLCAxMSkgXiByb3RyKEUsIDI1KTtcbiAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICBjb25zdCBzaWdtYTAgPSByb3RyKEEsIDIpIF4gcm90cihBLCAxMykgXiByb3RyKEEsIDIyKTtcbiAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xuICAgICAgSCA9IEc7XG4gICAgICBHID0gRjtcbiAgICAgIEYgPSBFO1xuICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgIEQgPSBDO1xuICAgICAgQyA9IEI7XG4gICAgICBCID0gQTtcbiAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgIH1cbiAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICB9XG4gIHByb3RlY3RlZCByb3VuZENsZWFuKCk6IHZvaWQge1xuICAgIGNsZWFuKFNIQTI1Nl9XKTtcbiAgfVxuICBkZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIGNsZWFuKHRoaXMuYnVmZmVyKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgcHJvdGVjdGVkIEE6IG51bWJlciA9IFNIQTIyNF9JVlswXSB8IDA7XG4gIHByb3RlY3RlZCBCOiBudW1iZXIgPSBTSEEyMjRfSVZbMV0gfCAwO1xuICBwcm90ZWN0ZWQgQzogbnVtYmVyID0gU0hBMjI0X0lWWzJdIHwgMDtcbiAgcHJvdGVjdGVkIEQ6IG51bWJlciA9IFNIQTIyNF9JVlszXSB8IDA7XG4gIHByb3RlY3RlZCBFOiBudW1iZXIgPSBTSEEyMjRfSVZbNF0gfCAwO1xuICBwcm90ZWN0ZWQgRjogbnVtYmVyID0gU0hBMjI0X0lWWzVdIHwgMDtcbiAgcHJvdGVjdGVkIEc6IG51bWJlciA9IFNIQTIyNF9JVls2XSB8IDA7XG4gIHByb3RlY3RlZCBIOiBudW1iZXIgPSBTSEEyMjRfSVZbN10gfCAwO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigyOCk7XG4gIH1cbn1cblxuLy8gU0hBMi01MTIgaXMgc2xvd2VyIHRoYW4gc2hhMjU2IGluIGpzIGJlY2F1c2UgdTY0IG9wZXJhdGlvbnMgYXJlIHNsb3cuXG5cbi8vIFJvdW5kIGNvbnRhbnRzXG4vLyBGaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4MCBwcmltZXMgMi4uNDA5XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEs1MTIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHU2NC5zcGxpdChbXG4gICcweDQyOGEyZjk4ZDcyOGFlMjInLCAnMHg3MTM3NDQ5MTIzZWY2NWNkJywgJzB4YjVjMGZiY2ZlYzRkM2IyZicsICcweGU5YjVkYmE1ODE4OWRiYmMnLFxuICAnMHgzOTU2YzI1YmYzNDhiNTM4JywgJzB4NTlmMTExZjFiNjA1ZDAxOScsICcweDkyM2Y4MmE0YWYxOTRmOWInLCAnMHhhYjFjNWVkNWRhNmQ4MTE4JyxcbiAgJzB4ZDgwN2FhOThhMzAzMDI0MicsICcweDEyODM1YjAxNDU3MDZmYmUnLCAnMHgyNDMxODViZTRlZTRiMjhjJywgJzB4NTUwYzdkYzNkNWZmYjRlMicsXG4gICcweDcyYmU1ZDc0ZjI3Yjg5NmYnLCAnMHg4MGRlYjFmZTNiMTY5NmIxJywgJzB4OWJkYzA2YTcyNWM3MTIzNScsICcweGMxOWJmMTc0Y2Y2OTI2OTQnLFxuICAnMHhlNDliNjljMTllZjE0YWQyJywgJzB4ZWZiZTQ3ODYzODRmMjVlMycsICcweDBmYzE5ZGM2OGI4Y2Q1YjUnLCAnMHgyNDBjYTFjYzc3YWM5YzY1JyxcbiAgJzB4MmRlOTJjNmY1OTJiMDI3NScsICcweDRhNzQ4NGFhNmVhNmU0ODMnLCAnMHg1Y2IwYTlkY2JkNDFmYmQ0JywgJzB4NzZmOTg4ZGE4MzExNTNiNScsXG4gICcweDk4M2U1MTUyZWU2NmRmYWInLCAnMHhhODMxYzY2ZDJkYjQzMjEwJywgJzB4YjAwMzI3Yzg5OGZiMjEzZicsICcweGJmNTk3ZmM3YmVlZjBlZTQnLFxuICAnMHhjNmUwMGJmMzNkYTg4ZmMyJywgJzB4ZDVhNzkxNDc5MzBhYTcyNScsICcweDA2Y2E2MzUxZTAwMzgyNmYnLCAnMHgxNDI5Mjk2NzBhMGU2ZTcwJyxcbiAgJzB4MjdiNzBhODU0NmQyMmZmYycsICcweDJlMWIyMTM4NWMyNmM5MjYnLCAnMHg0ZDJjNmRmYzVhYzQyYWVkJywgJzB4NTMzODBkMTM5ZDk1YjNkZicsXG4gICcweDY1MGE3MzU0OGJhZjYzZGUnLCAnMHg3NjZhMGFiYjNjNzdiMmE4JywgJzB4ODFjMmM5MmU0N2VkYWVlNicsICcweDkyNzIyYzg1MTQ4MjM1M2InLFxuICAnMHhhMmJmZThhMTRjZjEwMzY0JywgJzB4YTgxYTY2NGJiYzQyMzAwMScsICcweGMyNGI4YjcwZDBmODk3OTEnLCAnMHhjNzZjNTFhMzA2NTRiZTMwJyxcbiAgJzB4ZDE5MmU4MTlkNmVmNTIxOCcsICcweGQ2OTkwNjI0NTU2NWE5MTAnLCAnMHhmNDBlMzU4NTU3NzEyMDJhJywgJzB4MTA2YWEwNzAzMmJiZDFiOCcsXG4gICcweDE5YTRjMTE2YjhkMmQwYzgnLCAnMHgxZTM3NmMwODUxNDFhYjUzJywgJzB4Mjc0ODc3NGNkZjhlZWI5OScsICcweDM0YjBiY2I1ZTE5YjQ4YTgnLFxuICAnMHgzOTFjMGNiM2M1Yzk1YTYzJywgJzB4NGVkOGFhNGFlMzQxOGFjYicsICcweDViOWNjYTRmNzc2M2UzNzMnLCAnMHg2ODJlNmZmM2Q2YjJiOGEzJyxcbiAgJzB4NzQ4ZjgyZWU1ZGVmYjJmYycsICcweDc4YTU2MzZmNDMxNzJmNjAnLCAnMHg4NGM4NzgxNGExZjBhYjcyJywgJzB4OGNjNzAyMDgxYTY0MzllYycsXG4gICcweDkwYmVmZmZhMjM2MzFlMjgnLCAnMHhhNDUwNmNlYmRlODJiZGU5JywgJzB4YmVmOWEzZjdiMmM2NzkxNScsICcweGM2NzE3OGYyZTM3MjUzMmInLFxuICAnMHhjYTI3M2VjZWVhMjY2MTljJywgJzB4ZDE4NmI4YzcyMWMwYzIwNycsICcweGVhZGE3ZGQ2Y2RlMGViMWUnLCAnMHhmNTdkNGY3ZmVlNmVkMTc4JyxcbiAgJzB4MDZmMDY3YWE3MjE3NmZiYScsICcweDBhNjM3ZGM1YTJjODk4YTYnLCAnMHgxMTNmOTgwNGJlZjkwZGFlJywgJzB4MWI3MTBiMzUxMzFjNDcxYicsXG4gICcweDI4ZGI3N2Y1MjMwNDdkODQnLCAnMHgzMmNhYWI3YjQwYzcyNDkzJywgJzB4M2M5ZWJlMGExNWM5YmViYycsICcweDQzMWQ2N2M0OWMxMDBkNGMnLFxuICAnMHg0Y2M1ZDRiZWNiM2U0MmI2JywgJzB4NTk3ZjI5OWNmYzY1N2UyYScsICcweDVmY2I2ZmFiM2FkNmZhZWMnLCAnMHg2YzQ0MTk4YzRhNDc1ODE3J1xuXS5tYXAobiA9PiBCaWdJbnQobikpKSkoKTtcbmNvbnN0IFNIQTUxMl9LaCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gSzUxMlswXSkoKTtcbmNvbnN0IFNIQTUxMl9LbCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gSzUxMlsxXSkoKTtcblxuLy8gUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlcnNcbmNvbnN0IFNIQTUxMl9XX0ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNvbnN0IFNIQTUxMl9XX0wgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcblxuZXhwb3J0IGNsYXNzIFNIQTUxMiBleHRlbmRzIEhhc2hNRDxTSEE1MTI+IHtcbiAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gIHByb3RlY3RlZCBBaDogbnVtYmVyID0gU0hBNTEyX0lWWzBdIHwgMDtcbiAgcHJvdGVjdGVkIEFsOiBudW1iZXIgPSBTSEE1MTJfSVZbMV0gfCAwO1xuICBwcm90ZWN0ZWQgQmg6IG51bWJlciA9IFNIQTUxMl9JVlsyXSB8IDA7XG4gIHByb3RlY3RlZCBCbDogbnVtYmVyID0gU0hBNTEyX0lWWzNdIHwgMDtcbiAgcHJvdGVjdGVkIENoOiBudW1iZXIgPSBTSEE1MTJfSVZbNF0gfCAwO1xuICBwcm90ZWN0ZWQgQ2w6IG51bWJlciA9IFNIQTUxMl9JVls1XSB8IDA7XG4gIHByb3RlY3RlZCBEaDogbnVtYmVyID0gU0hBNTEyX0lWWzZdIHwgMDtcbiAgcHJvdGVjdGVkIERsOiBudW1iZXIgPSBTSEE1MTJfSVZbN10gfCAwO1xuICBwcm90ZWN0ZWQgRWg6IG51bWJlciA9IFNIQTUxMl9JVls4XSB8IDA7XG4gIHByb3RlY3RlZCBFbDogbnVtYmVyID0gU0hBNTEyX0lWWzldIHwgMDtcbiAgcHJvdGVjdGVkIEZoOiBudW1iZXIgPSBTSEE1MTJfSVZbMTBdIHwgMDtcbiAgcHJvdGVjdGVkIEZsOiBudW1iZXIgPSBTSEE1MTJfSVZbMTFdIHwgMDtcbiAgcHJvdGVjdGVkIEdoOiBudW1iZXIgPSBTSEE1MTJfSVZbMTJdIHwgMDtcbiAgcHJvdGVjdGVkIEdsOiBudW1iZXIgPSBTSEE1MTJfSVZbMTNdIHwgMDtcbiAgcHJvdGVjdGVkIEhoOiBudW1iZXIgPSBTSEE1MTJfSVZbMTRdIHwgMDtcbiAgcHJvdGVjdGVkIEhsOiBudW1iZXIgPSBTSEE1MTJfSVZbMTVdIHwgMDtcblxuICBjb25zdHJ1Y3RvcihvdXRwdXRMZW46IG51bWJlciA9IDY0KSB7XG4gICAgc3VwZXIoMTI4LCBvdXRwdXRMZW4sIDE2LCBmYWxzZSk7XG4gIH1cbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHByb3RlY3RlZCBnZXQoKTogW1xuICAgIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLFxuICAgIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXG4gIF0ge1xuICAgIGNvbnN0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgcmV0dXJuIFtBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbF07XG4gIH1cbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHByb3RlY3RlZCBzZXQoXG4gICAgQWg6IG51bWJlciwgQWw6IG51bWJlciwgQmg6IG51bWJlciwgQmw6IG51bWJlciwgQ2g6IG51bWJlciwgQ2w6IG51bWJlciwgRGg6IG51bWJlciwgRGw6IG51bWJlcixcbiAgICBFaDogbnVtYmVyLCBFbDogbnVtYmVyLCBGaDogbnVtYmVyLCBGbDogbnVtYmVyLCBHaDogbnVtYmVyLCBHbDogbnVtYmVyLCBIaDogbnVtYmVyLCBIbDogbnVtYmVyXG4gICk6IHZvaWQge1xuICAgIHRoaXMuQWggPSBBaCB8IDA7XG4gICAgdGhpcy5BbCA9IEFsIHwgMDtcbiAgICB0aGlzLkJoID0gQmggfCAwO1xuICAgIHRoaXMuQmwgPSBCbCB8IDA7XG4gICAgdGhpcy5DaCA9IENoIHwgMDtcbiAgICB0aGlzLkNsID0gQ2wgfCAwO1xuICAgIHRoaXMuRGggPSBEaCB8IDA7XG4gICAgdGhpcy5EbCA9IERsIHwgMDtcbiAgICB0aGlzLkVoID0gRWggfCAwO1xuICAgIHRoaXMuRWwgPSBFbCB8IDA7XG4gICAgdGhpcy5GaCA9IEZoIHwgMDtcbiAgICB0aGlzLkZsID0gRmwgfCAwO1xuICAgIHRoaXMuR2ggPSBHaCB8IDA7XG4gICAgdGhpcy5HbCA9IEdsIHwgMDtcbiAgICB0aGlzLkhoID0gSGggfCAwO1xuICAgIHRoaXMuSGwgPSBIbCB8IDA7XG4gIH1cbiAgcHJvdGVjdGVkIHByb2Nlc3ModmlldzogRGF0YVZpZXcsIG9mZnNldDogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNjQgd29yZHMgd1sxNi4uNzldIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNCkge1xuICAgICAgU0hBNTEyX1dfSFtpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgICBTSEE1MTJfV19MW2ldID0gdmlldy5nZXRVaW50MzIoKG9mZnNldCArPSA0KSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcbiAgICAgIC8vIHMwIDo9ICh3W2ktMTVdIHJpZ2h0cm90YXRlIDEpIHhvciAod1tpLTE1XSByaWdodHJvdGF0ZSA4KSB4b3IgKHdbaS0xNV0gcmlnaHRzaGlmdCA3KVxuICAgICAgY29uc3QgVzE1aCA9IFNIQTUxMl9XX0hbaSAtIDE1XSB8IDA7XG4gICAgICBjb25zdCBXMTVsID0gU0hBNTEyX1dfTFtpIC0gMTVdIHwgMDtcbiAgICAgIGNvbnN0IHMwaCA9IHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNIKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNIKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgY29uc3QgczBsID0gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0woVzE1aCwgVzE1bCwgNyk7XG4gICAgICAvLyBzMSA6PSAod1tpLTJdIHJpZ2h0cm90YXRlIDE5KSB4b3IgKHdbaS0yXSByaWdodHJvdGF0ZSA2MSkgeG9yICh3W2ktMl0gcmlnaHRzaGlmdCA2KVxuICAgICAgY29uc3QgVzJoID0gU0hBNTEyX1dfSFtpIC0gMl0gfCAwO1xuICAgICAgY29uc3QgVzJsID0gU0hBNTEyX1dfTFtpIC0gMl0gfCAwO1xuICAgICAgY29uc3QgczFoID0gdTY0LnJvdHJTSChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCSChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNIKFcyaCwgVzJsLCA2KTtcbiAgICAgIGNvbnN0IHMxbCA9IHU2NC5yb3RyU0woVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkwoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTTChXMmgsIFcybCwgNik7XG4gICAgICAvLyBTSEEyNTZfV1tpXSA9IHMwICsgczEgKyBTSEEyNTZfV1tpIC0gN10gKyBTSEEyNTZfV1tpIC0gMTZdO1xuICAgICAgY29uc3QgU1VNbCA9IHU2NC5hZGQ0TChzMGwsIHMxbCwgU0hBNTEyX1dfTFtpIC0gN10sIFNIQTUxMl9XX0xbaSAtIDE2XSk7XG4gICAgICBjb25zdCBTVU1oID0gdTY0LmFkZDRIKFNVTWwsIHMwaCwgczFoLCBTSEE1MTJfV19IW2kgLSA3XSwgU0hBNTEyX1dfSFtpIC0gMTZdKTtcbiAgICAgIFNIQTUxMl9XX0hbaV0gPSBTVU1oIHwgMDtcbiAgICAgIFNIQTUxMl9XX0xbaV0gPSBTVU1sIHwgMDtcbiAgICB9XG4gICAgbGV0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA4MCByb3VuZHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgIC8vIFMxIDo9IChlIHJpZ2h0cm90YXRlIDE0KSB4b3IgKGUgcmlnaHRyb3RhdGUgMTgpIHhvciAoZSByaWdodHJvdGF0ZSA0MSlcbiAgICAgIGNvbnN0IHNpZ21hMWggPSB1NjQucm90clNIKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTSChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkgoRWgsIEVsLCA0MSk7XG4gICAgICBjb25zdCBzaWdtYTFsID0gdTY0LnJvdHJTTChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0woRWgsIEVsLCAxOCkgXiB1NjQucm90ckJMKEVoLCBFbCwgNDEpO1xuICAgICAgLy9jb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgY29uc3QgQ0hJaCA9IChFaCAmIEZoKSBeICh+RWggJiBHaCk7XG4gICAgICBjb25zdCBDSElsID0gKEVsICYgRmwpIF4gKH5FbCAmIEdsKTtcbiAgICAgIC8vIFQxID0gSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTUxMl9LW2ldICsgU0hBNTEyX1dbaV1cbiAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgY29uc3QgVDFsbCA9IHU2NC5hZGQ1TChIbCwgc2lnbWExbCwgQ0hJbCwgU0hBNTEyX0tsW2ldLCBTSEE1MTJfV19MW2ldKTtcbiAgICAgIGNvbnN0IFQxaCA9IHU2NC5hZGQ1SChUMWxsLCBIaCwgc2lnbWExaCwgQ0hJaCwgU0hBNTEyX0toW2ldLCBTSEE1MTJfV19IW2ldKTtcbiAgICAgIGNvbnN0IFQxbCA9IFQxbGwgfCAwO1xuICAgICAgLy8gUzAgOj0gKGEgcmlnaHRyb3RhdGUgMjgpIHhvciAoYSByaWdodHJvdGF0ZSAzNCkgeG9yIChhIHJpZ2h0cm90YXRlIDM5KVxuICAgICAgY29uc3Qgc2lnbWEwaCA9IHU2NC5yb3RyU0goQWgsIEFsLCAyOCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM5KTtcbiAgICAgIGNvbnN0IHNpZ21hMGwgPSB1NjQucm90clNMKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzOSk7XG4gICAgICBjb25zdCBNQUpoID0gKEFoICYgQmgpIF4gKEFoICYgQ2gpIF4gKEJoICYgQ2gpO1xuICAgICAgY29uc3QgTUFKbCA9IChBbCAmIEJsKSBeIChBbCAmIENsKSBeIChCbCAmIENsKTtcbiAgICAgIEhoID0gR2ggfCAwO1xuICAgICAgSGwgPSBHbCB8IDA7XG4gICAgICBHaCA9IEZoIHwgMDtcbiAgICAgIEdsID0gRmwgfCAwO1xuICAgICAgRmggPSBFaCB8IDA7XG4gICAgICBGbCA9IEVsIHwgMDtcbiAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZChEaCB8IDAsIERsIHwgMCwgVDFoIHwgMCwgVDFsIHwgMCkpO1xuICAgICAgRGggPSBDaCB8IDA7XG4gICAgICBEbCA9IENsIHwgMDtcbiAgICAgIENoID0gQmggfCAwO1xuICAgICAgQ2wgPSBCbCB8IDA7XG4gICAgICBCaCA9IEFoIHwgMDtcbiAgICAgIEJsID0gQWwgfCAwO1xuICAgICAgY29uc3QgQWxsID0gdTY0LmFkZDNMKFQxbCwgc2lnbWEwbCwgTUFKbCk7XG4gICAgICBBaCA9IHU2NC5hZGQzSChBbGwsIFQxaCwgc2lnbWEwaCwgTUFKaCk7XG4gICAgICBBbCA9IEFsbCB8IDA7XG4gICAgfVxuICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgKHsgaDogQWgsIGw6IEFsIH0gPSB1NjQuYWRkKHRoaXMuQWggfCAwLCB0aGlzLkFsIHwgMCwgQWggfCAwLCBBbCB8IDApKTtcbiAgICAoeyBoOiBCaCwgbDogQmwgfSA9IHU2NC5hZGQodGhpcy5CaCB8IDAsIHRoaXMuQmwgfCAwLCBCaCB8IDAsIEJsIHwgMCkpO1xuICAgICh7IGg6IENoLCBsOiBDbCB9ID0gdTY0LmFkZCh0aGlzLkNoIHwgMCwgdGhpcy5DbCB8IDAsIENoIHwgMCwgQ2wgfCAwKSk7XG4gICAgKHsgaDogRGgsIGw6IERsIH0gPSB1NjQuYWRkKHRoaXMuRGggfCAwLCB0aGlzLkRsIHwgMCwgRGggfCAwLCBEbCB8IDApKTtcbiAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQodGhpcy5FaCB8IDAsIHRoaXMuRWwgfCAwLCBFaCB8IDAsIEVsIHwgMCkpO1xuICAgICh7IGg6IEZoLCBsOiBGbCB9ID0gdTY0LmFkZCh0aGlzLkZoIHwgMCwgdGhpcy5GbCB8IDAsIEZoIHwgMCwgRmwgfCAwKSk7XG4gICAgKHsgaDogR2gsIGw6IEdsIH0gPSB1NjQuYWRkKHRoaXMuR2ggfCAwLCB0aGlzLkdsIHwgMCwgR2ggfCAwLCBHbCB8IDApKTtcbiAgICAoeyBoOiBIaCwgbDogSGwgfSA9IHU2NC5hZGQodGhpcy5IaCB8IDAsIHRoaXMuSGwgfCAwLCBIaCB8IDAsIEhsIHwgMCkpO1xuICAgIHRoaXMuc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKTtcbiAgfVxuICBwcm90ZWN0ZWQgcm91bmRDbGVhbigpOiB2b2lkIHtcbiAgICBjbGVhbihTSEE1MTJfV19ILCBTSEE1MTJfV19MKTtcbiAgfVxuICBkZXN0cm95KCk6IHZvaWQge1xuICAgIGNsZWFuKHRoaXMuYnVmZmVyKTtcbiAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU0hBMzg0IGV4dGVuZHMgU0hBNTEyIHtcbiAgcHJvdGVjdGVkIEFoOiBudW1iZXIgPSBTSEEzODRfSVZbMF0gfCAwO1xuICBwcm90ZWN0ZWQgQWw6IG51bWJlciA9IFNIQTM4NF9JVlsxXSB8IDA7XG4gIHByb3RlY3RlZCBCaDogbnVtYmVyID0gU0hBMzg0X0lWWzJdIHwgMDtcbiAgcHJvdGVjdGVkIEJsOiBudW1iZXIgPSBTSEEzODRfSVZbM10gfCAwO1xuICBwcm90ZWN0ZWQgQ2g6IG51bWJlciA9IFNIQTM4NF9JVls0XSB8IDA7XG4gIHByb3RlY3RlZCBDbDogbnVtYmVyID0gU0hBMzg0X0lWWzVdIHwgMDtcbiAgcHJvdGVjdGVkIERoOiBudW1iZXIgPSBTSEEzODRfSVZbNl0gfCAwO1xuICBwcm90ZWN0ZWQgRGw6IG51bWJlciA9IFNIQTM4NF9JVls3XSB8IDA7XG4gIHByb3RlY3RlZCBFaDogbnVtYmVyID0gU0hBMzg0X0lWWzhdIHwgMDtcbiAgcHJvdGVjdGVkIEVsOiBudW1iZXIgPSBTSEEzODRfSVZbOV0gfCAwO1xuICBwcm90ZWN0ZWQgRmg6IG51bWJlciA9IFNIQTM4NF9JVlsxMF0gfCAwO1xuICBwcm90ZWN0ZWQgRmw6IG51bWJlciA9IFNIQTM4NF9JVlsxMV0gfCAwO1xuICBwcm90ZWN0ZWQgR2g6IG51bWJlciA9IFNIQTM4NF9JVlsxMl0gfCAwO1xuICBwcm90ZWN0ZWQgR2w6IG51bWJlciA9IFNIQTM4NF9JVlsxM10gfCAwO1xuICBwcm90ZWN0ZWQgSGg6IG51bWJlciA9IFNIQTM4NF9JVlsxNF0gfCAwO1xuICBwcm90ZWN0ZWQgSGw6IG51bWJlciA9IFNIQTM4NF9JVlsxNV0gfCAwO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKDQ4KTtcbiAgfVxufVxuXG4vKipcbiAqIFRydW5jYXRlZCBTSEE1MTIvMjU2IGFuZCBTSEE1MTIvMjI0LlxuICogU0hBNTEyX0lWIGlzIFhPUmVkIHdpdGggMHhhNWE1YTVhNWE1YTVhNWE1LCB0aGVuIHVzZWQgYXMgXCJpbnRlcm1lZGlhcnlcIiBJViBvZiBTSEE1MTIvdC5cbiAqIFRoZW4gdCBoYXNoZXMgc3RyaW5nIHRvIHByb2R1Y2UgcmVzdWx0IElWLlxuICogU2VlIGB0ZXN0L21pc2Mvc2hhMi1nZW4taXYuanNgLlxuICovXG5cbi8qKiBTSEE1MTIvMjI0IElWICovXG5jb25zdCBUMjI0X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAweDhjM2QzN2M4LCAweDE5NTQ0ZGEyLCAweDczZTE5OTY2LCAweDg5ZGNkNGQ2LCAweDFkZmFiN2FlLCAweDMyZmY5YzgyLCAweDY3OWRkNTE0LCAweDU4MmY5ZmNmLFxuICAweDBmNmQyYjY5LCAweDdiZDQ0ZGE4LCAweDc3ZTM2ZjczLCAweDA0YzQ4OTQyLCAweDNmOWQ4NWE4LCAweDZhMWQzNmM4LCAweDExMTJlNmFkLCAweDkxZDY5MmExLFxuXSk7XG5cbi8qKiBTSEE1MTIvMjU2IElWICovXG5jb25zdCBUMjU2X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAweDIyMzEyMTk0LCAweGZjMmJmNzJjLCAweDlmNTU1ZmEzLCAweGM4NGM2NGMyLCAweDIzOTNiODZiLCAweDZmNTNiMTUxLCAweDk2Mzg3NzE5LCAweDU5NDBlYWJkLFxuICAweDk2MjgzZWUyLCAweGE4OGVmZmUzLCAweGJlNWUxZTI1LCAweDUzODYzOTkyLCAweDJiMDE5OWZjLCAweDJjODViOGFhLCAweDBlYjcyZGRjLCAweDgxYzUyY2EyLFxuXSk7XG5cbmV4cG9ydCBjbGFzcyBTSEE1MTJfMjI0IGV4dGVuZHMgU0hBNTEyIHtcbiAgcHJvdGVjdGVkIEFoOiBudW1iZXIgPSBUMjI0X0lWWzBdIHwgMDtcbiAgcHJvdGVjdGVkIEFsOiBudW1iZXIgPSBUMjI0X0lWWzFdIHwgMDtcbiAgcHJvdGVjdGVkIEJoOiBudW1iZXIgPSBUMjI0X0lWWzJdIHwgMDtcbiAgcHJvdGVjdGVkIEJsOiBudW1iZXIgPSBUMjI0X0lWWzNdIHwgMDtcbiAgcHJvdGVjdGVkIENoOiBudW1iZXIgPSBUMjI0X0lWWzRdIHwgMDtcbiAgcHJvdGVjdGVkIENsOiBudW1iZXIgPSBUMjI0X0lWWzVdIHwgMDtcbiAgcHJvdGVjdGVkIERoOiBudW1iZXIgPSBUMjI0X0lWWzZdIHwgMDtcbiAgcHJvdGVjdGVkIERsOiBudW1iZXIgPSBUMjI0X0lWWzddIHwgMDtcbiAgcHJvdGVjdGVkIEVoOiBudW1iZXIgPSBUMjI0X0lWWzhdIHwgMDtcbiAgcHJvdGVjdGVkIEVsOiBudW1iZXIgPSBUMjI0X0lWWzldIHwgMDtcbiAgcHJvdGVjdGVkIEZoOiBudW1iZXIgPSBUMjI0X0lWWzEwXSB8IDA7XG4gIHByb3RlY3RlZCBGbDogbnVtYmVyID0gVDIyNF9JVlsxMV0gfCAwO1xuICBwcm90ZWN0ZWQgR2g6IG51bWJlciA9IFQyMjRfSVZbMTJdIHwgMDtcbiAgcHJvdGVjdGVkIEdsOiBudW1iZXIgPSBUMjI0X0lWWzEzXSB8IDA7XG4gIHByb3RlY3RlZCBIaDogbnVtYmVyID0gVDIyNF9JVlsxNF0gfCAwO1xuICBwcm90ZWN0ZWQgSGw6IG51bWJlciA9IFQyMjRfSVZbMTVdIHwgMDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigyOCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNIQTUxMl8yNTYgZXh0ZW5kcyBTSEE1MTIge1xuICBwcm90ZWN0ZWQgQWg6IG51bWJlciA9IFQyNTZfSVZbMF0gfCAwO1xuICBwcm90ZWN0ZWQgQWw6IG51bWJlciA9IFQyNTZfSVZbMV0gfCAwO1xuICBwcm90ZWN0ZWQgQmg6IG51bWJlciA9IFQyNTZfSVZbMl0gfCAwO1xuICBwcm90ZWN0ZWQgQmw6IG51bWJlciA9IFQyNTZfSVZbM10gfCAwO1xuICBwcm90ZWN0ZWQgQ2g6IG51bWJlciA9IFQyNTZfSVZbNF0gfCAwO1xuICBwcm90ZWN0ZWQgQ2w6IG51bWJlciA9IFQyNTZfSVZbNV0gfCAwO1xuICBwcm90ZWN0ZWQgRGg6IG51bWJlciA9IFQyNTZfSVZbNl0gfCAwO1xuICBwcm90ZWN0ZWQgRGw6IG51bWJlciA9IFQyNTZfSVZbN10gfCAwO1xuICBwcm90ZWN0ZWQgRWg6IG51bWJlciA9IFQyNTZfSVZbOF0gfCAwO1xuICBwcm90ZWN0ZWQgRWw6IG51bWJlciA9IFQyNTZfSVZbOV0gfCAwO1xuICBwcm90ZWN0ZWQgRmg6IG51bWJlciA9IFQyNTZfSVZbMTBdIHwgMDtcbiAgcHJvdGVjdGVkIEZsOiBudW1iZXIgPSBUMjU2X0lWWzExXSB8IDA7XG4gIHByb3RlY3RlZCBHaDogbnVtYmVyID0gVDI1Nl9JVlsxMl0gfCAwO1xuICBwcm90ZWN0ZWQgR2w6IG51bWJlciA9IFQyNTZfSVZbMTNdIHwgMDtcbiAgcHJvdGVjdGVkIEhoOiBudW1iZXIgPSBUMjU2X0lWWzE0XSB8IDA7XG4gIHByb3RlY3RlZCBIbDogbnVtYmVyID0gVDI1Nl9JVlsxNV0gfCAwO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKDMyKTtcbiAgfVxufVxuXG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb24gZnJvbSBSRkMgNDYzNC5cbiAqXG4gKiBJdCBpcyB0aGUgZmFzdGVzdCBKUyBoYXNoLCBldmVuIGZhc3RlciB0aGFuIEJsYWtlMy5cbiAqIFRvIGJyZWFrIHNoYTI1NiB1c2luZyBiaXJ0aGRheSBhdHRhY2ssIGF0dGFja2VycyBuZWVkIHRvIHRyeSAyXjEyOCBoYXNoZXMuXG4gKiBCVEMgbmV0d29yayBpcyBkb2luZyAyXjcwIGhhc2hlcy9zZWMgKDJeOTUgaGFzaGVzL3llYXIpIGFzIHBlciAyMDI1LlxuICovXG5leHBvcnQgY29uc3Qgc2hhMjU2OiBDSGFzaCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IFNIQTI1NigpKTtcbi8qKiBTSEEyLTIyNCBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQgKi9cbmV4cG9ydCBjb25zdCBzaGEyMjQ6IENIYXNoID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgU0hBMjI0KCkpO1xuXG4vKiogU0hBMi01MTIgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0LiAqL1xuZXhwb3J0IGNvbnN0IHNoYTUxMjogQ0hhc2ggPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEE1MTIoKSk7XG4vKiogU0hBMi0zODQgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0LiAqL1xuZXhwb3J0IGNvbnN0IHNoYTM4NDogQ0hhc2ggPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEEzODQoKSk7XG5cbi8qKlxuICogU0hBMi01MTIvMjU2IFwidHJ1bmNhdGVkXCIgaGFzaCBmdW5jdGlvbiwgd2l0aCBpbXByb3ZlZCByZXNpc3RhbmNlIHRvIGxlbmd0aCBleHRlbnNpb24gYXR0YWNrcy5cbiAqIFNlZSB0aGUgcGFwZXIgb24gW3RydW5jYXRlZCBTSEE1MTJdKGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTAvNTQ4LnBkZikuXG4gKi9cbmV4cG9ydCBjb25zdCBzaGE1MTJfMjU2OiBDSGFzaCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IFNIQTUxMl8yNTYoKSk7XG4vKipcbiAqIFNIQTItNTEyLzIyNCBcInRydW5jYXRlZFwiIGhhc2ggZnVuY3Rpb24sIHdpdGggaW1wcm92ZWQgcmVzaXN0YW5jZSB0byBsZW5ndGggZXh0ZW5zaW9uIGF0dGFja3MuXG4gKiBTZWUgdGhlIHBhcGVyIG9uIFt0cnVuY2F0ZWQgU0hBNTEyXShodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEwLzU0OC5wZGYpLlxuICovXG5leHBvcnQgY29uc3Qgc2hhNTEyXzIyNDogQ0hhc2ggPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEE1MTJfMjI0KCkpO1xuIiwgIi8qKlxuICogSGV4LCBieXRlcyBhbmQgbnVtYmVyIHV0aWxpdGllcy5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHtcbiAgYWJ5dGVzIGFzIGFieXRlc18sXG4gIGJ5dGVzVG9IZXggYXMgYnl0ZXNUb0hleF8sXG4gIGNvbmNhdEJ5dGVzIGFzIGNvbmNhdEJ5dGVzXyxcbiAgaGV4VG9CeXRlcyBhcyBoZXhUb0J5dGVzXyxcbiAgaXNCeXRlcyBhcyBpc0J5dGVzXyxcbn0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscy5qcyc7XG5leHBvcnQge1xuICBhYnl0ZXMsXG4gIGFudW1iZXIsXG4gIGJ5dGVzVG9IZXgsXG4gIGJ5dGVzVG9VdGY4LFxuICBjb25jYXRCeXRlcyxcbiAgaGV4VG9CeXRlcyxcbiAgaXNCeXRlcyxcbiAgcmFuZG9tQnl0ZXMsXG4gIHV0ZjhUb0J5dGVzLFxufSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzLmpzJztcbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuZXhwb3J0IHR5cGUgSGV4ID0gVWludDhBcnJheSB8IHN0cmluZzsgLy8gaGV4IHN0cmluZ3MgYXJlIGFjY2VwdGVkIGZvciBzaW1wbGljaXR5XG5leHBvcnQgdHlwZSBQcml2S2V5ID0gSGV4IHwgYmlnaW50OyAvLyBiaWdpbnRzIGFyZSBhY2NlcHRlZCB0byBlYXNlIGxlYXJuaW5nIGN1cnZlXG5leHBvcnQgdHlwZSBDSGFzaCA9IHtcbiAgKG1lc3NhZ2U6IFVpbnQ4QXJyYXkgfCBzdHJpbmcpOiBVaW50OEFycmF5O1xuICBibG9ja0xlbjogbnVtYmVyO1xuICBvdXRwdXRMZW46IG51bWJlcjtcbiAgY3JlYXRlKG9wdHM/OiB7IGRrTGVuPzogbnVtYmVyIH0pOiBhbnk7IC8vIEZvciBzaGFrZVxufTtcbmV4cG9ydCB0eXBlIEZIYXNoID0gKG1lc3NhZ2U6IFVpbnQ4QXJyYXkgfCBzdHJpbmcpID0+IFVpbnQ4QXJyYXk7XG5cbmV4cG9ydCBmdW5jdGlvbiBhYm9vbCh0aXRsZTogc3RyaW5nLCB2YWx1ZTogYm9vbGVhbik6IHZvaWQge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgYm9vbGVhbiBleHBlY3RlZCwgZ290ICcgKyB2YWx1ZSk7XG59XG5cbi8vIHRtcCBuYW1lIHVudGlsIHYyXG5leHBvcnQgZnVuY3Rpb24gX2Fib29sMih2YWx1ZTogYm9vbGVhbiwgdGl0bGU6IHN0cmluZyA9ICcnKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgIGNvbnN0IHByZWZpeCA9IHRpdGxlICYmIGBcIiR7dGl0bGV9XCJgO1xuICAgIHRocm93IG5ldyBFcnJvcihwcmVmaXggKyAnZXhwZWN0ZWQgYm9vbGVhbiwgZ290IHR5cGU9JyArIHR5cGVvZiB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyB0bXAgbmFtZSB1bnRpbCB2MlxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIFVpbnQ4QXJyYXkuICovXG5leHBvcnQgZnVuY3Rpb24gX2FieXRlczIodmFsdWU6IFVpbnQ4QXJyYXksIGxlbmd0aD86IG51bWJlciwgdGl0bGU6IHN0cmluZyA9ICcnKTogVWludDhBcnJheSB7XG4gIGNvbnN0IGJ5dGVzID0gaXNCeXRlc18odmFsdWUpO1xuICBjb25zdCBsZW4gPSB2YWx1ZT8ubGVuZ3RoO1xuICBjb25zdCBuZWVkc0xlbiA9IGxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICBpZiAoIWJ5dGVzIHx8IChuZWVkc0xlbiAmJiBsZW4gIT09IGxlbmd0aCkpIHtcbiAgICBjb25zdCBwcmVmaXggPSB0aXRsZSAmJiBgXCIke3RpdGxlfVwiIGA7XG4gICAgY29uc3Qgb2ZMZW4gPSBuZWVkc0xlbiA/IGAgb2YgbGVuZ3RoICR7bGVuZ3RofWAgOiAnJztcbiAgICBjb25zdCBnb3QgPSBieXRlcyA/IGBsZW5ndGg9JHtsZW59YCA6IGB0eXBlPSR7dHlwZW9mIHZhbHVlfWA7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCArICdleHBlY3RlZCBVaW50OEFycmF5JyArIG9mTGVuICsgJywgZ290ICcgKyBnb3QpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gVXNlZCBpbiB3ZWllcnN0cmFzcywgZGVyXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW06IG51bWJlciB8IGJpZ2ludCk6IHN0cmluZyB7XG4gIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gIHJldHVybiBoZXgubGVuZ3RoICYgMSA/ICcwJyArIGhleCA6IGhleDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleDogc3RyaW5nKTogYmlnaW50IHtcbiAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gIHJldHVybiBoZXggPT09ICcnID8gXzBuIDogQmlnSW50KCcweCcgKyBoZXgpOyAvLyBCaWcgRW5kaWFuXG59XG5cbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJCRShieXRlczogVWludDhBcnJheSk6IGJpZ2ludCB7XG4gIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4XyhieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlczogVWludDhBcnJheSk6IGJpZ2ludCB7XG4gIGFieXRlc18oYnl0ZXMpO1xuICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleF8oVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuOiBudW1iZXIgfCBiaWdpbnQsIGxlbjogbnVtYmVyKTogVWludDhBcnJheSB7XG4gIHJldHVybiBoZXhUb0J5dGVzXyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzTEUobjogbnVtYmVyIHwgYmlnaW50LCBsZW46IG51bWJlcik6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikucmV2ZXJzZSgpO1xufVxuLy8gVW5wYWRkZWQsIHJhcmVseSB1c2VkXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9WYXJCeXRlc0JFKG46IG51bWJlciB8IGJpZ2ludCk6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gaGV4VG9CeXRlc18obnVtYmVyVG9IZXhVbnBhZGRlZChuKSk7XG59XG5cbi8qKlxuICogVGFrZXMgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjb252ZXJ0cyB0byBVaW50OEFycmF5LlxuICogVmFsaWRhdGVzIG91dHB1dCBsZW5ndGguXG4gKiBXaWxsIHRocm93IGVycm9yIGZvciBvdGhlciB0eXBlcy5cbiAqIEBwYXJhbSB0aXRsZSBkZXNjcmlwdGl2ZSB0aXRsZSBmb3IgYW4gZXJyb3IgZS5nLiAnc2VjcmV0IGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZTogc3RyaW5nLCBoZXg6IEhleCwgZXhwZWN0ZWRMZW5ndGg/OiBudW1iZXIpOiBVaW50OEFycmF5IHtcbiAgbGV0IHJlczogVWludDhBcnJheTtcbiAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IGhleFRvQnl0ZXNfKGhleCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheSwgY2F1c2U6ICcgKyBlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNCeXRlc18oaGV4KSkge1xuICAgIC8vIFVpbnQ4QXJyYXkuZnJvbSgpIGluc3RlYWQgb2YgaGFzaC5zbGljZSgpIGJlY2F1c2Ugbm9kZS5qcyBCdWZmZXJcbiAgICAvLyBpcyBpbnN0YW5jZSBvZiBVaW50OEFycmF5LCBhbmQgaXRzIHNsaWNlKCkgY3JlYXRlcyAqKm11dGFibGUqKiBjb3B5XG4gICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheScpO1xuICB9XG4gIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gIGlmICh0eXBlb2YgZXhwZWN0ZWRMZW5ndGggPT09ICdudW1iZXInICYmIGxlbiAhPT0gZXhwZWN0ZWRMZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBvZiBsZW5ndGggJyArIGV4cGVjdGVkTGVuZ3RoICsgJyBleHBlY3RlZCwgZ290ICcgKyBsZW4pO1xuICByZXR1cm4gcmVzO1xufVxuXG4vLyBDb21wYXJlcyAyIHU4YS1zIGluIGtpbmRhIGNvbnN0YW50IHRpbWVcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGE6IFVpbnQ4QXJyYXksIGI6IFVpbnQ4QXJyYXkpOiBib29sZWFuIHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBsZXQgZGlmZiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykgZGlmZiB8PSBhW2ldIF4gYltpXTtcbiAgcmV0dXJuIGRpZmYgPT09IDA7XG59XG4vKipcbiAqIENvcGllcyBVaW50OEFycmF5LiBXZSBjYW4ndCB1c2UgdThhLnNsaWNlKCksIGJlY2F1c2UgdThhIGNhbiBiZSBCdWZmZXIsXG4gKiBhbmQgQnVmZmVyI3NsaWNlIGNyZWF0ZXMgbXV0YWJsZSBjb3B5LiBOZXZlciB1c2UgQnVmZmVycyFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHlCeXRlcyhieXRlczogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gVWludDhBcnJheS5mcm9tKGJ5dGVzKTtcbn1cblxuLyoqXG4gKiBEZWNvZGVzIDctYml0IEFTQ0lJIHN0cmluZyB0byBVaW50OEFycmF5LCB0aHJvd3Mgb24gbm9uLWFzY2lpIHN5bWJvbHNcbiAqIFNob3VsZCBiZSBzYWZlIHRvIHVzZSBmb3IgdGhpbmdzIGV4cGVjdGVkIHRvIGJlIEFTQ0lJLlxuICogUmV0dXJucyBleGFjdCBzYW1lIHJlc3VsdCBhcyB1dGY4VG9CeXRlcyBmb3IgQVNDSUkgb3IgdGhyb3dzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNjaWlUb0J5dGVzKGFzY2lpOiBzdHJpbmcpOiBVaW50OEFycmF5IHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShhc2NpaSwgKGMsIGkpID0+IHtcbiAgICBjb25zdCBjaGFyQ29kZSA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoYy5sZW5ndGggIT09IDEgfHwgY2hhckNvZGUgPiAxMjcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYHN0cmluZyBjb250YWlucyBub24tQVNDSUkgY2hhcmFjdGVyIFwiJHthc2NpaVtpXX1cIiB3aXRoIGNvZGUgJHtjaGFyQ29kZX0gYXQgcG9zaXRpb24gJHtpfWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjaGFyQ29kZTtcbiAgfSk7XG59XG5cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuLy8gZXhwb3J0IGNvbnN0IHV0ZjhUb0J5dGVzOiB0eXBlb2YgdXRmOFRvQnl0ZXNfID0gdXRmOFRvQnl0ZXNfO1xuLyoqXG4gKiBDb252ZXJ0cyBieXRlcyB0byBzdHJpbmcgdXNpbmcgVVRGOCBlbmNvZGluZy5cbiAqIEBleGFtcGxlIGJ5dGVzVG9VdGY4KFVpbnQ4QXJyYXkuZnJvbShbOTcsIDk4LCA5OV0pKSAvLyAnYWJjJ1xuICovXG4vLyBleHBvcnQgY29uc3QgYnl0ZXNUb1V0Zjg6IHR5cGVvZiBieXRlc1RvVXRmOF8gPSBieXRlc1RvVXRmOF87XG5cbi8vIElzIHBvc2l0aXZlIGJpZ2ludFxuY29uc3QgaXNQb3NCaWcgPSAobjogYmlnaW50KSA9PiB0eXBlb2YgbiA9PT0gJ2JpZ2ludCcgJiYgXzBuIDw9IG47XG5cbmV4cG9ydCBmdW5jdGlvbiBpblJhbmdlKG46IGJpZ2ludCwgbWluOiBiaWdpbnQsIG1heDogYmlnaW50KTogYm9vbGVhbiB7XG4gIHJldHVybiBpc1Bvc0JpZyhuKSAmJiBpc1Bvc0JpZyhtaW4pICYmIGlzUG9zQmlnKG1heCkgJiYgbWluIDw9IG4gJiYgbiA8IG1heDtcbn1cblxuLyoqXG4gKiBBc3NlcnRzIG1pbiA8PSBuIDwgbWF4LiBOT1RFOiBJdCdzIDwgbWF4IGFuZCBub3QgPD0gbWF4LlxuICogQGV4YW1wbGVcbiAqIGFJblJhbmdlKCd4JywgeCwgMW4sIDI1Nm4pOyAvLyB3b3VsZCBhc3N1bWUgeCBpcyBpbiAoMW4uLjI1NW4pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhSW5SYW5nZSh0aXRsZTogc3RyaW5nLCBuOiBiaWdpbnQsIG1pbjogYmlnaW50LCBtYXg6IGJpZ2ludCk6IHZvaWQge1xuICAvLyBXaHkgbWluIDw9IG4gPCBtYXggYW5kIG5vdCBhIChtaW4gPCBuIDwgbWF4KSBPUiBiIChtaW4gPD0gbiA8PSBtYXgpP1xuICAvLyBjb25zaWRlciBQPTI1Nm4sIG1pbj0wbiwgbWF4PVBcbiAgLy8gLSBhIGZvciBtaW49MCB3b3VsZCByZXF1aXJlIC0xOiAgICAgICAgICBgaW5SYW5nZSgneCcsIHgsIC0xbiwgUClgXG4gIC8vIC0gYiB3b3VsZCBjb21tb25seSByZXF1aXJlIHN1YnRyYWN0aW9uOiAgYGluUmFuZ2UoJ3gnLCB4LCAwbiwgUCAtIDFuKWBcbiAgLy8gLSBvdXIgd2F5IGlzIHRoZSBjbGVhbmVzdDogICAgICAgICAgICAgICBgaW5SYW5nZSgneCcsIHgsIDBuLCBQKVxuICBpZiAoIWluUmFuZ2UobiwgbWluLCBtYXgpKVxuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgdmFsaWQgJyArIHRpdGxlICsgJzogJyArIG1pbiArICcgPD0gbiA8ICcgKyBtYXggKyAnLCBnb3QgJyArIG4pO1xufVxuXG4vLyBCaXQgb3BlcmF0aW9uc1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqIFRPRE86IG1lcmdlIHdpdGggbkxlbmd0aCBpbiBtb2R1bGFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRMZW4objogYmlnaW50KTogbnVtYmVyIHtcbiAgbGV0IGxlbjtcbiAgZm9yIChsZW4gPSAwOyBuID4gXzBuOyBuID4+PSBfMW4sIGxlbiArPSAxKTtcbiAgcmV0dXJuIGxlbjtcbn1cblxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0R2V0KG46IGJpZ2ludCwgcG9zOiBudW1iZXIpOiBiaWdpbnQge1xuICByZXR1cm4gKG4gPj4gQmlnSW50KHBvcykpICYgXzFuO1xufVxuXG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdFNldChuOiBiaWdpbnQsIHBvczogbnVtYmVyLCB2YWx1ZTogYm9vbGVhbik6IGJpZ2ludCB7XG4gIHJldHVybiBuIHwgKCh2YWx1ZSA/IF8xbiA6IF8wbikgPDwgQmlnSW50KHBvcykpO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBtYXNrIGZvciBOIGJpdHMuIE5vdCB1c2luZyAqKiBvcGVyYXRvciB3aXRoIGJpZ2ludHMgYmVjYXVzZSBvZiBvbGQgZW5naW5lcy5cbiAqIFNhbWUgYXMgQmlnSW50KGAwYiR7QXJyYXkoaSkuZmlsbCgnMScpLmpvaW4oJycpfWApXG4gKi9cbmV4cG9ydCBjb25zdCBiaXRNYXNrID0gKG46IG51bWJlcik6IGJpZ2ludCA9PiAoXzFuIDw8IEJpZ0ludChuKSkgLSBfMW47XG5cbi8vIERSQkdcblxudHlwZSBQcmVkPFQ+ID0gKHY6IFVpbnQ4QXJyYXkpID0+IFQgfCB1bmRlZmluZWQ7XG4vKipcbiAqIE1pbmltYWwgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgd2lsbCBjYWxsIERSQkcgdW50aWwgMm5kIGFyZyByZXR1cm5zIHNvbWV0aGluZyBtZWFuaW5nZnVsXG4gKiBAZXhhbXBsZVxuICogICBjb25zdCBkcmJnID0gY3JlYXRlSG1hY0RSQkc8S2V5PigzMiwgMzIsIGhtYWMpO1xuICogICBkcmJnKHNlZWQsIGJ5dGVzVG9LZXkpOyAvLyBieXRlc1RvS2V5IG11c3QgcmV0dXJuIEtleSBvciB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhtYWNEcmJnPFQ+KFxuICBoYXNoTGVuOiBudW1iZXIsXG4gIHFCeXRlTGVuOiBudW1iZXIsXG4gIGhtYWNGbjogKGtleTogVWludDhBcnJheSwgLi4ubWVzc2FnZXM6IFVpbnQ4QXJyYXlbXSkgPT4gVWludDhBcnJheVxuKTogKHNlZWQ6IFVpbnQ4QXJyYXksIHByZWRpY2F0ZTogUHJlZDxUPikgPT4gVCB7XG4gIGlmICh0eXBlb2YgaGFzaExlbiAhPT0gJ251bWJlcicgfHwgaGFzaExlbiA8IDIpIHRocm93IG5ldyBFcnJvcignaGFzaExlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIGlmICh0eXBlb2YgcUJ5dGVMZW4gIT09ICdudW1iZXInIHx8IHFCeXRlTGVuIDwgMikgdGhyb3cgbmV3IEVycm9yKCdxQnl0ZUxlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgLy8gU3RlcCBCLCBTdGVwIEM6IHNldCBoYXNoTGVuIHRvIDgqY2VpbChobGVuLzgpXG4gIGNvbnN0IHU4biA9IChsZW46IG51bWJlcikgPT4gbmV3IFVpbnQ4QXJyYXkobGVuKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG4gIGNvbnN0IHU4b2YgPSAoYnl0ZTogbnVtYmVyKSA9PiBVaW50OEFycmF5Lm9mKGJ5dGUpOyAvLyBhbm90aGVyIHNob3J0Y3V0XG4gIGxldCB2ID0gdThuKGhhc2hMZW4pOyAvLyBNaW5pbWFsIG5vbi1mdWxsLXNwZWMgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICBsZXQgaSA9IDA7IC8vIEl0ZXJhdGlvbnMgY291bnRlciwgd2lsbCB0aHJvdyB3aGVuIG92ZXIgMTAwMFxuICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICB2LmZpbGwoMSk7XG4gICAgay5maWxsKDApO1xuICAgIGkgPSAwO1xuICB9O1xuICBjb25zdCBoID0gKC4uLmI6IFVpbnQ4QXJyYXlbXSkgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgY29uc3QgcmVzZWVkID0gKHNlZWQgPSB1OG4oMCkpID0+IHtcbiAgICAvLyBITUFDLURSQkcgcmVzZWVkKCkgZnVuY3Rpb24uIFN0ZXBzIEQtR1xuICAgIGsgPSBoKHU4b2YoMHgwMCksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMCB8fCBzZWVkKVxuICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBrID0gaCh1OG9mKDB4MDEpLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDEgfHwgc2VlZClcbiAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gIH07XG4gIGNvbnN0IGdlbiA9ICgpID0+IHtcbiAgICAvLyBITUFDLURSQkcgZ2VuZXJhdGUoKSBmdW5jdGlvblxuICAgIGlmIChpKysgPj0gMTAwMCkgdGhyb3cgbmV3IEVycm9yKCdkcmJnOiB0cmllZCAxMDAwIHZhbHVlcycpO1xuICAgIGxldCBsZW4gPSAwO1xuICAgIGNvbnN0IG91dDogVWludDhBcnJheVtdID0gW107XG4gICAgd2hpbGUgKGxlbiA8IHFCeXRlTGVuKSB7XG4gICAgICB2ID0gaCgpO1xuICAgICAgY29uc3Qgc2wgPSB2LnNsaWNlKCk7XG4gICAgICBvdXQucHVzaChzbCk7XG4gICAgICBsZW4gKz0gdi5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXRCeXRlc18oLi4ub3V0KTtcbiAgfTtcbiAgY29uc3QgZ2VuVW50aWwgPSAoc2VlZDogVWludDhBcnJheSwgcHJlZDogUHJlZDxUPik6IFQgPT4ge1xuICAgIHJlc2V0KCk7XG4gICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICBsZXQgcmVzOiBUIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICB3aGlsZSAoIShyZXMgPSBwcmVkKGdlbigpKSkpIHJlc2VlZCgpO1xuICAgIHJlc2V0KCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgcmV0dXJuIGdlblVudGlsO1xufVxuXG4vLyBWYWxpZGF0aW5nIGN1cnZlcyBhbmQgZmllbGRzXG5cbmNvbnN0IHZhbGlkYXRvckZucyA9IHtcbiAgYmlnaW50OiAodmFsOiBhbnkpOiBib29sZWFuID0+IHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnLFxuICBmdW5jdGlvbjogKHZhbDogYW55KTogYm9vbGVhbiA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuICBib29sZWFuOiAodmFsOiBhbnkpOiBib29sZWFuID0+IHR5cGVvZiB2YWwgPT09ICdib29sZWFuJyxcbiAgc3RyaW5nOiAodmFsOiBhbnkpOiBib29sZWFuID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnLFxuICBzdHJpbmdPclVpbnQ4QXJyYXk6ICh2YWw6IGFueSk6IGJvb2xlYW4gPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgaXNCeXRlc18odmFsKSxcbiAgaXNTYWZlSW50ZWdlcjogKHZhbDogYW55KTogYm9vbGVhbiA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwpLFxuICBhcnJheTogKHZhbDogYW55KTogYm9vbGVhbiA9PiBBcnJheS5pc0FycmF5KHZhbCksXG4gIGZpZWxkOiAodmFsOiBhbnksIG9iamVjdDogYW55KTogYW55ID0+IChvYmplY3QgYXMgYW55KS5GcC5pc1ZhbGlkKHZhbCksXG4gIGhhc2g6ICh2YWw6IGFueSk6IGJvb2xlYW4gPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn0gYXMgY29uc3Q7XG50eXBlIFZhbGlkYXRvciA9IGtleW9mIHR5cGVvZiB2YWxpZGF0b3JGbnM7XG50eXBlIFZhbE1hcDxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj4gPSB7IFtLIGluIGtleW9mIFRdPzogVmFsaWRhdG9yIH07XG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0PFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+PihcbiAgb2JqZWN0OiBULFxuICB2YWxpZGF0b3JzOiBWYWxNYXA8VD4sXG4gIG9wdFZhbGlkYXRvcnM6IFZhbE1hcDxUPiA9IHt9XG4pOiBUIHtcbiAgY29uc3QgY2hlY2tGaWVsZCA9IChmaWVsZE5hbWU6IGtleW9mIFQsIHR5cGU6IFZhbGlkYXRvciwgaXNPcHRpb25hbDogYm9vbGVhbikgPT4ge1xuICAgIGNvbnN0IGNoZWNrVmFsID0gdmFsaWRhdG9yRm5zW3R5cGVdO1xuICAgIGlmICh0eXBlb2YgY2hlY2tWYWwgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB2YWxpZGF0b3IgZnVuY3Rpb24nKTtcblxuICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWUgYXMga2V5b2YgdHlwZW9mIG9iamVjdF07XG4gICAgaWYgKGlzT3B0aW9uYWwgJiYgdmFsID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICBpZiAoIWNoZWNrVmFsKHZhbCwgb2JqZWN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAncGFyYW0gJyArIFN0cmluZyhmaWVsZE5hbWUpICsgJyBpcyBpbnZhbGlkLiBFeHBlY3RlZCAnICsgdHlwZSArICcsIGdvdCAnICsgdmFsXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSkgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUhLCBmYWxzZSk7XG4gIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0VmFsaWRhdG9ycykpIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlISwgdHJ1ZSk7XG4gIHJldHVybiBvYmplY3Q7XG59XG4vLyB2YWxpZGF0ZSB0eXBlIHRlc3RzXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcbi8vIC8vIFNob3VsZCBmYWlsIHR5cGUtY2hlY2tcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHozID0gdmFsaWRhdGVPYmplY3QobywgeyB0ZXN0OiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0hhc2godmFsOiBDSGFzaCk6IGJvb2xlYW4ge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfdmFsaWRhdGVPYmplY3QoXG4gIG9iamVjdDogUmVjb3JkPHN0cmluZywgYW55PixcbiAgZmllbGRzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICBvcHRGaWVsZHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fVxuKTogdm9pZCB7XG4gIGlmICghb2JqZWN0IHx8IHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnKSB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHZhbGlkIG9wdGlvbnMgb2JqZWN0Jyk7XG4gIHR5cGUgSXRlbSA9IGtleW9mIHR5cGVvZiBvYmplY3Q7XG4gIGZ1bmN0aW9uIGNoZWNrRmllbGQoZmllbGROYW1lOiBJdGVtLCBleHBlY3RlZFR5cGU6IHN0cmluZywgaXNPcHQ6IGJvb2xlYW4pIHtcbiAgICBjb25zdCB2YWwgPSBvYmplY3RbZmllbGROYW1lXTtcbiAgICBpZiAoaXNPcHQgJiYgdmFsID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICBjb25zdCBjdXJyZW50ID0gdHlwZW9mIHZhbDtcbiAgICBpZiAoY3VycmVudCAhPT0gZXhwZWN0ZWRUeXBlIHx8IHZhbCA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyYW0gXCIke2ZpZWxkTmFtZX1cIiBpcyBpbnZhbGlkOiBleHBlY3RlZCAke2V4cGVjdGVkVHlwZX0sIGdvdCAke2N1cnJlbnR9YCk7XG4gIH1cbiAgT2JqZWN0LmVudHJpZXMoZmllbGRzKS5mb3JFYWNoKChbaywgdl0pID0+IGNoZWNrRmllbGQoaywgdiwgZmFsc2UpKTtcbiAgT2JqZWN0LmVudHJpZXMob3B0RmllbGRzKS5mb3JFYWNoKChbaywgdl0pID0+IGNoZWNrRmllbGQoaywgdiwgdHJ1ZSkpO1xufVxuXG4vKipcbiAqIHRocm93cyBub3QgaW1wbGVtZW50ZWQgZXJyb3JcbiAqL1xuZXhwb3J0IGNvbnN0IG5vdEltcGxlbWVudGVkID0gKCk6IG5ldmVyID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbi8qKlxuICogTWVtb2l6ZXMgKGNhY2hlcykgY29tcHV0YXRpb24gcmVzdWx0LlxuICogVXNlcyBXZWFrTWFwOiB0aGUgdmFsdWUgaXMgZ29pbmcgYXV0by1jbGVhbmVkIGJ5IEdDIGFmdGVyIGxhc3QgcmVmZXJlbmNlIGlzIHJlbW92ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZW1vaXplZDxUIGV4dGVuZHMgb2JqZWN0LCBSLCBPIGV4dGVuZHMgYW55W10+KFxuICBmbjogKGFyZzogVCwgLi4uYXJnczogTykgPT4gUlxuKTogKGFyZzogVCwgLi4uYXJnczogTykgPT4gUiB7XG4gIGNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwPFQsIFI+KCk7XG4gIHJldHVybiAoYXJnOiBULCAuLi5hcmdzOiBPKTogUiA9PiB7XG4gICAgY29uc3QgdmFsID0gbWFwLmdldChhcmcpO1xuICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHZhbDtcbiAgICBjb25zdCBjb21wdXRlZCA9IGZuKGFyZywgLi4uYXJncyk7XG4gICAgbWFwLnNldChhcmcsIGNvbXB1dGVkKTtcbiAgICByZXR1cm4gY29tcHV0ZWQ7XG4gIH07XG59XG4iLCAiLyoqXG4gKiBVdGlscyBmb3IgbW9kdWxhciBkaXZpc2lvbiBhbmQgZmllbGRzLlxuICogRmllbGQgb3ZlciAxMSBpcyBhIGZpbml0ZSAoR2Fsb2lzKSBmaWVsZCBpcyBpbnRlZ2VyIG51bWJlciBvcGVyYXRpb25zIGBtb2QgMTFgLlxuICogVGhlcmUgaXMgbm8gZGl2aXNpb246IGl0IGlzIHJlcGxhY2VkIGJ5IG1vZHVsYXIgbXVsdGlwbGljYXRpdmUgaW52ZXJzZS5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHtcbiAgX3ZhbGlkYXRlT2JqZWN0LFxuICBhbnVtYmVyLFxuICBiaXRNYXNrLFxuICBieXRlc1RvTnVtYmVyQkUsXG4gIGJ5dGVzVG9OdW1iZXJMRSxcbiAgZW5zdXJlQnl0ZXMsXG4gIG51bWJlclRvQnl0ZXNCRSxcbiAgbnVtYmVyVG9CeXRlc0xFLFxufSBmcm9tICcuLi91dGlscy50cyc7XG5cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiksIF8zbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF80biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNCksIF81biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNSksIF83biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF84biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoOCksIF85biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoOSksIF8xNm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDE2KTtcblxuLy8gQ2FsY3VsYXRlcyBhIG1vZHVsbyBiXG5leHBvcnQgZnVuY3Rpb24gbW9kKGE6IGJpZ2ludCwgYjogYmlnaW50KTogYmlnaW50IHtcbiAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgcmFpc2UgbnVtIHRvIHBvd2VyIGFuZCBkbyBtb2R1bGFyIGRpdmlzaW9uLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICogQGV4YW1wbGVcbiAqIHBvdygybiwgNm4sIDExbikgLy8gNjRuICUgMTFuID09IDluXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb3cobnVtOiBiaWdpbnQsIHBvd2VyOiBiaWdpbnQsIG1vZHVsbzogYmlnaW50KTogYmlnaW50IHtcbiAgcmV0dXJuIEZwUG93KEZpZWxkKG1vZHVsbyksIG51bSwgcG93ZXIpO1xufVxuXG4vKiogRG9lcyBgeF4oMl5wb3dlcilgIG1vZCBwLiBgcG93MigzMCwgNClgID09IGAzMF4oMl40KWAgKi9cbmV4cG9ydCBmdW5jdGlvbiBwb3cyKHg6IGJpZ2ludCwgcG93ZXI6IGJpZ2ludCwgbW9kdWxvOiBiaWdpbnQpOiBiaWdpbnQge1xuICBsZXQgcmVzID0geDtcbiAgd2hpbGUgKHBvd2VyLS0gPiBfMG4pIHtcbiAgICByZXMgKj0gcmVzO1xuICAgIHJlcyAlPSBtb2R1bG87XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBJbnZlcnNlcyBudW1iZXIgb3ZlciBtb2R1bG8uXG4gKiBJbXBsZW1lbnRlZCB1c2luZyBbRXVjbGlkZWFuIEdDRF0oaHR0cHM6Ly9icmlsbGlhbnQub3JnL3dpa2kvZXh0ZW5kZWQtZXVjbGlkZWFuLWFsZ29yaXRobS8pLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG51bWJlcjogYmlnaW50LCBtb2R1bG86IGJpZ2ludCk6IGJpZ2ludCB7XG4gIGlmIChudW1iZXIgPT09IF8wbikgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGV4cGVjdGVkIG5vbi16ZXJvIG51bWJlcicpO1xuICBpZiAobW9kdWxvIDw9IF8wbikgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIG1vZHVsdXMsIGdvdCAnICsgbW9kdWxvKTtcbiAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXG4gIGxldCBhID0gbW9kKG51bWJlciwgbW9kdWxvKTtcbiAgbGV0IGIgPSBtb2R1bG87XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBsZXQgeCA9IF8wbiwgeSA9IF8xbiwgdSA9IF8xbiwgdiA9IF8wbjtcbiAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgIC8vIEpJVCBhcHBsaWVzIG9wdGltaXphdGlvbiBpZiB0aG9zZSB0d28gbGluZXMgZm9sbG93IGVhY2ggb3RoZXJcbiAgICBjb25zdCBxID0gYiAvIGE7XG4gICAgY29uc3QgciA9IGIgJSBhO1xuICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgY29uc3QgbiA9IHkgLSB2ICogcTtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBiID0gYSwgYSA9IHIsIHggPSB1LCB5ID0gdiwgdSA9IG0sIHYgPSBuO1xuICB9XG4gIGNvbnN0IGdjZCA9IGI7XG4gIGlmIChnY2QgIT09IF8xbikgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGRvZXMgbm90IGV4aXN0Jyk7XG4gIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SXNTcXVhcmU8VD4oRnA6IElGaWVsZDxUPiwgcm9vdDogVCwgbjogVCk6IHZvaWQge1xuICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG59XG5cbi8vIE5vdCBhbGwgcm9vdHMgYXJlIHBvc3NpYmxlISBFeGFtcGxlIHdoaWNoIHdpbGwgdGhyb3c6XG4vLyBjb25zdCBOVU0gPVxuLy8gbiA9IDcyMDU3NTk0MDM3OTI3ODE2bjtcbi8vIEZwID0gRmllbGQoQmlnSW50KCcweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYicpKTtcbmZ1bmN0aW9uIHNxcnQzbW9kNDxUPihGcDogSUZpZWxkPFQ+LCBuOiBUKSB7XG4gIGNvbnN0IHAxZGl2NCA9IChGcC5PUkRFUiArIF8xbikgLyBfNG47XG4gIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgYXNzZXJ0SXNTcXVhcmUoRnAsIHJvb3QsIG4pO1xuICByZXR1cm4gcm9vdDtcbn1cblxuZnVuY3Rpb24gc3FydDVtb2Q4PFQ+KEZwOiBJRmllbGQ8VD4sIG46IFQpIHtcbiAgY29uc3QgcDVkaXY4ID0gKEZwLk9SREVSIC0gXzVuKSAvIF84bjtcbiAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuKTtcbiAgY29uc3QgdiA9IEZwLnBvdyhuMiwgcDVkaXY4KTtcbiAgY29uc3QgbnYgPSBGcC5tdWwobiwgdik7XG4gIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4pLCB2KTtcbiAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xuICBhc3NlcnRJc1NxdWFyZShGcCwgcm9vdCwgbik7XG4gIHJldHVybiByb290O1xufVxuXG4vLyBCYXNlZCBvbiBSRkM5MzgwLCBLb25nIGFsZ29yaXRobVxuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBzcXJ0OW1vZDE2KFA6IGJpZ2ludCk6IDxUPihGcDogSUZpZWxkPFQ+LCBuOiBUKSA9PiBUIHtcbiAgY29uc3QgRnBfID0gRmllbGQoUCk7XG4gIGNvbnN0IHRuID0gdG9uZWxsaVNoYW5rcyhQKTtcbiAgY29uc3QgYzEgPSB0bihGcF8sIEZwXy5uZWcoRnBfLk9ORSkpOy8vICAxLiBjMSA9IHNxcnQoLTEpIGluIEYsIGkuZS4sIChjMV4yKSA9PSAtMSBpbiBGXG4gIGNvbnN0IGMyID0gdG4oRnBfLCBjMSk7ICAgICAgICAgICAgICAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuICBjb25zdCBjMyA9IHRuKEZwXywgRnBfLm5lZyhjMSkpOyAgICAgLy8gIDMuIGMzID0gc3FydCgtYzEpIGluIEYsIGkuZS4sIChjM14yKSA9PSAtYzEgaW4gRlxuICBjb25zdCBjNCA9IChQICsgXzduKSAvIF8xNm47ICAgICAgICAgLy8gIDQuIGM0ID0gKHEgKyA3KSAvIDE2ICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICByZXR1cm4gPFQ+KEZwOiBJRmllbGQ8VD4sIG46IFQpID0+IHtcbiAgICBsZXQgdHYxID0gRnAucG93KG4sIGM0KTsgICAgICAgICAgIC8vICAxLiB0djEgPSB4XmM0XG4gICAgbGV0IHR2MiA9IEZwLm11bCh0djEsIGMxKTsgICAgICAgICAvLyAgMi4gdHYyID0gYzEgKiB0djFcbiAgICBjb25zdCB0djMgPSBGcC5tdWwodHYxLCBjMik7ICAgICAgIC8vICAzLiB0djMgPSBjMiAqIHR2MVxuICAgIGNvbnN0IHR2NCA9IEZwLm11bCh0djEsIGMzKTsgICAgICAgLy8gIDQuIHR2NCA9IGMzICogdHYxXG4gICAgY29uc3QgZTEgPSBGcC5lcWwoRnAuc3FyKHR2MiksIG4pOyAvLyAgNS4gIGUxID0gKHR2Ml4yKSA9PSB4XG4gICAgY29uc3QgZTIgPSBGcC5lcWwoRnAuc3FyKHR2MyksIG4pOyAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4gICAgdHYxID0gRnAuY21vdih0djEsIHR2MiwgZTEpOyAgICAgICAvLyAgNy4gdHYxID0gQ01PVih0djEsIHR2MiwgZTEpICAjIFNlbGVjdCB0djIgaWYgKHR2Ml4yKSA9PSB4XG4gICAgdHYyID0gRnAuY21vdih0djQsIHR2MywgZTIpOyAgICAgICAvLyAgOC4gdHYyID0gQ01PVih0djQsIHR2MywgZTIpICAjIFNlbGVjdCB0djMgaWYgKHR2M14yKSA9PSB4XG4gICAgY29uc3QgZTMgPSBGcC5lcWwoRnAuc3FyKHR2MiksIG4pOyAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4gICAgY29uc3Qgcm9vdCA9IEZwLmNtb3YodHYxLCB0djIsIGUzKTsvLyAxMC4gIHogPSBDTU9WKHR2MSwgdHYyLCBlMykgICAjIFNlbGVjdCBzcXJ0IGZyb20gdHYxICYgdHYyXG4gICAgYXNzZXJ0SXNTcXVhcmUoRnAsIHJvb3QsIG4pO1xuICAgIHJldHVybiByb290O1xuICB9O1xufVxuXG4vKipcbiAqIFRvbmVsbGktU2hhbmtzIHNxdWFyZSByb290IHNlYXJjaCBhbGdvcml0aG0uXG4gKiAxLiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTIpXG4gKiAyLiBTcXVhcmUgUm9vdHMgZnJvbSAxOyAyNCwgNTEsIDEwIHRvIERhbiBTaGFua3NcbiAqIEBwYXJhbSBQIGZpZWxkIG9yZGVyXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHRha2VzIGZpZWxkIEZwIChjcmVhdGVkIGZyb20gUCkgYW5kIG51bWJlciBuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b25lbGxpU2hhbmtzKFA6IGJpZ2ludCk6IDxUPihGcDogSUZpZWxkPFQ+LCBuOiBUKSA9PiBUIHtcbiAgLy8gSW5pdGlhbGl6YXRpb24gKHByZWNvbXB1dGF0aW9uKS5cbiAgLy8gQ2FjaGluZyBpbml0aWFsaXphdGlvbiBjb3VsZCBib29zdCBwZXJmIGJ5IDclLlxuICBpZiAoUCA8IF8zbikgdGhyb3cgbmV3IEVycm9yKCdzcXJ0IGlzIG5vdCBkZWZpbmVkIGZvciBzbWFsbCBmaWVsZCcpO1xuICAvLyBGYWN0b3IgUCAtIDEgPSBRICogMl5TLCB3aGVyZSBRIGlzIG9kZFxuICBsZXQgUSA9IFAgLSBfMW47XG4gIGxldCBTID0gMDtcbiAgd2hpbGUgKFEgJSBfMm4gPT09IF8wbikge1xuICAgIFEgLz0gXzJuO1xuICAgIFMrKztcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGZpcnN0IHF1YWRyYXRpYyBub24tcmVzaWR1ZSBaID49IDJcbiAgbGV0IFogPSBfMm47XG4gIGNvbnN0IF9GcCA9IEZpZWxkKFApO1xuICB3aGlsZSAoRnBMZWdlbmRyZShfRnAsIFopID09PSAxKSB7XG4gICAgLy8gQmFzaWMgcHJpbWFsaXR5IHRlc3QgZm9yIFAuIEFmdGVyIHggaXRlcmF0aW9ucywgY2hhbmNlIG9mXG4gICAgLy8gbm90IGZpbmRpbmcgcXVhZHJhdGljIG5vbi1yZXNpZHVlIGlzIDJeeCwgc28gMl4xMDAwLlxuICAgIGlmIChaKysgPiAxMDAwKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290OiBwcm9iYWJseSBub24tcHJpbWUgUCcpO1xuICB9XG4gIC8vIEZhc3QtcGF0aDsgdXN1YWxseSBkb25lIGJlZm9yZSBaLCBidXQgd2UgZG8gXCJwcmltYWxpdHkgdGVzdFwiLlxuICBpZiAoUyA9PT0gMSkgcmV0dXJuIHNxcnQzbW9kNDtcblxuICAvLyBTbG93LXBhdGhcbiAgLy8gVE9ETzogdGVzdCBvbiBGcDIgYW5kIG90aGVyc1xuICBsZXQgY2MgPSBfRnAucG93KFosIFEpOyAvLyBjID0gel5RXG4gIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlTbG93PFQ+KEZwOiBJRmllbGQ8VD4sIG46IFQpOiBUIHtcbiAgICBpZiAoRnAuaXMwKG4pKSByZXR1cm4gbjtcbiAgICAvLyBDaGVjayBpZiBuIGlzIGEgcXVhZHJhdGljIHJlc2lkdWUgdXNpbmcgTGVnZW5kcmUgc3ltYm9sXG4gICAgaWYgKEZwTGVnZW5kcmUoRnAsIG4pICE9PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG5cbiAgICAvLyBJbml0aWFsaXplIHZhcmlhYmxlcyBmb3IgdGhlIG1haW4gbG9vcFxuICAgIGxldCBNID0gUztcbiAgICBsZXQgYyA9IEZwLm11bChGcC5PTkUsIGNjKTsgLy8gYyA9IHpeUSwgbW92ZSBjYyBmcm9tIGZpZWxkIF9GcCBpbnRvIGZpZWxkIEZwXG4gICAgbGV0IHQgPSBGcC5wb3cobiwgUSk7IC8vIHQgPSBuXlEsIGZpcnN0IGd1ZXNzIGF0IHRoZSBmdWRnZSBmYWN0b3JcbiAgICBsZXQgUiA9IEZwLnBvdyhuLCBRMWRpdjIpOyAvLyBSID0gbl4oKFErMSkvMiksIGZpcnN0IGd1ZXNzIGF0IHRoZSBzcXVhcmUgcm9vdFxuXG4gICAgLy8gTWFpbiBsb29wXG4gICAgLy8gd2hpbGUgdCAhPSAxXG4gICAgd2hpbGUgKCFGcC5lcWwodCwgRnAuT05FKSkge1xuICAgICAgaWYgKEZwLmlzMCh0KSkgcmV0dXJuIEZwLlpFUk87IC8vIGlmIHQ9MCByZXR1cm4gUj0wXG4gICAgICBsZXQgaSA9IDE7XG5cbiAgICAgIC8vIEZpbmQgdGhlIHNtYWxsZXN0IGkgPj0gMSBzdWNoIHRoYXQgdF4oMl5pKSBcdTIyNjEgMSAobW9kIFApXG4gICAgICBsZXQgdF90bXAgPSBGcC5zcXIodCk7IC8vIHReKDJeMSlcbiAgICAgIHdoaWxlICghRnAuZXFsKHRfdG1wLCBGcC5PTkUpKSB7XG4gICAgICAgIGkrKztcbiAgICAgICAgdF90bXAgPSBGcC5zcXIodF90bXApOyAvLyB0XigyXjIpLi4uXG4gICAgICAgIGlmIChpID09PSBNKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZXhwb25lbnQgZm9yIGI6IDJeKE0gLSBpIC0gMSlcbiAgICAgIGNvbnN0IGV4cG9uZW50ID0gXzFuIDw8IEJpZ0ludChNIC0gaSAtIDEpOyAvLyBiaWdpbnQgaXMgaW1wb3J0YW50XG4gICAgICBjb25zdCBiID0gRnAucG93KGMsIGV4cG9uZW50KTsgLy8gYiA9IDJeKE0gLSBpIC0gMSlcblxuICAgICAgLy8gVXBkYXRlIHZhcmlhYmxlc1xuICAgICAgTSA9IGk7XG4gICAgICBjID0gRnAuc3FyKGIpOyAvLyBjID0gYl4yXG4gICAgICB0ID0gRnAubXVsKHQsIGMpOyAvLyB0ID0gKHQgKiBiXjIpXG4gICAgICBSID0gRnAubXVsKFIsIGIpOyAvLyBSID0gUipiXG4gICAgfVxuICAgIHJldHVybiBSO1xuICB9O1xufVxuXG4vKipcbiAqIFNxdWFyZSByb290IGZvciBhIGZpbml0ZSBmaWVsZC4gV2lsbCB0cnkgb3B0aW1pemVkIHZlcnNpb25zIGZpcnN0OlxuICpcbiAqIDEuIFAgXHUyMjYxIDMgKG1vZCA0KVxuICogMi4gUCBcdTIyNjEgNSAobW9kIDgpXG4gKiAzLiBQIFx1MjI2MSA5IChtb2QgMTYpXG4gKiA0LiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAqXG4gKiBEaWZmZXJlbnQgYWxnb3JpdGhtcyBjYW4gZ2l2ZSBkaWZmZXJlbnQgcm9vdHMsIGl0IGlzIHVwIHRvIHVzZXIgdG8gZGVjaWRlIHdoaWNoIG9uZSB0aGV5IHdhbnQuXG4gKiBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydChQOiBiaWdpbnQpOiA8VD4oRnA6IElGaWVsZDxUPiwgbjogVCkgPT4gVCB7XG4gIC8vIFAgXHUyMjYxIDMgKG1vZCA0KSA9PiBcdTIyMUFuID0gbl4oKFArMSkvNClcbiAgaWYgKFAgJSBfNG4gPT09IF8zbikgcmV0dXJuIHNxcnQzbW9kNDtcbiAgLy8gUCBcdTIyNjEgNSAobW9kIDgpID0+IEF0a2luIGFsZ29yaXRobSwgcGFnZSAxMCBvZiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGZcbiAgaWYgKFAgJSBfOG4gPT09IF81bikgcmV0dXJuIHNxcnQ1bW9kODtcbiAgLy8gUCBcdTIyNjEgOSAobW9kIDE2KSA9PiBLb25nIGFsZ29yaXRobSwgcGFnZSAxMSBvZiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKGFsZ29yaXRobSA0KVxuICBpZiAoUCAlIF8xNm4gPT09IF85bikgcmV0dXJuIHNxcnQ5bW9kMTYoUCk7XG4gIC8vIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICByZXR1cm4gdG9uZWxsaVNoYW5rcyhQKTtcbn1cblxuLy8gTGl0dGxlLWVuZGlhbiBjaGVjayBmb3IgZmlyc3QgTEUgYml0IChsYXN0IEJFIGJpdCk7XG5leHBvcnQgY29uc3QgaXNOZWdhdGl2ZUxFID0gKG51bTogYmlnaW50LCBtb2R1bG86IGJpZ2ludCk6IGJvb2xlYW4gPT5cbiAgKG1vZChudW0sIG1vZHVsbykgJiBfMW4pID09PSBfMW47XG5cbi8qKiBGaWVsZCBpcyBub3QgYWx3YXlzIG92ZXIgcHJpbWU6IGZvciBleGFtcGxlLCBGcDIgaGFzIE9SREVSKHEpPXBebS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUZpZWxkPFQ+IHtcbiAgT1JERVI6IGJpZ2ludDtcbiAgaXNMRTogYm9vbGVhbjtcbiAgQllURVM6IG51bWJlcjtcbiAgQklUUzogbnVtYmVyO1xuICBNQVNLOiBiaWdpbnQ7XG4gIFpFUk86IFQ7XG4gIE9ORTogVDtcbiAgLy8gMS1hcmdcbiAgY3JlYXRlOiAobnVtOiBUKSA9PiBUO1xuICBpc1ZhbGlkOiAobnVtOiBUKSA9PiBib29sZWFuO1xuICBpczA6IChudW06IFQpID0+IGJvb2xlYW47XG4gIGlzVmFsaWROb3QwOiAobnVtOiBUKSA9PiBib29sZWFuO1xuICBuZWcobnVtOiBUKTogVDtcbiAgaW52KG51bTogVCk6IFQ7XG4gIHNxcnQobnVtOiBUKTogVDtcbiAgc3FyKG51bTogVCk6IFQ7XG4gIC8vIDItYXJnc1xuICBlcWwobGhzOiBULCByaHM6IFQpOiBib29sZWFuO1xuICBhZGQobGhzOiBULCByaHM6IFQpOiBUO1xuICBzdWIobGhzOiBULCByaHM6IFQpOiBUO1xuICBtdWwobGhzOiBULCByaHM6IFQgfCBiaWdpbnQpOiBUO1xuICBwb3cobGhzOiBULCBwb3dlcjogYmlnaW50KTogVDtcbiAgZGl2KGxoczogVCwgcmhzOiBUIHwgYmlnaW50KTogVDtcbiAgLy8gTiBmb3IgTm9uTm9ybWFsaXplZCAoZm9yIG5vdylcbiAgYWRkTihsaHM6IFQsIHJoczogVCk6IFQ7XG4gIHN1Yk4obGhzOiBULCByaHM6IFQpOiBUO1xuICBtdWxOKGxoczogVCwgcmhzOiBUIHwgYmlnaW50KTogVDtcbiAgc3FyTihudW06IFQpOiBUO1xuXG4gIC8vIE9wdGlvbmFsXG4gIC8vIFNob3VsZCBiZSBzYW1lIGFzIHNnbjAgZnVuY3Rpb24gaW5cbiAgLy8gW1JGQzkzODBdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNC4xKS5cbiAgLy8gTk9URTogc2duMCBpcyAnbmVnYXRpdmUgaW4gTEUnLCB3aGljaCBpcyBzYW1lIGFzIG9kZC4gQW5kIG5lZ2F0aXZlIGluIExFIGlzIGtpbmRhIHN0cmFuZ2UgZGVmaW5pdGlvbiBhbnl3YXkuXG4gIGlzT2RkPyhudW06IFQpOiBib29sZWFuOyAvLyBPZGQgaW5zdGVhZCBvZiBldmVuIHNpbmNlIHdlIGhhdmUgaXQgZm9yIEZwMlxuICBhbGxvd2VkTGVuZ3Rocz86IG51bWJlcltdO1xuICAvLyBsZWdlbmRyZT8obnVtOiBUKTogVDtcbiAgaW52ZXJ0QmF0Y2g6IChsc3Q6IFRbXSkgPT4gVFtdO1xuICB0b0J5dGVzKG51bTogVCk6IFVpbnQ4QXJyYXk7XG4gIGZyb21CeXRlcyhieXRlczogVWludDhBcnJheSwgc2tpcFZhbGlkYXRpb24/OiBib29sZWFuKTogVDtcbiAgLy8gSWYgYyBpcyBGYWxzZSwgQ01PViByZXR1cm5zIGEsIG90aGVyd2lzZSBpdCByZXR1cm5zIGIuXG4gIGNtb3YoYTogVCwgYjogVCwgYzogYm9vbGVhbik6IFQ7XG59XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEZJRUxEX0ZJRUxEUyA9IFtcbiAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgJ2VxbCcsICdhZGQnLCAnc3ViJywgJ211bCcsICdwb3cnLCAnZGl2JyxcbiAgJ2FkZE4nLCAnc3ViTicsICdtdWxOJywgJ3Nxck4nXG5dIGFzIGNvbnN0O1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRmllbGQ8VD4oZmllbGQ6IElGaWVsZDxUPik6IElGaWVsZDxUPiB7XG4gIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgT1JERVI6ICdiaWdpbnQnLFxuICAgIE1BU0s6ICdiaWdpbnQnLFxuICAgIEJZVEVTOiAnbnVtYmVyJyxcbiAgICBCSVRTOiAnbnVtYmVyJyxcbiAgfSBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICBjb25zdCBvcHRzID0gRklFTERfRklFTERTLnJlZHVjZSgobWFwLCB2YWw6IHN0cmluZykgPT4ge1xuICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICByZXR1cm4gbWFwO1xuICB9LCBpbml0aWFsKTtcbiAgX3ZhbGlkYXRlT2JqZWN0KGZpZWxkLCBvcHRzKTtcbiAgLy8gY29uc3QgbWF4ID0gMTYzODQ7XG4gIC8vIGlmIChmaWVsZC5CWVRFUyA8IDEgfHwgZmllbGQuQllURVMgPiBtYXgpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZCcpO1xuICAvLyBpZiAoZmllbGQuQklUUyA8IDEgfHwgZmllbGQuQklUUyA+IDggKiBtYXgpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZCcpO1xuICByZXR1cm4gZmllbGQ7XG59XG5cbi8vIEdlbmVyaWMgZmllbGQgZnVuY3Rpb25zXG5cbi8qKlxuICogU2FtZSBhcyBgcG93YCBidXQgZm9yIEZwOiBub24tY29uc3RhbnQtdGltZS5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwUG93PFQ+KEZwOiBJRmllbGQ8VD4sIG51bTogVCwgcG93ZXI6IGJpZ2ludCk6IFQge1xuICBpZiAocG93ZXIgPCBfMG4pIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBleHBvbmVudCwgbmVnYXRpdmVzIHVuc3VwcG9ydGVkJyk7XG4gIGlmIChwb3dlciA9PT0gXzBuKSByZXR1cm4gRnAuT05FO1xuICBpZiAocG93ZXIgPT09IF8xbikgcmV0dXJuIG51bTtcbiAgbGV0IHAgPSBGcC5PTkU7XG4gIGxldCBkID0gbnVtO1xuICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICBpZiAocG93ZXIgJiBfMW4pIHAgPSBGcC5tdWwocCwgZCk7XG4gICAgZCA9IEZwLnNxcihkKTtcbiAgICBwb3dlciA+Pj0gXzFuO1xuICB9XG4gIHJldHVybiBwO1xufVxuXG4vKipcbiAqIEVmZmljaWVudGx5IGludmVydCBhbiBhcnJheSBvZiBGaWVsZCBlbGVtZW50cy5cbiAqIEV4Y2VwdGlvbi1mcmVlLiBXaWxsIHJldHVybiBgdW5kZWZpbmVkYCBmb3IgMCBlbGVtZW50cy5cbiAqIEBwYXJhbSBwYXNzWmVybyBtYXAgMCB0byAwIChpbnN0ZWFkIG9mIHVuZGVmaW5lZClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2g8VD4oRnA6IElGaWVsZDxUPiwgbnVtczogVFtdLCBwYXNzWmVybyA9IGZhbHNlKTogVFtdIHtcbiAgY29uc3QgaW52ZXJ0ZWQgPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpLmZpbGwocGFzc1plcm8gPyBGcC5aRVJPIDogdW5kZWZpbmVkKTtcbiAgLy8gV2FsayBmcm9tIGZpcnN0IHRvIGxhc3QsIG11bHRpcGx5IHRoZW0gYnkgZWFjaCBvdGhlciBNT0QgcFxuICBjb25zdCBtdWx0aXBsaWVkQWNjID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgaWYgKEZwLmlzMChudW0pKSByZXR1cm4gYWNjO1xuICAgIGludmVydGVkW2ldID0gYWNjO1xuICAgIHJldHVybiBGcC5tdWwoYWNjLCBudW0pO1xuICB9LCBGcC5PTkUpO1xuICAvLyBJbnZlcnQgbGFzdCBlbGVtZW50XG4gIGNvbnN0IGludmVydGVkQWNjID0gRnAuaW52KG11bHRpcGxpZWRBY2MpO1xuICAvLyBXYWxrIGZyb20gbGFzdCB0byBmaXJzdCwgbXVsdGlwbHkgdGhlbSBieSBpbnZlcnRlZCBlYWNoIG90aGVyIE1PRCBwXG4gIG51bXMucmVkdWNlUmlnaHQoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgaWYgKEZwLmlzMChudW0pKSByZXR1cm4gYWNjO1xuICAgIGludmVydGVkW2ldID0gRnAubXVsKGFjYywgaW52ZXJ0ZWRbaV0pO1xuICAgIHJldHVybiBGcC5tdWwoYWNjLCBudW0pO1xuICB9LCBpbnZlcnRlZEFjYyk7XG4gIHJldHVybiBpbnZlcnRlZDtcbn1cblxuLy8gVE9ETzogcmVtb3ZlXG5leHBvcnQgZnVuY3Rpb24gRnBEaXY8VD4oRnA6IElGaWVsZDxUPiwgbGhzOiBULCByaHM6IFQgfCBiaWdpbnQpOiBUIHtcbiAgcmV0dXJuIEZwLm11bChsaHMsIHR5cGVvZiByaHMgPT09ICdiaWdpbnQnID8gaW52ZXJ0KHJocywgRnAuT1JERVIpIDogRnAuaW52KHJocykpO1xufVxuXG4vKipcbiAqIExlZ2VuZHJlIHN5bWJvbC5cbiAqIExlZ2VuZHJlIGNvbnN0YW50IGlzIHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApXG4gKiB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICpcbiAqICogKGEgfCBwKSBcdTIyNjEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcCksIHF1YWRyYXRpYyByZXNpZHVlXG4gKiAqIChhIHwgcCkgXHUyMjYxIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKSwgcXVhZHJhdGljIG5vbiByZXNpZHVlXG4gKiAqIChhIHwgcCkgXHUyMjYxIDAgICAgaWYgYSBcdTIyNjEgMCAobW9kIHApXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcExlZ2VuZHJlPFQ+KEZwOiBJRmllbGQ8VD4sIG46IFQpOiAtMSB8IDAgfCAxIHtcbiAgLy8gV2UgY2FuIHVzZSAzcmQgYXJndW1lbnQgYXMgb3B0aW9uYWwgY2FjaGUgb2YgdGhpcyB2YWx1ZVxuICAvLyBidXQgc2VlbXMgdW5uZWVkZWQgZm9yIG5vdy4gVGhlIG9wZXJhdGlvbiBpcyB2ZXJ5IGZhc3QuXG4gIGNvbnN0IHAxbW9kMiA9IChGcC5PUkRFUiAtIF8xbikgLyBfMm47XG4gIGNvbnN0IHBvd2VyZWQgPSBGcC5wb3cobiwgcDFtb2QyKTtcbiAgY29uc3QgeWVzID0gRnAuZXFsKHBvd2VyZWQsIEZwLk9ORSk7XG4gIGNvbnN0IHplcm8gPSBGcC5lcWwocG93ZXJlZCwgRnAuWkVSTyk7XG4gIGNvbnN0IG5vID0gRnAuZXFsKHBvd2VyZWQsIEZwLm5lZyhGcC5PTkUpKTtcbiAgaWYgKCF5ZXMgJiYgIXplcm8gJiYgIW5vKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgTGVnZW5kcmUgc3ltYm9sIHJlc3VsdCcpO1xuICByZXR1cm4geWVzID8gMSA6IHplcm8gPyAwIDogLTE7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBUcnVlIHdoZW5ldmVyIHRoZSB2YWx1ZSB4IGlzIGEgc3F1YXJlIGluIHRoZSBmaWVsZCBGLlxuZXhwb3J0IGZ1bmN0aW9uIEZwSXNTcXVhcmU8VD4oRnA6IElGaWVsZDxUPiwgbjogVCk6IGJvb2xlYW4ge1xuICBjb25zdCBsID0gRnBMZWdlbmRyZShGcCwgbik7XG4gIHJldHVybiBsID09PSAxO1xufVxuXG5leHBvcnQgdHlwZSBOTGVuZ3RoID0geyBuQnl0ZUxlbmd0aDogbnVtYmVyOyBuQml0TGVuZ3RoOiBudW1iZXIgfTtcbi8vIENVUlZFLm4gbGVuZ3Roc1xuZXhwb3J0IGZ1bmN0aW9uIG5MZW5ndGgobjogYmlnaW50LCBuQml0TGVuZ3RoPzogbnVtYmVyKTogTkxlbmd0aCB7XG4gIC8vIEJpdCBzaXplLCBieXRlIHNpemUgb2YgQ1VSVkUublxuICBpZiAobkJpdExlbmd0aCAhPT0gdW5kZWZpbmVkKSBhbnVtYmVyKG5CaXRMZW5ndGgpO1xuICBjb25zdCBfbkJpdExlbmd0aCA9IG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5CaXRMZW5ndGggOiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcbiAgcmV0dXJuIHsgbkJpdExlbmd0aDogX25CaXRMZW5ndGgsIG5CeXRlTGVuZ3RoIH07XG59XG5cbnR5cGUgRnBGaWVsZCA9IElGaWVsZDxiaWdpbnQ+ICYgUmVxdWlyZWQ8UGljazxJRmllbGQ8YmlnaW50PiwgJ2lzT2RkJz4+O1xudHlwZSBTcXJ0Rm4gPSAobjogYmlnaW50KSA9PiBiaWdpbnQ7XG50eXBlIEZpZWxkT3B0cyA9IFBhcnRpYWw8e1xuICBzcXJ0OiBTcXJ0Rm47XG4gIGlzTEU6IGJvb2xlYW47XG4gIEJJVFM6IG51bWJlcjtcbiAgbW9kRnJvbUJ5dGVzOiBib29sZWFuOyAvLyBibHMxMi0zODEgcmVxdWlyZXMgbW9kKG4pIGluc3RlYWQgb2YgcmVqZWN0aW5nIGtleXMgPj0gblxuICBhbGxvd2VkTGVuZ3Rocz86IHJlYWRvbmx5IG51bWJlcltdOyAvLyBmb3IgUDUyMSAoYWRkcyBwYWRkaW5nIGZvciBzbWFsbGVyIHNpemVzKVxufT47XG4vKipcbiAqIENyZWF0ZXMgYSBmaW5pdGUgZmllbGQuIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIDEuIERlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bC5cbiAqICogMi4gSWRlbnRpY2FsIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzLlxuICogKiAzLiBgT2JqZWN0LmZyZWV6ZWAuXG4gKiBGcmFnaWxlOiBhbHdheXMgcnVuIGEgYmVuY2htYXJrIG9uIGEgY2hhbmdlLlxuICogU2VjdXJpdHkgbm90ZTogb3BlcmF0aW9ucyBkb24ndCBjaGVjayAnaXNWYWxpZCcgZm9yIGFsbCBlbGVtZW50cyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyxcbiAqIGl0IGlzIGNhbGxlciByZXNwb25zaWJpbGl0eSB0byBjaGVjayB0aGlzLlxuICogVGhpcyBpcyBsb3ctbGV2ZWwgY29kZSwgcGxlYXNlIG1ha2Ugc3VyZSB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAqXG4gKiBOb3RlIGFib3V0IGZpZWxkIHByb3BlcnRpZXM6XG4gKiAqIENIQVJBQ1RFUklTVElDIHAgPSBwcmltZSBudW1iZXIsIG51bWJlciBvZiBlbGVtZW50cyBpbiBtYWluIHN1Ymdyb3VwLlxuICogKiBPUkRFUiBxID0gc2ltaWxhciB0byBjb2ZhY3RvciBpbiBjdXJ2ZXMsIG1heSBiZSBjb21wb3NpdGUgYHEgPSBwXm1gLlxuICpcbiAqIEBwYXJhbSBPUkRFUiBmaWVsZCBvcmRlciwgcHJvYmFibHkgcHJpbWUsIG9yIGNvdWxkIGJlIGNvbXBvc2l0ZVxuICogQHBhcmFtIGJpdExlbiBob3cgbWFueSBiaXRzIHRoZSBmaWVsZCBjb25zdW1lc1xuICogQHBhcmFtIGlzTEUgKGRlZmF1bHQ6IGZhbHNlKSBpZiBlbmNvZGluZyAvIGRlY29kaW5nIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gRmllbGQoXG4gIE9SREVSOiBiaWdpbnQsXG4gIGJpdExlbk9yT3B0cz86IG51bWJlciB8IEZpZWxkT3B0cywgLy8gVE9ETzogdXNlIG9wdHMgb25seSBpbiB2Mj9cbiAgaXNMRSA9IGZhbHNlLFxuICBvcHRzOiB7IHNxcnQ/OiBTcXJ0Rm4gfSA9IHt9XG4pOiBSZWFkb25seTxGcEZpZWxkPiB7XG4gIGlmIChPUkRFUiA8PSBfMG4pIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZDogZXhwZWN0ZWQgT1JERVIgPiAwLCBnb3QgJyArIE9SREVSKTtcbiAgbGV0IF9uYml0TGVuZ3RoOiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIGxldCBfc3FydDogU3FydEZuIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICBsZXQgbW9kRnJvbUJ5dGVzOiBib29sZWFuID0gZmFsc2U7XG4gIGxldCBhbGxvd2VkTGVuZ3RoczogdW5kZWZpbmVkIHwgcmVhZG9ubHkgbnVtYmVyW10gPSB1bmRlZmluZWQ7XG4gIGlmICh0eXBlb2YgYml0TGVuT3JPcHRzID09PSAnb2JqZWN0JyAmJiBiaXRMZW5Pck9wdHMgIT0gbnVsbCkge1xuICAgIGlmIChvcHRzLnNxcnQgfHwgaXNMRSkgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc3BlY2lmeSBvcHRzIGluIHR3byBhcmd1bWVudHMnKTtcbiAgICBjb25zdCBfb3B0cyA9IGJpdExlbk9yT3B0cztcbiAgICBpZiAoX29wdHMuQklUUykgX25iaXRMZW5ndGggPSBfb3B0cy5CSVRTO1xuICAgIGlmIChfb3B0cy5zcXJ0KSBfc3FydCA9IF9vcHRzLnNxcnQ7XG4gICAgaWYgKHR5cGVvZiBfb3B0cy5pc0xFID09PSAnYm9vbGVhbicpIGlzTEUgPSBfb3B0cy5pc0xFO1xuICAgIGlmICh0eXBlb2YgX29wdHMubW9kRnJvbUJ5dGVzID09PSAnYm9vbGVhbicpIG1vZEZyb21CeXRlcyA9IF9vcHRzLm1vZEZyb21CeXRlcztcbiAgICBhbGxvd2VkTGVuZ3RocyA9IF9vcHRzLmFsbG93ZWRMZW5ndGhzO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgYml0TGVuT3JPcHRzID09PSAnbnVtYmVyJykgX25iaXRMZW5ndGggPSBiaXRMZW5Pck9wdHM7XG4gICAgaWYgKG9wdHMuc3FydCkgX3NxcnQgPSBvcHRzLnNxcnQ7XG4gIH1cbiAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIF9uYml0TGVuZ3RoKTtcbiAgaWYgKEJZVEVTID4gMjA0OCkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkOiBleHBlY3RlZCBPUkRFUiBvZiA8PSAyMDQ4IGJ5dGVzJyk7XG4gIGxldCBzcXJ0UDogUmV0dXJuVHlwZTx0eXBlb2YgRnBTcXJ0PjsgLy8gY2FjaGVkIHNxcnRQXG4gIGNvbnN0IGY6IFJlYWRvbmx5PEZwRmllbGQ+ID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgT1JERVIsXG4gICAgaXNMRSxcbiAgICBCSVRTLFxuICAgIEJZVEVTLFxuICAgIE1BU0s6IGJpdE1hc2soQklUUyksXG4gICAgWkVSTzogXzBuLFxuICAgIE9ORTogXzFuLFxuICAgIGFsbG93ZWRMZW5ndGhzOiBhbGxvd2VkTGVuZ3RocyxcbiAgICBjcmVhdGU6IChudW0pID0+IG1vZChudW0sIE9SREVSKSxcbiAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCAnICsgdHlwZW9mIG51bSk7XG4gICAgICByZXR1cm4gXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUjsgLy8gMCBpcyB2YWxpZCBlbGVtZW50LCBidXQgaXQncyBub3QgaW52ZXJ0aWJsZVxuICAgIH0sXG4gICAgaXMwOiAobnVtKSA9PiBudW0gPT09IF8wbixcbiAgICAvLyBpcyB2YWxpZCBhbmQgaW52ZXJ0aWJsZVxuICAgIGlzVmFsaWROb3QwOiAobnVtOiBiaWdpbnQpID0+ICFmLmlzMChudW0pICYmIGYuaXNWYWxpZChudW0pLFxuICAgIGlzT2RkOiAobnVtKSA9PiAobnVtICYgXzFuKSA9PT0gXzFuLFxuICAgIG5lZzogKG51bSkgPT4gbW9kKC1udW0sIE9SREVSKSxcbiAgICBlcWw6IChsaHMsIHJocykgPT4gbGhzID09PSByaHMsXG5cbiAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcbiAgICBhZGQ6IChsaHMsIHJocykgPT4gbW9kKGxocyArIHJocywgT1JERVIpLFxuICAgIHN1YjogKGxocywgcmhzKSA9PiBtb2QobGhzIC0gcmhzLCBPUkRFUiksXG4gICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcbiAgICBwb3c6IChudW0sIHBvd2VyKSA9PiBGcFBvdyhmLCBudW0sIHBvd2VyKSxcbiAgICBkaXY6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIGludmVydChyaHMsIE9SREVSKSwgT1JERVIpLFxuXG4gICAgLy8gU2FtZSBhcyBhYm92ZSwgYnV0IGRvZXNuJ3Qgbm9ybWFsaXplXG4gICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxuICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuICAgIHN1Yk46IChsaHMsIHJocykgPT4gbGhzIC0gcmhzLFxuICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxuXG4gICAgaW52OiAobnVtKSA9PiBpbnZlcnQobnVtLCBPUkRFUiksXG4gICAgc3FydDpcbiAgICAgIF9zcXJ0IHx8XG4gICAgICAoKG4pID0+IHtcbiAgICAgICAgaWYgKCFzcXJ0UCkgc3FydFAgPSBGcFNxcnQoT1JERVIpO1xuICAgICAgICByZXR1cm4gc3FydFAoZiwgbik7XG4gICAgICB9KSxcbiAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/IG51bWJlclRvQnl0ZXNMRShudW0sIEJZVEVTKSA6IG51bWJlclRvQnl0ZXNCRShudW0sIEJZVEVTKSksXG4gICAgZnJvbUJ5dGVzOiAoYnl0ZXMsIHNraXBWYWxpZGF0aW9uID0gdHJ1ZSkgPT4ge1xuICAgICAgaWYgKGFsbG93ZWRMZW5ndGhzKSB7XG4gICAgICAgIGlmICghYWxsb3dlZExlbmd0aHMuaW5jbHVkZXMoYnl0ZXMubGVuZ3RoKSB8fCBieXRlcy5sZW5ndGggPiBCWVRFUykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdGaWVsZC5mcm9tQnl0ZXM6IGV4cGVjdGVkICcgKyBhbGxvd2VkTGVuZ3RocyArICcgYnl0ZXMsIGdvdCAnICsgYnl0ZXMubGVuZ3RoXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheShCWVRFUyk7XG4gICAgICAgIC8vIGlzTEUgYWRkIDAgdG8gcmlnaHQsICFpc0xFIHRvIHRoZSBsZWZ0LlxuICAgICAgICBwYWRkZWQuc2V0KGJ5dGVzLCBpc0xFID8gMCA6IHBhZGRlZC5sZW5ndGggLSBieXRlcy5sZW5ndGgpO1xuICAgICAgICBieXRlcyA9IHBhZGRlZDtcbiAgICAgIH1cbiAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkLmZyb21CeXRlczogZXhwZWN0ZWQgJyArIEJZVEVTICsgJyBieXRlcywgZ290ICcgKyBieXRlcy5sZW5ndGgpO1xuICAgICAgbGV0IHNjYWxhciA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIDogYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbiAgICAgIGlmIChtb2RGcm9tQnl0ZXMpIHNjYWxhciA9IG1vZChzY2FsYXIsIE9SREVSKTtcbiAgICAgIGlmICghc2tpcFZhbGlkYXRpb24pXG4gICAgICAgIGlmICghZi5pc1ZhbGlkKHNjYWxhcikpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZCBlbGVtZW50OiBvdXRzaWRlIG9mIHJhbmdlIDAuLk9SREVSJyk7XG4gICAgICAvLyBOT1RFOiB3ZSBkb24ndCB2YWxpZGF0ZSBzY2FsYXIgaGVyZSwgcGxlYXNlIHVzZSBpc1ZhbGlkLiBUaGlzIGRvbmUgc3VjaCB3YXkgYmVjYXVzZSBzb21lXG4gICAgICAvLyBwcm90b2NvbCBtYXkgYWxsb3cgbm9uLXJlZHVjZWQgc2NhbGFyIHRoYXQgcmVkdWNlZCBsYXRlciBvciBjaGFuZ2VkIHNvbWUgb3RoZXIgd2F5LlxuICAgICAgcmV0dXJuIHNjYWxhcjtcbiAgICB9LFxuICAgIC8vIFRPRE86IHdlIGRvbid0IG5lZWQgaXQgaGVyZSwgbW92ZSBvdXQgdG8gc2VwYXJhdGUgZm5cbiAgICBpbnZlcnRCYXRjaDogKGxzdCkgPT4gRnBJbnZlcnRCYXRjaChmLCBsc3QpLFxuICAgIC8vIFdlIGNhbid0IG1vdmUgdGhpcyBvdXQgYmVjYXVzZSBGcDYsIEZwMTIgaW1wbGVtZW50IGl0XG4gICAgLy8gYW5kIGl0J3MgdW5jbGVhciB3aGF0IHRvIHJldHVybiBpbiB0aGVyZS5cbiAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gIH0gYXMgRnBGaWVsZCk7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKGYpO1xufVxuXG4vLyBHZW5lcmljIHJhbmRvbSBzY2FsYXIsIHdlIGNhbiBkbyBzYW1lIGZvciBvdGhlciBmaWVsZHMgaWYgdmlhIEZwMi5tdWwoRnAyLk9ORSwgRnAyLnJhbmRvbSk/XG4vLyBUaGlzIGFsbG93cyB1bnNhZmUgbWV0aG9kcyBsaWtlIGlnbm9yZSBiaWFzIG9yIHplcm8uIFRoZXNlIHVuc2FmZSwgYnV0IG9mdGVuIHVzZWQgaW4gZGlmZmVyZW50IHByb3RvY29scyAoaWYgZGV0ZXJtaW5pc3RpYyBSTkcpLlxuLy8gd2hpY2ggbWVhbiB3ZSBjYW5ub3QgZm9yY2UgdGhpcyB2aWEgb3B0cy5cbi8vIE5vdCBzdXJlIHdoYXQgdG8gZG8gd2l0aCByYW5kb21CeXRlcywgd2UgY2FuIGFjY2VwdCBpdCBpbnNpZGUgb3B0cyBpZiB3YW50ZWQuXG4vLyBQcm9iYWJseSBuZWVkIHRvIGV4cG9ydCBnZXRNaW5IYXNoTGVuZ3RoIHNvbWV3aGVyZT9cbi8vIHJhbmRvbShieXRlcz86IFVpbnQ4QXJyYXksIHVuc2FmZUFsbG93WmVybyA9IGZhbHNlLCB1bnNhZmVBbGxvd0JpYXMgPSBmYWxzZSkge1xuLy8gICBjb25zdCBMRU4gPSAhdW5zYWZlQWxsb3dCaWFzID8gZ2V0TWluSGFzaExlbmd0aChPUkRFUikgOiBCWVRFUztcbi8vICAgaWYgKGJ5dGVzID09PSB1bmRlZmluZWQpIGJ5dGVzID0gcmFuZG9tQnl0ZXMoTEVOKTsgLy8gX29wdHMucmFuZG9tQnl0ZXM/XG4vLyAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIDogYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbi8vICAgLy8gYG1vZCh4LCAxMSlgIGNhbiBzb21ldGltZXMgcHJvZHVjZSAwLiBgbW9kKHgsIDEwKSArIDFgIGlzIHRoZSBzYW1lLCBidXQgbm8gMFxuLy8gICBjb25zdCByZWR1Y2VkID0gdW5zYWZlQWxsb3daZXJvID8gbW9kKG51bSwgT1JERVIpIDogbW9kKG51bSwgT1JERVIgLSBfMW4pICsgXzFuO1xuLy8gICByZXR1cm4gcmVkdWNlZDtcbi8vIH0sXG5cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRPZGQ8VD4oRnA6IElGaWVsZDxUPiwgZWxtOiBUKTogVCB7XG4gIGlmICghRnAuaXNPZGQpIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZFwiKTtcbiAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gcm9vdCA6IEZwLm5lZyhyb290KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydEV2ZW48VD4oRnA6IElGaWVsZDxUPiwgZWxtOiBUKTogVCB7XG4gIGlmICghRnAuaXNPZGQpIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZFwiKTtcbiAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gRnAubmVnKHJvb3QpIDogcm9vdDtcbn1cblxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBTYW1lIGFzIG1hcEtleVRvRmllbGQsIGJ1dCBhY2NlcHRzIGxlc3MgYnl0ZXMgKDQwIGluc3RlYWQgb2YgNDggZm9yIDMyLWJ5dGUgZmllbGQpLlxuICogV2hpY2ggbWFrZXMgaXQgc2xpZ2h0bHkgbW9yZSBiaWFzZWQsIGxlc3Mgc2VjdXJlLlxuICogQGRlcHJlY2F0ZWQgdXNlIGBtYXBLZXlUb0ZpZWxkYCBpbnN0ZWFkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoVG9Qcml2YXRlU2NhbGFyKFxuICBoYXNoOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICBncm91cE9yZGVyOiBiaWdpbnQsXG4gIGlzTEUgPSBmYWxzZVxuKTogYmlnaW50IHtcbiAgaGFzaCA9IGVuc3VyZUJ5dGVzKCdwcml2YXRlSGFzaCcsIGhhc2gpO1xuICBjb25zdCBoYXNoTGVuID0gaGFzaC5sZW5ndGg7XG4gIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICBpZiAobWluTGVuIDwgMjQgfHwgaGFzaExlbiA8IG1pbkxlbiB8fCBoYXNoTGVuID4gMTAyNClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnaGFzaFRvUHJpdmF0ZVNjYWxhcjogZXhwZWN0ZWQgJyArIG1pbkxlbiArICctMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICcgKyBoYXNoTGVuXG4gICAgKTtcbiAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShoYXNoKSA6IGJ5dGVzVG9OdW1iZXJCRShoYXNoKTtcbiAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xufVxuXG4vKipcbiAqIFJldHVybnMgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGNvbnN1bWVkIGJ5IHRoZSBmaWVsZCBlbGVtZW50LlxuICogRm9yIGV4YW1wbGUsIDMyIGJ5dGVzIGZvciB1c3VhbCAyNTYtYml0IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIGZpZWxkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXI6IGJpZ2ludCk6IG51bWJlciB7XG4gIGlmICh0eXBlb2YgZmllbGRPcmRlciAhPT0gJ2JpZ2ludCcpIHRocm93IG5ldyBFcnJvcignZmllbGQgb3JkZXIgbXVzdCBiZSBiaWdpbnQnKTtcbiAgY29uc3QgYml0TGVuZ3RoID0gZmllbGRPcmRlci50b1N0cmluZygyKS5sZW5ndGg7XG4gIHJldHVybiBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBtaW5pbWFsIGFtb3VudCBvZiBieXRlcyB0aGF0IGNhbiBiZSBzYWZlbHkgcmVkdWNlZFxuICogYnkgZmllbGQgb3JkZXIuXG4gKiBTaG91bGQgYmUgMl4tMTI4IGZvciAxMjgtYml0IGN1cnZlIHN1Y2ggYXMgUDI1Ni5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiB0YXJnZXQgaGFzaFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyOiBiaWdpbnQpOiBudW1iZXIge1xuICBjb25zdCBsZW5ndGggPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICByZXR1cm4gbGVuZ3RoICsgTWF0aC5jZWlsKGxlbmd0aCAvIDIpO1xufVxuXG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIENhbiB0YWtlIChuICsgbi8yKSBvciBtb3JlIGJ5dGVzIG9mIHVuaWZvcm0gaW5wdXQgZS5nLiBmcm9tIENTUFJORyBvciBLREZcbiAqIGFuZCBjb252ZXJ0IHRoZW0gaW50byBwcml2YXRlIHNjYWxhciwgd2l0aCB0aGUgbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAqIE5lZWRzIGF0IGxlYXN0IDQ4IGJ5dGVzIG9mIGlucHV0IGZvciAzMi1ieXRlIHByaXZhdGUga2V5LlxuICogaHR0cHM6Ly9yZXNlYXJjaC5rdWRlbHNraXNlY3VyaXR5LmNvbS8yMDIwLzA3LzI4L3RoZS1kZWZpbml0aXZlLWd1aWRlLXRvLW1vZHVsby1iaWFzLWFuZC1ob3ctdG8tYXZvaWQtaXQvXG4gKiBGSVBTIDE4Ni01LCBBLjIgaHR0cHM6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9kZXRhaWwvZmlwcy8xODYvNS9maW5hbFxuICogUkZDIDkzODAsIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNVxuICogQHBhcmFtIGhhc2ggaGFzaCBvdXRwdXQgZnJvbSBTSEEzIG9yIGEgc2ltaWxhciBmdW5jdGlvblxuICogQHBhcmFtIGdyb3VwT3JkZXIgc2l6ZSBvZiBzdWJncm91cCAtIChlLmcuIHNlY3AyNTZrMS5DVVJWRS5uKVxuICogQHBhcmFtIGlzTEUgaW50ZXJwcmV0IGhhc2ggYnl0ZXMgYXMgTEUgbnVtXG4gKiBAcmV0dXJucyB2YWxpZCBwcml2YXRlIHNjYWxhclxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwSGFzaFRvRmllbGQoa2V5OiBVaW50OEFycmF5LCBmaWVsZE9yZGVyOiBiaWdpbnQsIGlzTEUgPSBmYWxzZSk6IFVpbnQ4QXJyYXkge1xuICBjb25zdCBsZW4gPSBrZXkubGVuZ3RoO1xuICBjb25zdCBmaWVsZExlbiA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gIGNvbnN0IG1pbkxlbiA9IGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcik7XG4gIC8vIE5vIHNtYWxsIG51bWJlcnM6IG5lZWQgdG8gdW5kZXJzdGFuZCBiaWFzIHN0b3J5LiBObyBodWdlIG51bWJlcnM6IGVhc2llciB0byBkZXRlY3QgSlMgdGltaW5ncy5cbiAgaWYgKGxlbiA8IDE2IHx8IGxlbiA8IG1pbkxlbiB8fCBsZW4gPiAxMDI0KVxuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgJyArIG1pbkxlbiArICctMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICcgKyBsZW4pO1xuICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckxFKGtleSkgOiBieXRlc1RvTnVtYmVyQkUoa2V5KTtcbiAgLy8gYG1vZCh4LCAxMSlgIGNhbiBzb21ldGltZXMgcHJvZHVjZSAwLiBgbW9kKHgsIDEwKSArIDFgIGlzIHRoZSBzYW1lLCBidXQgbm8gMFxuICBjb25zdCByZWR1Y2VkID0gbW9kKG51bSwgZmllbGRPcmRlciAtIF8xbikgKyBfMW47XG4gIHJldHVybiBpc0xFID8gbnVtYmVyVG9CeXRlc0xFKHJlZHVjZWQsIGZpZWxkTGVuKSA6IG51bWJlclRvQnl0ZXNCRShyZWR1Y2VkLCBmaWVsZExlbik7XG59XG4iLCAiLyoqXG4gKiBNZXRob2RzIGZvciBlbGxpcHRpYyBjdXJ2ZSBtdWx0aXBsaWNhdGlvbiBieSBzY2FsYXJzLlxuICogQ29udGFpbnMgd05BRiwgcGlwcGVuZ2VyLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBiaXRMZW4sIGJpdE1hc2ssIHZhbGlkYXRlT2JqZWN0IH0gZnJvbSAnLi4vdXRpbHMudHMnO1xuaW1wb3J0IHsgRmllbGQsIEZwSW52ZXJ0QmF0Y2gsIG5MZW5ndGgsIHZhbGlkYXRlRmllbGQsIHR5cGUgSUZpZWxkIH0gZnJvbSAnLi9tb2R1bGFyLnRzJztcblxuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuXG5leHBvcnQgdHlwZSBBZmZpbmVQb2ludDxUPiA9IHtcbiAgeDogVDtcbiAgeTogVDtcbn0gJiB7IFo/OiBuZXZlciB9O1xuXG4vLyBUaGlzIHdhcyBpbml0aWFseSBkbyB0aGlzIHdheSB0byByZS11c2UgbW9udGdvbWVyeSBsYWRkZXIgaW4gZmllbGQgKGFkZC0+bXVsLGRvdWJsZS0+c3FyKSwgYnV0XG4vLyB0aGF0IGRpZG4ndCBoYXBwZW4gYW5kIHRoZXJlIGlzIHByb2JhYmx5IG5vdCBtdWNoIHJlYXNvbiB0byBoYXZlIHNlcGFyYXRlIEdyb3VwIGxpa2UgdGhpcz9cbmV4cG9ydCBpbnRlcmZhY2UgR3JvdXA8VCBleHRlbmRzIEdyb3VwPFQ+PiB7XG4gIGRvdWJsZSgpOiBUO1xuICBuZWdhdGUoKTogVDtcbiAgYWRkKG90aGVyOiBUKTogVDtcbiAgc3VidHJhY3Qob3RoZXI6IFQpOiBUO1xuICBlcXVhbHMob3RoZXI6IFQpOiBib29sZWFuO1xuICBtdWx0aXBseShzY2FsYXI6IGJpZ2ludCk6IFQ7XG4gIHRvQWZmaW5lPyhpbnZlcnRlZFo/OiBhbnkpOiBBZmZpbmVQb2ludDxhbnk+O1xufVxuXG4vLyBXZSBjYW4ndCBcImFic3RyYWN0IG91dFwiIGNvb3JkaW5hdGVzIChYLCBZLCBaOyBhbmQgVCBpbiBFZHdhcmRzKTogYXJndW1lbnQgbmFtZXMgb2YgY29uc3RydWN0b3Jcbi8vIGFyZSBub3QgYWNjZXNzaWJsZS4gU2VlIFR5cGVzY3JpcHQgZ2gtNTYwOTMsIGdoLTQxNTk0LlxuLy9cbi8vIFdlIGhhdmUgdG8gdXNlIHJlY3Vyc2l2ZSB0eXBlcywgc28gaXQgd2lsbCByZXR1cm4gYWN0dWFsIHBvaW50LCBub3QgY29uc3RhaW5lZCBgQ3VydmVQb2ludGAuXG4vLyBJZiwgYXQgYW55IHBvaW50LCBQIGlzIGBhbnlgLCBpdCB3aWxsIGVyYXNlIGFsbCB0eXBlcyBhbmQgcmVwbGFjZSBpdFxuLy8gd2l0aCBgYW55YCwgYmVjYXVzZSBvZiByZWN1cnNpb24sIGBhbnkgaW1wbGVtZW50cyBDdXJ2ZVBvaW50YCxcbi8vIGJ1dCB3ZSBsb3NlIGFsbCBjb25zdHJhaW5zIG9uIG1ldGhvZHMuXG5cbi8qKiBCYXNlIGludGVyZmFjZSBmb3IgYWxsIGVsbGlwdGljIGN1cnZlIFBvaW50cy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3VydmVQb2ludDxGLCBQIGV4dGVuZHMgQ3VydmVQb2ludDxGLCBQPj4gZXh0ZW5kcyBHcm91cDxQPiB7XG4gIC8qKiBBZmZpbmUgeCBjb29yZGluYXRlLiBEaWZmZXJlbnQgZnJvbSBwcm9qZWN0aXZlIC8gZXh0ZW5kZWQgWCBjb29yZGluYXRlLiAqL1xuICB4OiBGO1xuICAvKiogQWZmaW5lIHkgY29vcmRpbmF0ZS4gRGlmZmVyZW50IGZyb20gcHJvamVjdGl2ZSAvIGV4dGVuZGVkIFkgY29vcmRpbmF0ZS4gKi9cbiAgeTogRjtcbiAgWj86IEY7XG4gIGRvdWJsZSgpOiBQO1xuICBuZWdhdGUoKTogUDtcbiAgYWRkKG90aGVyOiBQKTogUDtcbiAgc3VidHJhY3Qob3RoZXI6IFApOiBQO1xuICBlcXVhbHMob3RoZXI6IFApOiBib29sZWFuO1xuICBtdWx0aXBseShzY2FsYXI6IGJpZ2ludCk6IFA7XG4gIGFzc2VydFZhbGlkaXR5KCk6IHZvaWQ7XG4gIGNsZWFyQ29mYWN0b3IoKTogUDtcbiAgaXMwKCk6IGJvb2xlYW47XG4gIGlzVG9yc2lvbkZyZWUoKTogYm9vbGVhbjtcbiAgaXNTbWFsbE9yZGVyKCk6IGJvb2xlYW47XG4gIG11bHRpcGx5VW5zYWZlKHNjYWxhcjogYmlnaW50KTogUDtcbiAgLyoqXG4gICAqIE1hc3NpdmVseSBzcGVlZHMgdXAgYHAubXVsdGlwbHkobilgIGJ5IHVzaW5nIHByZWNvbXB1dGUgdGFibGVzIChjYWNoaW5nKS4gU2VlIHtAbGluayB3TkFGfS5cbiAgICogQHBhcmFtIGlzTGF6eSBjYWxjdWxhdGUgY2FjaGUgbm93LiBEZWZhdWx0ICh0cnVlKSBlbnN1cmVzIGl0J3MgZGVmZXJyZWQgdG8gZmlyc3QgYG11bHRpcGx5KClgXG4gICAqL1xuICBwcmVjb21wdXRlKHdpbmRvd1NpemU/OiBudW1iZXIsIGlzTGF6eT86IGJvb2xlYW4pOiBQO1xuICAvKiogQ29udmVydHMgcG9pbnQgdG8gMkQgeHkgYWZmaW5lIGNvb3JkaW5hdGVzICovXG4gIHRvQWZmaW5lKGludmVydGVkWj86IEYpOiBBZmZpbmVQb2ludDxGPjtcbiAgdG9CeXRlcygpOiBVaW50OEFycmF5O1xuICB0b0hleCgpOiBzdHJpbmc7XG59XG5cbi8qKiBCYXNlIGludGVyZmFjZSBmb3IgYWxsIGVsbGlwdGljIGN1cnZlIFBvaW50IGNvbnN0cnVjdG9ycy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3VydmVQb2ludENvbnM8UCBleHRlbmRzIEN1cnZlUG9pbnQ8YW55LCBQPj4ge1xuICBbU3ltYm9sLmhhc0luc3RhbmNlXTogKGl0ZW06IHVua25vd24pID0+IGJvb2xlYW47XG4gIEJBU0U6IFA7XG4gIFpFUk86IFA7XG4gIC8qKiBGaWVsZCBmb3IgYmFzaWMgY3VydmUgbWF0aCAqL1xuICBGcDogSUZpZWxkPFBfRjxQPj47XG4gIC8qKiBTY2FsYXIgZmllbGQsIGZvciBzY2FsYXJzIGluIG11bHRpcGx5IGFuZCBvdGhlcnMgKi9cbiAgRm46IElGaWVsZDxiaWdpbnQ+O1xuICAvKiogQ3JlYXRlcyBwb2ludCBmcm9tIHgsIHkuIERvZXMgTk9UIHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyB2YWxpZC4gVXNlIGAuYXNzZXJ0VmFsaWRpdHkoKWAuICovXG4gIGZyb21BZmZpbmUocDogQWZmaW5lUG9pbnQ8UF9GPFA+Pik6IFA7XG4gIGZyb21CeXRlcyhieXRlczogVWludDhBcnJheSk6IFA7XG4gIGZyb21IZXgoaGV4OiBVaW50OEFycmF5IHwgc3RyaW5nKTogUDtcbn1cblxuLy8gVHlwZSBpbmZlcmVuY2UgaGVscGVyczogUEMgLSBQb2ludENvbnN0cnVjdG9yLCBQIC0gUG9pbnQsIEZwIC0gRmllbGQgZWxlbWVudFxuLy8gU2hvcnQgbmFtZXMsIGJlY2F1c2Ugd2UgdXNlIHRoZW0gYSBsb3QgaW4gcmVzdWx0IHR5cGVzOlxuLy8gKiB3ZSBjYW4ndCBkbyAnUCA9IEdldEN1cnZlUG9pbnQ8UEM+JzogdGhpcyBpcyBkZWZhdWx0IHZhbHVlIGFuZCBkb2Vzbid0IGNvbnN0cmFpbiBhbnl0aGluZ1xuLy8gKiB3ZSBjYW4ndCBkbyAndHlwZSBYID0gR2V0Q3VydmVQb2ludDxQQz4nOiBpdCB3b24ndCBiZSBhY2Nlc2libGUgZm9yIGFyZ3VtZW50cy9yZXR1cm4gdHlwZXNcbi8vICogYEN1cnZlUG9pbnRDb25zPFAgZXh0ZW5kcyBDdXJ2ZVBvaW50PGFueSwgUD4+YCBjb25zdHJhaW50cyBmcm9tIGludGVyZmFjZSBkZWZpbml0aW9uXG4vLyAgIHdvbid0IHByb3BhZ2F0ZSwgaWYgYFBDIGV4dGVuZHMgQ3VydmVQb2ludENvbnM8YW55PmA6IHRoZSBQIHdvdWxkIGJlICdhbnknLCB3aGljaCBpcyBpbmNvcnJlY3Rcbi8vICogUEMgY291bGQgYmUgc3VwZXIgc3BlY2lmaWMgd2l0aCBzdXBlciBzcGVjaWZpYyBQLCB3aGljaCBpbXBsZW1lbnRzIEN1cnZlUG9pbnQ8YW55LCBQPi5cbi8vICAgdGhpcyBtZWFucyB3ZSBuZWVkIHRvIGRvIHN0dWZmIGxpa2Vcbi8vICAgYGZ1bmN0aW9uIHRlc3Q8UCBleHRlbmRzIEN1cnZlUG9pbnQ8YW55LCBQPiwgUEMgZXh0ZW5kcyBDdXJ2ZVBvaW50Q29uczxQPj4oYFxuLy8gICBpZiB3ZSB3YW50IHR5cGUgc2FmZXR5IGFyb3VuZCBQLCBvdGhlcndpc2UgUENfUDxQQz4gd2lsbCBiZSBhbnlcblxuLyoqIFJldHVybnMgRnAgdHlwZSBmcm9tIFBvaW50IChQX0Y8UD4gPT0gUC5GKSAqL1xuZXhwb3J0IHR5cGUgUF9GPFAgZXh0ZW5kcyBDdXJ2ZVBvaW50PGFueSwgUD4+ID0gUCBleHRlbmRzIEN1cnZlUG9pbnQ8aW5mZXIgRiwgUD4gPyBGIDogbmV2ZXI7XG4vKiogUmV0dXJucyBGcCB0eXBlIGZyb20gUG9pbnRDb25zIChQQ19GPFBDPiA9PSBQQy5QLkYpICovXG5leHBvcnQgdHlwZSBQQ19GPFBDIGV4dGVuZHMgQ3VydmVQb2ludENvbnM8Q3VydmVQb2ludDxhbnksIGFueT4+PiA9IFBDWydGcCddWydaRVJPJ107XG4vKiogUmV0dXJucyBQb2ludCB0eXBlIGZyb20gUG9pbnRDb25zIChQQ19QPFBDPiA9PSBQQy5QKSAqL1xuZXhwb3J0IHR5cGUgUENfUDxQQyBleHRlbmRzIEN1cnZlUG9pbnRDb25zPEN1cnZlUG9pbnQ8YW55LCBhbnk+Pj4gPSBQQ1snWkVSTyddO1xuXG4vLyBVZ2x5IGhhY2sgdG8gZ2V0IHByb3BlciB0eXBlIGluZmVyZW5jZSwgYmVjYXVzZSBpbiB0eXBlc2NyaXB0IGZhaWxzIHRvIGluZmVyIHJlc3Vyc2l2ZWx5LlxuLy8gVGhlIGhhY2sgYWxsb3dzIHRvIGRvIHVwIHRvIDEwIGNoYWluZWQgb3BlcmF0aW9ucyB3aXRob3V0IGFwcGx5aW5nIHR5cGUgZXJhc3VyZS5cbi8vXG4vLyBUeXBlcyB3aGljaCB3b24ndCB3b3JrOlxuLy8gKiBgQ3VydmVQb2ludENvbnM8Q3VydmVQb2ludDxhbnksIGFueT4+YCwgd2lsbCByZXR1cm4gYGFueWAgYWZ0ZXIgMSBvcGVyYXRpb25cbi8vICogYEN1cnZlUG9pbnRDb25zPGFueT46IFdlaWVyc3RyYXNzUG9pbnRDb25zPGJpZ2ludD4gZXh0ZW5kcyBDdXJ2ZVBvaW50Q29uczxhbnk+ID0gZmFsc2VgXG4vLyAqIGBQIGV4dGVuZHMgQ3VydmVQb2ludCwgUEMgZXh0ZW5kcyBDdXJ2ZVBvaW50Q29uczxQPmBcbi8vICAgICAqIEl0IGNhbid0IGluZmVyIFAgZnJvbSBQQyBhbG9uZVxuLy8gICAgICogVG9vIG1hbnkgcmVsYXRpb25zIGJldHdlZW4gRiwgUCAmIFBDXG4vLyAgICAgKiBJdCB3aWxsIGluZmVyIFAvRiBpZiBgYXJnOiBDdXJ2ZVBvaW50Q29uczxGLCBQPmAsIGJ1dCB3aWxsIGZhaWwgaWYgUEMgaXMgZ2VuZXJpY1xuLy8gICAgICogSXQgd2lsbCB3b3JrIGNvcnJlY3RseSBpZiB0aGVyZSBpcyBhbiBhZGRpdGlvbmFsIGFyZ3VtZW50IG9mIHR5cGUgUFxuLy8gICAgICogQnV0IGdlbmVyYWxseSwgd2UgZG9uJ3Qgd2FudCB0byBwYXJhbWV0cml6ZSBgQ3VydmVQb2ludENvbnNgIG92ZXIgYEZgOiBpdCB3aWxsIGNvbXBsaWNhdGVcbi8vICAgICAgIHR5cGVzLCBtYWtpbmcgdGhlbSB1bi1pbmZlcmFibGVcbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IHR5cGUgUENfQU5ZID0gQ3VydmVQb2ludENvbnM8XG4gIEN1cnZlUG9pbnQ8YW55LFxuICBDdXJ2ZVBvaW50PGFueSxcbiAgQ3VydmVQb2ludDxhbnksXG4gIEN1cnZlUG9pbnQ8YW55LFxuICBDdXJ2ZVBvaW50PGFueSxcbiAgQ3VydmVQb2ludDxhbnksXG4gIEN1cnZlUG9pbnQ8YW55LFxuICBDdXJ2ZVBvaW50PGFueSxcbiAgQ3VydmVQb2ludDxhbnksXG4gIEN1cnZlUG9pbnQ8YW55LCBhbnk+XG4gID4+Pj4+Pj4+PlxuPjtcblxuZXhwb3J0IGludGVyZmFjZSBDdXJ2ZUxlbmd0aHMge1xuICBzZWNyZXRLZXk/OiBudW1iZXI7XG4gIHB1YmxpY0tleT86IG51bWJlcjtcbiAgcHVibGljS2V5VW5jb21wcmVzc2VkPzogbnVtYmVyO1xuICBwdWJsaWNLZXlIYXNQcmVmaXg/OiBib29sZWFuO1xuICBzaWduYXR1cmU/OiBudW1iZXI7XG4gIHNlZWQ/OiBudW1iZXI7XG59XG5leHBvcnQgdHlwZSBHcm91cENvbnN0cnVjdG9yPFQ+ID0ge1xuICBCQVNFOiBUO1xuICBaRVJPOiBUO1xufTtcbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IHR5cGUgRXh0ZW5kZWRHcm91cENvbnN0cnVjdG9yPFQ+ID0gR3JvdXBDb25zdHJ1Y3RvcjxUPiAmIHtcbiAgRnA6IElGaWVsZDxhbnk+O1xuICBGbjogSUZpZWxkPGJpZ2ludD47XG4gIGZyb21BZmZpbmUoYXA6IEFmZmluZVBvaW50PGFueT4pOiBUO1xufTtcbmV4cG9ydCB0eXBlIE1hcHBlcjxUPiA9IChpOiBUW10pID0+IFRbXTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZUN0PFQgZXh0ZW5kcyB7IG5lZ2F0ZTogKCkgPT4gVCB9Pihjb25kaXRpb246IGJvb2xlYW4sIGl0ZW06IFQpOiBUIHtcbiAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG59XG5cbi8qKlxuICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAqIGludmVyc2lvbiBvbiBhbGwgb2YgdGhlbS4gSW52ZXJzaW9uIGlzIHZlcnkgc2xvdyBvcGVyYXRpb24sXG4gKiBzbyB0aGlzIGltcHJvdmVzIHBlcmZvcm1hbmNlIG1hc3NpdmVseS5cbiAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplWjxQIGV4dGVuZHMgQ3VydmVQb2ludDxhbnksIFA+LCBQQyBleHRlbmRzIEN1cnZlUG9pbnRDb25zPFA+PihcbiAgYzogUEMsXG4gIHBvaW50czogUFtdXG4pOiBQW10ge1xuICBjb25zdCBpbnZlcnRlZFpzID0gRnBJbnZlcnRCYXRjaChcbiAgICBjLkZwLFxuICAgIHBvaW50cy5tYXAoKHApID0+IHAuWiEpXG4gICk7XG4gIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBjLmZyb21BZmZpbmUocC50b0FmZmluZShpbnZlcnRlZFpzW2ldKSkpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVcoVzogbnVtYmVyLCBiaXRzOiBudW1iZXIpIHtcbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihXKSB8fCBXIDw9IDAgfHwgVyA+IGJpdHMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHdpbmRvdyBzaXplLCBleHBlY3RlZCBbMS4uJyArIGJpdHMgKyAnXSwgZ290IFc9JyArIFcpO1xufVxuXG4vKiogSW50ZXJuYWwgd05BRiBvcHRzIGZvciBzcGVjaWZpYyBXIGFuZCBzY2FsYXJCaXRzICovXG5leHBvcnQgdHlwZSBXT3B0cyA9IHtcbiAgd2luZG93czogbnVtYmVyO1xuICB3aW5kb3dTaXplOiBudW1iZXI7XG4gIG1hc2s6IGJpZ2ludDtcbiAgbWF4TnVtYmVyOiBudW1iZXI7XG4gIHNoaWZ0Qnk6IGJpZ2ludDtcbn07XG5cbmZ1bmN0aW9uIGNhbGNXT3B0cyhXOiBudW1iZXIsIHNjYWxhckJpdHM6IG51bWJlcik6IFdPcHRzIHtcbiAgdmFsaWRhdGVXKFcsIHNjYWxhckJpdHMpO1xuICBjb25zdCB3aW5kb3dzID0gTWF0aC5jZWlsKHNjYWxhckJpdHMgLyBXKSArIDE7IC8vIFc9OCAzMy4gTm90IDMyLCBiZWNhdXNlIHdlIHNraXAgemVyb1xuICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpOyAvLyBXPTggMTI4LiBOb3QgMjU2LCBiZWNhdXNlIHdlIHNraXAgemVyb1xuICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7IC8vIFc9OCAyNTZcbiAgY29uc3QgbWFzayA9IGJpdE1hc2soVyk7IC8vIFc9OCAyNTUgPT0gbWFzayAwYjExMTExMTExXG4gIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7IC8vIFc9OCA4XG4gIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUsIG1hc2ssIG1heE51bWJlciwgc2hpZnRCeSB9O1xufVxuXG5mdW5jdGlvbiBjYWxjT2Zmc2V0cyhuOiBiaWdpbnQsIHdpbmRvdzogbnVtYmVyLCB3T3B0czogV09wdHMpIHtcbiAgY29uc3QgeyB3aW5kb3dTaXplLCBtYXNrLCBtYXhOdW1iZXIsIHNoaWZ0QnkgfSA9IHdPcHRzO1xuICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spOyAvLyBleHRyYWN0IFcgYml0cy5cbiAgbGV0IG5leHROID0gbiA+PiBzaGlmdEJ5OyAvLyBzaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuXG4gIC8vIFdoYXQgYWN0dWFsbHkgaGFwcGVucyBoZXJlOlxuICAvLyBjb25zdCBoaWdoZXN0Qml0ID0gTnVtYmVyKG1hc2sgXiAobWFzayA+PiAxbikpO1xuICAvLyBsZXQgd2JpdHMyID0gd2JpdHMgLSAxOyAvLyBza2lwIHplcm9cbiAgLy8gaWYgKHdiaXRzMiAmIGhpZ2hlc3RCaXQpIHsgd2JpdHMyIF49IE51bWJlcihtYXNrKTsgLy8gKH4pO1xuXG4gIC8vIHNwbGl0IGlmIGJpdHMgPiBtYXg6ICsyMjQgPT4gMjU2LTMyXG4gIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAvLyB3ZSBza2lwIHplcm8sIHdoaWNoIG1lYW5zIGluc3RlYWQgb2YgYD49IHNpemUtMWAsIHdlIGRvIGA+IHNpemVgXG4gICAgd2JpdHMgLT0gbWF4TnVtYmVyOyAvLyAtMzIsIGNhbiBiZSBtYXhOdW1iZXIgLSB3Yml0cywgYnV0IHRoZW4gd2UgbmVlZCB0byBzZXQgaXNOZWcgaGVyZS5cbiAgICBuZXh0TiArPSBfMW47IC8vICsyNTYgKGNhcnJ5KVxuICB9XG4gIGNvbnN0IG9mZnNldFN0YXJ0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgY29uc3Qgb2Zmc2V0ID0gb2Zmc2V0U3RhcnQgKyBNYXRoLmFicyh3Yml0cykgLSAxOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICBjb25zdCBpc1plcm8gPSB3Yml0cyA9PT0gMDsgLy8gaXMgY3VycmVudCB3aW5kb3cgc2xpY2UgYSAwP1xuICBjb25zdCBpc05lZyA9IHdiaXRzIDwgMDsgLy8gaXMgY3VycmVudCB3aW5kb3cgc2xpY2UgbmVnYXRpdmU/XG4gIGNvbnN0IGlzTmVnRiA9IHdpbmRvdyAlIDIgIT09IDA7IC8vIGZha2UgcmFuZG9tIHN0YXRlbWVudCBmb3Igbm9pc2VcbiAgY29uc3Qgb2Zmc2V0RiA9IG9mZnNldFN0YXJ0OyAvLyBmYWtlIG9mZnNldCBmb3Igbm9pc2VcbiAgcmV0dXJuIHsgbmV4dE4sIG9mZnNldCwgaXNaZXJvLCBpc05lZywgaXNOZWdGLCBvZmZzZXRGIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTVNNUG9pbnRzKHBvaW50czogYW55W10sIGM6IGFueSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSkgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBleHBlY3RlZCcpO1xuICBwb2ludHMuZm9yRWFjaCgocCwgaSkgPT4ge1xuICAgIGlmICghKHAgaW5zdGFuY2VvZiBjKSkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50IGF0IGluZGV4ICcgKyBpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFyczogYW55W10sIGZpZWxkOiBhbnkpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHNjYWxhcnMpKSB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IG9mIHNjYWxhcnMgZXhwZWN0ZWQnKTtcbiAgc2NhbGFycy5mb3JFYWNoKChzLCBpKSA9PiB7XG4gICAgaWYgKCFmaWVsZC5pc1ZhbGlkKHMpKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyIGF0IGluZGV4ICcgKyBpKTtcbiAgfSk7XG59XG5cbi8vIFNpbmNlIHBvaW50cyBpbiBkaWZmZXJlbnQgZ3JvdXBzIGNhbm5vdCBiZSBlcXVhbCAoZGlmZmVyZW50IG9iamVjdCBjb25zdHJ1Y3RvciksXG4vLyB3ZSBjYW4gaGF2ZSBzaW5nbGUgcGxhY2UgdG8gc3RvcmUgcHJlY29tcHV0ZXMuXG4vLyBBbGxvd3MgdG8gbWFrZSBwb2ludHMgZnJvemVuIC8gaW1tdXRhYmxlLlxuY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBXZWFrTWFwPGFueSwgYW55W10+KCk7XG5jb25zdCBwb2ludFdpbmRvd1NpemVzID0gbmV3IFdlYWtNYXA8YW55LCBudW1iZXI+KCk7XG5cbmZ1bmN0aW9uIGdldFcoUDogYW55KTogbnVtYmVyIHtcbiAgLy8gVG8gZGlzYWJsZSBwcmVjb21wdXRlczpcbiAgLy8gcmV0dXJuIDE7XG4gIHJldHVybiBwb2ludFdpbmRvd1NpemVzLmdldChQKSB8fCAxO1xufVxuXG5mdW5jdGlvbiBhc3NlcnQwKG46IGJpZ2ludCk6IHZvaWQge1xuICBpZiAobiAhPT0gXzBuKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgd05BRicpO1xufVxuXG4vKipcbiAqIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbiAqIFRhYmxlIGdlbmVyYXRpb24gdGFrZXMgKiozME1CIG9mIHJhbSBhbmQgMTBtcyBvbiBoaWdoLWVuZCBDUFUqKixcbiAqIGJ1dCBtYXkgdGFrZSBtdWNoIGxvbmdlciBvbiBzbG93IGRldmljZXMuIEFjdHVhbCBnZW5lcmF0aW9uIHdpbGwgaGFwcGVuIG9uXG4gKiBmaXJzdCBjYWxsIG9mIGBtdWx0aXBseSgpYC4gQnkgZGVmYXVsdCwgYEJBU0VgIHBvaW50IGlzIHByZWNvbXB1dGVkLlxuICpcbiAqIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuICogQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4gKiAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbiAqIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3JcbiAqIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbiAqIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8gXHVEODM1XHVEQzRBKSArIDEnIHBvaW50IGFkZGl0aW9ucyAoZml4ZWQgZm9yIGFueSBzY2FsYXIpXG4gKiAtICsxIHdpbmRvdyBpcyBuZWNjZXNzYXJ5IGZvciB3TkFGXG4gKiAtIHdOQUYgcmVkdWNlcyB0YWJsZSBzaXplOiAyeCBsZXNzIG1lbW9yeSArIDJ4IGZhc3RlciBnZW5lcmF0aW9uLCBidXQgMTAlIHNsb3dlciBtdWx0aXBsaWNhdGlvblxuICpcbiAqIEB0b2RvIFJlc2VhcmNoIHJldHVybmluZyAyZCBKUyBhcnJheSBvZiB3aW5kb3dzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHdpbmRvdy5cbiAqIFRoaXMgd291bGQgYWxsb3cgd2luZG93cyB0byBiZSBpbiBkaWZmZXJlbnQgbWVtb3J5IGxvY2F0aW9uc1xuICovXG5leHBvcnQgY2xhc3Mgd05BRjxQQyBleHRlbmRzIFBDX0FOWT4ge1xuICBwcml2YXRlIHJlYWRvbmx5IEJBU0U6IFBDX1A8UEM+O1xuICBwcml2YXRlIHJlYWRvbmx5IFpFUk86IFBDX1A8UEM+O1xuICBwcml2YXRlIHJlYWRvbmx5IEZuOiBQQ1snRm4nXTtcbiAgcmVhZG9ubHkgYml0czogbnVtYmVyO1xuXG4gIC8vIFBhcmFtZXRyaXplZCB3aXRoIGEgZ2l2ZW4gUG9pbnQgY2xhc3MgKG5vdCBpbmRpdmlkdWFsIHBvaW50KVxuICBjb25zdHJ1Y3RvcihQb2ludDogUEMsIGJpdHM6IG51bWJlcikge1xuICAgIHRoaXMuQkFTRSA9IFBvaW50LkJBU0U7XG4gICAgdGhpcy5aRVJPID0gUG9pbnQuWkVSTztcbiAgICB0aGlzLkZuID0gUG9pbnQuRm47XG4gICAgdGhpcy5iaXRzID0gYml0cztcbiAgfVxuXG4gIC8vIG5vbi1jb25zdCB0aW1lIG11bHRpcGxpY2F0aW9uIGxhZGRlclxuICBfdW5zYWZlTGFkZGVyKGVsbTogUENfUDxQQz4sIG46IGJpZ2ludCwgcDogUENfUDxQQz4gPSB0aGlzLlpFUk8pOiBQQ19QPFBDPiB7XG4gICAgbGV0IGQ6IFBDX1A8UEM+ID0gZWxtO1xuICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICBpZiAobiAmIF8xbikgcCA9IHAuYWRkKGQpO1xuICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICBuID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB3TkFGIHByZWNvbXB1dGF0aW9uIHdpbmRvdy4gVXNlZCBmb3IgY2FjaGluZy5cbiAgICogRGVmYXVsdCB3aW5kb3cgc2l6ZSBpcyBzZXQgYnkgYHV0aWxzLnByZWNvbXB1dGUoKWAgYW5kIGlzIGVxdWFsIHRvIDguXG4gICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcbiAgICogMl4oXHVEODM1XHVEQzRBXHUyMjEyMSkgKiAoTWF0aC5jZWlsKFx1RDgzNVx1REM1QiAvIFx1RDgzNVx1REM0QSkgKyAxKSwgd2hlcmU6XG4gICAqIC0gXHVEODM1XHVEQzRBIGlzIHRoZSB3aW5kb3cgc2l6ZVxuICAgKiAtIFx1RDgzNVx1REM1QiBpcyB0aGUgYml0bGVuZ3RoIG9mIHRoZSBjdXJ2ZSBvcmRlci5cbiAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxuICAgKiBAcGFyYW0gcG9pbnQgUG9pbnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICogQHJldHVybnMgcHJlY29tcHV0ZWQgcG9pbnQgdGFibGVzIGZsYXR0ZW5lZCB0byBhIHNpbmdsZSBhcnJheVxuICAgKi9cbiAgcHJpdmF0ZSBwcmVjb21wdXRlV2luZG93KHBvaW50OiBQQ19QPFBDPiwgVzogbnVtYmVyKTogUENfUDxQQz5bXSB7XG4gICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBjYWxjV09wdHMoVywgdGhpcy5iaXRzKTtcbiAgICBjb25zdCBwb2ludHM6IFBDX1A8UEM+W10gPSBbXTtcbiAgICBsZXQgcDogUENfUDxQQz4gPSBwb2ludDtcbiAgICBsZXQgYmFzZSA9IHA7XG4gICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgIGJhc2UgPSBwO1xuICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAvLyBpPTEsIGJjIHdlIHNraXAgMFxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgIH1cbiAgICAgIHAgPSBiYXNlLmRvdWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgZWMgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICogTW9yZSBjb21wYWN0IGltcGxlbWVudGF0aW9uOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL25vYmxlLXNlY3AyNTZrMS9ibG9iLzQ3Y2IxNjY5YjZlNTA2YWQ2NmIzNWZlN2Q3NjEzMmFlOTc0NjVkYTIvaW5kZXgudHMjTDUwMi1MNTQxXG4gICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICovXG4gIHByaXZhdGUgd05BRihXOiBudW1iZXIsIHByZWNvbXB1dGVzOiBQQ19QPFBDPltdLCBuOiBiaWdpbnQpOiB7IHA6IFBDX1A8UEM+OyBmOiBQQ19QPFBDPiB9IHtcbiAgICAvLyBTY2FsYXIgc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiBmaWVsZCBvcmRlclxuICAgIGlmICghdGhpcy5Gbi5pc1ZhbGlkKG4pKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyJyk7XG4gICAgLy8gQWNjdW11bGF0b3JzXG4gICAgbGV0IHAgPSB0aGlzLlpFUk87XG4gICAgbGV0IGYgPSB0aGlzLkJBU0U7XG4gICAgLy8gVGhpcyBjb2RlIHdhcyBmaXJzdCB3cml0dGVuIHdpdGggYXNzdW1wdGlvbiB0aGF0ICdmJyBhbmQgJ3AnIHdpbGwgbmV2ZXIgYmUgaW5maW5pdHkgcG9pbnQ6XG4gICAgLy8gc2luY2UgZWFjaCBhZGRpdGlvbiBpcyBtdWx0aXBsaWVkIGJ5IDIgKiogVywgaXQgY2Fubm90IGNhbmNlbCBlYWNoIG90aGVyLiBIb3dldmVyLFxuICAgIC8vIHRoZXJlIGlzIG5lZ2F0ZSBub3c6IGl0IGlzIHBvc3NpYmxlIHRoYXQgbmVnYXRlZCBlbGVtZW50IGZyb20gbG93IHZhbHVlXG4gICAgLy8gd291bGQgYmUgdGhlIHNhbWUgYXMgaGlnaCBlbGVtZW50LCB3aGljaCB3aWxsIGNyZWF0ZSBjYXJyeSBpbnRvIG5leHQgd2luZG93LlxuICAgIC8vIEl0J3Mgbm90IG9idmlvdXMgaG93IHRoaXMgY2FuIGZhaWwsIGJ1dCBzdGlsbCB3b3J0aCBpbnZlc3RpZ2F0aW5nIGxhdGVyLlxuICAgIGNvbnN0IHdvID0gY2FsY1dPcHRzKFcsIHRoaXMuYml0cyk7XG4gICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd28ud2luZG93czsgd2luZG93KyspIHtcbiAgICAgIC8vIChuID09PSBfMG4pIGlzIGhhbmRsZWQgYW5kIG5vdCBlYXJseS1leGl0ZWQuIGlzRXZlbiBhbmQgb2Zmc2V0RiBhcmUgdXNlZCBmb3Igbm9pc2VcbiAgICAgIGNvbnN0IHsgbmV4dE4sIG9mZnNldCwgaXNaZXJvLCBpc05lZywgaXNOZWdGLCBvZmZzZXRGIH0gPSBjYWxjT2Zmc2V0cyhuLCB3aW5kb3csIHdvKTtcbiAgICAgIG4gPSBuZXh0TjtcbiAgICAgIGlmIChpc1plcm8pIHtcbiAgICAgICAgLy8gYml0cyBhcmUgMDogYWRkIGdhcmJhZ2UgdG8gZmFrZSBwb2ludFxuICAgICAgICAvLyBJbXBvcnRhbnQgcGFydCBmb3IgY29uc3QtdGltZSBnZXRQdWJsaWNLZXk6IGFkZCByYW5kb20gXCJub2lzZVwiIHBvaW50IHRvIGYuXG4gICAgICAgIGYgPSBmLmFkZChuZWdhdGVDdChpc05lZ0YsIHByZWNvbXB1dGVzW29mZnNldEZdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBiaXRzIGFyZSAxOiBhZGQgdG8gcmVzdWx0IHBvaW50XG4gICAgICAgIHAgPSBwLmFkZChuZWdhdGVDdChpc05lZywgcHJlY29tcHV0ZXNbb2Zmc2V0XSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnQwKG4pO1xuICAgIC8vIFJldHVybiBib3RoIHJlYWwgYW5kIGZha2UgcG9pbnRzOiBKSVQgd29uJ3QgZWxpbWluYXRlIGYuXG4gICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSBpcyBhIHdheSB0byBGIGJlIGluZmluaXR5LXBvaW50IGV2ZW4gaWYgcCBpcyBub3QsXG4gICAgLy8gd2hpY2ggbWFrZXMgaXQgbGVzcyBjb25zdC10aW1lOiBhcm91bmQgMSBiaWdpbnQgbXVsdGlwbHkuXG4gICAgcmV0dXJuIHsgcCwgZiB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgZWMgdW5zYWZlIChub24gY29uc3QtdGltZSkgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICogQHBhcmFtIGFjYyBhY2N1bXVsYXRvciBwb2ludCB0byBhZGQgcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uXG4gICAqIEByZXR1cm5zIHBvaW50XG4gICAqL1xuICBwcml2YXRlIHdOQUZVbnNhZmUoXG4gICAgVzogbnVtYmVyLFxuICAgIHByZWNvbXB1dGVzOiBQQ19QPFBDPltdLFxuICAgIG46IGJpZ2ludCxcbiAgICBhY2M6IFBDX1A8UEM+ID0gdGhpcy5aRVJPXG4gICk6IFBDX1A8UEM+IHtcbiAgICBjb25zdCB3byA9IGNhbGNXT3B0cyhXLCB0aGlzLmJpdHMpO1xuICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdvLndpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICBpZiAobiA9PT0gXzBuKSBicmVhazsgLy8gRWFybHktZXhpdCwgc2tpcCAwIHZhbHVlXG4gICAgICBjb25zdCB7IG5leHROLCBvZmZzZXQsIGlzWmVybywgaXNOZWcgfSA9IGNhbGNPZmZzZXRzKG4sIHdpbmRvdywgd28pO1xuICAgICAgbiA9IG5leHROO1xuICAgICAgaWYgKGlzWmVybykge1xuICAgICAgICAvLyBXaW5kb3cgYml0cyBhcmUgMDogc2tpcCBwcm9jZXNzaW5nLlxuICAgICAgICAvLyBNb3ZlIHRvIG5leHQgd2luZG93LlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBwcmVjb21wdXRlc1tvZmZzZXRdO1xuICAgICAgICBhY2MgPSBhY2MuYWRkKGlzTmVnID8gaXRlbS5uZWdhdGUoKSA6IGl0ZW0pOyAvLyBSZS11c2luZyBhY2MgYWxsb3dzIHRvIHNhdmUgYWRkcyBpbiBNU01cbiAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0MChuKTtcbiAgICByZXR1cm4gYWNjO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRQcmVjb21wdXRlcyhXOiBudW1iZXIsIHBvaW50OiBQQ19QPFBDPiwgdHJhbnNmb3JtPzogTWFwcGVyPFBDX1A8UEM+Pik6IFBDX1A8UEM+W10ge1xuICAgIC8vIENhbGN1bGF0ZSBwcmVjb21wdXRlcyBvbiBhIGZpcnN0IHJ1biwgcmV1c2UgdGhlbSBhZnRlclxuICAgIGxldCBjb21wID0gcG9pbnRQcmVjb21wdXRlcy5nZXQocG9pbnQpO1xuICAgIGlmICghY29tcCkge1xuICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhwb2ludCwgVykgYXMgUENfUDxQQz5bXTtcbiAgICAgIGlmIChXICE9PSAxKSB7XG4gICAgICAgIC8vIERvaW5nIHRyYW5zZm9ybSBvdXRzaWRlIG9mIGlmIGJyaW5ncyAxNSUgcGVyZiBoaXRcbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIGNvbXAgPSB0cmFuc2Zvcm0oY29tcCk7XG4gICAgICAgIHBvaW50UHJlY29tcHV0ZXMuc2V0KHBvaW50LCBjb21wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbXA7XG4gIH1cblxuICBjYWNoZWQoXG4gICAgcG9pbnQ6IFBDX1A8UEM+LFxuICAgIHNjYWxhcjogYmlnaW50LFxuICAgIHRyYW5zZm9ybT86IE1hcHBlcjxQQ19QPFBDPj5cbiAgKTogeyBwOiBQQ19QPFBDPjsgZjogUENfUDxQQz4gfSB7XG4gICAgY29uc3QgVyA9IGdldFcocG9pbnQpO1xuICAgIHJldHVybiB0aGlzLndOQUYoVywgdGhpcy5nZXRQcmVjb21wdXRlcyhXLCBwb2ludCwgdHJhbnNmb3JtKSwgc2NhbGFyKTtcbiAgfVxuXG4gIHVuc2FmZShwb2ludDogUENfUDxQQz4sIHNjYWxhcjogYmlnaW50LCB0cmFuc2Zvcm0/OiBNYXBwZXI8UENfUDxQQz4+LCBwcmV2PzogUENfUDxQQz4pOiBQQ19QPFBDPiB7XG4gICAgY29uc3QgVyA9IGdldFcocG9pbnQpO1xuICAgIGlmIChXID09PSAxKSByZXR1cm4gdGhpcy5fdW5zYWZlTGFkZGVyKHBvaW50LCBzY2FsYXIsIHByZXYpOyAvLyBGb3IgVz0xIGxhZGRlciBpcyB+eDIgZmFzdGVyXG4gICAgcmV0dXJuIHRoaXMud05BRlVuc2FmZShXLCB0aGlzLmdldFByZWNvbXB1dGVzKFcsIHBvaW50LCB0cmFuc2Zvcm0pLCBzY2FsYXIsIHByZXYpO1xuICB9XG5cbiAgLy8gV2UgY2FsY3VsYXRlIHByZWNvbXB1dGVzIGZvciBlbGxpcHRpYyBjdXJ2ZSBwb2ludCBtdWx0aXBsaWNhdGlvblxuICAvLyB1c2luZyB3aW5kb3dlZCBtZXRob2QuIFRoaXMgc3BlY2lmaWVzIHdpbmRvdyBzaXplIGFuZFxuICAvLyBzdG9yZXMgcHJlY29tcHV0ZWQgdmFsdWVzLiBVc3VhbGx5IG9ubHkgYmFzZSBwb2ludCB3b3VsZCBiZSBwcmVjb21wdXRlZC5cbiAgY3JlYXRlQ2FjaGUoUDogUENfUDxQQz4sIFc6IG51bWJlcik6IHZvaWQge1xuICAgIHZhbGlkYXRlVyhXLCB0aGlzLmJpdHMpO1xuICAgIHBvaW50V2luZG93U2l6ZXMuc2V0KFAsIFcpO1xuICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKFApO1xuICB9XG5cbiAgaGFzQ2FjaGUoZWxtOiBQQ19QPFBDPik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBnZXRXKGVsbSkgIT09IDE7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmRvbW9ycGhpc20tc3BlY2lmaWMgbXVsdGlwbGljYXRpb24gZm9yIEtvYmxpdHogY3VydmVzLlxuICogQ29zdDogMTI4IGRibCwgMC0yNTYgYWRkcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bEVuZG9VbnNhZmU8UCBleHRlbmRzIEN1cnZlUG9pbnQ8YW55LCBQPiwgUEMgZXh0ZW5kcyBDdXJ2ZVBvaW50Q29uczxQPj4oXG4gIFBvaW50OiBQQyxcbiAgcG9pbnQ6IFAsXG4gIGsxOiBiaWdpbnQsXG4gIGsyOiBiaWdpbnRcbik6IHsgcDE6IFA7IHAyOiBQIH0ge1xuICBsZXQgYWNjID0gcG9pbnQ7XG4gIGxldCBwMSA9IFBvaW50LlpFUk87XG4gIGxldCBwMiA9IFBvaW50LlpFUk87XG4gIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xuICAgIGlmIChrMSAmIF8xbikgcDEgPSBwMS5hZGQoYWNjKTtcbiAgICBpZiAoazIgJiBfMW4pIHAyID0gcDIuYWRkKGFjYyk7XG4gICAgYWNjID0gYWNjLmRvdWJsZSgpO1xuICAgIGsxID4+PSBfMW47XG4gICAgazIgPj49IF8xbjtcbiAgfVxuICByZXR1cm4geyBwMSwgcDIgfTtcbn1cblxuLyoqXG4gKiBQaXBwZW5nZXIgYWxnb3JpdGhtIGZvciBtdWx0aS1zY2FsYXIgbXVsdGlwbGljYXRpb24gKE1TTSwgUGEgKyBRYiArIFJjICsgLi4uKS5cbiAqIDMweCBmYXN0ZXIgdnMgbmFpdmUgYWRkaXRpb24gb24gTD00MDk2LCAxMHggZmFzdGVyIHRoYW4gcHJlY29tcHV0ZXMuXG4gKiBGb3IgTj0yNTRiaXQsIEw9MSwgaXQgZG9lczogMTAyNCBBREQgKyAyNTQgREJMLiBGb3IgTD01OiAxNTM2IEFERCArIDI1NCBEQkwuXG4gKiBBbGdvcml0aG1pY2FsbHkgY29uc3RhbnQtdGltZSAoZm9yIHNhbWUgTCksIGV2ZW4gd2hlbiAxIHBvaW50ICsgc2NhbGFyLCBvciB3aGVuIHNjYWxhciA9IDAuXG4gKiBAcGFyYW0gYyBDdXJ2ZSBQb2ludCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGZpZWxkTiBmaWVsZCBvdmVyIENVUlZFLk4gLSBpbXBvcnRhbnQgdGhhdCBpdCdzIG5vdCBvdmVyIENVUlZFLlBcbiAqIEBwYXJhbSBwb2ludHMgYXJyYXkgb2YgTCBjdXJ2ZSBwb2ludHNcbiAqIEBwYXJhbSBzY2FsYXJzIGFycmF5IG9mIEwgc2NhbGFycyAoYWthIHNlY3JldCBrZXlzIC8gYmlnaW50cylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBpcHBlbmdlcjxQIGV4dGVuZHMgQ3VydmVQb2ludDxhbnksIFA+LCBQQyBleHRlbmRzIEN1cnZlUG9pbnRDb25zPFA+PihcbiAgYzogUEMsXG4gIGZpZWxkTjogSUZpZWxkPGJpZ2ludD4sXG4gIHBvaW50czogUFtdLFxuICBzY2FsYXJzOiBiaWdpbnRbXVxuKTogUCB7XG4gIC8vIElmIHdlIHNwbGl0IHNjYWxhcnMgYnkgc29tZSB3aW5kb3cgKGxldCdzIHNheSA4IGJpdHMpLCBldmVyeSBjaHVuayB3aWxsIG9ubHlcbiAgLy8gdGFrZSAyNTYgYnVja2V0cyBldmVuIGlmIHRoZXJlIGFyZSA0MDk2IHNjYWxhcnMsIGFsc28gcmUtdXNlcyBkb3VibGUuXG4gIC8vIFRPRE86XG4gIC8vIC0gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAyNC83NTAucGRmXG4gIC8vIC0gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzEwMjg3XG4gIC8vIDAgaXMgYWNjZXB0ZWQgaW4gc2NhbGFyc1xuICB2YWxpZGF0ZU1TTVBvaW50cyhwb2ludHMsIGMpO1xuICB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFycywgZmllbGROKTtcbiAgY29uc3QgcGxlbmd0aCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHNsZW5ndGggPSBzY2FsYXJzLmxlbmd0aDtcbiAgaWYgKHBsZW5ndGggIT09IHNsZW5ndGgpIHRocm93IG5ldyBFcnJvcignYXJyYXlzIG9mIHBvaW50cyBhbmQgc2NhbGFycyBtdXN0IGhhdmUgZXF1YWwgbGVuZ3RoJyk7XG4gIC8vIGlmIChwbGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IG11c3QgYmUgb2YgbGVuZ3RoID49IDInKTtcbiAgY29uc3QgemVybyA9IGMuWkVSTztcbiAgY29uc3Qgd2JpdHMgPSBiaXRMZW4oQmlnSW50KHBsZW5ndGgpKTtcbiAgbGV0IHdpbmRvd1NpemUgPSAxOyAvLyBiaXRzXG4gIGlmICh3Yml0cyA+IDEyKSB3aW5kb3dTaXplID0gd2JpdHMgLSAzO1xuICBlbHNlIGlmICh3Yml0cyA+IDQpIHdpbmRvd1NpemUgPSB3Yml0cyAtIDI7XG4gIGVsc2UgaWYgKHdiaXRzID4gMCkgd2luZG93U2l6ZSA9IDI7XG4gIGNvbnN0IE1BU0sgPSBiaXRNYXNrKHdpbmRvd1NpemUpO1xuICBjb25zdCBidWNrZXRzID0gbmV3IEFycmF5KE51bWJlcihNQVNLKSArIDEpLmZpbGwoemVybyk7IC8vICsxIGZvciB6ZXJvIGFycmF5XG4gIGNvbnN0IGxhc3RCaXRzID0gTWF0aC5mbG9vcigoZmllbGROLkJJVFMgLSAxKSAvIHdpbmRvd1NpemUpICogd2luZG93U2l6ZTtcbiAgbGV0IHN1bSA9IHplcm87XG4gIGZvciAobGV0IGkgPSBsYXN0Qml0czsgaSA+PSAwOyBpIC09IHdpbmRvd1NpemUpIHtcbiAgICBidWNrZXRzLmZpbGwoemVybyk7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBzbGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IHNjYWxhciA9IHNjYWxhcnNbal07XG4gICAgICBjb25zdCB3Yml0cyA9IE51bWJlcigoc2NhbGFyID4+IEJpZ0ludChpKSkgJiBNQVNLKTtcbiAgICAgIGJ1Y2tldHNbd2JpdHNdID0gYnVja2V0c1t3Yml0c10uYWRkKHBvaW50c1tqXSk7XG4gICAgfVxuICAgIGxldCByZXNJID0gemVybzsgLy8gbm90IHVzaW5nIHRoaXMgd2lsbCBkbyBzbWFsbCBzcGVlZC11cCwgYnV0IHdpbGwgbG9zZSBjdFxuICAgIC8vIFNraXAgZmlyc3QgYnVja2V0LCBiZWNhdXNlIGl0IGlzIHplcm9cbiAgICBmb3IgKGxldCBqID0gYnVja2V0cy5sZW5ndGggLSAxLCBzdW1JID0gemVybzsgaiA+IDA7IGotLSkge1xuICAgICAgc3VtSSA9IHN1bUkuYWRkKGJ1Y2tldHNbal0pO1xuICAgICAgcmVzSSA9IHJlc0kuYWRkKHN1bUkpO1xuICAgIH1cbiAgICBzdW0gPSBzdW0uYWRkKHJlc0kpO1xuICAgIGlmIChpICE9PSAwKSBmb3IgKGxldCBqID0gMDsgaiA8IHdpbmRvd1NpemU7IGorKykgc3VtID0gc3VtLmRvdWJsZSgpO1xuICB9XG4gIHJldHVybiBzdW0gYXMgUDtcbn1cbi8qKlxuICogUHJlY29tcHV0ZWQgbXVsdGktc2NhbGFyIG11bHRpcGxpY2F0aW9uIChNU00sIFBhICsgUWIgKyBSYyArIC4uLikuXG4gKiBAcGFyYW0gYyBDdXJ2ZSBQb2ludCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGZpZWxkTiBmaWVsZCBvdmVyIENVUlZFLk4gLSBpbXBvcnRhbnQgdGhhdCBpdCdzIG5vdCBvdmVyIENVUlZFLlBcbiAqIEBwYXJhbSBwb2ludHMgYXJyYXkgb2YgTCBjdXJ2ZSBwb2ludHNcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHdoaWNoIG11bHRpcGxpZXMgcG9pbnRzIHdpdGggc2NhYXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVjb21wdXRlTVNNVW5zYWZlPFAgZXh0ZW5kcyBDdXJ2ZVBvaW50PGFueSwgUD4sIFBDIGV4dGVuZHMgQ3VydmVQb2ludENvbnM8UD4+KFxuICBjOiBQQyxcbiAgZmllbGROOiBJRmllbGQ8YmlnaW50PixcbiAgcG9pbnRzOiBQW10sXG4gIHdpbmRvd1NpemU6IG51bWJlclxuKTogKHNjYWxhcnM6IGJpZ2ludFtdKSA9PiBQIHtcbiAgLyoqXG4gICAqIFBlcmZvcm1hbmNlIEFuYWx5c2lzIG9mIFdpbmRvdy1iYXNlZCBQcmVjb21wdXRhdGlvblxuICAgKlxuICAgKiBCYXNlIENhc2UgKDI1Ni1iaXQgc2NhbGFyLCA4LWJpdCB3aW5kb3cpOlxuICAgKiAtIFN0YW5kYXJkIHByZWNvbXB1dGF0aW9uIHJlcXVpcmVzOlxuICAgKiAgIC0gMzEgYWRkaXRpb25zIHBlciBzY2FsYXIgXHUwMEQ3IDI1NiBzY2FsYXJzID0gNyw5MzYgb3BzXG4gICAqICAgLSBQbHVzIDI1NSBzdW1tYXJ5IGFkZGl0aW9ucyA9IDgsMTkxIHRvdGFsIG9wc1xuICAgKiAgIE5vdGU6IFN1bW1hcnkgYWRkaXRpb25zIGNhbiBiZSBvcHRpbWl6ZWQgdmlhIGFjY3VtdWxhdG9yXG4gICAqXG4gICAqIENodW5rZWQgUHJlY29tcHV0YXRpb24gQW5hbHlzaXM6XG4gICAqIC0gVXNpbmcgMzIgY2h1bmtzIHJlcXVpcmVzOlxuICAgKiAgIC0gMjU1IGFkZGl0aW9ucyBwZXIgY2h1bmtcbiAgICogICAtIDI1NiBkb3VibGluZ3NcbiAgICogICAtIFRvdGFsOiAoMjU1IFx1MDBENyAzMikgKyAyNTYgPSA4LDQxNiBvcHNcbiAgICpcbiAgICogTWVtb3J5IFVzYWdlIENvbXBhcmlzb246XG4gICAqIFdpbmRvdyBTaXplIHwgU3RhbmRhcmQgUG9pbnRzIHwgQ2h1bmtlZCBQb2ludHNcbiAgICogLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLVxuICAgKiAgICAgNC1iaXQgICB8ICAgICA1MjAgICAgICAgICB8ICAgICAgMTVcbiAgICogICAgIDgtYml0ICAgfCAgICA0LDIyNCAgICAgICAgfCAgICAgMjU1XG4gICAqICAgIDEwLWJpdCAgIHwgICAxMyw4MjQgICAgICAgIHwgICAxLDAyM1xuICAgKiAgICAxNi1iaXQgICB8ICA1NTcsMDU2ICAgICAgICB8ICA2NSw1MzVcbiAgICpcbiAgICogS2V5IEFkdmFudGFnZXM6XG4gICAqIDEuIEVuYWJsZXMgbGFyZ2VyIHdpbmRvdyBzaXplcyBkdWUgdG8gcmVkdWNlZCBtZW1vcnkgb3ZlcmhlYWRcbiAgICogMi4gTW9yZSBlZmZpY2llbnQgZm9yIHNtYWxsZXIgc2NhbGFyIGNvdW50czpcbiAgICogICAgLSAxNiBjaHVua3M6ICgxNiBcdTAwRDcgMjU1KSArIDI1NiA9IDQsMzM2IG9wc1xuICAgKiAgICAtIH4yeCBmYXN0ZXIgdGhhbiBzdGFuZGFyZCA4LDE5MSBvcHNcbiAgICpcbiAgICogTGltaXRhdGlvbnM6XG4gICAqIC0gTm90IHN1aXRhYmxlIGZvciBwbGFpbiBwcmVjb21wdXRlcyAocmVxdWlyZXMgMjU2IGNvbnN0YW50IGRvdWJsaW5ncylcbiAgICogLSBQZXJmb3JtYW5jZSBkZWdyYWRlcyB3aXRoIGxhcmdlciBzY2FsYXIgY291bnRzOlxuICAgKiAgIC0gT3B0aW1hbCBmb3IgfjI1NiBzY2FsYXJzXG4gICAqICAgLSBMZXNzIGVmZmljaWVudCBmb3IgNDA5Nisgc2NhbGFycyAoUGlwcGVuZ2VyIHByZWZlcnJlZClcbiAgICovXG4gIHZhbGlkYXRlVyh3aW5kb3dTaXplLCBmaWVsZE4uQklUUyk7XG4gIHZhbGlkYXRlTVNNUG9pbnRzKHBvaW50cywgYyk7XG4gIGNvbnN0IHplcm8gPSBjLlpFUk87XG4gIGNvbnN0IHRhYmxlU2l6ZSA9IDIgKiogd2luZG93U2l6ZSAtIDE7IC8vIHRhYmxlIHNpemUgKHdpdGhvdXQgemVybylcbiAgY29uc3QgY2h1bmtzID0gTWF0aC5jZWlsKGZpZWxkTi5CSVRTIC8gd2luZG93U2l6ZSk7IC8vIGNodW5rcyBvZiBpdGVtXG4gIGNvbnN0IE1BU0sgPSBiaXRNYXNrKHdpbmRvd1NpemUpO1xuICBjb25zdCB0YWJsZXMgPSBwb2ludHMubWFwKChwOiBQKSA9PiB7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGFjYyA9IHA7IGkgPCB0YWJsZVNpemU7IGkrKykge1xuICAgICAgcmVzLnB1c2goYWNjKTtcbiAgICAgIGFjYyA9IGFjYy5hZGQocCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0pO1xuICByZXR1cm4gKHNjYWxhcnM6IGJpZ2ludFtdKTogUCA9PiB7XG4gICAgdmFsaWRhdGVNU01TY2FsYXJzKHNjYWxhcnMsIGZpZWxkTik7XG4gICAgaWYgKHNjYWxhcnMubGVuZ3RoID4gcG9pbnRzLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgb2Ygc2NhbGFycyBtdXN0IGJlIHNtYWxsZXIgdGhhbiBhcnJheSBvZiBwb2ludHMnKTtcbiAgICBsZXQgcmVzID0gemVybztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rczsgaSsrKSB7XG4gICAgICAvLyBObyBuZWVkIHRvIGRvdWJsZSBpZiBhY2N1bXVsYXRvciBpcyBzdGlsbCB6ZXJvLlxuICAgICAgaWYgKHJlcyAhPT0gemVybykgZm9yIChsZXQgaiA9IDA7IGogPCB3aW5kb3dTaXplOyBqKyspIHJlcyA9IHJlcy5kb3VibGUoKTtcbiAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoY2h1bmtzICogd2luZG93U2l6ZSAtIChpICsgMSkgKiB3aW5kb3dTaXplKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2NhbGFycy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBuID0gc2NhbGFyc1tqXTtcbiAgICAgICAgY29uc3QgY3VyciA9IE51bWJlcigobiA+PiBzaGlmdEJ5KSAmIE1BU0spO1xuICAgICAgICBpZiAoIWN1cnIpIGNvbnRpbnVlOyAvLyBza2lwIHplcm8gc2NhbGFycyBjaHVua3NcbiAgICAgICAgcmVzID0gcmVzLmFkZCh0YWJsZXNbal1bY3VyciAtIDFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn1cblxuLy8gVE9ETzogcmVtb3ZlXG4vKipcbiAqIEdlbmVyaWMgQmFzaWNDdXJ2ZSBpbnRlcmZhY2U6IHdvcmtzIGV2ZW4gZm9yIHBvbHlub21pYWwgZmllbGRzIChCTFMpOiBQLCBuLCBoIHdvdWxkIGJlIG9rLlxuICogVGhvdWdoIGdlbmVyYXRvciBjYW4gYmUgZGlmZmVyZW50IChGcDIgLyBGcDYgZm9yIEJMUykuXG4gKi9cbmV4cG9ydCB0eXBlIEJhc2ljQ3VydmU8VD4gPSB7XG4gIEZwOiBJRmllbGQ8VD47IC8vIEZpZWxkIG92ZXIgd2hpY2ggd2UnbGwgZG8gY2FsY3VsYXRpb25zIChGcClcbiAgbjogYmlnaW50OyAvLyBDdXJ2ZSBvcmRlciwgdG90YWwgY291bnQgb2YgdmFsaWQgcG9pbnRzIGluIHRoZSBmaWVsZFxuICBuQml0TGVuZ3RoPzogbnVtYmVyOyAvLyBiaXQgbGVuZ3RoIG9mIGN1cnZlIG9yZGVyXG4gIG5CeXRlTGVuZ3RoPzogbnVtYmVyOyAvLyBieXRlIGxlbmd0aCBvZiBjdXJ2ZSBvcmRlclxuICBoOiBiaWdpbnQ7IC8vIGNvZmFjdG9yLiB3ZSBjYW4gYXNzaWduIGRlZmF1bHQ9MSwgYnV0IHVzZXJzIHdpbGwganVzdCBpZ25vcmUgaXQgdy9vIHZhbGlkYXRpb25cbiAgaEVmZj86IGJpZ2ludDsgLy8gTnVtYmVyIHRvIG11bHRpcGx5IHRvIGNsZWFyIGNvZmFjdG9yXG4gIEd4OiBUOyAvLyBiYXNlIHBvaW50IFggY29vcmRpbmF0ZVxuICBHeTogVDsgLy8gYmFzZSBwb2ludCBZIGNvb3JkaW5hdGVcbiAgYWxsb3dJbmZpbml0eVBvaW50PzogYm9vbGVhbjsgLy8gYmxzMTItMzgxIHJlcXVpcmVzIGl0LiBaRVJPIHBvaW50IGlzIHZhbGlkLCBidXQgaW52YWxpZCBwdWJrZXlcbn07XG5cbi8vIFRPRE86IHJlbW92ZVxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVCYXNpYzxGUCwgVD4oXG4gIGN1cnZlOiBCYXNpY0N1cnZlPEZQPiAmIFRcbik6IFJlYWRvbmx5PFxuICB7XG4gICAgcmVhZG9ubHkgbkJpdExlbmd0aDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IG5CeXRlTGVuZ3RoOiBudW1iZXI7XG4gIH0gJiBCYXNpY0N1cnZlPEZQPiAmXG4gICAgVCAmIHtcbiAgICAgIHA6IGJpZ2ludDtcbiAgICB9XG4+IHtcbiAgdmFsaWRhdGVGaWVsZChjdXJ2ZS5GcCk7XG4gIHZhbGlkYXRlT2JqZWN0KFxuICAgIGN1cnZlLFxuICAgIHtcbiAgICAgIG46ICdiaWdpbnQnLFxuICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICBHeDogJ2ZpZWxkJyxcbiAgICAgIEd5OiAnZmllbGQnLFxuICAgIH0sXG4gICAge1xuICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9XG4gICk7XG4gIC8vIFNldCBkZWZhdWx0c1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLi4ubkxlbmd0aChjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcbiAgICAuLi5jdXJ2ZSxcbiAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gIH0gYXMgY29uc3QpO1xufVxuXG5leHBvcnQgdHlwZSBWYWxpZEN1cnZlUGFyYW1zPFQ+ID0ge1xuICBwOiBiaWdpbnQ7XG4gIG46IGJpZ2ludDtcbiAgaDogYmlnaW50O1xuICBhOiBUO1xuICBiPzogVDtcbiAgZD86IFQ7XG4gIEd4OiBUO1xuICBHeTogVDtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpZWxkPFQ+KG9yZGVyOiBiaWdpbnQsIGZpZWxkPzogSUZpZWxkPFQ+LCBpc0xFPzogYm9vbGVhbik6IElGaWVsZDxUPiB7XG4gIGlmIChmaWVsZCkge1xuICAgIGlmIChmaWVsZC5PUkRFUiAhPT0gb3JkZXIpIHRocm93IG5ldyBFcnJvcignRmllbGQuT1JERVIgbXVzdCBtYXRjaCBvcmRlcjogRnAgPT0gcCwgRm4gPT0gbicpO1xuICAgIHZhbGlkYXRlRmllbGQoZmllbGQpO1xuICAgIHJldHVybiBmaWVsZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gRmllbGQob3JkZXIsIHsgaXNMRSB9KSBhcyB1bmtub3duIGFzIElGaWVsZDxUPjtcbiAgfVxufVxuZXhwb3J0IHR5cGUgRnBGbjxUPiA9IHsgRnA6IElGaWVsZDxUPjsgRm46IElGaWVsZDxiaWdpbnQ+IH07XG5cbi8qKiBWYWxpZGF0ZXMgQ1VSVkUgb3B0cyBhbmQgY3JlYXRlcyBmaWVsZHMgKi9cbmV4cG9ydCBmdW5jdGlvbiBfY3JlYXRlQ3VydmVGaWVsZHM8VD4oXG4gIHR5cGU6ICd3ZWllcnN0cmFzcycgfCAnZWR3YXJkcycsXG4gIENVUlZFOiBWYWxpZEN1cnZlUGFyYW1zPFQ+LFxuICBjdXJ2ZU9wdHM6IFBhcnRpYWw8RnBGbjxUPj4gPSB7fSxcbiAgRnBGbkxFPzogYm9vbGVhblxuKTogRnBGbjxUPiAmIHsgQ1VSVkU6IFZhbGlkQ3VydmVQYXJhbXM8VD4gfSB7XG4gIGlmIChGcEZuTEUgPT09IHVuZGVmaW5lZCkgRnBGbkxFID0gdHlwZSA9PT0gJ2Vkd2FyZHMnO1xuICBpZiAoIUNVUlZFIHx8IHR5cGVvZiBDVVJWRSAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgdmFsaWQgJHt0eXBlfSBDVVJWRSBvYmplY3RgKTtcbiAgZm9yIChjb25zdCBwIG9mIFsncCcsICduJywgJ2gnXSBhcyBjb25zdCkge1xuICAgIGNvbnN0IHZhbCA9IENVUlZFW3BdO1xuICAgIGlmICghKHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnICYmIHZhbCA+IF8wbikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENVUlZFLiR7cH0gbXVzdCBiZSBwb3NpdGl2ZSBiaWdpbnRgKTtcbiAgfVxuICBjb25zdCBGcCA9IGNyZWF0ZUZpZWxkKENVUlZFLnAsIGN1cnZlT3B0cy5GcCwgRnBGbkxFKTtcbiAgY29uc3QgRm4gPSBjcmVhdGVGaWVsZChDVVJWRS5uLCBjdXJ2ZU9wdHMuRm4sIEZwRm5MRSk7XG4gIGNvbnN0IF9iOiAnYicgfCAnZCcgPSB0eXBlID09PSAnd2VpZXJzdHJhc3MnID8gJ2InIDogJ2QnO1xuICBjb25zdCBwYXJhbXMgPSBbJ0d4JywgJ0d5JywgJ2EnLCBfYl0gYXMgY29uc3Q7XG4gIGZvciAoY29uc3QgcCBvZiBwYXJhbXMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKCFGcC5pc1ZhbGlkKENVUlZFW3BdKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ1VSVkUuJHtwfSBtdXN0IGJlIHZhbGlkIGZpZWxkIGVsZW1lbnQgb2YgQ1VSVkUuRnBgKTtcbiAgfVxuICBDVVJWRSA9IE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbih7fSwgQ1VSVkUpKTtcbiAgcmV0dXJuIHsgQ1VSVkUsIEZwLCBGbiB9O1xufVxuIiwgIi8qKlxuICogVHdpc3RlZCBFZHdhcmRzIGN1cnZlLiBUaGUgZm9ybXVsYSBpczogYXhcdTAwQjIgKyB5XHUwMEIyID0gMSArIGR4XHUwMEIyeVx1MDBCMi5cbiAqIEZvciBkZXNpZ24gcmF0aW9uYWxlIG9mIHR5cGVzIC8gZXhwb3J0cywgc2VlIHdlaWVyc3RyYXNzIG1vZHVsZSBkb2N1bWVudGF0aW9uLlxuICogVW50d2lzdGVkIEVkd2FyZHMgY3VydmVzIGV4aXN0LCBidXQgdGhleSBhcmVuJ3QgdXNlZCBpbiByZWFsLXdvcmxkIHByb3RvY29scy5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHtcbiAgX3ZhbGlkYXRlT2JqZWN0LFxuICBfYWJvb2wyIGFzIGFib29sLFxuICBfYWJ5dGVzMiBhcyBhYnl0ZXMsXG4gIGFJblJhbmdlLFxuICBieXRlc1RvSGV4LFxuICBieXRlc1RvTnVtYmVyTEUsXG4gIGNvbmNhdEJ5dGVzLFxuICBjb3B5Qnl0ZXMsXG4gIGVuc3VyZUJ5dGVzLFxuICBpc0J5dGVzLFxuICBtZW1vaXplZCxcbiAgbm90SW1wbGVtZW50ZWQsXG4gIHJhbmRvbUJ5dGVzIGFzIHJhbmRvbUJ5dGVzV2ViLFxuICB0eXBlIEZIYXNoLFxuICB0eXBlIEhleCxcbn0gZnJvbSAnLi4vdXRpbHMudHMnO1xuaW1wb3J0IHtcbiAgX2NyZWF0ZUN1cnZlRmllbGRzLFxuICBub3JtYWxpemVaLFxuICBwaXBwZW5nZXIsXG4gIHdOQUYsXG4gIHR5cGUgQWZmaW5lUG9pbnQsXG4gIHR5cGUgQmFzaWNDdXJ2ZSxcbiAgdHlwZSBDdXJ2ZUxlbmd0aHMsXG4gIHR5cGUgQ3VydmVQb2ludCxcbiAgdHlwZSBDdXJ2ZVBvaW50Q29ucyxcbn0gZnJvbSAnLi9jdXJ2ZS50cyc7XG5pbXBvcnQgeyBGaWVsZCwgdHlwZSBJRmllbGQsIHR5cGUgTkxlbmd0aCB9IGZyb20gJy4vbW9kdWxhci50cyc7XG5cbi8vIEJlIGZyaWVuZGx5IHRvIGJhZCBFQ01BU2NyaXB0IHBhcnNlcnMgYnkgbm90IHVzaW5nIGJpZ2ludCBsaXRlcmFsc1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfOG4gPSBCaWdJbnQoOCk7XG5cbmV4cG9ydCB0eXBlIFVWUmF0aW8gPSAodTogYmlnaW50LCB2OiBiaWdpbnQpID0+IHsgaXNWYWxpZDogYm9vbGVhbjsgdmFsdWU6IGJpZ2ludCB9O1xuXG4vKiogSW5zdGFuY2Ugb2YgRXh0ZW5kZWQgUG9pbnQgd2l0aCBjb29yZGluYXRlcyBpbiBYLCBZLCBaLCBULiAqL1xuZXhwb3J0IGludGVyZmFjZSBFZHdhcmRzUG9pbnQgZXh0ZW5kcyBDdXJ2ZVBvaW50PGJpZ2ludCwgRWR3YXJkc1BvaW50PiB7XG4gIC8qKiBleHRlbmRlZCBYIGNvb3JkaW5hdGUuIERpZmZlcmVudCBmcm9tIGFmZmluZSB4LiAqL1xuICByZWFkb25seSBYOiBiaWdpbnQ7XG4gIC8qKiBleHRlbmRlZCBZIGNvb3JkaW5hdGUuIERpZmZlcmVudCBmcm9tIGFmZmluZSB5LiAqL1xuICByZWFkb25seSBZOiBiaWdpbnQ7XG4gIC8qKiBleHRlbmRlZCBaIGNvb3JkaW5hdGUgKi9cbiAgcmVhZG9ubHkgWjogYmlnaW50O1xuICAvKiogZXh0ZW5kZWQgVCBjb29yZGluYXRlICovXG4gIHJlYWRvbmx5IFQ6IGJpZ2ludDtcblxuICAvKiogQGRlcHJlY2F0ZWQgdXNlIGB0b0J5dGVzYCAqL1xuICB0b1Jhd0J5dGVzKCk6IFVpbnQ4QXJyYXk7XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgYHAucHJlY29tcHV0ZSh3aW5kb3dTaXplKWAgKi9cbiAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZTogbnVtYmVyKTogdm9pZDtcbiAgLyoqIEBkZXByZWNhdGVkIHVzZSAuWCAqL1xuICByZWFkb25seSBleDogYmlnaW50O1xuICAvKiogQGRlcHJlY2F0ZWQgdXNlIC5ZICovXG4gIHJlYWRvbmx5IGV5OiBiaWdpbnQ7XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgLlogKi9cbiAgcmVhZG9ubHkgZXo6IGJpZ2ludDtcbiAgLyoqIEBkZXByZWNhdGVkIHVzZSAuVCAqL1xuICByZWFkb25seSBldDogYmlnaW50O1xufVxuLyoqIFN0YXRpYyBtZXRob2RzIG9mIEV4dGVuZGVkIFBvaW50IHdpdGggY29vcmRpbmF0ZXMgaW4gWCwgWSwgWiwgVC4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRWR3YXJkc1BvaW50Q29ucyBleHRlbmRzIEN1cnZlUG9pbnRDb25zPEVkd2FyZHNQb2ludD4ge1xuICBuZXcgKFg6IGJpZ2ludCwgWTogYmlnaW50LCBaOiBiaWdpbnQsIFQ6IGJpZ2ludCk6IEVkd2FyZHNQb2ludDtcbiAgQ1VSVkUoKTogRWR3YXJkc09wdHM7XG4gIGZyb21CeXRlcyhieXRlczogVWludDhBcnJheSwgemlwMjE1PzogYm9vbGVhbik6IEVkd2FyZHNQb2ludDtcbiAgZnJvbUhleChoZXg6IEhleCwgemlwMjE1PzogYm9vbGVhbik6IEVkd2FyZHNQb2ludDtcbiAgLyoqIEBkZXByZWNhdGVkIHVzZSBgaW1wb3J0IHsgcGlwcGVuZ2VyIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9jdXJ2ZS5qcyc7YCAqL1xuICBtc20ocG9pbnRzOiBFZHdhcmRzUG9pbnRbXSwgc2NhbGFyczogYmlnaW50W10pOiBFZHdhcmRzUG9pbnQ7XG59XG4vKiogQGRlcHJlY2F0ZWQgdXNlIEVkd2FyZHNQb2ludCAqL1xuZXhwb3J0IHR5cGUgRXh0UG9pbnRUeXBlID0gRWR3YXJkc1BvaW50O1xuLyoqIEBkZXByZWNhdGVkIHVzZSBFZHdhcmRzUG9pbnRDb25zICovXG5leHBvcnQgdHlwZSBFeHRQb2ludENvbnN0cnVjdG9yID0gRWR3YXJkc1BvaW50Q29ucztcblxuLyoqXG4gKiBUd2lzdGVkIEVkd2FyZHMgY3VydmUgb3B0aW9ucy5cbiAqXG4gKiAqIGE6IGZvcm11bGEgcGFyYW1cbiAqICogZDogZm9ybXVsYSBwYXJhbVxuICogKiBwOiBwcmltZSBjaGFyYWN0ZXJpc3RpYyAob3JkZXIpIG9mIGZpbml0ZSBmaWVsZCwgaW4gd2hpY2ggYXJpdGhtZXRpY3MgaXMgZG9uZVxuICogKiBuOiBvcmRlciBvZiBwcmltZSBzdWJncm91cCBhLmsuYSB0b3RhbCBhbW91bnQgb2YgdmFsaWQgY3VydmUgcG9pbnRzXG4gKiAqIGg6IGNvZmFjdG9yLiBoKm4gaXMgZ3JvdXAgb3JkZXI7IG4gaXMgc3ViZ3JvdXAgb3JkZXJcbiAqICogR3g6IHggY29vcmRpbmF0ZSBvZiBnZW5lcmF0b3IgcG9pbnQgYS5rLmEuIGJhc2UgcG9pbnRcbiAqICogR3k6IHkgY29vcmRpbmF0ZSBvZiBnZW5lcmF0b3IgcG9pbnRcbiAqL1xuZXhwb3J0IHR5cGUgRWR3YXJkc09wdHMgPSBSZWFkb25seTx7XG4gIHA6IGJpZ2ludDtcbiAgbjogYmlnaW50O1xuICBoOiBiaWdpbnQ7XG4gIGE6IGJpZ2ludDtcbiAgZDogYmlnaW50O1xuICBHeDogYmlnaW50O1xuICBHeTogYmlnaW50O1xufT47XG5cbi8qKlxuICogRXh0cmEgY3VydmUgb3B0aW9ucyBmb3IgVHdpc3RlZCBFZHdhcmRzLlxuICpcbiAqICogRnA6IHJlZGVmaW5lZCBGaWVsZCBvdmVyIGN1cnZlLnBcbiAqICogRm46IHJlZGVmaW5lZCBGaWVsZCBvdmVyIGN1cnZlLm5cbiAqICogdXZSYXRpbzogaGVscGVyIGZ1bmN0aW9uIGZvciBkZWNvbXByZXNzaW9uLCBjYWxjdWxhdGluZyBcdTIyMUEodS92KVxuICovXG5leHBvcnQgdHlwZSBFZHdhcmRzRXh0cmFPcHRzID0gUGFydGlhbDx7XG4gIEZwOiBJRmllbGQ8YmlnaW50PjtcbiAgRm46IElGaWVsZDxiaWdpbnQ+O1xuICBGcEZuTEU6IGJvb2xlYW47XG4gIHV2UmF0aW86ICh1OiBiaWdpbnQsIHY6IGJpZ2ludCkgPT4geyBpc1ZhbGlkOiBib29sZWFuOyB2YWx1ZTogYmlnaW50IH07XG59PjtcblxuLyoqXG4gKiBFZERTQSAoRWR3YXJkcyBEaWdpdGFsIFNpZ25hdHVyZSBhbGdvcml0aG0pIG9wdGlvbnMuXG4gKlxuICogKiBoYXNoOiBoYXNoIGZ1bmN0aW9uIHVzZWQgdG8gaGFzaCBzZWNyZXQga2V5cyBhbmQgbWVzc2FnZXNcbiAqICogYWRqdXN0U2NhbGFyQnl0ZXM6IGNsZWFycyBiaXRzIHRvIGdldCB2YWxpZCBmaWVsZCBlbGVtZW50XG4gKiAqIGRvbWFpbjogVXNlZCBmb3IgaGFzaGluZ1xuICogKiBtYXBUb0N1cnZlOiBmb3IgaGFzaC10by1jdXJ2ZSBzdGFuZGFyZFxuICogKiBwcmVoYXNoOiBSRkMgODAzMiBwcmUtaGFzaGluZyBvZiBtZXNzYWdlcyB0byBzaWduKCkgLyB2ZXJpZnkoKVxuICogKiByYW5kb21CeXRlczogZnVuY3Rpb24gZ2VuZXJhdGluZyByYW5kb20gYnl0ZXMsIHVzZWQgZm9yIHJhbmRvbVNlY3JldEtleVxuICovXG5leHBvcnQgdHlwZSBFZERTQU9wdHMgPSBQYXJ0aWFsPHtcbiAgYWRqdXN0U2NhbGFyQnl0ZXM6IChieXRlczogVWludDhBcnJheSkgPT4gVWludDhBcnJheTtcbiAgZG9tYWluOiAoZGF0YTogVWludDhBcnJheSwgY3R4OiBVaW50OEFycmF5LCBwaGZsYWc6IGJvb2xlYW4pID0+IFVpbnQ4QXJyYXk7XG4gIG1hcFRvQ3VydmU6IChzY2FsYXI6IGJpZ2ludFtdKSA9PiBBZmZpbmVQb2ludDxiaWdpbnQ+O1xuICBwcmVoYXNoOiBGSGFzaDtcbiAgcmFuZG9tQnl0ZXM6IChieXRlc0xlbmd0aD86IG51bWJlcikgPT4gVWludDhBcnJheTtcbn0+O1xuXG4vKipcbiAqIEVkRFNBIChFZHdhcmRzIERpZ2l0YWwgU2lnbmF0dXJlIGFsZ29yaXRobSkgaW50ZXJmYWNlLlxuICpcbiAqIEFsbG93cyB0byBjcmVhdGUgYW5kIHZlcmlmeSBzaWduYXR1cmVzLCBjcmVhdGUgcHVibGljIGFuZCBzZWNyZXQga2V5cy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFZERTQSB7XG4gIGtleWdlbjogKHNlZWQ/OiBVaW50OEFycmF5KSA9PiB7IHNlY3JldEtleTogVWludDhBcnJheTsgcHVibGljS2V5OiBVaW50OEFycmF5IH07XG4gIGdldFB1YmxpY0tleTogKHNlY3JldEtleTogSGV4KSA9PiBVaW50OEFycmF5O1xuICBzaWduOiAobWVzc2FnZTogSGV4LCBzZWNyZXRLZXk6IEhleCwgb3B0aW9ucz86IHsgY29udGV4dD86IEhleCB9KSA9PiBVaW50OEFycmF5O1xuICB2ZXJpZnk6IChcbiAgICBzaWc6IEhleCxcbiAgICBtZXNzYWdlOiBIZXgsXG4gICAgcHVibGljS2V5OiBIZXgsXG4gICAgb3B0aW9ucz86IHsgY29udGV4dD86IEhleDsgemlwMjE1OiBib29sZWFuIH1cbiAgKSA9PiBib29sZWFuO1xuICBQb2ludDogRWR3YXJkc1BvaW50Q29ucztcbiAgdXRpbHM6IHtcbiAgICByYW5kb21TZWNyZXRLZXk6IChzZWVkPzogVWludDhBcnJheSkgPT4gVWludDhBcnJheTtcbiAgICBpc1ZhbGlkU2VjcmV0S2V5OiAoc2VjcmV0S2V5OiBVaW50OEFycmF5KSA9PiBib29sZWFuO1xuICAgIGlzVmFsaWRQdWJsaWNLZXk6IChwdWJsaWNLZXk6IFVpbnQ4QXJyYXksIHppcDIxNT86IGJvb2xlYW4pID0+IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBlZCBwdWJsaWMga2V5IHRvIHggcHVibGljIGtleS5cbiAgICAgKlxuICAgICAqIFRoZXJlIGlzIE5PIGBmcm9tTW9udGdvbWVyeWA6XG4gICAgICogLSBUaGVyZSBhcmUgMiB2YWxpZCBlZDI1NTE5IHBvaW50cyBmb3IgZXZlcnkgeDI1NTE5LCB3aXRoIGZsaXBwZWQgY29vcmRpbmF0ZVxuICAgICAqIC0gU29tZXRpbWVzIHRoZXJlIGFyZSAwIHZhbGlkIGVkMjU1MTkgcG9pbnRzLCBiZWNhdXNlIHgyNTUxOSAqYWRkaXRpb25hbGx5KlxuICAgICAqICAgYWNjZXB0cyBpbnB1dHMgb24gdGhlIHF1YWRyYXRpYyB0d2lzdCwgd2hpY2ggY2FuJ3QgYmUgbW92ZWQgdG8gZWQyNTUxOVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHNvbWVvbmVzUHViID0gZWQyNTUxOS5nZXRQdWJsaWNLZXkoZWQyNTUxOS51dGlscy5yYW5kb21TZWNyZXRLZXkoKSk7XG4gICAgICogY29uc3QgYVByaXYgPSB4MjU1MTkudXRpbHMucmFuZG9tU2VjcmV0S2V5KCk7XG4gICAgICogeDI1NTE5LmdldFNoYXJlZFNlY3JldChhUHJpdiwgZWQyNTUxOS51dGlscy50b01vbnRnb21lcnkoc29tZW9uZXNQdWIpKVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHRvTW9udGdvbWVyeTogKHB1YmxpY0tleTogVWludDhBcnJheSkgPT4gVWludDhBcnJheTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBlZCBzZWNyZXQga2V5IHRvIHggc2VjcmV0IGtleS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3Qgc29tZW9uZXNQdWIgPSB4MjU1MTkuZ2V0UHVibGljS2V5KHgyNTUxOS51dGlscy5yYW5kb21TZWNyZXRLZXkoKSk7XG4gICAgICogY29uc3QgYVByaXYgPSBlZDI1NTE5LnV0aWxzLnJhbmRvbVNlY3JldEtleSgpO1xuICAgICAqIHgyNTUxOS5nZXRTaGFyZWRTZWNyZXQoZWQyNTUxOS51dGlscy50b01vbnRnb21lcnlTZWNyZXQoYVByaXYpLCBzb21lb25lc1B1YilcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB0b01vbnRnb21lcnlTZWNyZXQ6IChwcml2YXRlS2V5OiBVaW50OEFycmF5KSA9PiBVaW50OEFycmF5O1xuICAgIGdldEV4dGVuZGVkUHVibGljS2V5OiAoa2V5OiBIZXgpID0+IHtcbiAgICAgIGhlYWQ6IFVpbnQ4QXJyYXk7XG4gICAgICBwcmVmaXg6IFVpbnQ4QXJyYXk7XG4gICAgICBzY2FsYXI6IGJpZ2ludDtcbiAgICAgIHBvaW50OiBFZHdhcmRzUG9pbnQ7XG4gICAgICBwb2ludEJ5dGVzOiBVaW50OEFycmF5O1xuICAgIH07XG5cbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIGByYW5kb21TZWNyZXRLZXlgICovXG4gICAgcmFuZG9tUHJpdmF0ZUtleTogKHNlZWQ/OiBVaW50OEFycmF5KSA9PiBVaW50OEFycmF5O1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgYHBvaW50LnByZWNvbXB1dGUoKWAgKi9cbiAgICBwcmVjb21wdXRlOiAod2luZG93U2l6ZT86IG51bWJlciwgcG9pbnQ/OiBFZHdhcmRzUG9pbnQpID0+IEVkd2FyZHNQb2ludDtcbiAgfTtcbiAgbGVuZ3RoczogQ3VydmVMZW5ndGhzO1xufVxuXG5mdW5jdGlvbiBpc0VkVmFsaWRYWShGcDogSUZpZWxkPGJpZ2ludD4sIENVUlZFOiBFZHdhcmRzT3B0cywgeDogYmlnaW50LCB5OiBiaWdpbnQpOiBib29sZWFuIHtcbiAgY29uc3QgeDIgPSBGcC5zcXIoeCk7XG4gIGNvbnN0IHkyID0gRnAuc3FyKHkpO1xuICBjb25zdCBsZWZ0ID0gRnAuYWRkKEZwLm11bChDVVJWRS5hLCB4MiksIHkyKTtcbiAgY29uc3QgcmlnaHQgPSBGcC5hZGQoRnAuT05FLCBGcC5tdWwoQ1VSVkUuZCwgRnAubXVsKHgyLCB5MikpKTtcbiAgcmV0dXJuIEZwLmVxbChsZWZ0LCByaWdodCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlZHdhcmRzKHBhcmFtczogRWR3YXJkc09wdHMsIGV4dHJhT3B0czogRWR3YXJkc0V4dHJhT3B0cyA9IHt9KTogRWR3YXJkc1BvaW50Q29ucyB7XG4gIGNvbnN0IHZhbGlkYXRlZCA9IF9jcmVhdGVDdXJ2ZUZpZWxkcygnZWR3YXJkcycsIHBhcmFtcywgZXh0cmFPcHRzLCBleHRyYU9wdHMuRnBGbkxFKTtcbiAgY29uc3QgeyBGcCwgRm4gfSA9IHZhbGlkYXRlZDtcbiAgbGV0IENVUlZFID0gdmFsaWRhdGVkLkNVUlZFIGFzIEVkd2FyZHNPcHRzO1xuICBjb25zdCB7IGg6IGNvZmFjdG9yIH0gPSBDVVJWRTtcbiAgX3ZhbGlkYXRlT2JqZWN0KGV4dHJhT3B0cywge30sIHsgdXZSYXRpbzogJ2Z1bmN0aW9uJyB9KTtcblxuICAvLyBJbXBvcnRhbnQ6XG4gIC8vIFRoZXJlIGFyZSBzb21lIHBsYWNlcyB3aGVyZSBGcC5CWVRFUyBpcyB1c2VkIGluc3RlYWQgb2YgbkJ5dGVMZW5ndGguXG4gIC8vIFNvIGZhciwgZXZlcnl0aGluZyBoYXMgYmVlbiB0ZXN0ZWQgd2l0aCBjdXJ2ZXMgb2YgRnAuQllURVMgPT0gbkJ5dGVMZW5ndGguXG4gIC8vIFRPRE86IHRlc3QgYW5kIGZpbmQgY3VydmVzIHdoaWNoIGJlaGF2ZSBvdGhlcndpc2UuXG4gIGNvbnN0IE1BU0sgPSBfMm4gPDwgKEJpZ0ludChGbi5CWVRFUyAqIDgpIC0gXzFuKTtcbiAgY29uc3QgbW9kUCA9IChuOiBiaWdpbnQpID0+IEZwLmNyZWF0ZShuKTsgLy8gRnVuY3Rpb24gb3ZlcnJpZGVzXG5cbiAgLy8gc3FydCh1L3YpXG4gIGNvbnN0IHV2UmF0aW8gPVxuICAgIGV4dHJhT3B0cy51dlJhdGlvIHx8XG4gICAgKCh1OiBiaWdpbnQsIHY6IGJpZ2ludCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSwgdmFsdWU6IEZwLnNxcnQoRnAuZGl2KHUsIHYpKSB9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgdmFsdWU6IF8wbiB9O1xuICAgICAgfVxuICAgIH0pO1xuXG4gIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAvLyBlcXVhdGlvbiBheFx1MDBCMiArIHlcdTAwQjIgPSAxICsgZHhcdTAwQjJ5XHUwMEIyIHNob3VsZCB3b3JrIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gIGlmICghaXNFZFZhbGlkWFkoRnAsIENVUlZFLCBDVVJWRS5HeCwgQ1VSVkUuR3kpKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIGN1cnZlIHBhcmFtczogZ2VuZXJhdG9yIHBvaW50Jyk7XG5cbiAgLyoqXG4gICAqIEFzc2VydHMgY29vcmRpbmF0ZSBpcyB2YWxpZDogMCA8PSBuIDwgTUFTSy5cbiAgICogQ29vcmRpbmF0ZXMgPj0gRnAuT1JERVIgYXJlIGFsbG93ZWQgZm9yIHppcDIxNS5cbiAgICovXG4gIGZ1bmN0aW9uIGFjb29yZCh0aXRsZTogc3RyaW5nLCBuOiBiaWdpbnQsIGJhblplcm8gPSBmYWxzZSkge1xuICAgIGNvbnN0IG1pbiA9IGJhblplcm8gPyBfMW4gOiBfMG47XG4gICAgYUluUmFuZ2UoJ2Nvb3JkaW5hdGUgJyArIHRpdGxlLCBuLCBtaW4sIE1BU0spO1xuICAgIHJldHVybiBuO1xuICB9XG5cbiAgZnVuY3Rpb24gYWV4dHBvaW50KG90aGVyOiB1bmtub3duKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpIHRocm93IG5ldyBFcnJvcignRXh0ZW5kZWRQb2ludCBleHBlY3RlZCcpO1xuICB9XG4gIC8vIENvbnZlcnRzIEV4dGVuZGVkIHBvaW50IHRvIGRlZmF1bHQgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgY29uc3QgdG9BZmZpbmVNZW1vID0gbWVtb2l6ZWQoKHA6IFBvaW50LCBpej86IGJpZ2ludCk6IEFmZmluZVBvaW50PGJpZ2ludD4gPT4ge1xuICAgIGNvbnN0IHsgWCwgWSwgWiB9ID0gcDtcbiAgICBjb25zdCBpczAgPSBwLmlzMCgpO1xuICAgIGlmIChpeiA9PSBudWxsKSBpeiA9IGlzMCA/IF84biA6IChGcC5pbnYoWikgYXMgYmlnaW50KTsgLy8gOCB3YXMgY2hvc2VuIGFyYml0cmFyaWx5XG4gICAgY29uc3QgeCA9IG1vZFAoWCAqIGl6KTtcbiAgICBjb25zdCB5ID0gbW9kUChZICogaXopO1xuICAgIGNvbnN0IHp6ID0gRnAubXVsKFosIGl6KTtcbiAgICBpZiAoaXMwKSByZXR1cm4geyB4OiBfMG4sIHk6IF8xbiB9O1xuICAgIGlmICh6eiAhPT0gXzFuKSB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICByZXR1cm4geyB4LCB5IH07XG4gIH0pO1xuICBjb25zdCBhc3NlcnRWYWxpZE1lbW8gPSBtZW1vaXplZCgocDogUG9pbnQpID0+IHtcbiAgICBjb25zdCB7IGEsIGQgfSA9IENVUlZFO1xuICAgIGlmIChwLmlzMCgpKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogWkVSTycpOyAvLyBUT0RPOiBvcHRpbWl6ZSwgd2l0aCB2YXJzIGJlbG93P1xuICAgIC8vIEVxdWF0aW9uIGluIGFmZmluZSBjb29yZGluYXRlczogYXhcdTAwQjIgKyB5XHUwMEIyID0gMSArIGR4XHUwMEIyeVx1MDBCMlxuICAgIC8vIEVxdWF0aW9uIGluIHByb2plY3RpdmUgY29vcmRpbmF0ZXMgKFgvWiwgWS9aLCBaKTogIChhWFx1MDBCMiArIFlcdTAwQjIpWlx1MDBCMiA9IFpcdTIwNzQgKyBkWFx1MDBCMllcdTAwQjJcbiAgICBjb25zdCB7IFgsIFksIFosIFQgfSA9IHA7XG4gICAgY29uc3QgWDIgPSBtb2RQKFggKiBYKTsgLy8gWFx1MDBCMlxuICAgIGNvbnN0IFkyID0gbW9kUChZICogWSk7IC8vIFlcdTAwQjJcbiAgICBjb25zdCBaMiA9IG1vZFAoWiAqIFopOyAvLyBaXHUwMEIyXG4gICAgY29uc3QgWjQgPSBtb2RQKFoyICogWjIpOyAvLyBaXHUyMDc0XG4gICAgY29uc3QgYVgyID0gbW9kUChYMiAqIGEpOyAvLyBhWFx1MDBCMlxuICAgIGNvbnN0IGxlZnQgPSBtb2RQKFoyICogbW9kUChhWDIgKyBZMikpOyAvLyAoYVhcdTAwQjIgKyBZXHUwMEIyKVpcdTAwQjJcbiAgICBjb25zdCByaWdodCA9IG1vZFAoWjQgKyBtb2RQKGQgKiBtb2RQKFgyICogWTIpKSk7IC8vIFpcdTIwNzQgKyBkWFx1MDBCMllcdTAwQjJcbiAgICBpZiAobGVmdCAhPT0gcmlnaHQpIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0ICgxKScpO1xuICAgIC8vIEluIEV4dGVuZGVkIGNvb3JkaW5hdGVzIHdlIGFsc28gaGF2ZSBULCB3aGljaCBpcyB4Knk9VC9aOiBjaGVjayBYKlkgPT0gWipUXG4gICAgY29uc3QgWFkgPSBtb2RQKFggKiBZKTtcbiAgICBjb25zdCBaVCA9IG1vZFAoWiAqIFQpO1xuICAgIGlmIChYWSAhPT0gWlQpIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0ICgyKScpO1xuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuICAvLyBFeHRlbmRlZCBQb2ludCB3b3JrcyBpbiBleHRlbmRlZCBjb29yZGluYXRlczogKFgsIFksIFosIFQpIFx1MjIwQiAoeD1YL1osIHk9WS9aLCBUPXh5KS5cbiAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHdpc3RlZF9FZHdhcmRzX2N1cnZlI0V4dGVuZGVkX2Nvb3JkaW5hdGVzXG4gIGNsYXNzIFBvaW50IGltcGxlbWVudHMgRWR3YXJkc1BvaW50IHtcbiAgICAvLyBiYXNlIC8gZ2VuZXJhdG9yIHBvaW50XG4gICAgc3RhdGljIHJlYWRvbmx5IEJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBfMW4sIG1vZFAoQ1VSVkUuR3ggKiBDVVJWRS5HeSkpO1xuICAgIC8vIHplcm8gLyBpbmZpbml0eSAvIGlkZW50aXR5IHBvaW50XG4gICAgc3RhdGljIHJlYWRvbmx5IFpFUk8gPSBuZXcgUG9pbnQoXzBuLCBfMW4sIF8xbiwgXzBuKTsgLy8gMCwgMSwgMSwgMFxuICAgIC8vIG1hdGggZmllbGRcbiAgICBzdGF0aWMgcmVhZG9ubHkgRnAgPSBGcDtcbiAgICAvLyBzY2FsYXIgZmllbGRcbiAgICBzdGF0aWMgcmVhZG9ubHkgRm4gPSBGbjtcblxuICAgIHJlYWRvbmx5IFg6IGJpZ2ludDtcbiAgICByZWFkb25seSBZOiBiaWdpbnQ7XG4gICAgcmVhZG9ubHkgWjogYmlnaW50O1xuICAgIHJlYWRvbmx5IFQ6IGJpZ2ludDtcblxuICAgIGNvbnN0cnVjdG9yKFg6IGJpZ2ludCwgWTogYmlnaW50LCBaOiBiaWdpbnQsIFQ6IGJpZ2ludCkge1xuICAgICAgdGhpcy5YID0gYWNvb3JkKCd4JywgWCk7XG4gICAgICB0aGlzLlkgPSBhY29vcmQoJ3knLCBZKTtcbiAgICAgIHRoaXMuWiA9IGFjb29yZCgneicsIFosIHRydWUpO1xuICAgICAgdGhpcy5UID0gYWNvb3JkKCd0JywgVCk7XG4gICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cblxuICAgIHN0YXRpYyBDVVJWRSgpOiBFZHdhcmRzT3B0cyB7XG4gICAgICByZXR1cm4gQ1VSVkU7XG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21BZmZpbmUocDogQWZmaW5lUG9pbnQ8YmlnaW50Pik6IFBvaW50IHtcbiAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpIHRocm93IG5ldyBFcnJvcignZXh0ZW5kZWQgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcbiAgICAgIGFjb29yZCgneCcsIHgpO1xuICAgICAgYWNvb3JkKCd5JywgeSk7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHksIF8xbiwgbW9kUCh4ICogeSkpO1xuICAgIH1cblxuICAgIC8vIFVzZXMgYWxnbyBmcm9tIFJGQzgwMzIgNS4xLjMuXG4gICAgc3RhdGljIGZyb21CeXRlcyhieXRlczogVWludDhBcnJheSwgemlwMjE1ID0gZmFsc2UpOiBQb2ludCB7XG4gICAgICBjb25zdCBsZW4gPSBGcC5CWVRFUztcbiAgICAgIGNvbnN0IHsgYSwgZCB9ID0gQ1VSVkU7XG4gICAgICBieXRlcyA9IGNvcHlCeXRlcyhhYnl0ZXMoYnl0ZXMsIGxlbiwgJ3BvaW50JykpO1xuICAgICAgYWJvb2woemlwMjE1LCAnemlwMjE1Jyk7XG4gICAgICBjb25zdCBub3JtZWQgPSBjb3B5Qnl0ZXMoYnl0ZXMpOyAvLyBjb3B5IGFnYWluLCB3ZSdsbCBtYW5pcHVsYXRlIGl0XG4gICAgICBjb25zdCBsYXN0Qnl0ZSA9IGJ5dGVzW2xlbiAtIDFdOyAvLyBzZWxlY3QgbGFzdCBieXRlXG4gICAgICBub3JtZWRbbGVuIC0gMV0gPSBsYXN0Qnl0ZSAmIH4weDgwOyAvLyBjbGVhciBsYXN0IGJpdFxuICAgICAgY29uc3QgeSA9IGJ5dGVzVG9OdW1iZXJMRShub3JtZWQpO1xuXG4gICAgICAvLyB6aXAyMTU9dHJ1ZSBpcyBnb29kIGZvciBjb25zZW5zdXMtY3JpdGljYWwgYXBwcy4gPWZhbHNlIGZvbGxvd3MgUkZDODAzMiAvIE5JU1QxODYtNS5cbiAgICAgIC8vIFJGQzgwMzIgcHJvaGliaXRzID49IHAsIGJ1dCBaSVAyMTUgZG9lc24ndFxuICAgICAgLy8gemlwMjE1PXRydWU6ICAwIDw9IHkgPCBNQVNLICgyXjI1NiBmb3IgZWQyNTUxOSlcbiAgICAgIC8vIHppcDIxNT1mYWxzZTogMCA8PSB5IDwgUCAoMl4yNTUtMTkgZm9yIGVkMjU1MTkpXG4gICAgICBjb25zdCBtYXggPSB6aXAyMTUgPyBNQVNLIDogRnAuT1JERVI7XG4gICAgICBhSW5SYW5nZSgncG9pbnQueScsIHksIF8wbiwgbWF4KTtcblxuICAgICAgLy8gRWQyNTUxOTogeFx1MDBCMiA9ICh5XHUwMEIyLTEpLyhkeVx1MDBCMisxKSBtb2QgcC4gRWQ0NDg6IHhcdTAwQjIgPSAoeVx1MDBCMi0xKS8oZHlcdTAwQjItMSkgbW9kIHAuIEdlbmVyaWMgY2FzZTpcbiAgICAgIC8vIGF4XHUwMEIyK3lcdTAwQjI9MStkeFx1MDBCMnlcdTAwQjIgPT4geVx1MDBCMi0xPWR4XHUwMEIyeVx1MDBCMi1heFx1MDBCMiA9PiB5XHUwMEIyLTE9eFx1MDBCMihkeVx1MDBCMi1hKSA9PiB4XHUwMEIyPSh5XHUwMEIyLTEpLyhkeVx1MDBCMi1hKVxuICAgICAgY29uc3QgeTIgPSBtb2RQKHkgKiB5KTsgLy8gZGVub21pbmF0b3IgaXMgYWx3YXlzIG5vbi0wIG1vZCBwLlxuICAgICAgY29uc3QgdSA9IG1vZFAoeTIgLSBfMW4pOyAvLyB1ID0geVx1MDBCMiAtIDFcbiAgICAgIGNvbnN0IHYgPSBtb2RQKGQgKiB5MiAtIGEpOyAvLyB2ID0gZCB5XHUwMEIyICsgMS5cbiAgICAgIGxldCB7IGlzVmFsaWQsIHZhbHVlOiB4IH0gPSB1dlJhdGlvKHUsIHYpOyAvLyBcdTIyMUEodS92KVxuICAgICAgaWYgKCFpc1ZhbGlkKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogaW52YWxpZCB5IGNvb3JkaW5hdGUnKTtcbiAgICAgIGNvbnN0IGlzWE9kZCA9ICh4ICYgXzFuKSA9PT0gXzFuOyAvLyBUaGVyZSBhcmUgMiBzcXVhcmUgcm9vdHMuIFVzZSB4XzAgYml0IHRvIHNlbGVjdCBwcm9wZXJcbiAgICAgIGNvbnN0IGlzTGFzdEJ5dGVPZGQgPSAobGFzdEJ5dGUgJiAweDgwKSAhPT0gMDsgLy8geF8wLCBsYXN0IGJpdFxuICAgICAgaWYgKCF6aXAyMTUgJiYgeCA9PT0gXzBuICYmIGlzTGFzdEJ5dGVPZGQpXG4gICAgICAgIC8vIGlmIHg9MCBhbmQgeF8wID0gMSwgZmFpbFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeD0wIGFuZCB4XzA9MScpO1xuICAgICAgaWYgKGlzTGFzdEJ5dGVPZGQgIT09IGlzWE9kZCkgeCA9IG1vZFAoLXgpOyAvLyBpZiB4XzAgIT0geCBtb2QgMiwgc2V0IHggPSBwLXhcbiAgICAgIHJldHVybiBQb2ludC5mcm9tQWZmaW5lKHsgeCwgeSB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21IZXgoYnl0ZXM6IFVpbnQ4QXJyYXksIHppcDIxNSA9IGZhbHNlKTogUG9pbnQge1xuICAgICAgcmV0dXJuIFBvaW50LmZyb21CeXRlcyhlbnN1cmVCeXRlcygncG9pbnQnLCBieXRlcyksIHppcDIxNSk7XG4gICAgfVxuXG4gICAgZ2V0IHgoKTogYmlnaW50IHtcbiAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICB9XG4gICAgZ2V0IHkoKTogYmlnaW50IHtcbiAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICB9XG5cbiAgICBwcmVjb21wdXRlKHdpbmRvd1NpemU6IG51bWJlciA9IDgsIGlzTGF6eSA9IHRydWUpIHtcbiAgICAgIHduYWYuY3JlYXRlQ2FjaGUodGhpcywgd2luZG93U2l6ZSk7XG4gICAgICBpZiAoIWlzTGF6eSkgdGhpcy5tdWx0aXBseShfMm4pOyAvLyByYW5kb20gbnVtYmVyXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBVc2VmdWwgaW4gZnJvbUFmZmluZSgpIC0gbm90IGZvciBmcm9tQnl0ZXMoKSwgd2hpY2ggYWx3YXlzIGNyZWF0ZWQgdmFsaWQgcG9pbnRzLlxuICAgIGFzc2VydFZhbGlkaXR5KCk6IHZvaWQge1xuICAgICAgYXNzZXJ0VmFsaWRNZW1vKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgZXF1YWxzKG90aGVyOiBQb2ludCk6IGJvb2xlYW4ge1xuICAgICAgYWV4dHBvaW50KG90aGVyKTtcbiAgICAgIGNvbnN0IHsgWDogWDEsIFk6IFkxLCBaOiBaMSB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHsgWDogWDIsIFk6IFkyLCBaOiBaMiB9ID0gb3RoZXI7XG4gICAgICBjb25zdCBYMVoyID0gbW9kUChYMSAqIFoyKTtcbiAgICAgIGNvbnN0IFgyWjEgPSBtb2RQKFgyICogWjEpO1xuICAgICAgY29uc3QgWTFaMiA9IG1vZFAoWTEgKiBaMik7XG4gICAgICBjb25zdCBZMloxID0gbW9kUChZMiAqIFoxKTtcbiAgICAgIHJldHVybiBYMVoyID09PSBYMloxICYmIFkxWjIgPT09IFkyWjE7XG4gICAgfVxuXG4gICAgaXMwKCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgIH1cblxuICAgIG5lZ2F0ZSgpOiBQb2ludCB7XG4gICAgICAvLyBGbGlwcyBwb2ludCBzaWduIHRvIGEgbmVnYXRpdmUgb25lICgteCwgeSBpbiBhZmZpbmUgY29vcmRzKVxuICAgICAgcmV0dXJuIG5ldyBQb2ludChtb2RQKC10aGlzLlgpLCB0aGlzLlksIHRoaXMuWiwgbW9kUCgtdGhpcy5UKSk7XG4gICAgfVxuXG4gICAgLy8gRmFzdCBhbGdvIGZvciBkb3VibGluZyBFeHRlbmRlZCBQb2ludC5cbiAgICAvLyBodHRwczovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLmh0bWwjZG91YmxpbmctZGJsLTIwMDgtaHdjZFxuICAgIC8vIENvc3Q6IDRNICsgNFMgKyAxKmEgKyA2YWRkICsgMSoyLlxuICAgIGRvdWJsZSgpOiBQb2ludCB7XG4gICAgICBjb25zdCB7IGEgfSA9IENVUlZFO1xuICAgICAgY29uc3QgeyBYOiBYMSwgWTogWTEsIFo6IFoxIH0gPSB0aGlzO1xuICAgICAgY29uc3QgQSA9IG1vZFAoWDEgKiBYMSk7IC8vIEEgPSBYMTJcbiAgICAgIGNvbnN0IEIgPSBtb2RQKFkxICogWTEpOyAvLyBCID0gWTEyXG4gICAgICBjb25zdCBDID0gbW9kUChfMm4gKiBtb2RQKFoxICogWjEpKTsgLy8gQyA9IDIqWjEyXG4gICAgICBjb25zdCBEID0gbW9kUChhICogQSk7IC8vIEQgPSBhKkFcbiAgICAgIGNvbnN0IHgxeTEgPSBYMSArIFkxO1xuICAgICAgY29uc3QgRSA9IG1vZFAobW9kUCh4MXkxICogeDF5MSkgLSBBIC0gQik7IC8vIEUgPSAoWDErWTEpMi1BLUJcbiAgICAgIGNvbnN0IEcgPSBEICsgQjsgLy8gRyA9IEQrQlxuICAgICAgY29uc3QgRiA9IEcgLSBDOyAvLyBGID0gRy1DXG4gICAgICBjb25zdCBIID0gRCAtIEI7IC8vIEggPSBELUJcbiAgICAgIGNvbnN0IFgzID0gbW9kUChFICogRik7IC8vIFgzID0gRSpGXG4gICAgICBjb25zdCBZMyA9IG1vZFAoRyAqIEgpOyAvLyBZMyA9IEcqSFxuICAgICAgY29uc3QgVDMgPSBtb2RQKEUgKiBIKTsgLy8gVDMgPSBFKkhcbiAgICAgIGNvbnN0IFozID0gbW9kUChGICogRyk7IC8vIFozID0gRipHXG4gICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMsIFQzKTtcbiAgICB9XG5cbiAgICAvLyBGYXN0IGFsZ28gZm9yIGFkZGluZyAyIEV4dGVuZGVkIFBvaW50cy5cbiAgICAvLyBodHRwczovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLmh0bWwjYWRkaXRpb24tYWRkLTIwMDgtaHdjZFxuICAgIC8vIENvc3Q6IDlNICsgMSphICsgMSpkICsgN2FkZC5cbiAgICBhZGQob3RoZXI6IFBvaW50KSB7XG4gICAgICBhZXh0cG9pbnQob3RoZXIpO1xuICAgICAgY29uc3QgeyBhLCBkIH0gPSBDVVJWRTtcbiAgICAgIGNvbnN0IHsgWDogWDEsIFk6IFkxLCBaOiBaMSwgVDogVDEgfSA9IHRoaXM7XG4gICAgICBjb25zdCB7IFg6IFgyLCBZOiBZMiwgWjogWjIsIFQ6IFQyIH0gPSBvdGhlcjtcbiAgICAgIGNvbnN0IEEgPSBtb2RQKFgxICogWDIpOyAvLyBBID0gWDEqWDJcbiAgICAgIGNvbnN0IEIgPSBtb2RQKFkxICogWTIpOyAvLyBCID0gWTEqWTJcbiAgICAgIGNvbnN0IEMgPSBtb2RQKFQxICogZCAqIFQyKTsgLy8gQyA9IFQxKmQqVDJcbiAgICAgIGNvbnN0IEQgPSBtb2RQKFoxICogWjIpOyAvLyBEID0gWjEqWjJcbiAgICAgIGNvbnN0IEUgPSBtb2RQKChYMSArIFkxKSAqIChYMiArIFkyKSAtIEEgLSBCKTsgLy8gRSA9IChYMStZMSkqKFgyK1kyKS1BLUJcbiAgICAgIGNvbnN0IEYgPSBEIC0gQzsgLy8gRiA9IEQtQ1xuICAgICAgY29uc3QgRyA9IEQgKyBDOyAvLyBHID0gRCtDXG4gICAgICBjb25zdCBIID0gbW9kUChCIC0gYSAqIEEpOyAvLyBIID0gQi1hKkFcbiAgICAgIGNvbnN0IFgzID0gbW9kUChFICogRik7IC8vIFgzID0gRSpGXG4gICAgICBjb25zdCBZMyA9IG1vZFAoRyAqIEgpOyAvLyBZMyA9IEcqSFxuICAgICAgY29uc3QgVDMgPSBtb2RQKEUgKiBIKTsgLy8gVDMgPSBFKkhcbiAgICAgIGNvbnN0IFozID0gbW9kUChGICogRyk7IC8vIFozID0gRipHXG4gICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMsIFQzKTtcbiAgICB9XG5cbiAgICBzdWJ0cmFjdChvdGhlcjogUG9pbnQpOiBQb2ludCB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgIH1cblxuICAgIC8vIENvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgbXVsdGlwbHkoc2NhbGFyOiBiaWdpbnQpOiBQb2ludCB7XG4gICAgICAvLyAxIDw9IHNjYWxhciA8IExcbiAgICAgIGlmICghRm4uaXNWYWxpZE5vdDAoc2NhbGFyKSkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNjYWxhcjogZXhwZWN0ZWQgMSA8PSBzYyA8IGN1cnZlLm4nKTtcbiAgICAgIGNvbnN0IHsgcCwgZiB9ID0gd25hZi5jYWNoZWQodGhpcywgc2NhbGFyLCAocCkgPT4gbm9ybWFsaXplWihQb2ludCwgcCkpO1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZVooUG9pbnQsIFtwLCBmXSlbMF07XG4gICAgfVxuXG4gICAgLy8gTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgIC8vIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgLy8gYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24uXG4gICAgLy8gRG9lcyBOT1QgYWxsb3cgc2NhbGFycyBoaWdoZXIgdGhhbiBDVVJWRS5uLlxuICAgIC8vIEFjY2VwdHMgb3B0aW9uYWwgYWNjdW11bGF0b3IgdG8gbWVyZ2Ugd2l0aCBtdWx0aXBseSAoaW1wb3J0YW50IGZvciBzcGFyc2Ugc2NhbGFycylcbiAgICBtdWx0aXBseVVuc2FmZShzY2FsYXI6IGJpZ2ludCwgYWNjID0gUG9pbnQuWkVSTyk6IFBvaW50IHtcbiAgICAgIC8vIDAgPD0gc2NhbGFyIDwgTFxuICAgICAgaWYgKCFGbi5pc1ZhbGlkKHNjYWxhcikpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYXI6IGV4cGVjdGVkIDAgPD0gc2MgPCBjdXJ2ZS5uJyk7XG4gICAgICBpZiAoc2NhbGFyID09PSBfMG4pIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgaWYgKHRoaXMuaXMwKCkgfHwgc2NhbGFyID09PSBfMW4pIHJldHVybiB0aGlzO1xuICAgICAgcmV0dXJuIHduYWYudW5zYWZlKHRoaXMsIHNjYWxhciwgKHApID0+IG5vcm1hbGl6ZVooUG9pbnQsIHApLCBhY2MpO1xuICAgIH1cblxuICAgIC8vIENoZWNrcyBpZiBwb2ludCBpcyBvZiBzbWFsbCBvcmRlci5cbiAgICAvLyBJZiB5b3UgYWRkIHNvbWV0aGluZyB0byBzbWFsbCBvcmRlciBwb2ludCwgeW91IHdpbGwgaGF2ZSBcImRpcnR5XCJcbiAgICAvLyBwb2ludCB3aXRoIHRvcnNpb24gY29tcG9uZW50LlxuICAgIC8vIE11bHRpcGxpZXMgcG9pbnQgYnkgY29mYWN0b3IgYW5kIGNoZWNrcyBpZiB0aGUgcmVzdWx0IGlzIDAuXG4gICAgaXNTbWFsbE9yZGVyKCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoY29mYWN0b3IpLmlzMCgpO1xuICAgIH1cblxuICAgIC8vIE11bHRpcGxpZXMgcG9pbnQgYnkgY3VydmUgb3JkZXIgYW5kIGNoZWNrcyBpZiB0aGUgcmVzdWx0IGlzIDAuXG4gICAgLy8gUmV0dXJucyBgZmFsc2VgIGlzIHRoZSBwb2ludCBpcyBkaXJ0eS5cbiAgICBpc1RvcnNpb25GcmVlKCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIHduYWYudW5zYWZlKHRoaXMsIENVUlZFLm4pLmlzMCgpO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnRzIEV4dGVuZGVkIHBvaW50IHRvIGRlZmF1bHQgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgIHRvQWZmaW5lKGludmVydGVkWj86IGJpZ2ludCk6IEFmZmluZVBvaW50PGJpZ2ludD4ge1xuICAgICAgcmV0dXJuIHRvQWZmaW5lTWVtbyh0aGlzLCBpbnZlcnRlZFopO1xuICAgIH1cblxuICAgIGNsZWFyQ29mYWN0b3IoKTogUG9pbnQge1xuICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pIHJldHVybiB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoY29mYWN0b3IpO1xuICAgIH1cblxuICAgIHRvQnl0ZXMoKTogVWludDhBcnJheSB7XG4gICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgIC8vIEZwLnRvQnl0ZXMoKSBhbGxvd3Mgbm9uLWNhbm9uaWNhbCBlbmNvZGluZyBvZiB5ICg+PSBwKS5cbiAgICAgIGNvbnN0IGJ5dGVzID0gRnAudG9CeXRlcyh5KTtcbiAgICAgIC8vIEVhY2ggeSBoYXMgMiB2YWxpZCBwb2ludHM6ICh4LCB5KSwgKHgsLXkpLlxuICAgICAgLy8gV2hlbiBjb21wcmVzc2luZywgaXQncyBlbm91Z2ggdG8gc3RvcmUgeSBhbmQgdXNlIHRoZSBsYXN0IGJ5dGUgdG8gZW5jb2RlIHNpZ24gb2YgeFxuICAgICAgYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gfD0geCAmIF8xbiA/IDB4ODAgOiAwO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICB0b0hleCgpOiBzdHJpbmcge1xuICAgICAgcmV0dXJuIGJ5dGVzVG9IZXgodGhpcy50b0J5dGVzKCkpO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGA8UG9pbnQgJHt0aGlzLmlzMCgpID8gJ1pFUk8nIDogdGhpcy50b0hleCgpfT5gO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZVxuICAgIGdldCBleCgpOiBiaWdpbnQge1xuICAgICAgcmV0dXJuIHRoaXMuWDtcbiAgICB9XG4gICAgZ2V0IGV5KCk6IGJpZ2ludCB7XG4gICAgICByZXR1cm4gdGhpcy5ZO1xuICAgIH1cbiAgICBnZXQgZXooKTogYmlnaW50IHtcbiAgICAgIHJldHVybiB0aGlzLlo7XG4gICAgfVxuICAgIGdldCBldCgpOiBiaWdpbnQge1xuICAgICAgcmV0dXJuIHRoaXMuVDtcbiAgICB9XG4gICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzOiBQb2ludFtdKTogUG9pbnRbXSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplWihQb2ludCwgcG9pbnRzKTtcbiAgICB9XG4gICAgc3RhdGljIG1zbShwb2ludHM6IFBvaW50W10sIHNjYWxhcnM6IGJpZ2ludFtdKTogUG9pbnQge1xuICAgICAgcmV0dXJuIHBpcHBlbmdlcihQb2ludCwgRm4sIHBvaW50cywgc2NhbGFycyk7XG4gICAgfVxuICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemU6IG51bWJlcikge1xuICAgICAgdGhpcy5wcmVjb21wdXRlKHdpbmRvd1NpemUpO1xuICAgIH1cbiAgICB0b1Jhd0J5dGVzKCk6IFVpbnQ4QXJyYXkge1xuICAgICAgcmV0dXJuIHRoaXMudG9CeXRlcygpO1xuICAgIH1cbiAgfVxuICBjb25zdCB3bmFmID0gbmV3IHdOQUYoUG9pbnQsIEZuLkJJVFMpO1xuICBQb2ludC5CQVNFLnByZWNvbXB1dGUoOCk7IC8vIEVuYWJsZSBwcmVjb21wdXRlcy4gU2xvd3MgZG93biBmaXJzdCBwdWJsaWNLZXkgY29tcHV0YXRpb24gYnkgMjBtcy5cbiAgcmV0dXJuIFBvaW50O1xufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHByaW1lLW9yZGVyIHBvaW50cyBsaWtlIFJpc3RyZXR0bzI1NSBhbmQgRGVjYWY0NDguXG4gKiBUaGVzZSBwb2ludHMgZWxpbWluYXRlIGNvZmFjdG9yIGlzc3VlcyBieSByZXByZXNlbnRpbmcgZXF1aXZhbGVuY2UgY2xhc3Nlc1xuICogb2YgRWR3YXJkcyBjdXJ2ZSBwb2ludHMuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQcmltZUVkd2FyZHNQb2ludDxUIGV4dGVuZHMgUHJpbWVFZHdhcmRzUG9pbnQ8VD4+XG4gIGltcGxlbWVudHMgQ3VydmVQb2ludDxiaWdpbnQsIFQ+XG57XG4gIHN0YXRpYyBCQVNFOiBQcmltZUVkd2FyZHNQb2ludDxhbnk+O1xuICBzdGF0aWMgWkVSTzogUHJpbWVFZHdhcmRzUG9pbnQ8YW55PjtcbiAgc3RhdGljIEZwOiBJRmllbGQ8YmlnaW50PjtcbiAgc3RhdGljIEZuOiBJRmllbGQ8YmlnaW50PjtcblxuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZXA6IEVkd2FyZHNQb2ludDtcblxuICBjb25zdHJ1Y3RvcihlcDogRWR3YXJkc1BvaW50KSB7XG4gICAgdGhpcy5lcCA9IGVwO1xuICB9XG5cbiAgLy8gQWJzdHJhY3QgbWV0aG9kcyB0aGF0IG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3Nlc1xuICBhYnN0cmFjdCB0b0J5dGVzKCk6IFVpbnQ4QXJyYXk7XG4gIGFic3RyYWN0IGVxdWFscyhvdGhlcjogVCk6IGJvb2xlYW47XG5cbiAgLy8gU3RhdGljIG1ldGhvZHMgdGhhdCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXNcbiAgc3RhdGljIGZyb21CeXRlcyhfYnl0ZXM6IFVpbnQ4QXJyYXkpOiBhbnkge1xuICAgIG5vdEltcGxlbWVudGVkKCk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUhleChfaGV4OiBIZXgpOiBhbnkge1xuICAgIG5vdEltcGxlbWVudGVkKCk7XG4gIH1cblxuICBnZXQgeCgpOiBiaWdpbnQge1xuICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgfVxuICBnZXQgeSgpOiBiaWdpbnQge1xuICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgfVxuXG4gIC8vIENvbW1vbiBpbXBsZW1lbnRhdGlvbnNcbiAgY2xlYXJDb2ZhY3RvcigpOiBUIHtcbiAgICAvLyBuby1vcCBmb3IgcHJpbWUtb3JkZXIgZ3JvdXBzXG4gICAgcmV0dXJuIHRoaXMgYXMgYW55O1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRpdHkoKTogdm9pZCB7XG4gICAgdGhpcy5lcC5hc3NlcnRWYWxpZGl0eSgpO1xuICB9XG5cbiAgdG9BZmZpbmUoaW52ZXJ0ZWRaPzogYmlnaW50KTogQWZmaW5lUG9pbnQ8YmlnaW50PiB7XG4gICAgcmV0dXJuIHRoaXMuZXAudG9BZmZpbmUoaW52ZXJ0ZWRaKTtcbiAgfVxuXG4gIHRvSGV4KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGJ5dGVzVG9IZXgodGhpcy50b0J5dGVzKCkpO1xuICB9XG5cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy50b0hleCgpO1xuICB9XG5cbiAgaXNUb3JzaW9uRnJlZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlzU21hbGxPcmRlcigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBhZGQob3RoZXI6IFQpOiBUIHtcbiAgICB0aGlzLmFzc2VydFNhbWUob3RoZXIpO1xuICAgIHJldHVybiB0aGlzLmluaXQodGhpcy5lcC5hZGQob3RoZXIuZXApKTtcbiAgfVxuXG4gIHN1YnRyYWN0KG90aGVyOiBUKTogVCB7XG4gICAgdGhpcy5hc3NlcnRTYW1lKG90aGVyKTtcbiAgICByZXR1cm4gdGhpcy5pbml0KHRoaXMuZXAuc3VidHJhY3Qob3RoZXIuZXApKTtcbiAgfVxuXG4gIG11bHRpcGx5KHNjYWxhcjogYmlnaW50KTogVCB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdCh0aGlzLmVwLm11bHRpcGx5KHNjYWxhcikpO1xuICB9XG5cbiAgbXVsdGlwbHlVbnNhZmUoc2NhbGFyOiBiaWdpbnQpOiBUIHtcbiAgICByZXR1cm4gdGhpcy5pbml0KHRoaXMuZXAubXVsdGlwbHlVbnNhZmUoc2NhbGFyKSk7XG4gIH1cblxuICBkb3VibGUoKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdCh0aGlzLmVwLmRvdWJsZSgpKTtcbiAgfVxuXG4gIG5lZ2F0ZSgpOiBUIHtcbiAgICByZXR1cm4gdGhpcy5pbml0KHRoaXMuZXAubmVnYXRlKCkpO1xuICB9XG5cbiAgcHJlY29tcHV0ZSh3aW5kb3dTaXplPzogbnVtYmVyLCBpc0xhenk/OiBib29sZWFuKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdCh0aGlzLmVwLnByZWNvbXB1dGUod2luZG93U2l6ZSwgaXNMYXp5KSk7XG4gIH1cblxuICAvLyBIZWxwZXIgbWV0aG9kc1xuICBhYnN0cmFjdCBpczAoKTogYm9vbGVhbjtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IGFzc2VydFNhbWUob3RoZXI6IFQpOiB2b2lkO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgaW5pdChlcDogRWR3YXJkc1BvaW50KTogVDtcblxuICAvKiogQGRlcHJlY2F0ZWQgdXNlIGB0b0J5dGVzYCAqL1xuICB0b1Jhd0J5dGVzKCk6IFVpbnQ4QXJyYXkge1xuICAgIHJldHVybiB0aGlzLnRvQnl0ZXMoKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIEVkRFNBIHNpZ25hdHVyZXMgb3ZlciBnaXZlbiBFZHdhcmRzIGN1cnZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZWRkc2EoUG9pbnQ6IEVkd2FyZHNQb2ludENvbnMsIGNIYXNoOiBGSGFzaCwgZWRkc2FPcHRzOiBFZERTQU9wdHMgPSB7fSk6IEVkRFNBIHtcbiAgaWYgKHR5cGVvZiBjSGFzaCAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdcImhhc2hcIiBmdW5jdGlvbiBwYXJhbSBpcyByZXF1aXJlZCcpO1xuICBfdmFsaWRhdGVPYmplY3QoXG4gICAgZWRkc2FPcHRzLFxuICAgIHt9LFxuICAgIHtcbiAgICAgIGFkanVzdFNjYWxhckJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgcmFuZG9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICBkb21haW46ICdmdW5jdGlvbicsXG4gICAgICBwcmVoYXNoOiAnZnVuY3Rpb24nLFxuICAgICAgbWFwVG9DdXJ2ZTogJ2Z1bmN0aW9uJyxcbiAgICB9XG4gICk7XG5cbiAgY29uc3QgeyBwcmVoYXNoIH0gPSBlZGRzYU9wdHM7XG4gIGNvbnN0IHsgQkFTRSwgRnAsIEZuIH0gPSBQb2ludDtcblxuICBjb25zdCByYW5kb21CeXRlcyA9IGVkZHNhT3B0cy5yYW5kb21CeXRlcyB8fCByYW5kb21CeXRlc1dlYjtcbiAgY29uc3QgYWRqdXN0U2NhbGFyQnl0ZXMgPSBlZGRzYU9wdHMuYWRqdXN0U2NhbGFyQnl0ZXMgfHwgKChieXRlczogVWludDhBcnJheSkgPT4gYnl0ZXMpO1xuICBjb25zdCBkb21haW4gPVxuICAgIGVkZHNhT3B0cy5kb21haW4gfHxcbiAgICAoKGRhdGE6IFVpbnQ4QXJyYXksIGN0eDogVWludDhBcnJheSwgcGhmbGFnOiBib29sZWFuKSA9PiB7XG4gICAgICBhYm9vbChwaGZsYWcsICdwaGZsYWcnKTtcbiAgICAgIGlmIChjdHgubGVuZ3RoIHx8IHBoZmxhZykgdGhyb3cgbmV3IEVycm9yKCdDb250ZXh0cy9wcmUtaGFzaCBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSk7IC8vIE5PT1BcblxuICAvLyBMaXR0bGUtZW5kaWFuIFNIQTUxMiB3aXRoIG1vZHVsbyBuXG4gIGZ1bmN0aW9uIG1vZE5fTEUoaGFzaDogVWludDhBcnJheSk6IGJpZ2ludCB7XG4gICAgcmV0dXJuIEZuLmNyZWF0ZShieXRlc1RvTnVtYmVyTEUoaGFzaCkpOyAvLyBOb3QgRm4uZnJvbUJ5dGVzOiBpdCBoYXMgbGVuZ3RoIGxpbWl0XG4gIH1cblxuICAvLyBHZXQgdGhlIGhhc2hlZCBwcml2YXRlIHNjYWxhciBwZXIgUkZDODAzMiA1LjEuNVxuICBmdW5jdGlvbiBnZXRQcml2YXRlU2NhbGFyKGtleTogSGV4KSB7XG4gICAgY29uc3QgbGVuID0gbGVuZ3Rocy5zZWNyZXRLZXk7XG4gICAga2V5ID0gZW5zdXJlQnl0ZXMoJ3ByaXZhdGUga2V5Jywga2V5LCBsZW4pO1xuICAgIC8vIEhhc2ggcHJpdmF0ZSBrZXkgd2l0aCBjdXJ2ZSdzIGhhc2ggZnVuY3Rpb24gdG8gcHJvZHVjZSB1bmlmb3JtaW5nbHkgcmFuZG9tIGlucHV0XG4gICAgLy8gQ2hlY2sgYnl0ZSBsZW5ndGhzOiBlbnN1cmUoNjQsIGgoZW5zdXJlKDMyLCBrZXkpKSlcbiAgICBjb25zdCBoYXNoZWQgPSBlbnN1cmVCeXRlcygnaGFzaGVkIHByaXZhdGUga2V5JywgY0hhc2goa2V5KSwgMiAqIGxlbik7XG4gICAgY29uc3QgaGVhZCA9IGFkanVzdFNjYWxhckJ5dGVzKGhhc2hlZC5zbGljZSgwLCBsZW4pKTsgLy8gY2xlYXIgZmlyc3QgaGFsZiBiaXRzLCBwcm9kdWNlIEZFXG4gICAgY29uc3QgcHJlZml4ID0gaGFzaGVkLnNsaWNlKGxlbiwgMiAqIGxlbik7IC8vIHNlY29uZCBoYWxmIGlzIGNhbGxlZCBrZXkgcHJlZml4ICg1LjEuNilcbiAgICBjb25zdCBzY2FsYXIgPSBtb2ROX0xFKGhlYWQpOyAvLyBUaGUgYWN0dWFsIHByaXZhdGUgc2NhbGFyXG4gICAgcmV0dXJuIHsgaGVhZCwgcHJlZml4LCBzY2FsYXIgfTtcbiAgfVxuXG4gIC8qKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBjcmVhdGVzIHB1YmxpYyBrZXkgZnJvbSBzY2FsYXIuIFJGQzgwMzIgNS4xLjUgKi9cbiAgZnVuY3Rpb24gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkoc2VjcmV0S2V5OiBIZXgpIHtcbiAgICBjb25zdCB7IGhlYWQsIHByZWZpeCwgc2NhbGFyIH0gPSBnZXRQcml2YXRlU2NhbGFyKHNlY3JldEtleSk7XG4gICAgY29uc3QgcG9pbnQgPSBCQVNFLm11bHRpcGx5KHNjYWxhcik7IC8vIFBvaW50IG9uIEVkd2FyZHMgY3VydmUgYWthIHB1YmxpYyBrZXlcbiAgICBjb25zdCBwb2ludEJ5dGVzID0gcG9pbnQudG9CeXRlcygpO1xuICAgIHJldHVybiB7IGhlYWQsIHByZWZpeCwgc2NhbGFyLCBwb2ludCwgcG9pbnRCeXRlcyB9O1xuICB9XG5cbiAgLyoqIENhbGN1bGF0ZXMgRWREU0EgcHViIGtleS4gUkZDODAzMiA1LjEuNS4gKi9cbiAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHNlY3JldEtleTogSGV4KTogVWludDhBcnJheSB7XG4gICAgcmV0dXJuIGdldEV4dGVuZGVkUHVibGljS2V5KHNlY3JldEtleSkucG9pbnRCeXRlcztcbiAgfVxuXG4gIC8vIGludCgnTEUnLCBTSEE1MTIoZG9tMihGLCBDKSB8fCBtc2dzKSkgbW9kIE5cbiAgZnVuY3Rpb24gaGFzaERvbWFpblRvU2NhbGFyKGNvbnRleHQ6IEhleCA9IFVpbnQ4QXJyYXkub2YoKSwgLi4ubXNnczogVWludDhBcnJheVtdKSB7XG4gICAgY29uc3QgbXNnID0gY29uY2F0Qnl0ZXMoLi4ubXNncyk7XG4gICAgcmV0dXJuIG1vZE5fTEUoY0hhc2goZG9tYWluKG1zZywgZW5zdXJlQnl0ZXMoJ2NvbnRleHQnLCBjb250ZXh0KSwgISFwcmVoYXNoKSkpO1xuICB9XG5cbiAgLyoqIFNpZ25zIG1lc3NhZ2Ugd2l0aCBwcml2YXRlS2V5LiBSRkM4MDMyIDUuMS42ICovXG4gIGZ1bmN0aW9uIHNpZ24obXNnOiBIZXgsIHNlY3JldEtleTogSGV4LCBvcHRpb25zOiB7IGNvbnRleHQ/OiBIZXggfSA9IHt9KTogVWludDhBcnJheSB7XG4gICAgbXNnID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtc2cpO1xuICAgIGlmIChwcmVoYXNoKSBtc2cgPSBwcmVoYXNoKG1zZyk7IC8vIGZvciBlZDI1NTE5cGggZXRjLlxuICAgIGNvbnN0IHsgcHJlZml4LCBzY2FsYXIsIHBvaW50Qnl0ZXMgfSA9IGdldEV4dGVuZGVkUHVibGljS2V5KHNlY3JldEtleSk7XG4gICAgY29uc3QgciA9IGhhc2hEb21haW5Ub1NjYWxhcihvcHRpb25zLmNvbnRleHQsIHByZWZpeCwgbXNnKTsgLy8gciA9IGRvbTIoRiwgQykgfHwgcHJlZml4IHx8IFBIKE0pXG4gICAgY29uc3QgUiA9IEJBU0UubXVsdGlwbHkocikudG9CeXRlcygpOyAvLyBSID0gckdcbiAgICBjb25zdCBrID0gaGFzaERvbWFpblRvU2NhbGFyKG9wdGlvbnMuY29udGV4dCwgUiwgcG9pbnRCeXRlcywgbXNnKTsgLy8gUiB8fCBBIHx8IFBIKE0pXG4gICAgY29uc3QgcyA9IEZuLmNyZWF0ZShyICsgayAqIHNjYWxhcik7IC8vIFMgPSAociArIGsgKiBzKSBtb2QgTFxuICAgIGlmICghRm4uaXNWYWxpZChzKSkgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogaW52YWxpZCBzJyk7IC8vIDAgPD0gcyA8IExcbiAgICBjb25zdCBycyA9IGNvbmNhdEJ5dGVzKFIsIEZuLnRvQnl0ZXMocykpO1xuICAgIHJldHVybiBhYnl0ZXMocnMsIGxlbmd0aHMuc2lnbmF0dXJlLCAncmVzdWx0Jyk7XG4gIH1cblxuICAvLyB2ZXJpZmljYXRpb24gcnVsZSBpcyBlaXRoZXIgemlwMjE1IG9yIHJmYzgwMzIgLyBuaXN0MTg2LTUuIENvbnN1bHQgZnJvbUhleDpcbiAgY29uc3QgdmVyaWZ5T3B0czogeyBjb250ZXh0PzogSGV4OyB6aXAyMTU/OiBib29sZWFuIH0gPSB7IHppcDIxNTogdHJ1ZSB9O1xuXG4gIC8qKlxuICAgKiBWZXJpZmllcyBFZERTQSBzaWduYXR1cmUgYWdhaW5zdCBtZXNzYWdlIGFuZCBwdWJsaWMga2V5LiBSRkM4MDMyIDUuMS43LlxuICAgKiBBbiBleHRlbmRlZCBncm91cCBlcXVhdGlvbiBpcyBjaGVja2VkLlxuICAgKi9cbiAgZnVuY3Rpb24gdmVyaWZ5KHNpZzogSGV4LCBtc2c6IEhleCwgcHVibGljS2V5OiBIZXgsIG9wdGlvbnMgPSB2ZXJpZnlPcHRzKTogYm9vbGVhbiB7XG4gICAgY29uc3QgeyBjb250ZXh0LCB6aXAyMTUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgbGVuID0gbGVuZ3Rocy5zaWduYXR1cmU7XG4gICAgc2lnID0gZW5zdXJlQnl0ZXMoJ3NpZ25hdHVyZScsIHNpZywgbGVuKTtcbiAgICBtc2cgPSBlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1zZyk7XG4gICAgcHVibGljS2V5ID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgbGVuZ3Rocy5wdWJsaWNLZXkpO1xuICAgIGlmICh6aXAyMTUgIT09IHVuZGVmaW5lZCkgYWJvb2woemlwMjE1LCAnemlwMjE1Jyk7XG4gICAgaWYgKHByZWhhc2gpIG1zZyA9IHByZWhhc2gobXNnKTsgLy8gZm9yIGVkMjU1MTlwaCwgZXRjXG5cbiAgICBjb25zdCBtaWQgPSBsZW4gLyAyO1xuICAgIGNvbnN0IHIgPSBzaWcuc3ViYXJyYXkoMCwgbWlkKTtcbiAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlckxFKHNpZy5zdWJhcnJheShtaWQsIGxlbikpO1xuICAgIGxldCBBLCBSLCBTQjtcbiAgICB0cnkge1xuICAgICAgLy8gemlwMjE1PXRydWUgaXMgZ29vZCBmb3IgY29uc2Vuc3VzLWNyaXRpY2FsIGFwcHMuID1mYWxzZSBmb2xsb3dzIFJGQzgwMzIgLyBOSVNUMTg2LTUuXG4gICAgICAvLyB6aXAyMTU9dHJ1ZTogIDAgPD0geSA8IE1BU0sgKDJeMjU2IGZvciBlZDI1NTE5KVxuICAgICAgLy8gemlwMjE1PWZhbHNlOiAwIDw9IHkgPCBQICgyXjI1NS0xOSBmb3IgZWQyNTUxOSlcbiAgICAgIEEgPSBQb2ludC5mcm9tQnl0ZXMocHVibGljS2V5LCB6aXAyMTUpO1xuICAgICAgUiA9IFBvaW50LmZyb21CeXRlcyhyLCB6aXAyMTUpO1xuICAgICAgU0IgPSBCQVNFLm11bHRpcGx5VW5zYWZlKHMpOyAvLyAwIDw9IHMgPCBsIGlzIGRvbmUgaW5zaWRlXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCF6aXAyMTUgJiYgQS5pc1NtYWxsT3JkZXIoKSkgcmV0dXJuIGZhbHNlOyAvLyB6aXAyMTUgYWxsb3dzIHB1YmxpYyBrZXlzIG9mIHNtYWxsIG9yZGVyXG5cbiAgICBjb25zdCBrID0gaGFzaERvbWFpblRvU2NhbGFyKGNvbnRleHQsIFIudG9CeXRlcygpLCBBLnRvQnl0ZXMoKSwgbXNnKTtcbiAgICBjb25zdCBSa0EgPSBSLmFkZChBLm11bHRpcGx5VW5zYWZlKGspKTtcbiAgICAvLyBFeHRlbmRlZCBncm91cCBlcXVhdGlvblxuICAgIC8vIFs4XVtTXUIgPSBbOF1SICsgWzhdW2tdQSdcbiAgICByZXR1cm4gUmtBLnN1YnRyYWN0KFNCKS5jbGVhckNvZmFjdG9yKCkuaXMwKCk7XG4gIH1cblxuICBjb25zdCBfc2l6ZSA9IEZwLkJZVEVTOyAvLyAzMiBmb3IgZWQyNTUxOSwgNTcgZm9yIGVkNDQ4XG4gIGNvbnN0IGxlbmd0aHMgPSB7XG4gICAgc2VjcmV0S2V5OiBfc2l6ZSxcbiAgICBwdWJsaWNLZXk6IF9zaXplLFxuICAgIHNpZ25hdHVyZTogMiAqIF9zaXplLFxuICAgIHNlZWQ6IF9zaXplLFxuICB9O1xuICBmdW5jdGlvbiByYW5kb21TZWNyZXRLZXkoc2VlZCA9IHJhbmRvbUJ5dGVzKGxlbmd0aHMuc2VlZCkpOiBVaW50OEFycmF5IHtcbiAgICByZXR1cm4gYWJ5dGVzKHNlZWQsIGxlbmd0aHMuc2VlZCwgJ3NlZWQnKTtcbiAgfVxuICBmdW5jdGlvbiBrZXlnZW4oc2VlZD86IFVpbnQ4QXJyYXkpIHtcbiAgICBjb25zdCBzZWNyZXRLZXkgPSB1dGlscy5yYW5kb21TZWNyZXRLZXkoc2VlZCk7XG4gICAgcmV0dXJuIHsgc2VjcmV0S2V5LCBwdWJsaWNLZXk6IGdldFB1YmxpY0tleShzZWNyZXRLZXkpIH07XG4gIH1cbiAgZnVuY3Rpb24gaXNWYWxpZFNlY3JldEtleShrZXk6IFVpbnQ4QXJyYXkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNCeXRlcyhrZXkpICYmIGtleS5sZW5ndGggPT09IEZuLkJZVEVTO1xuICB9XG4gIGZ1bmN0aW9uIGlzVmFsaWRQdWJsaWNLZXkoa2V5OiBVaW50OEFycmF5LCB6aXAyMTU/OiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAhIVBvaW50LmZyb21CeXRlcyhrZXksIHppcDIxNSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb25zdCB1dGlscyA9IHtcbiAgICBnZXRFeHRlbmRlZFB1YmxpY0tleSxcbiAgICByYW5kb21TZWNyZXRLZXksXG4gICAgaXNWYWxpZFNlY3JldEtleSxcbiAgICBpc1ZhbGlkUHVibGljS2V5LFxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGVkIHB1YmxpYyBrZXkgdG8geCBwdWJsaWMga2V5LiBVc2VzIGZvcm11bGE6XG4gICAgICogLSBlZDI1NTE5OlxuICAgICAqICAgLSBgKHUsIHYpID0gKCgxK3kpLygxLXkpLCBzcXJ0KC00ODY2NjQpKnUveClgXG4gICAgICogICAtIGAoeCwgeSkgPSAoc3FydCgtNDg2NjY0KSp1L3YsICh1LTEpLyh1KzEpKWBcbiAgICAgKiAtIGVkNDQ4OlxuICAgICAqICAgLSBgKHUsIHYpID0gKCh5LTEpLyh5KzEpLCBzcXJ0KDE1NjMyNCkqdS94KWBcbiAgICAgKiAgIC0gYCh4LCB5KSA9IChzcXJ0KDE1NjMyNCkqdS92LCAoMSt1KS8oMS11KSlgXG4gICAgICovXG4gICAgdG9Nb250Z29tZXJ5KHB1YmxpY0tleTogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkge1xuICAgICAgY29uc3QgeyB5IH0gPSBQb2ludC5mcm9tQnl0ZXMocHVibGljS2V5KTtcbiAgICAgIGNvbnN0IHNpemUgPSBsZW5ndGhzLnB1YmxpY0tleTtcbiAgICAgIGNvbnN0IGlzMjU1MTkgPSBzaXplID09PSAzMjtcbiAgICAgIGlmICghaXMyNTUxOSAmJiBzaXplICE9PSA1NykgdGhyb3cgbmV3IEVycm9yKCdvbmx5IGRlZmluZWQgZm9yIDI1NTE5IGFuZCA0NDgnKTtcbiAgICAgIGNvbnN0IHUgPSBpczI1NTE5ID8gRnAuZGl2KF8xbiArIHksIF8xbiAtIHkpIDogRnAuZGl2KHkgLSBfMW4sIHkgKyBfMW4pO1xuICAgICAgcmV0dXJuIEZwLnRvQnl0ZXModSk7XG4gICAgfSxcblxuICAgIHRvTW9udGdvbWVyeVNlY3JldChzZWNyZXRLZXk6IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5IHtcbiAgICAgIGNvbnN0IHNpemUgPSBsZW5ndGhzLnNlY3JldEtleTtcbiAgICAgIGFieXRlcyhzZWNyZXRLZXksIHNpemUpO1xuICAgICAgY29uc3QgaGFzaGVkID0gY0hhc2goc2VjcmV0S2V5LnN1YmFycmF5KDAsIHNpemUpKTtcbiAgICAgIHJldHVybiBhZGp1c3RTY2FsYXJCeXRlcyhoYXNoZWQpLnN1YmFycmF5KDAsIHNpemUpO1xuICAgIH0sXG5cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICByYW5kb21Qcml2YXRlS2V5OiByYW5kb21TZWNyZXRLZXksXG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQ6IEVkd2FyZHNQb2ludCA9IFBvaW50LkJBU0UpOiBFZHdhcmRzUG9pbnQge1xuICAgICAgcmV0dXJuIHBvaW50LnByZWNvbXB1dGUod2luZG93U2l6ZSwgZmFsc2UpO1xuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIGtleWdlbixcbiAgICBnZXRQdWJsaWNLZXksXG4gICAgc2lnbixcbiAgICB2ZXJpZnksXG4gICAgdXRpbHMsXG4gICAgUG9pbnQsXG4gICAgbGVuZ3RocyxcbiAgfSk7XG59XG5cbi8vIFRPRE86IHJlbW92ZSBldmVyeXRoaW5nIGJlbG93XG5leHBvcnQgdHlwZSBDdXJ2ZVR5cGUgPSBCYXNpY0N1cnZlPGJpZ2ludD4gJiB7XG4gIGE6IGJpZ2ludDsgLy8gY3VydmUgcGFyYW0gYVxuICBkOiBiaWdpbnQ7IC8vIGN1cnZlIHBhcmFtIGRcbiAgLyoqIEBkZXByZWNhdGVkIHRoZSBwcm9wZXJ0eSB3aWxsIGJlIHJlbW92ZWQgaW4gbmV4dCByZWxlYXNlICovXG4gIGhhc2g6IEZIYXNoOyAvLyBIYXNoaW5nXG4gIHJhbmRvbUJ5dGVzPzogKGJ5dGVzTGVuZ3RoPzogbnVtYmVyKSA9PiBVaW50OEFycmF5OyAvLyBDU1BSTkdcbiAgYWRqdXN0U2NhbGFyQnl0ZXM/OiAoYnl0ZXM6IFVpbnQ4QXJyYXkpID0+IFVpbnQ4QXJyYXk7IC8vIGNsZWFycyBiaXRzIHRvIGdldCB2YWxpZCBmaWVsZCBlbGVtdG5cbiAgZG9tYWluPzogKGRhdGE6IFVpbnQ4QXJyYXksIGN0eDogVWludDhBcnJheSwgcGhmbGFnOiBib29sZWFuKSA9PiBVaW50OEFycmF5OyAvLyBVc2VkIGZvciBoYXNoaW5nXG4gIHV2UmF0aW8/OiBVVlJhdGlvOyAvLyBSYXRpbyBcdTIyMUEodS92KVxuICBwcmVoYXNoPzogRkhhc2g7IC8vIFJGQyA4MDMyIHByZS1oYXNoaW5nIG9mIG1lc3NhZ2VzIHRvIHNpZ24oKSAvIHZlcmlmeSgpXG4gIG1hcFRvQ3VydmU/OiAoc2NhbGFyOiBiaWdpbnRbXSkgPT4gQWZmaW5lUG9pbnQ8YmlnaW50PjsgLy8gZm9yIGhhc2gtdG8tY3VydmUgc3RhbmRhcmRcbn07XG5leHBvcnQgdHlwZSBDdXJ2ZVR5cGVXaXRoTGVuZ3RoID0gUmVhZG9ubHk8Q3VydmVUeXBlICYgUGFydGlhbDxOTGVuZ3RoPj47XG5leHBvcnQgdHlwZSBDdXJ2ZUZuID0ge1xuICAvKiogQGRlcHJlY2F0ZWQgdGhlIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZCBpbiBuZXh0IHJlbGVhc2UgKi9cbiAgQ1VSVkU6IEN1cnZlVHlwZTtcbiAga2V5Z2VuOiBFZERTQVsna2V5Z2VuJ107XG4gIGdldFB1YmxpY0tleTogRWREU0FbJ2dldFB1YmxpY0tleSddO1xuICBzaWduOiBFZERTQVsnc2lnbiddO1xuICB2ZXJpZnk6IEVkRFNBWyd2ZXJpZnknXTtcbiAgUG9pbnQ6IEVkd2FyZHNQb2ludENvbnM7XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgYFBvaW50YCAqL1xuICBFeHRlbmRlZFBvaW50OiBFZHdhcmRzUG9pbnRDb25zO1xuICB1dGlsczogRWREU0FbJ3V0aWxzJ107XG4gIGxlbmd0aHM6IEN1cnZlTGVuZ3Rocztcbn07XG5leHBvcnQgdHlwZSBFZENvbXBvc2VkID0ge1xuICBDVVJWRTogRWR3YXJkc09wdHM7XG4gIGN1cnZlT3B0czogRWR3YXJkc0V4dHJhT3B0cztcbiAgaGFzaDogRkhhc2g7XG4gIGVkZHNhT3B0czogRWREU0FPcHRzO1xufTtcbmZ1bmN0aW9uIF9lZGRzYV9sZWdhY3lfb3B0c190b19uZXcoYzogQ3VydmVUeXBlV2l0aExlbmd0aCk6IEVkQ29tcG9zZWQge1xuICBjb25zdCBDVVJWRTogRWR3YXJkc09wdHMgPSB7XG4gICAgYTogYy5hLFxuICAgIGQ6IGMuZCxcbiAgICBwOiBjLkZwLk9SREVSLFxuICAgIG46IGMubixcbiAgICBoOiBjLmgsXG4gICAgR3g6IGMuR3gsXG4gICAgR3k6IGMuR3ksXG4gIH07XG4gIGNvbnN0IEZwID0gYy5GcDtcbiAgY29uc3QgRm4gPSBGaWVsZChDVVJWRS5uLCBjLm5CaXRMZW5ndGgsIHRydWUpO1xuICBjb25zdCBjdXJ2ZU9wdHM6IEVkd2FyZHNFeHRyYU9wdHMgPSB7IEZwLCBGbiwgdXZSYXRpbzogYy51dlJhdGlvIH07XG4gIGNvbnN0IGVkZHNhT3B0czogRWREU0FPcHRzID0ge1xuICAgIHJhbmRvbUJ5dGVzOiBjLnJhbmRvbUJ5dGVzLFxuICAgIGFkanVzdFNjYWxhckJ5dGVzOiBjLmFkanVzdFNjYWxhckJ5dGVzLFxuICAgIGRvbWFpbjogYy5kb21haW4sXG4gICAgcHJlaGFzaDogYy5wcmVoYXNoLFxuICAgIG1hcFRvQ3VydmU6IGMubWFwVG9DdXJ2ZSxcbiAgfTtcbiAgcmV0dXJuIHsgQ1VSVkUsIGN1cnZlT3B0cywgaGFzaDogYy5oYXNoLCBlZGRzYU9wdHMgfTtcbn1cbmZ1bmN0aW9uIF9lZGRzYV9uZXdfb3V0cHV0X3RvX2xlZ2FjeShjOiBDdXJ2ZVR5cGVXaXRoTGVuZ3RoLCBlZGRzYTogRWREU0EpOiBDdXJ2ZUZuIHtcbiAgY29uc3QgUG9pbnQgPSBlZGRzYS5Qb2ludDtcbiAgY29uc3QgbGVnYWN5ID0gT2JqZWN0LmFzc2lnbih7fSwgZWRkc2EsIHtcbiAgICBFeHRlbmRlZFBvaW50OiBQb2ludCxcbiAgICBDVVJWRTogYyxcbiAgICBuQml0TGVuZ3RoOiBQb2ludC5Gbi5CSVRTLFxuICAgIG5CeXRlTGVuZ3RoOiBQb2ludC5Gbi5CWVRFUyxcbiAgfSk7XG4gIHJldHVybiBsZWdhY3k7XG59XG4vLyBUT0RPOiByZW1vdmUuIFVzZSBlZGRzYVxuZXhwb3J0IGZ1bmN0aW9uIHR3aXN0ZWRFZHdhcmRzKGM6IEN1cnZlVHlwZVdpdGhMZW5ndGgpOiBDdXJ2ZUZuIHtcbiAgY29uc3QgeyBDVVJWRSwgY3VydmVPcHRzLCBoYXNoLCBlZGRzYU9wdHMgfSA9IF9lZGRzYV9sZWdhY3lfb3B0c190b19uZXcoYyk7XG4gIGNvbnN0IFBvaW50ID0gZWR3YXJkcyhDVVJWRSwgY3VydmVPcHRzKTtcbiAgY29uc3QgRUREU0EgPSBlZGRzYShQb2ludCwgaGFzaCwgZWRkc2FPcHRzKTtcbiAgcmV0dXJuIF9lZGRzYV9uZXdfb3V0cHV0X3RvX2xlZ2FjeShjLCBFRERTQSk7XG59XG4iLCAiLyoqXG4gKiBlZDI1NTE5IFR3aXN0ZWQgRWR3YXJkcyBjdXJ2ZSB3aXRoIGZvbGxvd2luZyBhZGRvbnM6XG4gKiAtIFgyNTUxOSBFQ0RIXG4gKiAtIFJpc3RyZXR0byBjb2ZhY3RvciBlbGltaW5hdGlvblxuICogLSBFbGxpZ2F0b3IgaGFzaC10by1ncm91cCAvIHBvaW50IGluZGlzdGluZ3Vpc2hhYmlsaXR5XG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTUxMiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMi5qcyc7XG5pbXBvcnQgeyBhYnl0ZXMsIGNvbmNhdEJ5dGVzLCB1dGY4VG9CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMuanMnO1xuaW1wb3J0IHsgcGlwcGVuZ2VyLCB0eXBlIEFmZmluZVBvaW50IH0gZnJvbSAnLi9hYnN0cmFjdC9jdXJ2ZS50cyc7XG5pbXBvcnQge1xuICBQcmltZUVkd2FyZHNQb2ludCxcbiAgdHdpc3RlZEVkd2FyZHMsXG4gIHR5cGUgQ3VydmVGbixcbiAgdHlwZSBFZHdhcmRzT3B0cyxcbiAgdHlwZSBFZHdhcmRzUG9pbnQsXG59IGZyb20gJy4vYWJzdHJhY3QvZWR3YXJkcy50cyc7XG5pbXBvcnQge1xuICBfRFNUX3NjYWxhcixcbiAgY3JlYXRlSGFzaGVyLFxuICBleHBhbmRfbWVzc2FnZV94bWQsXG4gIHR5cGUgSDJDSGFzaGVyLFxuICB0eXBlIEgyQ0hhc2hlckJhc2UsXG4gIHR5cGUgSDJDTWV0aG9kLFxuICB0eXBlIGh0ZkJhc2ljT3B0cyxcbn0gZnJvbSAnLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLnRzJztcbmltcG9ydCB7XG4gIEZpZWxkLFxuICBGcEludmVydEJhdGNoLFxuICBGcFNxcnRFdmVuLFxuICBpc05lZ2F0aXZlTEUsXG4gIG1vZCxcbiAgcG93MixcbiAgdHlwZSBJRmllbGQsXG59IGZyb20gJy4vYWJzdHJhY3QvbW9kdWxhci50cyc7XG5pbXBvcnQgeyBtb250Z29tZXJ5LCB0eXBlIE1vbnRnb21lcnlFQ0RIIGFzIFhDdXJ2ZUZuIH0gZnJvbSAnLi9hYnN0cmFjdC9tb250Z29tZXJ5LnRzJztcbmltcG9ydCB7IGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIGVxdWFsQnl0ZXMsIHR5cGUgSGV4IH0gZnJvbSAnLi91dGlscy50cyc7XG5cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzVuID0gQmlnSW50KDUpLCBfOG4gPSBCaWdJbnQoOCk7XG5cbi8vIFAgPSAybioqMjU1bi0xOW5cbmNvbnN0IGVkMjU1MTlfQ1VSVkVfcCA9IEJpZ0ludChcbiAgJzB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZCdcbik7XG5cbi8vIE4gPSAybioqMjUybiArIDI3NzQyMzE3Nzc3MzcyMzUzNTM1ODUxOTM3NzkwODgzNjQ4NDkzblxuLy8gYSA9IEZwLmNyZWF0ZShCaWdJbnQoLTEpKVxuLy8gZCA9IC0xMjE2NjUvMTIxNjY2IGEuay5hLiBGcC5uZWcoMTIxNjY1ICogRnAuaW52KDEyMTY2NikpXG5jb25zdCBlZDI1NTE5X0NVUlZFOiBFZHdhcmRzT3B0cyA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKHtcbiAgcDogZWQyNTUxOV9DVVJWRV9wLFxuICBuOiBCaWdJbnQoJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxNGRlZjlkZWEyZjc5Y2Q2NTgxMjYzMWE1Y2Y1ZDNlZCcpLFxuICBoOiBfOG4sXG4gIGE6IEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVjJyksXG4gIGQ6IEJpZ0ludCgnMHg1MjAzNmNlZTJiNmZmZTczOGNjNzQwNzk3Nzc5ZTg5ODAwNzAwYTRkNDE0MWQ4YWI3NWViNGRjYTEzNTk3OGEzJyksXG4gIEd4OiBCaWdJbnQoJzB4MjE2OTM2ZDNjZDZlNTNmZWMwYTRlMjMxZmRkNmRjNWM2OTJjYzc2MDk1MjVhN2IyYzk1NjJkNjA4ZjI1ZDUxYScpLFxuICBHeTogQmlnSW50KCcweDY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NTgnKSxcbn0pKSgpO1xuXG5mdW5jdGlvbiBlZDI1NTE5X3Bvd18yXzI1Ml8zKHg6IGJpZ2ludCkge1xuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgY29uc3QgXzEwbiA9IEJpZ0ludCgxMCksIF8yMG4gPSBCaWdJbnQoMjApLCBfNDBuID0gQmlnSW50KDQwKSwgXzgwbiA9IEJpZ0ludCg4MCk7XG4gIGNvbnN0IFAgPSBlZDI1NTE5X0NVUlZFX3A7XG4gIGNvbnN0IHgyID0gKHggKiB4KSAlIFA7XG4gIGNvbnN0IGIyID0gKHgyICogeCkgJSBQOyAvLyB4XjMsIDExXG4gIGNvbnN0IGI0ID0gKHBvdzIoYjIsIF8ybiwgUCkgKiBiMikgJSBQOyAvLyB4XjE1LCAxMTExXG4gIGNvbnN0IGI1ID0gKHBvdzIoYjQsIF8xbiwgUCkgKiB4KSAlIFA7IC8vIHheMzFcbiAgY29uc3QgYjEwID0gKHBvdzIoYjUsIF81biwgUCkgKiBiNSkgJSBQO1xuICBjb25zdCBiMjAgPSAocG93MihiMTAsIF8xMG4sIFApICogYjEwKSAlIFA7XG4gIGNvbnN0IGI0MCA9IChwb3cyKGIyMCwgXzIwbiwgUCkgKiBiMjApICUgUDtcbiAgY29uc3QgYjgwID0gKHBvdzIoYjQwLCBfNDBuLCBQKSAqIGI0MCkgJSBQO1xuICBjb25zdCBiMTYwID0gKHBvdzIoYjgwLCBfODBuLCBQKSAqIGI4MCkgJSBQO1xuICBjb25zdCBiMjQwID0gKHBvdzIoYjE2MCwgXzgwbiwgUCkgKiBiODApICUgUDtcbiAgY29uc3QgYjI1MCA9IChwb3cyKGIyNDAsIF8xMG4sIFApICogYjEwKSAlIFA7XG4gIGNvbnN0IHBvd19wXzVfOCA9IChwb3cyKGIyNTAsIF8ybiwgUCkgKiB4KSAlIFA7XG4gIC8vIF4gVG8gcG93IHRvIChwKzMpLzgsIG11bHRpcGx5IGl0IGJ5IHguXG4gIHJldHVybiB7IHBvd19wXzVfOCwgYjIgfTtcbn1cblxuZnVuY3Rpb24gYWRqdXN0U2NhbGFyQnl0ZXMoYnl0ZXM6IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5IHtcbiAgLy8gU2VjdGlvbiA1OiBGb3IgWDI1NTE5LCBpbiBvcmRlciB0byBkZWNvZGUgMzIgcmFuZG9tIGJ5dGVzIGFzIGFuIGludGVnZXIgc2NhbGFyLFxuICAvLyBzZXQgdGhlIHRocmVlIGxlYXN0IHNpZ25pZmljYW50IGJpdHMgb2YgdGhlIGZpcnN0IGJ5dGVcbiAgYnl0ZXNbMF0gJj0gMjQ4OyAvLyAwYjExMTFfMTAwMFxuICAvLyBhbmQgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBsYXN0IHRvIHplcm8sXG4gIGJ5dGVzWzMxXSAmPSAxMjc7IC8vIDBiMDExMV8xMTExXG4gIC8vIHNldCB0aGUgc2Vjb25kIG1vc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBsYXN0IGJ5dGUgdG8gMVxuICBieXRlc1szMV0gfD0gNjQ7IC8vIDBiMDEwMF8wMDAwXG4gIHJldHVybiBieXRlcztcbn1cblxuLy8gXHUyMjFBKC0xKSBha2EgXHUyMjFBKGEpIGFrYSAyXigocC0xKS80KVxuLy8gRnAuc3FydChGcC5uZWcoMSkpXG5jb25zdCBFRDI1NTE5X1NRUlRfTTEgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KFxuICAnMTk2ODExNjEzNzY3MDc1MDU5NTY4MDcwNzkzMDQ5ODg1NDIwMTU0NDYwNjY1MTU5MjM4OTAxNjI3NDQwMjEwNzMxMjM4Mjk3ODQ3NTInXG4pO1xuLy8gc3FydCh1L3YpXG5mdW5jdGlvbiB1dlJhdGlvKHU6IGJpZ2ludCwgdjogYmlnaW50KTogeyBpc1ZhbGlkOiBib29sZWFuOyB2YWx1ZTogYmlnaW50IH0ge1xuICBjb25zdCBQID0gZWQyNTUxOV9DVVJWRV9wO1xuICBjb25zdCB2MyA9IG1vZCh2ICogdiAqIHYsIFApOyAvLyB2XHUwMEIzXG4gIGNvbnN0IHY3ID0gbW9kKHYzICogdjMgKiB2LCBQKTsgLy8gdlx1MjA3N1xuICAvLyAocCszKS84IGFuZCAocC01KS84XG4gIGNvbnN0IHBvdyA9IGVkMjU1MTlfcG93XzJfMjUyXzModSAqIHY3KS5wb3dfcF81Xzg7XG4gIGxldCB4ID0gbW9kKHUgKiB2MyAqIHBvdywgUCk7IC8vICh1dlx1MDBCMykodXZcdTIwNzcpXihwLTUpLzhcbiAgY29uc3QgdngyID0gbW9kKHYgKiB4ICogeCwgUCk7IC8vIHZ4XHUwMEIyXG4gIGNvbnN0IHJvb3QxID0geDsgLy8gRmlyc3Qgcm9vdCBjYW5kaWRhdGVcbiAgY29uc3Qgcm9vdDIgPSBtb2QoeCAqIEVEMjU1MTlfU1FSVF9NMSwgUCk7IC8vIFNlY29uZCByb290IGNhbmRpZGF0ZVxuICBjb25zdCB1c2VSb290MSA9IHZ4MiA9PT0gdTsgLy8gSWYgdnhcdTAwQjIgPSB1IChtb2QgcCksIHggaXMgYSBzcXVhcmUgcm9vdFxuICBjb25zdCB1c2VSb290MiA9IHZ4MiA9PT0gbW9kKC11LCBQKTsgLy8gSWYgdnhcdTAwQjIgPSAtdSwgc2V0IHggPC0tIHggKiAyXigocC0xKS80KVxuICBjb25zdCBub1Jvb3QgPSB2eDIgPT09IG1vZCgtdSAqIEVEMjU1MTlfU1FSVF9NMSwgUCk7IC8vIFRoZXJlIGlzIG5vIHZhbGlkIHJvb3QsIHZ4XHUwMEIyID0gLXVcdTIyMUEoLTEpXG4gIGlmICh1c2VSb290MSkgeCA9IHJvb3QxO1xuICBpZiAodXNlUm9vdDIgfHwgbm9Sb290KSB4ID0gcm9vdDI7IC8vIFdlIHJldHVybiByb290MiBhbnl3YXksIGZvciBjb25zdC10aW1lXG4gIGlmIChpc05lZ2F0aXZlTEUoeCwgUCkpIHggPSBtb2QoLXgsIFApO1xuICByZXR1cm4geyBpc1ZhbGlkOiB1c2VSb290MSB8fCB1c2VSb290MiwgdmFsdWU6IHggfTtcbn1cblxuY29uc3QgRnAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEZpZWxkKGVkMjU1MTlfQ1VSVkUucCwgeyBpc0xFOiB0cnVlIH0pKSgpO1xuY29uc3QgRm4gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEZpZWxkKGVkMjU1MTlfQ1VSVkUubiwgeyBpc0xFOiB0cnVlIH0pKSgpO1xuXG5jb25zdCBlZDI1NTE5RGVmYXVsdHMgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gIC4uLmVkMjU1MTlfQ1VSVkUsXG4gIEZwLFxuICBoYXNoOiBzaGE1MTIsXG4gIGFkanVzdFNjYWxhckJ5dGVzLFxuICAvLyBkb20yXG4gIC8vIFJhdGlvIG9mIHUgdG8gdi4gQWxsb3dzIHVzIHRvIGNvbWJpbmUgaW52ZXJzaW9uIGFuZCBzcXVhcmUgcm9vdC4gVXNlcyBhbGdvIGZyb20gUkZDODAzMiA1LjEuMy5cbiAgLy8gQ29uc3RhbnQtdGltZSwgdS9cdTIyMUF2XG4gIHV2UmF0aW8sXG59KSkoKTtcblxuLyoqXG4gKiBlZDI1NTE5IGN1cnZlIHdpdGggRWREU0Egc2lnbmF0dXJlcy5cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBlZDI1NTE5IH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9lZDI1NTE5JztcbiAqIGNvbnN0IHsgc2VjcmV0S2V5LCBwdWJsaWNLZXkgfSA9IGVkMjU1MTkua2V5Z2VuKCk7XG4gKiBjb25zdCBtc2cgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoJ2hlbGxvJyk7XG4gKiBjb25zdCBzaWcgPSBlZDI1NTE5LnNpZ24obXNnLCBwcml2KTtcbiAqIGVkMjU1MTkudmVyaWZ5KHNpZywgbXNnLCBwdWIpOyAvLyBEZWZhdWx0IG1vZGU6IGZvbGxvd3MgWklQMjE1XG4gKiBlZDI1NTE5LnZlcmlmeShzaWcsIG1zZywgcHViLCB7IHppcDIxNTogZmFsc2UgfSk7IC8vIFJGQzgwMzIgLyBGSVBTIDE4Ni01XG4gKi9cbmV4cG9ydCBjb25zdCBlZDI1NTE5OiBDdXJ2ZUZuID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB0d2lzdGVkRWR3YXJkcyhlZDI1NTE5RGVmYXVsdHMpKSgpO1xuXG5mdW5jdGlvbiBlZDI1NTE5X2RvbWFpbihkYXRhOiBVaW50OEFycmF5LCBjdHg6IFVpbnQ4QXJyYXksIHBoZmxhZzogYm9vbGVhbikge1xuICBpZiAoY3R4Lmxlbmd0aCA+IDI1NSkgdGhyb3cgbmV3IEVycm9yKCdDb250ZXh0IGlzIHRvbyBiaWcnKTtcbiAgcmV0dXJuIGNvbmNhdEJ5dGVzKFxuICAgIHV0ZjhUb0J5dGVzKCdTaWdFZDI1NTE5IG5vIEVkMjU1MTkgY29sbGlzaW9ucycpLFxuICAgIG5ldyBVaW50OEFycmF5KFtwaGZsYWcgPyAxIDogMCwgY3R4Lmxlbmd0aF0pLFxuICAgIGN0eCxcbiAgICBkYXRhXG4gICk7XG59XG5cbi8qKiBDb250ZXh0IG9mIGVkMjU1MTkuIFVzZXMgY29udGV4dCBmb3IgZG9tYWluIHNlcGFyYXRpb24uICovXG5leHBvcnQgY29uc3QgZWQyNTUxOWN0eDogQ3VydmVGbiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT5cbiAgdHdpc3RlZEVkd2FyZHMoe1xuICAgIC4uLmVkMjU1MTlEZWZhdWx0cyxcbiAgICBkb21haW46IGVkMjU1MTlfZG9tYWluLFxuICB9KSkoKTtcblxuLyoqIFByZWhhc2hlZCB2ZXJzaW9uIG9mIGVkMjU1MTkuIEFjY2VwdHMgYWxyZWFkeS1oYXNoZWQgbWVzc2FnZXMgaW4gc2lnbigpIGFuZCB2ZXJpZnkoKS4gKi9cbmV4cG9ydCBjb25zdCBlZDI1NTE5cGg6IEN1cnZlRm4gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+XG4gIHR3aXN0ZWRFZHdhcmRzKFxuICAgIE9iamVjdC5hc3NpZ24oe30sIGVkMjU1MTlEZWZhdWx0cywge1xuICAgICAgZG9tYWluOiBlZDI1NTE5X2RvbWFpbixcbiAgICAgIHByZWhhc2g6IHNoYTUxMixcbiAgICB9KVxuICApKSgpO1xuXG4vKipcbiAqIEVDREggdXNpbmcgY3VydmUyNTUxOSBha2EgeDI1NTE5LlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IHgyNTUxOSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOSc7XG4gKiBjb25zdCBwcml2ID0gJ2E1NDZlMzZiZjA1MjdjOWQzYjE2MTU0YjgyNDY1ZWRkNjIxNDRjMGFjMWZjNWExODUwNmEyMjQ0YmE0NDlhYzQnO1xuICogY29uc3QgcHViID0gJ2U2ZGI2ODY3NTgzMDMwZGIzNTk0YzFhNDI0YjE1ZjdjNzI2NjI0ZWMyNmIzMzUzYjEwYTkwM2E2ZDBhYjFjNGMnO1xuICogeDI1NTE5LmdldFNoYXJlZFNlY3JldChwcml2LCBwdWIpID09PSB4MjU1MTkuc2NhbGFyTXVsdChwcml2LCBwdWIpOyAvLyBhbGlhc2VzXG4gKiB4MjU1MTkuZ2V0UHVibGljS2V5KHByaXYpID09PSB4MjU1MTkuc2NhbGFyTXVsdEJhc2UocHJpdik7XG4gKiB4MjU1MTkuZ2V0UHVibGljS2V5KHgyNTUxOS51dGlscy5yYW5kb21TZWNyZXRLZXkoKSk7XG4gKi9cbmV4cG9ydCBjb25zdCB4MjU1MTk6IFhDdXJ2ZUZuID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gIGNvbnN0IFAgPSBGcC5PUkRFUjtcbiAgcmV0dXJuIG1vbnRnb21lcnkoe1xuICAgIFAsXG4gICAgdHlwZTogJ3gyNTUxOScsXG4gICAgcG93UG1pbnVzMjogKHg6IGJpZ2ludCk6IGJpZ2ludCA9PiB7XG4gICAgICAvLyB4XihwLTIpIGFrYSB4XigyXjI1NS0yMSlcbiAgICAgIGNvbnN0IHsgcG93X3BfNV84LCBiMiB9ID0gZWQyNTUxOV9wb3dfMl8yNTJfMyh4KTtcbiAgICAgIHJldHVybiBtb2QocG93Mihwb3dfcF81XzgsIF8zbiwgUCkgKiBiMiwgUCk7XG4gICAgfSxcbiAgICBhZGp1c3RTY2FsYXJCeXRlcyxcbiAgfSk7XG59KSgpO1xuXG4vLyBIYXNoIFRvIEN1cnZlIEVsbGlnYXRvcjIgTWFwIChOT1RFOiBkaWZmZXJlbnQgZnJvbSByaXN0cmV0dG8yNTUgZWxsaWdhdG9yKVxuLy8gTk9URTogdmVyeSBpbXBvcnRhbnQgcGFydCBpcyB1c2FnZSBvZiBGcFNxcnRFdmVuIGZvciBFTEwyX0MxX0VEV0FSRFMsIHNpbmNlXG4vLyBTYWdlTWF0aCByZXR1cm5zIGRpZmZlcmVudCByb290IGZpcnN0IGFuZCBldmVyeXRoaW5nIGZhbGxzIGFwYXJ0XG5jb25zdCBFTEwyX0MxID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoZWQyNTUxOV9DVVJWRV9wICsgXzNuKSAvIF84bikoKTsgLy8gMS4gYzEgPSAocSArIDMpIC8gOCAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuY29uc3QgRUxMMl9DMiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gRnAucG93KF8ybiwgRUxMMl9DMSkpKCk7IC8vIDIuIGMyID0gMl5jMVxuY29uc3QgRUxMMl9DMyA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gRnAuc3FydChGcC5uZWcoRnAuT05FKSkpKCk7IC8vIDMuIGMzID0gc3FydCgtMSlcblxuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5KHU6IGJpZ2ludCkge1xuICBjb25zdCBFTEwyX0M0ID0gKGVkMjU1MTlfQ1VSVkVfcCAtIF81bikgLyBfOG47IC8vIDQuIGM0ID0gKHEgLSA1KSAvIDggICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgY29uc3QgRUxMMl9KID0gQmlnSW50KDQ4NjY2Mik7XG5cbiAgbGV0IHR2MSA9IEZwLnNxcih1KTsgICAgICAgICAgLy8gIDEuICB0djEgPSB1XjJcbiAgdHYxID0gRnAubXVsKHR2MSwgXzJuKTsgICAgICAgLy8gIDIuICB0djEgPSAyICogdHYxXG4gIGxldCB4ZCA9IEZwLmFkZCh0djEsIEZwLk9ORSk7IC8vICAzLiAgIHhkID0gdHYxICsgMSAgICAgICAgICMgTm9uemVybzogLTEgaXMgc3F1YXJlIChtb2QgcCksIHR2MSBpcyBub3RcbiAgbGV0IHgxbiA9IEZwLm5lZyhFTEwyX0opOyAgICAgLy8gIDQuICB4MW4gPSAtSiAgICAgICAgICAgICAgIyB4MSA9IHgxbiAvIHhkID0gLUogLyAoMSArIDIgKiB1XjIpXG4gIGxldCB0djIgPSBGcC5zcXIoeGQpOyAgICAgICAgIC8vICA1LiAgdHYyID0geGReMlxuICBsZXQgZ3hkID0gRnAubXVsKHR2MiwgeGQpOyAgICAvLyAgNi4gIGd4ZCA9IHR2MiAqIHhkICAgICAgICAjIGd4ZCA9IHhkXjNcbiAgbGV0IGd4MSA9IEZwLm11bCh0djEsIEVMTDJfSik7Ly8gIDcuICBneDEgPSBKICogdHYxICAgICAgICAgIyB4MW4gKyBKICogeGRcbiAgZ3gxID0gRnAubXVsKGd4MSwgeDFuKTsgICAgICAgLy8gIDguICBneDEgPSBneDEgKiB4MW4gICAgICAgIyB4MW5eMiArIEogKiB4MW4gKiB4ZFxuICBneDEgPSBGcC5hZGQoZ3gxLCB0djIpOyAgICAgICAvLyAgOS4gIGd4MSA9IGd4MSArIHR2MiAgICAgICAjIHgxbl4yICsgSiAqIHgxbiAqIHhkICsgeGReMlxuICBneDEgPSBGcC5tdWwoZ3gxLCB4MW4pOyAgICAgICAvLyAgMTAuIGd4MSA9IGd4MSAqIHgxbiAgICAgICAjIHgxbl4zICsgSiAqIHgxbl4yICogeGQgKyB4MW4gKiB4ZF4yXG4gIGxldCB0djMgPSBGcC5zcXIoZ3hkKTsgICAgICAgIC8vICAxMS4gdHYzID0gZ3hkXjJcbiAgdHYyID0gRnAuc3FyKHR2Myk7ICAgICAgICAgICAgLy8gIDEyLiB0djIgPSB0djNeMiAgICAgICAgICAgIyBneGReNFxuICB0djMgPSBGcC5tdWwodHYzLCBneGQpOyAgICAgICAvLyAgMTMuIHR2MyA9IHR2MyAqIGd4ZCAgICAgICAjIGd4ZF4zXG4gIHR2MyA9IEZwLm11bCh0djMsIGd4MSk7ICAgICAgIC8vICAxNC4gdHYzID0gdHYzICogZ3gxICAgICAgICMgZ3gxICogZ3hkXjNcbiAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTsgICAgICAgLy8gIDE1LiB0djIgPSB0djIgKiB0djMgICAgICAgIyBneDEgKiBneGReN1xuICBsZXQgeTExID0gRnAucG93KHR2MiwgRUxMMl9DNCk7IC8vICAxNi4geTExID0gdHYyXmM0ICAgICAgICAjIChneDEgKiBneGReNyleKChwIC0gNSkgLyA4KVxuICB5MTEgPSBGcC5tdWwoeTExLCB0djMpOyAgICAgICAvLyAgMTcuIHkxMSA9IHkxMSAqIHR2MyAgICAgICAjIGd4MSpneGReMyooZ3gxKmd4ZF43KV4oKHAtNSkvOClcbiAgbGV0IHkxMiA9IEZwLm11bCh5MTEsIEVMTDJfQzMpOyAvLyAgMTguIHkxMiA9IHkxMSAqIGMzXG4gIHR2MiA9IEZwLnNxcih5MTEpOyAgICAgICAgICAgIC8vICAxOS4gdHYyID0geTExXjJcbiAgdHYyID0gRnAubXVsKHR2MiwgZ3hkKTsgICAgICAgLy8gIDIwLiB0djIgPSB0djIgKiBneGRcbiAgbGV0IGUxID0gRnAuZXFsKHR2MiwgZ3gxKTsgICAgLy8gIDIxLiAgZTEgPSB0djIgPT0gZ3gxXG4gIGxldCB5MSA9IEZwLmNtb3YoeTEyLCB5MTEsIGUxKTsgLy8gIDIyLiAgeTEgPSBDTU9WKHkxMiwgeTExLCBlMSkgICMgSWYgZyh4MSkgaXMgc3F1YXJlLCB0aGlzIGlzIGl0cyBzcXJ0XG4gIGxldCB4Mm4gPSBGcC5tdWwoeDFuLCB0djEpOyAgIC8vICAyMy4geDJuID0geDFuICogdHYxICAgICAgICMgeDIgPSB4Mm4gLyB4ZCA9IDIgKiB1XjIgKiB4MW4gLyB4ZFxuICBsZXQgeTIxID0gRnAubXVsKHkxMSwgdSk7ICAgICAvLyAgMjQuIHkyMSA9IHkxMSAqIHVcbiAgeTIxID0gRnAubXVsKHkyMSwgRUxMMl9DMik7ICAgLy8gIDI1LiB5MjEgPSB5MjEgKiBjMlxuICBsZXQgeTIyID0gRnAubXVsKHkyMSwgRUxMMl9DMyk7IC8vICAyNi4geTIyID0geTIxICogYzNcbiAgbGV0IGd4MiA9IEZwLm11bChneDEsIHR2MSk7ICAgLy8gIDI3LiBneDIgPSBneDEgKiB0djEgICAgICAgIyBnKHgyKSA9IGd4MiAvIGd4ZCA9IDIgKiB1XjIgKiBnKHgxKVxuICB0djIgPSBGcC5zcXIoeTIxKTsgICAgICAgICAgICAvLyAgMjguIHR2MiA9IHkyMV4yXG4gIHR2MiA9IEZwLm11bCh0djIsIGd4ZCk7ICAgICAgIC8vICAyOS4gdHYyID0gdHYyICogZ3hkXG4gIGxldCBlMiA9IEZwLmVxbCh0djIsIGd4Mik7ICAgIC8vICAzMC4gIGUyID0gdHYyID09IGd4MlxuICBsZXQgeTIgPSBGcC5jbW92KHkyMiwgeTIxLCBlMik7IC8vICAzMS4gIHkyID0gQ01PVih5MjIsIHkyMSwgZTIpICAjIElmIGcoeDIpIGlzIHNxdWFyZSwgdGhpcyBpcyBpdHMgc3FydFxuICB0djIgPSBGcC5zcXIoeTEpOyAgICAgICAgICAgICAvLyAgMzIuIHR2MiA9IHkxXjJcbiAgdHYyID0gRnAubXVsKHR2MiwgZ3hkKTsgICAgICAgLy8gIDMzLiB0djIgPSB0djIgKiBneGRcbiAgbGV0IGUzID0gRnAuZXFsKHR2MiwgZ3gxKTsgICAgLy8gIDM0LiAgZTMgPSB0djIgPT0gZ3gxXG4gIGxldCB4biA9IEZwLmNtb3YoeDJuLCB4MW4sIGUzKTsgLy8gIDM1LiAgeG4gPSBDTU9WKHgybiwgeDFuLCBlMykgICMgSWYgZTMsIHggPSB4MSwgZWxzZSB4ID0geDJcbiAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgZTMpOyAgLy8gIDM2LiAgIHkgPSBDTU9WKHkyLCB5MSwgZTMpICAgICMgSWYgZTMsIHkgPSB5MSwgZWxzZSB5ID0geTJcbiAgbGV0IGU0ID0gRnAuaXNPZGQhKHkpOyAgICAgICAgIC8vICAzNy4gIGU0ID0gc2duMCh5KSA9PSAxICAgICAgICAjIEZpeCBzaWduIG9mIHlcbiAgeSA9IEZwLmNtb3YoeSwgRnAubmVnKHkpLCBlMyAhPT0gZTQpOyAvLyAgMzguICAgeSA9IENNT1YoeSwgLXksIGUzIFhPUiBlNClcbiAgcmV0dXJuIHsgeE1uOiB4biwgeE1kOiB4ZCwgeU1uOiB5LCB5TWQ6IF8xbiB9OyAvLyAgMzkuIHJldHVybiAoeG4sIHhkLCB5LCAxKVxufVxuXG5jb25zdCBFTEwyX0MxX0VEV0FSRFMgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEZwU3FydEV2ZW4oRnAsIEZwLm5lZyhCaWdJbnQoNDg2NjY0KSkpKSgpOyAvLyBzZ24wKGMxKSBNVVNUIGVxdWFsIDBcbmZ1bmN0aW9uIG1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2Vkd2FyZHMyNTUxOSh1OiBiaWdpbnQpIHtcbiAgY29uc3QgeyB4TW4sIHhNZCwgeU1uLCB5TWQgfSA9IG1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2N1cnZlMjU1MTkodSk7IC8vICAxLiAgKHhNbiwgeE1kLCB5TW4sIHlNZCkgPVxuICAvLyBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5KHUpXG4gIGxldCB4biA9IEZwLm11bCh4TW4sIHlNZCk7IC8vICAyLiAgeG4gPSB4TW4gKiB5TWRcbiAgeG4gPSBGcC5tdWwoeG4sIEVMTDJfQzFfRURXQVJEUyk7IC8vICAzLiAgeG4gPSB4biAqIGMxXG4gIGxldCB4ZCA9IEZwLm11bCh4TWQsIHlNbik7IC8vICA0LiAgeGQgPSB4TWQgKiB5TW4gICAgIyB4biAvIHhkID0gYzEgKiB4TSAvIHlNXG4gIGxldCB5biA9IEZwLnN1Yih4TW4sIHhNZCk7IC8vICA1LiAgeW4gPSB4TW4gLSB4TWRcbiAgbGV0IHlkID0gRnAuYWRkKHhNbiwgeE1kKTsgLy8gIDYuICB5ZCA9IHhNbiArIHhNZCAgICAjIChuIC8gZCAtIDEpIC8gKG4gLyBkICsgMSkgPSAobiAtIGQpIC8gKG4gKyBkKVxuICBsZXQgdHYxID0gRnAubXVsKHhkLCB5ZCk7IC8vICA3LiB0djEgPSB4ZCAqIHlkXG4gIGxldCBlID0gRnAuZXFsKHR2MSwgRnAuWkVSTyk7IC8vICA4LiAgIGUgPSB0djEgPT0gMFxuICB4biA9IEZwLmNtb3YoeG4sIEZwLlpFUk8sIGUpOyAvLyAgOS4gIHhuID0gQ01PVih4biwgMCwgZSlcbiAgeGQgPSBGcC5jbW92KHhkLCBGcC5PTkUsIGUpOyAvLyAgMTAuIHhkID0gQ01PVih4ZCwgMSwgZSlcbiAgeW4gPSBGcC5jbW92KHluLCBGcC5PTkUsIGUpOyAvLyAgMTEuIHluID0gQ01PVih5biwgMSwgZSlcbiAgeWQgPSBGcC5jbW92KHlkLCBGcC5PTkUsIGUpOyAvLyAgMTIuIHlkID0gQ01PVih5ZCwgMSwgZSlcbiAgY29uc3QgW3hkX2ludiwgeWRfaW52XSA9IEZwSW52ZXJ0QmF0Y2goRnAsIFt4ZCwgeWRdLCB0cnVlKTsgLy8gYmF0Y2ggZGl2aXNpb25cbiAgcmV0dXJuIHsgeDogRnAubXVsKHhuLCB4ZF9pbnYpLCB5OiBGcC5tdWwoeW4sIHlkX2ludikgfTsgLy8gIDEzLiByZXR1cm4gKHhuLCB4ZCwgeW4sIHlkKVxufVxuXG4vKiogSGFzaGluZyB0byBlZDI1NTE5IHBvaW50cyAvIGZpZWxkLiBSRkMgOTM4MCBtZXRob2RzLiAqL1xuZXhwb3J0IGNvbnN0IGVkMjU1MTlfaGFzaGVyOiBIMkNIYXNoZXI8YmlnaW50PiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT5cbiAgY3JlYXRlSGFzaGVyKFxuICAgIGVkMjU1MTkuUG9pbnQsXG4gICAgKHNjYWxhcnM6IGJpZ2ludFtdKSA9PiBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9lZHdhcmRzMjU1MTkoc2NhbGFyc1swXSksXG4gICAge1xuICAgICAgRFNUOiAnZWR3YXJkczI1NTE5X1hNRDpTSEEtNTEyX0VMTDJfUk9fJyxcbiAgICAgIGVuY29kZURTVDogJ2Vkd2FyZHMyNTUxOV9YTUQ6U0hBLTUxMl9FTEwyX05VXycsXG4gICAgICBwOiBlZDI1NTE5X0NVUlZFX3AsXG4gICAgICBtOiAxLFxuICAgICAgazogMTI4LFxuICAgICAgZXhwYW5kOiAneG1kJyxcbiAgICAgIGhhc2g6IHNoYTUxMixcbiAgICB9XG4gICkpKCk7XG5cbi8vIFx1MjIxQSgtMSkgYWthIFx1MjIxQShhKSBha2EgMl4oKHAtMSkvNClcbmNvbnN0IFNRUlRfTTEgPSBFRDI1NTE5X1NRUlRfTTE7XG4vLyBcdTIyMUEoYWQgLSAxKVxuY29uc3QgU1FSVF9BRF9NSU5VU19PTkUgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KFxuICAnMjUwNjMwNjg5NTMzODQ2MjM0NzQxMTE0MTQxNTg3MDIxNTI3MDEyNDQ1MzE1MDI0OTI2NTY0NjAwNzkyMTA0ODI2MTA0MzA3NTAyMzUnXG4pO1xuLy8gMSAvIFx1MjIxQShhLWQpXG5jb25zdCBJTlZTUVJUX0FfTUlOVVNfRCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoXG4gICc1NDQ2OTMwNzAwODkwOTMxNjkyMDk5NTgxMzg2ODc0NTE0MTYwNTM5MzU5NzI5MjkyNzQ1NjkyMTIwNTMxMjg5NjMxMTcyMTAxNzU3OCdcbik7XG4vLyAxLWRcdTAwQjJcbmNvbnN0IE9ORV9NSU5VU19EX1NRID0gLyogQF9fUFVSRV9fICovIEJpZ0ludChcbiAgJzExNTk4NDMwMjE2Njg3Nzk4NzkxOTM3NzU1MjE4NTU1ODY2NDc5MzczNTc3NTk3MTU0MTc2NTQ0Mzk4Nzk3MjA4NzYxMTE4MDY4MzgnXG4pO1xuLy8gKGQtMSlcdTAwQjJcbmNvbnN0IERfTUlOVVNfT05FX1NRID0gLyogQF9fUFVSRV9fICovIEJpZ0ludChcbiAgJzQwNDQwODM0MzQ2MzA4NTM2ODU4MTAxMDQyNDY5MzIzMTkwODI2MjQ4Mzk5MTQ2MjM4NzA4MzUyMjQwMTMzMjIwODY1MTM3MjY1OTUyJ1xuKTtcbi8vIENhbGN1bGF0ZXMgMS9cdTIyMUEobnVtYmVyKVxuY29uc3QgaW52ZXJ0U3FydCA9IChudW1iZXI6IGJpZ2ludCkgPT4gdXZSYXRpbyhfMW4sIG51bWJlcik7XG5cbmNvbnN0IE1BWF8yNTVCID0gLyogQF9fUFVSRV9fICovIEJpZ0ludChcbiAgJzB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZidcbik7XG5jb25zdCBieXRlczI1NVRvTnVtYmVyTEUgPSAoYnl0ZXM6IFVpbnQ4QXJyYXkpID0+XG4gIGVkMjU1MTkuUG9pbnQuRnAuY3JlYXRlKGJ5dGVzVG9OdW1iZXJMRShieXRlcykgJiBNQVhfMjU1Qik7XG5cbnR5cGUgRXh0ZW5kZWRQb2ludCA9IEVkd2FyZHNQb2ludDtcblxuLyoqXG4gKiBDb21wdXRlcyBFbGxpZ2F0b3IgbWFwIGZvciBSaXN0cmV0dG8yNTUuXG4gKiBEZXNjcmliZWQgaW4gW1JGQzkzODBdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI2FwcGVuZGl4LUIpIGFuZCBvblxuICogdGhlIFt3ZWJzaXRlXShodHRwczovL3Jpc3RyZXR0by5ncm91cC9mb3JtdWxhcy9lbGxpZ2F0b3IuaHRtbCkuXG4gKi9cbmZ1bmN0aW9uIGNhbGNFbGxpZ2F0b3JSaXN0cmV0dG9NYXAocjA6IGJpZ2ludCk6IEV4dGVuZGVkUG9pbnQge1xuICBjb25zdCB7IGQgfSA9IGVkMjU1MTlfQ1VSVkU7XG4gIGNvbnN0IFAgPSBlZDI1NTE5X0NVUlZFX3A7XG4gIGNvbnN0IG1vZCA9IChuOiBiaWdpbnQpID0+IEZwLmNyZWF0ZShuKTtcbiAgY29uc3QgciA9IG1vZChTUVJUX00xICogcjAgKiByMCk7IC8vIDFcbiAgY29uc3QgTnMgPSBtb2QoKHIgKyBfMW4pICogT05FX01JTlVTX0RfU1EpOyAvLyAyXG4gIGxldCBjID0gQmlnSW50KC0xKTsgLy8gM1xuICBjb25zdCBEID0gbW9kKChjIC0gZCAqIHIpICogbW9kKHIgKyBkKSk7IC8vIDRcbiAgbGV0IHsgaXNWYWxpZDogTnNfRF9pc19zcSwgdmFsdWU6IHMgfSA9IHV2UmF0aW8oTnMsIEQpOyAvLyA1XG4gIGxldCBzXyA9IG1vZChzICogcjApOyAvLyA2XG4gIGlmICghaXNOZWdhdGl2ZUxFKHNfLCBQKSkgc18gPSBtb2QoLXNfKTtcbiAgaWYgKCFOc19EX2lzX3NxKSBzID0gc187IC8vIDdcbiAgaWYgKCFOc19EX2lzX3NxKSBjID0gcjsgLy8gOFxuICBjb25zdCBOdCA9IG1vZChjICogKHIgLSBfMW4pICogRF9NSU5VU19PTkVfU1EgLSBEKTsgLy8gOVxuICBjb25zdCBzMiA9IHMgKiBzO1xuICBjb25zdCBXMCA9IG1vZCgocyArIHMpICogRCk7IC8vIDEwXG4gIGNvbnN0IFcxID0gbW9kKE50ICogU1FSVF9BRF9NSU5VU19PTkUpOyAvLyAxMVxuICBjb25zdCBXMiA9IG1vZChfMW4gLSBzMik7IC8vIDEyXG4gIGNvbnN0IFczID0gbW9kKF8xbiArIHMyKTsgLy8gMTNcbiAgcmV0dXJuIG5ldyBlZDI1NTE5LlBvaW50KG1vZChXMCAqIFczKSwgbW9kKFcyICogVzEpLCBtb2QoVzEgKiBXMyksIG1vZChXMCAqIFcyKSk7XG59XG5cbmZ1bmN0aW9uIHJpc3RyZXR0bzI1NV9tYXAoYnl0ZXM6IFVpbnQ4QXJyYXkpOiBfUmlzdHJldHRvUG9pbnQge1xuICBhYnl0ZXMoYnl0ZXMsIDY0KTtcbiAgY29uc3QgcjEgPSBieXRlczI1NVRvTnVtYmVyTEUoYnl0ZXMuc3ViYXJyYXkoMCwgMzIpKTtcbiAgY29uc3QgUjEgPSBjYWxjRWxsaWdhdG9yUmlzdHJldHRvTWFwKHIxKTtcbiAgY29uc3QgcjIgPSBieXRlczI1NVRvTnVtYmVyTEUoYnl0ZXMuc3ViYXJyYXkoMzIsIDY0KSk7XG4gIGNvbnN0IFIyID0gY2FsY0VsbGlnYXRvclJpc3RyZXR0b01hcChyMik7XG4gIHJldHVybiBuZXcgX1Jpc3RyZXR0b1BvaW50KFIxLmFkZChSMikpO1xufVxuXG4vKipcbiAqIFdyYXBwZXIgb3ZlciBFZHdhcmRzIFBvaW50IGZvciByaXN0cmV0dG8yNTUuXG4gKlxuICogRWFjaCBlZDI1NTE5L0V4dGVuZGVkUG9pbnQgaGFzIDggZGlmZmVyZW50IGVxdWl2YWxlbnQgcG9pbnRzLiBUaGlzIGNhbiBiZVxuICogYSBzb3VyY2Ugb2YgYnVncyBmb3IgcHJvdG9jb2xzIGxpa2UgcmluZyBzaWduYXR1cmVzLiBSaXN0cmV0dG8gd2FzIGNyZWF0ZWQgdG8gc29sdmUgdGhpcy5cbiAqIFJpc3RyZXR0byBwb2ludCBvcGVyYXRlcyBpbiBYOlk6WjpUIGV4dGVuZGVkIGNvb3JkaW5hdGVzIGxpa2UgRXh0ZW5kZWRQb2ludCxcbiAqIGJ1dCBpdCBzaG91bGQgd29yayBpbiBpdHMgb3duIG5hbWVzcGFjZTogZG8gbm90IGNvbWJpbmUgdGhvc2UgdHdvLlxuICogU2VlIFtSRkM5NDk2XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTQ5NikuXG4gKi9cbmNsYXNzIF9SaXN0cmV0dG9Qb2ludCBleHRlbmRzIFByaW1lRWR3YXJkc1BvaW50PF9SaXN0cmV0dG9Qb2ludD4ge1xuICAvLyBEbyBOT1QgY2hhbmdlIHN5bnRheDogdGhlIGZvbGxvd2luZyBneW1uYXN0aWNzIGlzIGRvbmUsXG4gIC8vIGJlY2F1c2UgdHlwZXNjcmlwdCBzdHJpcHMgY29tbWVudHMsIHdoaWNoIG1ha2VzIGJ1bmRsZXJzIGRpc2FibGUgdHJlZS1zaGFraW5nLlxuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgc3RhdGljIEJBU0U6IF9SaXN0cmV0dG9Qb2ludCA9XG4gICAgLyogQF9fUFVSRV9fICovICgoKSA9PiBuZXcgX1Jpc3RyZXR0b1BvaW50KGVkMjU1MTkuUG9pbnQuQkFTRSkpKCk7XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBzdGF0aWMgWkVSTzogX1Jpc3RyZXR0b1BvaW50ID1cbiAgICAvKiBAX19QVVJFX18gKi8gKCgpID0+IG5ldyBfUmlzdHJldHRvUG9pbnQoZWQyNTUxOS5Qb2ludC5aRVJPKSkoKTtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHN0YXRpYyBGcDogSUZpZWxkPGJpZ2ludD4gPVxuICAgIC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gRnApKCk7XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBzdGF0aWMgRm46IElGaWVsZDxiaWdpbnQ+ID1cbiAgICAvKiBAX19QVVJFX18gKi8gKCgpID0+IEZuKSgpO1xuXG4gIGNvbnN0cnVjdG9yKGVwOiBFeHRlbmRlZFBvaW50KSB7XG4gICAgc3VwZXIoZXApO1xuICB9XG5cbiAgc3RhdGljIGZyb21BZmZpbmUoYXA6IEFmZmluZVBvaW50PGJpZ2ludD4pOiBfUmlzdHJldHRvUG9pbnQge1xuICAgIHJldHVybiBuZXcgX1Jpc3RyZXR0b1BvaW50KGVkMjU1MTkuUG9pbnQuZnJvbUFmZmluZShhcCkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzc2VydFNhbWUob3RoZXI6IF9SaXN0cmV0dG9Qb2ludCk6IHZvaWQge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgX1Jpc3RyZXR0b1BvaW50KSkgdGhyb3cgbmV3IEVycm9yKCdSaXN0cmV0dG9Qb2ludCBleHBlY3RlZCcpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGluaXQoZXA6IEVkd2FyZHNQb2ludCk6IF9SaXN0cmV0dG9Qb2ludCB7XG4gICAgcmV0dXJuIG5ldyBfUmlzdHJldHRvUG9pbnQoZXApO1xuICB9XG5cbiAgLyoqIEBkZXByZWNhdGVkIHVzZSBgaW1wb3J0IHsgcmlzdHJldHRvMjU1X2hhc2hlciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOS5qcyc7YCAqL1xuICBzdGF0aWMgaGFzaFRvQ3VydmUoaGV4OiBIZXgpOiBfUmlzdHJldHRvUG9pbnQge1xuICAgIHJldHVybiByaXN0cmV0dG8yNTVfbWFwKGVuc3VyZUJ5dGVzKCdyaXN0cmV0dG9IYXNoJywgaGV4LCA2NCkpO1xuICB9XG5cbiAgc3RhdGljIGZyb21CeXRlcyhieXRlczogVWludDhBcnJheSk6IF9SaXN0cmV0dG9Qb2ludCB7XG4gICAgYWJ5dGVzKGJ5dGVzLCAzMik7XG4gICAgY29uc3QgeyBhLCBkIH0gPSBlZDI1NTE5X0NVUlZFO1xuICAgIGNvbnN0IFAgPSBlZDI1NTE5X0NVUlZFX3A7XG4gICAgY29uc3QgbW9kID0gKG46IGJpZ2ludCkgPT4gRnAuY3JlYXRlKG4pO1xuICAgIGNvbnN0IHMgPSBieXRlczI1NVRvTnVtYmVyTEUoYnl0ZXMpO1xuICAgIC8vIDEuIENoZWNrIHRoYXQgc19ieXRlcyBpcyB0aGUgY2Fub25pY2FsIGVuY29kaW5nIG9mIGEgZmllbGQgZWxlbWVudCwgb3IgZWxzZSBhYm9ydC5cbiAgICAvLyAzLiBDaGVjayB0aGF0IHMgaXMgbm9uLW5lZ2F0aXZlLCBvciBlbHNlIGFib3J0XG4gICAgaWYgKCFlcXVhbEJ5dGVzKEZwLnRvQnl0ZXMocyksIGJ5dGVzKSB8fCBpc05lZ2F0aXZlTEUocywgUCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmlzdHJldHRvMjU1IGVuY29kaW5nIDEnKTtcbiAgICBjb25zdCBzMiA9IG1vZChzICogcyk7XG4gICAgY29uc3QgdTEgPSBtb2QoXzFuICsgYSAqIHMyKTsgLy8gNCAoYSBpcyAtMSlcbiAgICBjb25zdCB1MiA9IG1vZChfMW4gLSBhICogczIpOyAvLyA1XG4gICAgY29uc3QgdTFfMiA9IG1vZCh1MSAqIHUxKTtcbiAgICBjb25zdCB1Ml8yID0gbW9kKHUyICogdTIpO1xuICAgIGNvbnN0IHYgPSBtb2QoYSAqIGQgKiB1MV8yIC0gdTJfMik7IC8vIDZcbiAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlOiBJIH0gPSBpbnZlcnRTcXJ0KG1vZCh2ICogdTJfMikpOyAvLyA3XG4gICAgY29uc3QgRHggPSBtb2QoSSAqIHUyKTsgLy8gOFxuICAgIGNvbnN0IER5ID0gbW9kKEkgKiBEeCAqIHYpOyAvLyA5XG4gICAgbGV0IHggPSBtb2QoKHMgKyBzKSAqIER4KTsgLy8gMTBcbiAgICBpZiAoaXNOZWdhdGl2ZUxFKHgsIFApKSB4ID0gbW9kKC14KTsgLy8gMTBcbiAgICBjb25zdCB5ID0gbW9kKHUxICogRHkpOyAvLyAxMVxuICAgIGNvbnN0IHQgPSBtb2QoeCAqIHkpOyAvLyAxMlxuICAgIGlmICghaXNWYWxpZCB8fCBpc05lZ2F0aXZlTEUodCwgUCkgfHwgeSA9PT0gXzBuKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJpc3RyZXR0bzI1NSBlbmNvZGluZyAyJyk7XG4gICAgcmV0dXJuIG5ldyBfUmlzdHJldHRvUG9pbnQobmV3IGVkMjU1MTkuUG9pbnQoeCwgeSwgXzFuLCB0KSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgcmlzdHJldHRvLWVuY29kZWQgc3RyaW5nIHRvIHJpc3RyZXR0byBwb2ludC5cbiAgICogRGVzY3JpYmVkIGluIFtSRkM5NDk2XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTQ5NiNuYW1lLWRlY29kZSkuXG4gICAqIEBwYXJhbSBoZXggUmlzdHJldHRvLWVuY29kZWQgMzIgYnl0ZXMuIE5vdCBldmVyeSAzMi1ieXRlIHN0cmluZyBpcyB2YWxpZCByaXN0cmV0dG8gZW5jb2RpbmdcbiAgICovXG4gIHN0YXRpYyBmcm9tSGV4KGhleDogSGV4KTogX1Jpc3RyZXR0b1BvaW50IHtcbiAgICByZXR1cm4gX1Jpc3RyZXR0b1BvaW50LmZyb21CeXRlcyhlbnN1cmVCeXRlcygncmlzdHJldHRvSGV4JywgaGV4LCAzMikpO1xuICB9XG5cbiAgc3RhdGljIG1zbShwb2ludHM6IF9SaXN0cmV0dG9Qb2ludFtdLCBzY2FsYXJzOiBiaWdpbnRbXSk6IF9SaXN0cmV0dG9Qb2ludCB7XG4gICAgcmV0dXJuIHBpcHBlbmdlcihfUmlzdHJldHRvUG9pbnQsIGVkMjU1MTkuUG9pbnQuRm4sIHBvaW50cywgc2NhbGFycyk7XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlcyByaXN0cmV0dG8gcG9pbnQgdG8gVWludDhBcnJheS5cbiAgICogRGVzY3JpYmVkIGluIFtSRkM5NDk2XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTQ5NiNuYW1lLWVuY29kZSkuXG4gICAqL1xuICB0b0J5dGVzKCk6IFVpbnQ4QXJyYXkge1xuICAgIGxldCB7IFgsIFksIFosIFQgfSA9IHRoaXMuZXA7XG4gICAgY29uc3QgUCA9IGVkMjU1MTlfQ1VSVkVfcDtcbiAgICBjb25zdCBtb2QgPSAobjogYmlnaW50KSA9PiBGcC5jcmVhdGUobik7XG4gICAgY29uc3QgdTEgPSBtb2QobW9kKFogKyBZKSAqIG1vZChaIC0gWSkpOyAvLyAxXG4gICAgY29uc3QgdTIgPSBtb2QoWCAqIFkpOyAvLyAyXG4gICAgLy8gU3F1YXJlIHJvb3QgYWx3YXlzIGV4aXN0c1xuICAgIGNvbnN0IHUyc3EgPSBtb2QodTIgKiB1Mik7XG4gICAgY29uc3QgeyB2YWx1ZTogaW52c3FydCB9ID0gaW52ZXJ0U3FydChtb2QodTEgKiB1MnNxKSk7IC8vIDNcbiAgICBjb25zdCBEMSA9IG1vZChpbnZzcXJ0ICogdTEpOyAvLyA0XG4gICAgY29uc3QgRDIgPSBtb2QoaW52c3FydCAqIHUyKTsgLy8gNVxuICAgIGNvbnN0IHpJbnYgPSBtb2QoRDEgKiBEMiAqIFQpOyAvLyA2XG4gICAgbGV0IEQ6IGJpZ2ludDsgLy8gN1xuICAgIGlmIChpc05lZ2F0aXZlTEUoVCAqIHpJbnYsIFApKSB7XG4gICAgICBsZXQgX3ggPSBtb2QoWSAqIFNRUlRfTTEpO1xuICAgICAgbGV0IF95ID0gbW9kKFggKiBTUVJUX00xKTtcbiAgICAgIFggPSBfeDtcbiAgICAgIFkgPSBfeTtcbiAgICAgIEQgPSBtb2QoRDEgKiBJTlZTUVJUX0FfTUlOVVNfRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEQgPSBEMjsgLy8gOFxuICAgIH1cbiAgICBpZiAoaXNOZWdhdGl2ZUxFKFggKiB6SW52LCBQKSkgWSA9IG1vZCgtWSk7IC8vIDlcbiAgICBsZXQgcyA9IG1vZCgoWiAtIFkpICogRCk7IC8vIDEwIChjaGVjayBmb290ZXIncyBub3RlLCBubyBzcXJ0KC1hKSlcbiAgICBpZiAoaXNOZWdhdGl2ZUxFKHMsIFApKSBzID0gbW9kKC1zKTtcbiAgICByZXR1cm4gRnAudG9CeXRlcyhzKTsgLy8gMTFcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlcyB0d28gUmlzdHJldHRvIHBvaW50cy5cbiAgICogRGVzY3JpYmVkIGluIFtSRkM5NDk2XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTQ5NiNuYW1lLWVxdWFscykuXG4gICAqL1xuICBlcXVhbHMob3RoZXI6IF9SaXN0cmV0dG9Qb2ludCk6IGJvb2xlYW4ge1xuICAgIHRoaXMuYXNzZXJ0U2FtZShvdGhlcik7XG4gICAgY29uc3QgeyBYOiBYMSwgWTogWTEgfSA9IHRoaXMuZXA7XG4gICAgY29uc3QgeyBYOiBYMiwgWTogWTIgfSA9IG90aGVyLmVwO1xuICAgIGNvbnN0IG1vZCA9IChuOiBiaWdpbnQpID0+IEZwLmNyZWF0ZShuKTtcbiAgICAvLyAoeDEgKiB5MiA9PSB5MSAqIHgyKSB8ICh5MSAqIHkyID09IHgxICogeDIpXG4gICAgY29uc3Qgb25lID0gbW9kKFgxICogWTIpID09PSBtb2QoWTEgKiBYMik7XG4gICAgY29uc3QgdHdvID0gbW9kKFkxICogWTIpID09PSBtb2QoWDEgKiBYMik7XG4gICAgcmV0dXJuIG9uZSB8fCB0d287XG4gIH1cblxuICBpczAoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZXF1YWxzKF9SaXN0cmV0dG9Qb2ludC5aRVJPKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcmlzdHJldHRvMjU1OiB7XG4gIFBvaW50OiB0eXBlb2YgX1Jpc3RyZXR0b1BvaW50O1xufSA9IHsgUG9pbnQ6IF9SaXN0cmV0dG9Qb2ludCB9O1xuXG4vKiogSGFzaGluZyB0byByaXN0cmV0dG8yNTUgcG9pbnRzIC8gZmllbGQuIFJGQyA5MzgwIG1ldGhvZHMuICovXG5leHBvcnQgY29uc3QgcmlzdHJldHRvMjU1X2hhc2hlcjogSDJDSGFzaGVyQmFzZTxiaWdpbnQ+ID0ge1xuICBoYXNoVG9DdXJ2ZShtc2c6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBodGZCYXNpY09wdHMpOiBfUmlzdHJldHRvUG9pbnQge1xuICAgIGNvbnN0IERTVCA9IG9wdGlvbnM/LkRTVCB8fCAncmlzdHJldHRvMjU1X1hNRDpTSEEtNTEyX1IyNTVNQVBfUk9fJztcbiAgICBjb25zdCB4bWQgPSBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIDY0LCBzaGE1MTIpO1xuICAgIHJldHVybiByaXN0cmV0dG8yNTVfbWFwKHhtZCk7XG4gIH0sXG4gIGhhc2hUb1NjYWxhcihtc2c6IFVpbnQ4QXJyYXksIG9wdGlvbnM6IGh0ZkJhc2ljT3B0cyA9IHsgRFNUOiBfRFNUX3NjYWxhciB9KSB7XG4gICAgY29uc3QgeG1kID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgb3B0aW9ucy5EU1QsIDY0LCBzaGE1MTIpO1xuICAgIHJldHVybiBGbi5jcmVhdGUoYnl0ZXNUb051bWJlckxFKHhtZCkpO1xuICB9LFxufTtcblxuLy8gZXhwb3J0IGNvbnN0IHJpc3RyZXR0bzI1NV9vcHJmOiBPUFJGID0gY3JlYXRlT1JQRih7XG4vLyAgIG5hbWU6ICdyaXN0cmV0dG8yNTUtU0hBNTEyJyxcbi8vICAgUG9pbnQ6IFJpc3RyZXR0b1BvaW50LFxuLy8gICBoYXNoOiBzaGE1MTIsXG4vLyAgIGhhc2hUb0dyb3VwOiByaXN0cmV0dG8yNTVfaGFzaGVyLmhhc2hUb0N1cnZlLFxuLy8gICBoYXNoVG9TY2FsYXI6IHJpc3RyZXR0bzI1NV9oYXNoZXIuaGFzaFRvU2NhbGFyLFxuLy8gfSk7XG5cbi8qKlxuICogV2VpcmQgLyBib2d1cyBwb2ludHMsIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuICogQWxsIDggZWQyNTUxOSBwb2ludHMgb2YgOC10b3JzaW9uIHN1Ymdyb3VwIGNhbiBiZSBnZW5lcmF0ZWQgZnJvbSB0aGUgcG9pbnRcbiAqIFQgPSBgMjZlODk1OGZjMmIyMjdiMDQ1YzNmNDg5ZjJlZjk4ZjBkNWRmYWMwNWQzYzYzMzM5YjEzODAyODg2ZDUzZmMwNWAuXG4gKiBcdTI3RThUXHUyN0U5ID0geyBPLCBULCAyVCwgM1QsIDRULCA1VCwgNlQsIDdUIH1cbiAqL1xuZXhwb3J0IGNvbnN0IEVEMjU1MTlfVE9SU0lPTl9TVUJHUk9VUDogc3RyaW5nW10gPSBbXG4gICcwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgJ2M3MTc2YTcwM2Q0ZGQ4NGZiYTNjMGI3NjBkMTA2NzBmMmEyMDUzZmEyYzM5Y2NjNjRlYzdmZDc3OTJhYzAzN2EnLFxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MCcsXG4gICcyNmU4OTU4ZmMyYjIyN2IwNDVjM2Y0ODlmMmVmOThmMGQ1ZGZhYzA1ZDNjNjMzMzliMTM4MDI4ODZkNTNmYzA1JyxcbiAgJ2VjZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmN2YnLFxuICAnMjZlODk1OGZjMmIyMjdiMDQ1YzNmNDg5ZjJlZjk4ZjBkNWRmYWMwNWQzYzYzMzM5YjEzODAyODg2ZDUzZmM4NScsXG4gICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgJ2M3MTc2YTcwM2Q0ZGQ4NGZiYTNjMGI3NjBkMTA2NzBmMmEyMDUzZmEyYzM5Y2NjNjRlYzdmZDc3OTJhYzAzZmEnLFxuXTtcblxuLyoqIEBkZXByZWNhdGVkIHVzZSBgZWQyNTUxOS51dGlscy50b01vbnRnb21lcnlgICovXG5leHBvcnQgZnVuY3Rpb24gZWR3YXJkc1RvTW9udGdvbWVyeVB1YihlZHdhcmRzUHViOiBIZXgpOiBVaW50OEFycmF5IHtcbiAgcmV0dXJuIGVkMjU1MTkudXRpbHMudG9Nb250Z29tZXJ5KGVuc3VyZUJ5dGVzKCdwdWInLCBlZHdhcmRzUHViKSk7XG59XG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBlZDI1NTE5LnV0aWxzLnRvTW9udGdvbWVyeWAgKi9cbmV4cG9ydCBjb25zdCBlZHdhcmRzVG9Nb250Z29tZXJ5OiB0eXBlb2YgZWR3YXJkc1RvTW9udGdvbWVyeVB1YiA9IGVkd2FyZHNUb01vbnRnb21lcnlQdWI7XG5cbi8qKiBAZGVwcmVjYXRlZCB1c2UgYGVkMjU1MTkudXRpbHMudG9Nb250Z29tZXJ5U2VjcmV0YCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVkd2FyZHNUb01vbnRnb21lcnlQcml2KGVkd2FyZHNQcml2OiBVaW50OEFycmF5KTogVWludDhBcnJheSB7XG4gIHJldHVybiBlZDI1NTE5LnV0aWxzLnRvTW9udGdvbWVyeVNlY3JldChlbnN1cmVCeXRlcygncHViJywgZWR3YXJkc1ByaXYpKTtcbn1cblxuLyoqIEBkZXByZWNhdGVkIHVzZSBgcmlzdHJldHRvMjU1LlBvaW50YCAqL1xuZXhwb3J0IGNvbnN0IFJpc3RyZXR0b1BvaW50OiB0eXBlb2YgX1Jpc3RyZXR0b1BvaW50ID0gX1Jpc3RyZXR0b1BvaW50O1xuLyoqIEBkZXByZWNhdGVkIHVzZSBgaW1wb3J0IHsgZWQyNTUxOV9oYXNoZXIgfSBmcm9tICdAbm9ibGUvY3VydmVzL2VkMjU1MTkuanMnO2AgKi9cbmV4cG9ydCBjb25zdCBoYXNoVG9DdXJ2ZTogSDJDTWV0aG9kPGJpZ2ludD4gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGVkMjU1MTlfaGFzaGVyLmhhc2hUb0N1cnZlKSgpO1xuLyoqIEBkZXByZWNhdGVkIHVzZSBgaW1wb3J0IHsgZWQyNTUxOV9oYXNoZXIgfSBmcm9tICdAbm9ibGUvY3VydmVzL2VkMjU1MTkuanMnO2AgKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVUb0N1cnZlOiBIMkNNZXRob2Q8YmlnaW50PiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT5cbiAgZWQyNTUxOV9oYXNoZXIuZW5jb2RlVG9DdXJ2ZSkoKTtcbnR5cGUgUmlzdEhhc2hlciA9IChtc2c6IFVpbnQ4QXJyYXksIG9wdGlvbnM6IGh0ZkJhc2ljT3B0cykgPT4gX1Jpc3RyZXR0b1BvaW50O1xuLyoqIEBkZXByZWNhdGVkIHVzZSBgaW1wb3J0IHsgcmlzdHJldHRvMjU1X2hhc2hlciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOS5qcyc7YCAqL1xuZXhwb3J0IGNvbnN0IGhhc2hUb1Jpc3RyZXR0bzI1NTogUmlzdEhhc2hlciA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT5cbiAgcmlzdHJldHRvMjU1X2hhc2hlci5oYXNoVG9DdXJ2ZSBhcyBSaXN0SGFzaGVyKSgpO1xuLyoqIEBkZXByZWNhdGVkIHVzZSBgaW1wb3J0IHsgcmlzdHJldHRvMjU1X2hhc2hlciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOS5qcyc7YCAqL1xuZXhwb3J0IGNvbnN0IGhhc2hfdG9fcmlzdHJldHRvMjU1OiBSaXN0SGFzaGVyID0gLyogQF9fUFVSRV9fICovICgoKSA9PlxuICByaXN0cmV0dG8yNTVfaGFzaGVyLmhhc2hUb0N1cnZlIGFzIFJpc3RIYXNoZXIpKCk7XG4iLCAiLyoqXG4gKiBTSEEyLTI1NiBhLmsuYS4gc2hhMjU2LiBJbiBKUywgaXQgaXMgdGhlIGZhc3Rlc3QgaGFzaCwgZXZlbiBmYXN0ZXIgdGhhbiBCbGFrZTMuXG4gKlxuICogVG8gYnJlYWsgc2hhMjU2IHVzaW5nIGJpcnRoZGF5IGF0dGFjaywgYXR0YWNrZXJzIG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcy5cbiAqIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNzAgaGFzaGVzL3NlYyAoMl45NSBoYXNoZXMveWVhcikgYXMgcGVyIDIwMjUuXG4gKlxuICogQ2hlY2sgb3V0IFtGSVBTIDE4MC00XShodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmKS5cbiAqIEBtb2R1bGVcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmltcG9ydCB7XG4gIFNIQTIyNCBhcyBTSEEyMjRuLFxuICBzaGEyMjQgYXMgc2hhMjI0bixcbiAgU0hBMjU2IGFzIFNIQTI1Nm4sXG4gIHNoYTI1NiBhcyBzaGEyNTZuLFxufSBmcm9tICcuL3NoYTIudHMnO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL3NoYTJgIG1vZHVsZSAqL1xuZXhwb3J0IGNvbnN0IFNIQTI1NjogdHlwZW9mIFNIQTI1Nm4gPSBTSEEyNTZuO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL3NoYTJgIG1vZHVsZSAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NjogdHlwZW9mIHNoYTI1Nm4gPSBzaGEyNTZuO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL3NoYTJgIG1vZHVsZSAqL1xuZXhwb3J0IGNvbnN0IFNIQTIyNDogdHlwZW9mIFNIQTIyNG4gPSBTSEEyMjRuO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL3NoYTJgIG1vZHVsZSAqL1xuZXhwb3J0IGNvbnN0IHNoYTIyNDogdHlwZW9mIHNoYTIyNG4gPSBzaGEyMjRuO1xuIiwgIi8qKlxuICogVG8gYWRkIGEgbmV3IGVycm9yLCBmb2xsb3cgdGhlIGluc3RydWN0aW9ucyBhdFxuICogaHR0cHM6Ly9naXRodWIuY29tL2FuemEteHl6L2tpdC90cmVlL21haW4vcGFja2FnZXMvZXJyb3JzLyNhZGRpbmctYS1uZXctZXJyb3JcbiAqXG4gKiBAbW9kdWxlXG4gKiBAcHJpdmF0ZVJlbWFya3NcbiAqIFdBUk5JTkc6XG4gKiAgIC0gRG9uJ3QgcmVtb3ZlIGVycm9yIGNvZGVzXG4gKiAgIC0gRG9uJ3QgY2hhbmdlIG9yIHJlb3JkZXIgZXJyb3IgY29kZXMuXG4gKlxuICogR29vZCBuYW1pbmcgY29udmVudGlvbnM6XG4gKiAgIC0gUHJlZml4aW5nIGNvbW1vbiBlcnJvcnMg4oCUIGUuZy4gdW5kZXIgdGhlIHNhbWUgcGFja2FnZSDigJQgY2FuIGJlIGEgZ29vZCB3YXkgdG8gbmFtZXNwYWNlIHRoZW0uIEUuZy4gQWxsIGNvZGVjLXJlbGF0ZWQgZXJyb3JzIHN0YXJ0IHdpdGggYFNPTEFOQV9FUlJPUl9fQ09ERUNTX19gLlxuICogICAtIFVzZSBjb25zaXN0ZW50IG5hbWVzIOKAlCBlLmcuIGNob29zZSBgUERBYCBvciBgUFJPR1JBTV9ERVJJVkVEX0FERFJFU1NgIGFuZCBzdGljayB3aXRoIGl0LiBFbnN1cmUgeW91ciBuYW1lcyBhcmUgY29uc2lzdGVudCB3aXRoIGV4aXN0aW5nIGVycm9yIGNvZGVzLiBUaGUgZGVjaXNpb24gbWlnaHQgaGF2ZSBiZWVuIG1hZGUgZm9yIHlvdS5cbiAqICAgLSBSZWNvbW1lbmRlZCBwcmVmaXhlcyBhbmQgc3VmZml4ZXM6XG4gKiAgICAgLSBgTUFMRk9STUVEX2A6IFNvbWUgaW5wdXQgd2FzIG5vdCBjb25zdHJ1Y3RlZCBwcm9wZXJseS4gRS5nLiBgTUFMRk9STUVEX0JBU0U1OF9FTkNPREVEX0FERFJFU1NgLlxuICogICAgIC0gYElOVkFMSURfYDogU29tZSBpbnB1dCBpcyBpbnZhbGlkIChvdGhlciB0aGFuIGJlY2F1c2UgaXQgd2FzIE1BTEZPUk1FRCkuIEUuZy4gYElOVkFMSURfTlVNQkVSX09GX0JZVEVTYC5cbiAqICAgICAtIGBFWFBFQ1RFRF9gOiBTb21lIGlucHV0IHdhcyBkaWZmZXJlbnQgdGhhbiBleHBlY3RlZCwgbm8gbmVlZCB0byBzcGVjaWZ5IHRoZSBcIkdPVFwiIHBhcnQgdW5sZXNzIG5lY2Vzc2FyeS4gRS5nLiBgRVhQRUNURURfREVDT0RFRF9BQ0NPVU5UYC5cbiAqICAgICAtIGBfQ0FOTk9UX2A6IFNvbWUgb3BlcmF0aW9uIGNhbm5vdCBiZSBwZXJmb3JtZWQgb3Igc29tZSBpbnB1dCBjYW5ub3QgYmUgdXNlZCBkdWUgdG8gc29tZSBjb25kaXRpb24uIEUuZy4gYENBTk5PVF9ERUNPREVfRU1QVFlfQllURV9BUlJBWWAgb3IgYFBEQV9DQU5OT1RfRU5EX1dJVEhfUERBX01BUktFUmAuXG4gKiAgICAgLSBgX01VU1RfQkVfYDogU29tZSBjb25kaXRpb24gbXVzdCBiZSB0cnVlLiBFLmcuIGBOT05DRV9UUkFOU0FDVElPTl9GSVJTVF9JTlNUUlVDVElPTl9NVVNUX0JFX0FEVkFOQ0VfTk9OQ0VgLlxuICogICAgIC0gYF9GQUlMRURfVE9fYDogVHJpZWQgdG8gcGVyZm9ybSBzb21lIG9wZXJhdGlvbiBhbmQgZmFpbGVkLiBFLmcuIGBGQUlMRURfVE9fREVDT0RFX0FDQ09VTlRgLlxuICogICAgIC0gYF9OT1RfRk9VTkRgOiBTb21lIG9wZXJhdGlvbiBsZWFkIHRvIG5vdCBmaW5kaW5nIHNvbWV0aGluZy4gRS5nLiBgQUNDT1VOVF9OT1RfRk9VTkRgLlxuICogICAgIC0gYF9PVVRfT0ZfUkFOR0VgOiBTb21lIHZhbHVlIGlzIG91dCBvZiByYW5nZS4gRS5nLiBgRU5VTV9ESVNDUklNSU5BVE9SX09VVF9PRl9SQU5HRWAuXG4gKiAgICAgLSBgX0VYQ0VFREVEYDogU29tZSBsaW1pdCB3YXMgZXhjZWVkZWQuIEUuZy4gYFBEQV9NQVhfU0VFRF9MRU5HVEhfRVhDRUVERURgLlxuICogICAgIC0gYF9NSVNNQVRDSGA6IFNvbWUgZWxlbWVudHMgZG8gbm90IG1hdGNoLiBFLmcuIGBFTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSGAuXG4gKiAgICAgLSBgX01JU1NJTkdgOiBTb21lIHJlcXVpcmVkIGlucHV0IGlzIG1pc3NpbmcuIEUuZy4gYFRSQU5TQUNUSU9OX0ZFRV9QQVlFUl9NSVNTSU5HYC5cbiAqICAgICAtIGBfVU5JTVBMRU1FTlRFRGA6IFNvbWUgcmVxdWlyZWQgY29tcG9uZW50IGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGVudmlyb25tZW50LiBFLmcuIGBTVUJUTEVfQ1JZUFRPX1ZFUklGWV9GVU5DVElPTl9VTklNUExFTUVOVEVEYC5cbiAqL1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fQkxPQ0tfSEVJR0hUX0VYQ0VFREVEID0gMTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOVkFMSURfTk9OQ0UgPSAyO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fTk9OQ0VfQUNDT1VOVF9OT1RfRk9VTkQgPSAzO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fQkxPQ0tIQVNIX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFID0gNDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOVkFMSURfQkxPQ0tIQVNIX0JZVEVfTEVOR1RIID0gNTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0xBTVBPUlRTX09VVF9PRl9SQU5HRSA9IDY7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19NQUxGT1JNRURfQklHSU5UX1NUUklORyA9IDc7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19NQUxGT1JNRURfTlVNQkVSX1NUUklORyA9IDg7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19USU1FU1RBTVBfT1VUX09GX1JBTkdFID0gOTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9KU09OX1JQQ19FUlJPUiA9IDEwO1xuXG4vLyBKU09OLVJQQy1yZWxhdGVkIGVycm9ycy5cbi8vIFJlc2VydmUgZXJyb3IgY29kZXMgaW4gdGhlIHJhbmdlIFstMzI3NjgsIC0zMjAwMF1cbi8vIEtlZXAgaW4gc3luYyB3aXRoIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnphLXh5ei9hZ2F2ZS9ibG9iL21hc3Rlci9ycGMtY2xpZW50LWFwaS9zcmMvY3VzdG9tX2Vycm9yLnJzXG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fUEFSU0VfRVJST1IgPSAtMzI3MDA7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5URVJOQUxfRVJST1IgPSAtMzI2MDM7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9QQVJBTVMgPSAtMzI2MDI7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fTUVUSE9EX05PVF9GT1VORCA9IC0zMjYwMTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlZBTElEX1JFUVVFU1QgPSAtMzI2MDA7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX01JTl9DT05URVhUX1NMT1RfTk9UX1JFQUNIRUQgPSAtMzIwMTY7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1VOU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT04gPSAtMzIwMTU7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX1NUQVRVU19OT1RfQVZBSUxBQkxFX1lFVCA9IC0zMjAxNDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX0xFTl9NSVNNQVRDSCA9IC0zMjAxMztcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TQ0FOX0VSUk9SID0gLTMyMDEyO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9ISVNUT1JZX05PVF9BVkFJTEFCTEUgPSAtMzIwMTE7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0tFWV9FWENMVURFRF9GUk9NX1NFQ09OREFSWV9JTkRFWCA9IC0zMjAxMDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTE9OR19URVJNX1NUT1JBR0VfU0xPVF9TS0lQUEVEID0gLTMyMDA5O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9OT19TTkFQU0hPVCA9IC0zMjAwODtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0xPVF9TS0lQUEVEID0gLTMyMDA3O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9QUkVDT01QSUxFX1ZFUklGSUNBVElPTl9GQUlMVVJFID0gLTMyMDA2O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9OT0RFX1VOSEVBTFRIWSA9IC0zMjAwNTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfTk9UX0FWQUlMQUJMRSA9IC0zMjAwNDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFID0gLTMyMDAzO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFID0gLTMyMDAyO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19DTEVBTkVEX1VQID0gLTMyMDAxO1xuXG4vLyBBZGRyZXNzZXMtcmVsYXRlZCBlcnJvcnMuXG4vLyBSZXNlcnZlIGVycm9yIGNvZGVzIGluIHRoZSByYW5nZSBbMjgwMDAwMC0yODAwOTk5XS5cbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CWVRFX0xFTkdUSCA9IDI4MDAwMDA7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFID0gMjgwMDAwMTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CQVNFNThfRU5DT0RFRF9BRERSRVNTID0gMjgwMDAwMjtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9FRDI1NTE5X1BVQkxJQ19LRVkgPSAyODAwMDAzO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQUxGT1JNRURfUERBID0gMjgwMDAwNDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0JVTVBfU0VFRF9PVVRfT0ZfUkFOR0UgPSAyODAwMDA1O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfTlVNQkVSX09GX1BEQV9TRUVEU19FWENFRURFRCA9IDI4MDAwMDY7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BWF9QREFfU0VFRF9MRU5HVEhfRVhDRUVERUQgPSAyODAwMDA3O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX1NFRURTX1BPSU5UX09OX0NVUlZFID0gMjgwMDAwODtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fRkFJTEVEX1RPX0ZJTkRfVklBQkxFX1BEQV9CVU1QX1NFRUQgPSAyODAwMDA5O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19QREFfRU5EU19XSVRIX1BEQV9NQVJLRVIgPSAyODAwMDEwO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX09GRl9DVVJWRV9BRERSRVNTID0gMjgwMDAxMTtcblxuLy8gQWNjb3VudC1yZWxhdGVkIGVycm9ycy5cbi8vIFJlc2VydmUgZXJyb3IgY29kZXMgaW4gdGhlIHJhbmdlIFszMjMwMDAwLTMyMzA5OTldLlxuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0FDQ09VTlRfTk9UX0ZPVU5EID0gMzIzMDAwMDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19PTkVfT1JfTU9SRV9BQ0NPVU5UU19OT1RfRk9VTkQgPSAzMjMwMDAwMTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19GQUlMRURfVE9fREVDT0RFX0FDQ09VTlQgPSAzMjMwMDAyO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0VYUEVDVEVEX0RFQ09ERURfQUNDT1VOVCA9IDMyMzAwMDM7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRVhQRUNURURfQUxMX0FDQ09VTlRTX1RPX0JFX0RFQ09ERUQgPSAzMjMwMDA0O1xuXG4vLyBTdWJ0bGUtQ3J5cHRvLXJlbGF0ZWQgZXJyb3JzLlxuLy8gUmVzZXJ2ZSBlcnJvciBjb2RlcyBpbiB0aGUgcmFuZ2UgWzM2MTAwMDAtMzYxMDk5OV0uXG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19ESVNBTExPV0VEX0lOX0lOU0VDVVJFX0NPTlRFWFQgPSAzNjEwMDAwO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRElHRVNUX1VOSU1QTEVNRU5URUQgPSAzNjEwMDAxO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRUQyNTUxOV9BTEdPUklUSE1fVU5JTVBMRU1FTlRFRCA9IDM2MTAwMDI7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FWFBPUlRfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCA9IDM2MTAwMDM7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19HRU5FUkFURV9GVU5DVElPTl9VTklNUExFTUVOVEVEID0gMzYxMDAwNDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX1NJR05fRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCA9IDM2MTAwMDU7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19WRVJJRllfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCA9IDM2MTAwMDY7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19DQU5OT1RfRVhQT1JUX05PTl9FWFRSQUNUQUJMRV9LRVkgPSAzNjEwMDA3O1xuXG4vLyBDcnlwdG8tcmVsYXRlZCBlcnJvcnMuXG4vLyBSZXNlcnZlIGVycm9yIGNvZGVzIGluIHRoZSByYW5nZSBbMzYxMTAwMC0zNjExMDUwXS5cbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0NSWVBUT19fUkFORE9NX1ZBTFVFU19GVU5DVElPTl9VTklNUExFTUVOVEVEID0gMzYxMTAwMDtcblxuLy8gS2V5LXJlbGF0ZWQgZXJyb3JzLlxuLy8gUmVzZXJ2ZSBlcnJvciBjb2RlcyBpbiB0aGUgcmFuZ2UgWzM3MDQwMDAtMzcwNDk5OV0uXG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX0tFWV9QQUlSX0JZVEVfTEVOR1RIID0gMzcwNDAwMDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfUFJJVkFURV9LRVlfQllURV9MRU5HVEggPSAzNzA0MDAxO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9TSUdOQVRVUkVfQllURV9MRU5HVEggPSAzNzA0MDAyO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fS0VZU19fU0lHTkFUVVJFX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFID0gMzcwNDAwMztcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0tFWVNfX1BVQkxJQ19LRVlfTVVTVF9NQVRDSF9QUklWQVRFX0tFWSA9IDM3MDQwMDQ7XG5cbi8vIEluc3RydWN0aW9uLXJlbGF0ZWQgZXJyb3JzLlxuLy8gUmVzZXJ2ZSBlcnJvciBjb2RlcyBpbiB0aGUgcmFuZ2UgWzQxMjgwMDAtNDEyODk5OV0uXG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9BQ0NPVU5UUyA9IDQxMjgwMDA7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9EQVRBID0gNDEyODAwMTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19QUk9HUkFNX0lEX01JU01BVENIID0gNDEyODAwMjtcblxuLy8gSW5zdHJ1Y3Rpb24gZXJyb3JzLlxuLy8gUmVzZXJ2ZSBlcnJvciBjb2RlcyBzdGFydGluZyB3aXRoIFs0NjE1MDAwLTQ2MTU5OTldIGZvciB0aGUgUnVzdCBlbnVtIGBJbnN0cnVjdGlvbkVycm9yYC5cbi8vIEVycm9yIG5hbWVzIGhlcmUgYXJlIGRpY3RhdGVkIGJ5IHRoZSBSUEMgKHNlZSAuL2luc3RydWN0aW9uLWVycm9yLnRzKS5cbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTktOT1dOID0gNDYxNTAwMDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19HRU5FUklDX0VSUk9SID0gNDYxNTAwMTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FSR1VNRU5UID0gNDYxNTAwMjtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0lOU1RSVUNUSU9OX0RBVEEgPSA0NjE1MDAzO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9EQVRBID0gNDYxNTAwNDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0RBVEFfVE9PX1NNQUxMID0gNDYxNTAwNTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFMgPSA0NjE1MDA2O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9QUk9HUkFNX0lEID0gNDYxNTAwNztcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NSVNTSU5HX1JFUVVJUkVEX1NJR05BVFVSRSA9IDQ2MTUwMDg7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9BTFJFQURZX0lOSVRJQUxJWkVEID0gNDYxNTAwOTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTklOSVRJQUxJWkVEX0FDQ09VTlQgPSA0NjE1MDEwO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOQkFMQU5DRURfSU5TVFJVQ1RJT04gPSA0NjE1MDExO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01PRElGSUVEX1BST0dSQU1fSUQgPSA0NjE1MDEyO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYVEVSTkFMX0FDQ09VTlRfTEFNUE9SVF9TUEVORCA9IDQ2MTUwMTM7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhURVJOQUxfQUNDT1VOVF9EQVRBX01PRElGSUVEID0gNDYxNTAxNDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUFET05MWV9MQU1QT1JUX0NIQU5HRSA9IDQ2MTUwMTU7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfREFUQV9NT0RJRklFRCA9IDQ2MTUwMTY7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRFVQTElDQVRFX0FDQ09VTlRfSU5ERVggPSA0NjE1MDE3O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfTU9ESUZJRUQgPSA0NjE1MDE4O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFTlRfRVBPQ0hfTU9ESUZJRUQgPSA0NjE1MDE5O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX05PVF9FTk9VR0hfQUNDT1VOVF9LRVlTID0gNDYxNTAyMDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0RBVEFfU0laRV9DSEFOR0VEID0gNDYxNTAyMTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9FWEVDVVRBQkxFID0gNDYxNTAyMjtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19GQUlMRUQgPSA0NjE1MDIzO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX09VVFNUQU5ESU5HID0gNDYxNTAyNDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfQUNDT1VOVF9PVVRfT0ZfU1lOQyA9IDQ2MTUwMjU7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ1VTVE9NID0gNDYxNTAyNjtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0VSUk9SID0gNDYxNTAyNztcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0RBVEFfTU9ESUZJRUQgPSA0NjE1MDI4O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfTEFNUE9SVF9DSEFOR0UgPSA0NjE1MDI5O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfQUNDT1VOVF9OT1RfUkVOVF9FWEVNUFQgPSA0NjE1MDMwO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1BST0dSQU1fSUQgPSA0NjE1MDMxO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NBTExfREVQVEggPSA0NjE1MDMyO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01JU1NJTkdfQUNDT1VOVCA9IDQ2MTUwMzM7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVFTlRSQU5DWV9OT1RfQUxMT1dFRCA9IDQ2MTUwMzQ7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX1NFRURfTEVOR1RIX0VYQ0VFREVEID0gNDYxNTAzNTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX1NFRURTID0gNDYxNTAzNjtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX1JFQUxMT0MgPSA0NjE1MDM3O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NPTVBVVEFUSU9OQUxfQlVER0VUX0VYQ0VFREVEID0gNDYxNTAzODtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUklWSUxFR0VfRVNDQUxBVElPTiA9IDQ2MTUwMzk7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9FTlZJUk9OTUVOVF9TRVRVUF9GQUlMVVJFID0gNDYxNTA0MDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0ZBSUxFRF9UT19DT01QTEVURSA9IDQ2MTUwNDE7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9GQUlMRURfVE9fQ09NUElMRSA9IDQ2MTUwNDI7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU1NVVRBQkxFID0gNDYxNTA0MztcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTkNPUlJFQ1RfQVVUSE9SSVRZID0gNDYxNTA0NDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CT1JTSF9JT19FUlJPUiA9IDQ2MTUwNDU7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfUkVOVF9FWEVNUFQgPSA0NjE1MDQ2O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9PV05FUiA9IDQ2MTUwNDc7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQVJJVEhNRVRJQ19PVkVSRkxPVyA9IDQ2MTUwNDg7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfU1lTVkFSID0gNDYxNTA0OTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTExFR0FMX09XTkVSID0gNDYxNTA1MDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfQUNDT1VOVFNfREFUQV9BTExPQ0FUSU9OU19FWENFRURFRCA9IDQ2MTUwNTE7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0FDQ09VTlRTX0VYQ0VFREVEID0gNDYxNTA1MjtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfSU5TVFJVQ1RJT05fVFJBQ0VfTEVOR1RIX0VYQ0VFREVEID0gNDYxNTA1MztcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CVUlMVElOX1BST0dSQU1TX01VU1RfQ09OU1VNRV9DT01QVVRFX1VOSVRTID0gNDYxNTA1NDtcblxuLy8gU2lnbmVyLXJlbGF0ZWQgZXJyb3JzLlxuLy8gUmVzZXJ2ZSBlcnJvciBjb2RlcyBpbiB0aGUgcmFuZ2UgWzU1MDgwMDAtNTUwODk5OV0uXG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19TSUdORVJfX0FERFJFU1NfQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0lHTkVSUyA9IDU1MDgwMDA7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX0tFWV9QQUlSX1NJR05FUiA9IDU1MDgwMDE7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfU0lHTkVSID0gNTUwODAwMjtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9NT0RJRllJTkdfU0lHTkVSID0gNTUwODAwMztcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9QQVJUSUFMX1NJR05FUiA9IDU1MDgwMDQ7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1NJR05FUiA9IDU1MDgwMDU7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX01PRElGWUlOR19TSUdORVIgPSA1NTA4MDA2O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9QQVJUSUFMX1NJR05FUiA9IDU1MDgwMDc7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1NFTkRJTkdfU0lHTkVSID0gNTUwODAwODtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1NJR05FUl9fVFJBTlNBQ1RJT05fQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0VORElOR19TSUdORVJTID0gNTUwODAwOTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1NJR05FUl9fVFJBTlNBQ1RJT05fU0VORElOR19TSUdORVJfTUlTU0lORyA9IDU1MDgwMTA7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19TSUdORVJfX1dBTExFVF9NVUxUSVNJR05fVU5JTVBMRU1FTlRFRCA9IDU1MDgwMTE7XG5cbi8vIFRyYW5zYWN0aW9uLXJlbGF0ZWQgZXJyb3JzLlxuLy8gUmVzZXJ2ZSBlcnJvciBjb2RlcyBpbiB0aGUgcmFuZ2UgWzU2NjMwMDAtNTY2Mzk5OV0uXG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19DQU5OT1RfUEFZX0ZFRVMgPSA1NjYzMDAwO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVk9LRURfUFJPR1JBTVNfTVVTVF9OT1RfQkVfV1JJVEFCTEUgPSA1NjYzMDAxO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYUEVDVEVEX0JMT0NLSEFTSF9MSUZFVElNRSA9IDU2NjMwMDI7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfTk9OQ0VfTElGRVRJTUUgPSA1NjYzMDAzO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX1ZFUlNJT05fTlVNQkVSX09VVF9PRl9SQU5HRSA9IDU2NjMwMDQ7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9BRERSRVNTX0xPT0tVUF9UQUJMRV9DT05URU5UU19NSVNTSU5HID0gNTY2MzAwNTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0FERFJFU1NfTE9PS1VQX1RBQkxFX0lOREVYX09VVF9PRl9SQU5HRSA9IDU2NjMwMDY7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9JTlNUUlVDVElPTl9QUk9HUkFNX0FERFJFU1NfTk9UX0ZPVU5EID0gNTY2MzAwNztcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0ZFRV9QQVlFUl9NSVNTSU5HID0gNTY2MzAwODtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19TSUdOQVRVUkVTX01JU1NJTkcgPSA1NjYzMDA5O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0FERFJFU1NfTUlTU0lORyA9IDU2NjMwMTA7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkVFX1BBWUVSX01JU1NJTkcgPSA1NjYzMDExO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZFRV9QQVlFUl9TSUdOQVRVUkVfTUlTU0lORyA9IDU2NjMwMTI7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WQUxJRF9OT05DRV9UUkFOU0FDVElPTl9JTlNUUlVDVElPTlNfTUlTU0lORyA9IDU2NjMwMTM7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WQUxJRF9OT05DRV9UUkFOU0FDVElPTl9GSVJTVF9JTlNUUlVDVElPTl9NVVNUX0JFX0FEVkFOQ0VfTk9OQ0UgPSA1NjYzMDE0O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0FERFJFU1NFU19DQU5OT1RfU0lHTl9UUkFOU0FDVElPTiA9IDU2NjMwMTU7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQ0FOTk9UX0VOQ09ERV9XSVRIX0VNUFRZX1NJR05BVFVSRVMgPSA1NjYzMDE2O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX01FU1NBR0VfU0lHTkFUVVJFU19NSVNNQVRDSCA9IDU2NjMwMTc7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0VTVElNQVRFX0NPTVBVVEVfTElNSVQgPSA1NjYzMDE4O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9XSEVOX1NJTVVMQVRJTkdfVE9fRVNUSU1BVEVfQ09NUFVURV9MSU1JVCA9IDU2NjMwMTk7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhDRUVEU19TSVpFX0xJTUlUID0gNTY2MzAyMDtcblxuLy8gVHJhbnNhY3Rpb24gZXJyb3JzLlxuLy8gUmVzZXJ2ZSBlcnJvciBjb2RlcyBzdGFydGluZyB3aXRoIFs3MDUwMDAwLTcwNTA5OTldIGZvciB0aGUgUnVzdCBlbnVtIGBUcmFuc2FjdGlvbkVycm9yYC5cbi8vIEVycm9yIG5hbWVzIGhlcmUgYXJlIGRpY3RhdGVkIGJ5IHRoZSBSUEMgKHNlZSAuL3RyYW5zYWN0aW9uLWVycm9yLnRzKS5cbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTktOT1dOID0gNzA1MDAwMDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0lOX1VTRSA9IDcwNTAwMDE7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9MT0FERURfVFdJQ0UgPSA3MDUwMDAyO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX0ZPVU5EID0gNzA1MDAwMztcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19QUk9HUkFNX0FDQ09VTlRfTk9UX0ZPVU5EID0gNzA1MDAwNDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNfRk9SX0ZFRSA9IDcwNTAwMDU7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0ZPUl9GRUUgPSA3MDUwMDA2O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FMUkVBRFlfUFJPQ0VTU0VEID0gNzA1MDAwNztcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19CTE9DS0hBU0hfTk9UX0ZPVU5EID0gNzA1MDAwODtcbi8vIGBJbnN0cnVjdGlvbkVycm9yYCBpbnRlbnRpb25hbGx5IG9taXR0ZWQuXG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQ0FMTF9DSEFJTl9UT09fREVFUCA9IDcwNTAwMDk7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fTUlTU0lOR19TSUdOQVRVUkVfRk9SX0ZFRSA9IDcwNTAwMTA7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0lOREVYID0gNzA1MDAxMTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19TSUdOQVRVUkVfRkFJTFVSRSA9IDcwNTAwMTI7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9QUk9HUkFNX0ZPUl9FWEVDVVRJT04gPSA3MDUwMDEzO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1NBTklUSVpFX0ZBSUxVUkUgPSA3MDUwMDE0O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0NMVVNURVJfTUFJTlRFTkFOQ0UgPSA3MDUwMDE1O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX09VVFNUQU5ESU5HID0gNzA1MDAxNjtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX0JMT0NLX0NPU1RfTElNSVQgPSA3MDUwMDE3O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1ZFUlNJT04gPSA3MDUwMDE4O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfV1JJVEFCTEVfQUNDT1VOVCA9IDcwNTAwMTk7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9BQ0NPVU5UX0NPU1RfTElNSVQgPSA3MDUwMDIwO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9BQ0NPVU5UX0RBVEFfQkxPQ0tfTElNSVQgPSA3MDUwMDIxO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1RPT19NQU5ZX0FDQ09VTlRfTE9DS1MgPSA3MDUwMDIyO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FERFJFU1NfTE9PS1VQX1RBQkxFX05PVF9GT1VORCA9IDcwNTAwMjM7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9PV05FUiA9IDcwNTAwMjQ7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9EQVRBID0gNzA1MDAyNTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX0lOREVYID0gNzA1MDAyNjtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1JFTlRfUEFZSU5HX0FDQ09VTlQgPSA3MDUwMDI3O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9NQVhfVk9URV9DT1NUX0xJTUlUID0gNzA1MDAyODtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfQUNDT1VOVF9EQVRBX1RPVEFMX0xJTUlUID0gNzA1MDAyOTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfSU5TVFJVQ1RJT04gPSA3MDUwMDMwO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfUkVOVCA9IDcwNTAwMzE7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fTUFYX0xPQURFRF9BQ0NPVU5UU19EQVRBX1NJWkVfRVhDRUVERUQgPSA3MDUwMDMyO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfTE9BREVEX0FDQ09VTlRTX0RBVEFfU0laRV9MSU1JVCA9IDcwNTAwMzM7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUkVTQU5JVElaQVRJT05fTkVFREVEID0gNzA1MDAzNDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19QUk9HUkFNX0VYRUNVVElPTl9URU1QT1JBUklMWV9SRVNUUklDVEVEID0gNzA1MDAzNTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTkJBTEFOQ0VEX1RSQU5TQUNUSU9OID0gNzA1MDAzNjtcblxuLy8gQ29kZWMtcmVsYXRlZCBlcnJvcnMuXG4vLyBSZXNlcnZlIGVycm9yIGNvZGVzIGluIHRoZSByYW5nZSBbODA3ODAwMC04MDc4OTk5XS5cbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX0RFQ09ERV9FTVBUWV9CWVRFX0FSUkFZID0gODA3ODAwMDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9CWVRFX0xFTkdUSCA9IDgwNzgwMDE7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0ZJWEVEX0xFTkdUSCA9IDgwNzgwMDI7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCA9IDgwNzgwMDM7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9TSVpFX0NPTVBBVElCSUxJVFlfTUlTTUFUQ0ggPSA4MDc4MDA0O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSCA9IDgwNzgwMDU7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCA9IDgwNzgwMDY7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfTlVNQkVSX09GX0lURU1TID0gODA3ODAwNztcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5VTV9ESVNDUklNSU5BVE9SX09VVF9PRl9SQU5HRSA9IDgwNzgwMDg7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfRElTQ1JJTUlOQVRFRF9VTklPTl9WQVJJQU5UID0gODA3ODAwOTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9FTlVNX1ZBUklBTlQgPSA4MDc4MDEwO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fQ09ERUNTX19OVU1CRVJfT1VUX09GX1JBTkdFID0gODA3ODAxMTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9TVFJJTkdfRk9SX0JBU0UgPSA4MDc4MDEyO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCA9IDgwNzgwMTM7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19DT0RFQ1NfX09GRlNFVF9PVVRfT0ZfUkFOR0UgPSA4MDc4MDE0O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0xJVEVSQUxfVU5JT05fVkFSSUFOVCA9IDgwNzgwMTU7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0xJVEVSQUxfVU5JT05fRElTQ1JJTUlOQVRPUl9PVVRfT0ZfUkFOR0UgPSA4MDc4MDE2O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fQ09ERUNTX19VTklPTl9WQVJJQU5UX09VVF9PRl9SQU5HRSA9IDgwNzgwMTc7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQ09OU1RBTlQgPSA4MDc4MDE4O1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9aRVJPX1ZBTFVFX1RPX01BVENIX0lURU1fRklYRURfU0laRSA9IDgwNzgwMTk7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERURfQllURVNfTVVTVF9OT1RfSU5DTFVERV9TRU5USU5FTCA9IDgwNzgwMjA7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFUyA9IDgwNzgwMjE7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9VU0VfTEVYSUNBTF9WQUxVRVNfQVNfRU5VTV9ESVNDUklNSU5BVE9SUyA9IDgwNzgwMjI7XG5cbi8vIFJQQy1yZWxhdGVkIGVycm9ycy5cbi8vIFJlc2VydmUgZXJyb3IgY29kZXMgaW4gdGhlIHJhbmdlIFs4MTAwMDAwLTgxMDA5OTldLlxuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fUlBDX19JTlRFR0VSX09WRVJGTE9XID0gODEwMDAwMDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1JQQ19fVFJBTlNQT1JUX0hUVFBfSEVBREVSX0ZPUkJJRERFTiA9IDgxMDAwMDE7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19SUENfX1RSQU5TUE9SVF9IVFRQX0VSUk9SID0gODEwMDAwMjtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX1JQQ19fQVBJX1BMQU5fTUlTU0lOR19GT1JfUlBDX01FVEhPRCA9IDgxMDAwMDM7XG5cbi8vIFJQQy1TdWJzY3JpcHRpb25zLXJlbGF0ZWQgZXJyb3JzLlxuLy8gUmVzZXJ2ZSBlcnJvciBjb2RlcyBpbiB0aGUgcmFuZ2UgWzgxOTAwMDAtODE5MDk5OV0uXG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0FOTk9UX0NSRUFURV9TVUJTQ1JJUFRJT05fUExBTiA9IDgxOTAwMDA7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fRVhQRUNURURfU0VSVkVSX1NVQlNDUklQVElPTl9JRCA9IDgxOTAwMDE7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0hBTk5FTF9DTE9TRURfQkVGT1JFX01FU1NBR0VfQlVGRkVSRUQgPSA4MTkwMDAyO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfQ09OTkVDVElPTl9DTE9TRUQgPSA4MTkwMDAzO1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfRkFJTEVEX1RPX0NPTk5FQ1QgPSA4MTkwMDA0O1xuXG4vLyBJbnZhcmlhbnQgdmlvbGF0aW9uIGVycm9ycy5cbi8vIFJlc2VydmUgZXJyb3IgY29kZXMgaW4gdGhlIHJhbmdlIFs5OTAwMDAwLTk5MDA5OTldLlxuLy8gVGhlc2UgZXJyb3JzIHNob3VsZCBvbmx5IGJlIHRocm93biB3aGVuIHRoZXJlIGlzIGEgYnVnIHdpdGggdGhlXG4vLyBsaWJyYXJ5IGl0c2VsZiBhbmQgc2hvdWxkLCBpbiB0aGVvcnksIG5ldmVyIHJlYWNoIHRoZSBlbmQgdXNlci5cbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NVQlNDUklQVElPTl9JVEVSQVRPUl9TVEFURV9NSVNTSU5HID0gOTkwMDAwMDtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NVQlNDUklQVElPTl9JVEVSQVRPUl9NVVNUX05PVF9QT0xMX0JFRk9SRV9SRVNPTFZJTkdfRVhJU1RJTkdfTUVTU0FHRV9QUk9NSVNFID0gOTkwMDAwMTtcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0NBQ0hFRF9BQk9SVEFCTEVfSVRFUkFCTEVfQ0FDSEVfRU5UUllfTUlTU0lORyA9IDk5MDAwMDI7XG5leHBvcnQgY29uc3QgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TV0lUQ0hfTVVTVF9CRV9FWEhBVVNUSVZFID0gOTkwMDAwMztcbmV4cG9ydCBjb25zdCBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0RBVEFfUFVCTElTSEVSX0NIQU5ORUxfVU5JTVBMRU1FTlRFRCA9IDk5MDAwMDQ7XG5cbi8qKlxuICogQSB1bmlvbiBvZiBldmVyeSBTb2xhbmEgZXJyb3IgY29kZVxuICpcbiAqIEBwcml2YXRlUmVtYXJrc1xuICogWW91IG1pZ2h0IGJlIHdvbmRlcmluZyB3aHkgdGhpcyBpcyBub3QgYSBUeXBlU2NyaXB0IGVudW0gb3IgY29uc3QgZW51bS5cbiAqXG4gKiBPbmUgb2YgdGhlIGdvYWxzIG9mIHRoaXMgbGlicmFyeSBpcyB0byBlbmFibGUgcGVvcGxlIHRvIHVzZSBzb21lIG9yIG5vbmUgb2YgaXQgd2l0aG91dCBoYXZpbmcgdG9cbiAqIGJ1bmRsZSBhbGwgb2YgaXQuXG4gKlxuICogSWYgd2UgbWFkZSB0aGUgc2V0IG9mIGVycm9yIGNvZGVzIGFuIGVudW0gdGhlbiBhbnlvbmUgd2hvIGltcG9ydGVkIGl0IChldmVuIGlmIHRvIG9ubHkgdXNlIGFcbiAqIHNpbmdsZSBlcnJvciBjb2RlKSB3b3VsZCBiZSBmb3JjZWQgdG8gYnVuZGxlIGV2ZXJ5IGNvZGUgYW5kIGl0cyBsYWJlbC5cbiAqXG4gKiBDb25zdCBlbnVtcyBhcHBlYXIgdG8gc29sdmUgdGhpcyBwcm9ibGVtIGJ5IGxldHRpbmcgdGhlIGNvbXBpbGVyIGlubGluZSBvbmx5IHRoZSBjb2RlcyB0aGF0IGFyZVxuICogYWN0dWFsbHkgdXNlZC4gVW5mb3J0dW5hdGVseSBleHBvcnRpbmcgYW1iaWVudCAoY29uc3QpIGVudW1zIGZyb20gYSBsaWJyYXJ5IGxpa2UgYEBzb2xhbmEvZXJyb3JzYFxuICogaXMgbm90IHNhZmUsIGZvciBhIHZhcmlldHkgb2YgcmVhc29ucyBjb3ZlcmVkIGhlcmU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODgxODg1MFxuICovXG5leHBvcnQgdHlwZSBTb2xhbmFFcnJvckNvZGUgPVxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0FDQ09VTlRfTk9UX0ZPVU5EXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRVhQRUNURURfQUxMX0FDQ09VTlRTX1RPX0JFX0RFQ09ERURcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19FWFBFQ1RFRF9ERUNPREVEX0FDQ09VTlRcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19GQUlMRURfVE9fREVDT0RFX0FDQ09VTlRcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19PTkVfT1JfTU9SRV9BQ0NPVU5UU19OT1RfRk9VTkRcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fRkFJTEVEX1RPX0ZJTkRfVklBQkxFX1BEQV9CVU1QX1NFRURcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CQVNFNThfRU5DT0RFRF9BRERSRVNTXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfQllURV9MRU5HVEhcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9FRDI1NTE5X1BVQkxJQ19LRVlcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9PRkZfQ1VSVkVfQUREUkVTU1xuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX1NFRURTX1BPSU5UX09OX0NVUlZFXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BTEZPUk1FRF9QREFcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFYX05VTUJFUl9PRl9QREFfU0VFRFNfRVhDRUVERURcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFYX1BEQV9TRUVEX0xFTkdUSF9FWENFRURFRFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19QREFfQlVNUF9TRUVEX09VVF9PRl9SQU5HRVxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19QREFfRU5EU19XSVRIX1BEQV9NQVJLRVJcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0VcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0JMT0NLX0hFSUdIVF9FWENFRURFRFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fQkxPQ0tIQVNIX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9ERUNPREVfRU1QVFlfQllURV9BUlJBWVxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfVVNFX0xFWElDQUxfVkFMVUVTX0FTX0VOVU1fRElTQ1JJTUlOQVRPUlNcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENIXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENIXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOVU1fRElTQ1JJTUlOQVRPUl9PVVRfT0ZfUkFOR0VcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RIXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RIXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9aRVJPX1ZBTFVFX1RPX01BVENIX0lURU1fRklYRURfU0laRVxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0JZVEVfTEVOR1RIXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQ09OU1RBTlRcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9ESVNDUklNSU5BVEVEX1VOSU9OX1ZBUklBTlRcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9FTlVNX1ZBUklBTlRcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9MSVRFUkFMX1VOSU9OX1ZBUklBTlRcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9OVU1CRVJfT0ZfSVRFTVNcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9TVFJJTkdfRk9SX0JBU0VcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0NPREVDU19fTElURVJBTF9VTklPTl9ESVNDUklNSU5BVE9SX09VVF9PRl9SQU5HRVxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19OVU1CRVJfT1VUX09GX1JBTkdFXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19DT0RFQ1NfX09GRlNFVF9PVVRfT0ZfUkFOR0VcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0NPREVDU19fU0VOVElORUxfTUlTU0lOR19JTl9ERUNPREVEX0JZVEVTXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19DT0RFQ1NfX1VOSU9OX1ZBUklBTlRfT1VUX09GX1JBTkdFXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19DUllQVE9fX1JBTkRPTV9WQUxVRVNfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX0VYUEVDVEVEX1RPX0hBVkVfQUNDT1VOVFNcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19FWFBFQ1RFRF9UT19IQVZFX0RBVEFcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19QUk9HUkFNX0lEX01JU01BVENIXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9BTFJFQURZX0lOSVRJQUxJWkVEXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfRkFJTEVEXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfT1VUU1RBTkRJTkdcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0RBVEFfU0laRV9DSEFOR0VEXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9EQVRBX1RPT19TTUFMTFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX0VYRUNVVEFCTEVcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9SRU5UX0VYRU1QVFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FSSVRITUVUSUNfT1ZFUkZMT1dcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CT1JTSF9JT19FUlJPUlxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0JVSUxUSU5fUFJPR1JBTVNfTVVTVF9DT05TVU1FX0NPTVBVVEVfVU5JVFNcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DQUxMX0RFUFRIXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ09NUFVUQVRJT05BTF9CVURHRVRfRVhDRUVERURcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DVVNUT01cbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfQUNDT1VOVF9JTkRFWFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0RVUExJQ0FURV9BQ0NPVU5UX09VVF9PRl9TWU5DXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9BQ0NPVU5UX05PVF9SRU5UX0VYRU1QVFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfREFUQV9NT0RJRklFRFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfTEFNUE9SVF9DSEFOR0VcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX01PRElGSUVEXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhURVJOQUxfQUNDT1VOVF9EQVRBX01PRElGSUVEXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhURVJOQUxfQUNDT1VOVF9MQU1QT1JUX1NQRU5EXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fR0VORVJJQ19FUlJPUlxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lMTEVHQUxfT1dORVJcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTU1VVEFCTEVcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTkNPUlJFQ1RfQVVUSE9SSVRZXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5DT1JSRUNUX1BST0dSQU1fSURcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfREFUQVxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9PV05FUlxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQVJHVU1FTlRcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0VSUk9SXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9JTlNUUlVDVElPTl9EQVRBXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9SRUFMTE9DXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9TRUVEU1xuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9BQ0NPVU5UU19EQVRBX0FMTE9DQVRJT05TX0VYQ0VFREVEXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0FDQ09VTlRTX0VYQ0VFREVEXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0lOU1RSVUNUSU9OX1RSQUNFX0xFTkdUSF9FWENFRURFRFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9TRUVEX0xFTkdUSF9FWENFRURFRFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01JU1NJTkdfQUNDT1VOVFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01JU1NJTkdfUkVRVUlSRURfU0lHTkFUVVJFXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTU9ESUZJRURfUFJPR1JBTV9JRFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX05PVF9FTk9VR0hfQUNDT1VOVF9LRVlTXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJJVklMRUdFX0VTQ0FMQVRJT05cbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0VOVklST05NRU5UX1NFVFVQX0ZBSUxVUkVcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0ZBSUxFRF9UT19DT01QSUxFXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9GQUlMRURfVE9fQ09NUExFVEVcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUFET05MWV9EQVRBX01PRElGSUVEXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfTEFNUE9SVF9DSEFOR0VcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUVOVFJBTkNZX05PVF9BTExPV0VEXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVOVF9FUE9DSF9NT0RJRklFRFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOQkFMQU5DRURfSU5TVFJVQ1RJT05cbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTklOSVRJQUxJWkVEX0FDQ09VTlRcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTktOT1dOXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfUFJPR1JBTV9JRFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1NZU1ZBUlxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5WQUxJRF9CTE9DS0hBU0hfQllURV9MRU5HVEhcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOVkFMSURfTk9OQ0VcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0NBQ0hFRF9BQk9SVEFCTEVfSVRFUkFCTEVfQ0FDSEVfRU5UUllfTUlTU0lOR1xuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fREFUQV9QVUJMSVNIRVJfQ0hBTk5FTF9VTklNUExFTUVOVEVEXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TVUJTQ1JJUFRJT05fSVRFUkFUT1JfTVVTVF9OT1RfUE9MTF9CRUZPUkVfUkVTT0xWSU5HX0VYSVNUSU5HX01FU1NBR0VfUFJPTUlTRVxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fU1VCU0NSSVBUSU9OX0lURVJBVE9SX1NUQVRFX01JU1NJTkdcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NXSVRDSF9NVVNUX0JFX0VYSEFVU1RJVkVcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlRFUk5BTF9FUlJPUlxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUEFSQU1TXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9SRVFVRVNUXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fTUVUSE9EX05PVF9GT1VORFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1BBUlNFX0VSUk9SXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0NBTl9FUlJPUlxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19DTEVBTkVEX1VQXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX05PVF9BVkFJTEFCTEVcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVUXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0tFWV9FWENMVURFRF9GUk9NX1NFQ09OREFSWV9JTkRFWFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9MT05HX1RFUk1fU1RPUkFHRV9TTE9UX1NLSVBQRURcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTUlOX0NPTlRFWFRfU0xPVF9OT1RfUkVBQ0hFRFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9OT19TTkFQU0hPVFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9OT0RFX1VOSEVBTFRIWVxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NMT1RfU0tJUFBFRFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9ISVNUT1JZX05PVF9BVkFJTEFCTEVcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRVxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfTEVOX01JU01BVENIXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTFVSRVxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9VTlNVUFBPUlRFRF9UUkFOU0FDVElPTl9WRVJTSU9OXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX0tFWV9QQUlSX0JZVEVfTEVOR1RIXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX1BSSVZBVEVfS0VZX0JZVEVfTEVOR1RIXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX1NJR05BVFVSRV9CWVRFX0xFTkdUSFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fS0VZU19fUFVCTElDX0tFWV9NVVNUX01BVENIX1BSSVZBVEVfS0VZXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19LRVlTX19TSUdOQVRVUkVfU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0VcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0xBTVBPUlRTX09VVF9PRl9SQU5HRVxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fTUFMRk9STUVEX0JJR0lOVF9TVFJJTkdcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9KU09OX1JQQ19FUlJPUlxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fTUFMRk9STUVEX05VTUJFUl9TVFJJTkdcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX05PTkNFX0FDQ09VTlRfTk9UX0ZPVU5EXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19SUENfX0FQSV9QTEFOX01JU1NJTkdfRk9SX1JQQ19NRVRIT0RcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1JQQ19fSU5URUdFUl9PVkVSRkxPV1xuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9FUlJPUlxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9IRUFERVJfRk9SQklEREVOXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0FOTk9UX0NSRUFURV9TVUJTQ1JJUFRJT05fUExBTlxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfQ0xPU0VEX0JFRk9SRV9NRVNTQUdFX0JVRkZFUkVEXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0hBTk5FTF9DT05ORUNUSU9OX0NMT1NFRFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfRkFJTEVEX1RPX0NPTk5FQ1RcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19FWFBFQ1RFRF9TRVJWRVJfU1VCU0NSSVBUSU9OX0lEXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19TSUdORVJfX0FERFJFU1NfQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0lHTkVSU1xuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9LRVlfUEFJUl9TSUdORVJcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9NT0RJRllJTkdfU0lHTkVSXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfUEFSVElBTF9TSUdORVJcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9TSUdORVJcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fTU9ESUZZSU5HX1NJR05FUlxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9QQVJUSUFMX1NJR05FUlxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUlxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9TSUdORVJcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1NJR05FUl9fVFJBTlNBQ1RJT05fQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0VORElOR19TSUdORVJTXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19TSUdORVJfX1RSQU5TQUNUSU9OX1NFTkRJTkdfU0lHTkVSX01JU1NJTkdcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1NJR05FUl9fV0FMTEVUX01VTFRJU0lHTl9VTklNUExFTUVOVEVEXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19DQU5OT1RfRVhQT1JUX05PTl9FWFRSQUNUQUJMRV9LRVlcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0RJR0VTVF9VTklNUExFTUVOVEVEXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19ESVNBTExPV0VEX0lOX0lOU0VDVVJFX0NPTlRFWFRcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0VEMjU1MTlfQUxHT1JJVEhNX1VOSU1QTEVNRU5URURcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0VYUE9SVF9GVU5DVElPTl9VTklNUExFTUVOVEVEXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19HRU5FUkFURV9GVU5DVElPTl9VTklNUExFTUVOVEVEXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19TSUdOX0ZVTkNUSU9OX1VOSU1QTEVNRU5URURcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX1ZFUklGWV9GVU5DVElPTl9VTklNUExFTUVOVEVEXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19USU1FU1RBTVBfT1VUX09GX1JBTkdFXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQUREUkVTU19NSVNTSU5HXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQUREUkVTU0VTX0NBTk5PVF9TSUdOX1RSQU5TQUNUSU9OXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQ0FOTk9UX0VOQ09ERV9XSVRIX0VNUFRZX1NJR05BVFVSRVNcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWENFRURTX1NJWkVfTElNSVRcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWFBFQ1RFRF9CTE9DS0hBU0hfTElGRVRJTUVcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWFBFQ1RFRF9OT05DRV9MSUZFVElNRVxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfQUREUkVTU19MT09LVVBfVEFCTEVfQ09OVEVOVFNfTUlTU0lOR1xuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfQUREUkVTU19MT09LVVBfVEFCTEVfSU5ERVhfT1VUX09GX1JBTkdFXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9GRUVfUEFZRVJfTUlTU0lOR1xuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfSU5TVFJVQ1RJT05fUFJPR1JBTV9BRERSRVNTX05PVF9GT1VORFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19FU1RJTUFURV9DT01QVVRFX0xJTUlUXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1dIRU5fU0lNVUxBVElOR19UT19FU1RJTUFURV9DT01QVVRFX0xJTUlUXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkVFX1BBWUVSX01JU1NJTkdcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GRUVfUEFZRVJfU0lHTkFUVVJFX01JU1NJTkdcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZBTElEX05PTkNFX1RSQU5TQUNUSU9OX0ZJUlNUX0lOU1RSVUNUSU9OX01VU1RfQkVfQURWQU5DRV9OT05DRVxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVkFMSURfTk9OQ0VfVFJBTlNBQ1RJT05fSU5TVFJVQ1RJT05TX01JU1NJTkdcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZPS0VEX1BST0dSQU1TX0NBTk5PVF9QQVlfRkVFU1xuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVk9LRURfUFJPR1JBTVNfTVVTVF9OT1RfQkVfV1JJVEFCTEVcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19NRVNTQUdFX1NJR05BVFVSRVNfTUlTTUFUQ0hcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19TSUdOQVRVUkVTX01JU1NJTkdcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19WRVJTSU9OX05VTUJFUl9PVVRfT0ZfUkFOR0VcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19PVVRTVEFORElOR1xuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfSU5fVVNFXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9MT0FERURfVFdJQ0VcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9GT1VORFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FERFJFU1NfTE9PS1VQX1RBQkxFX05PVF9GT1VORFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FMUkVBRFlfUFJPQ0VTU0VEXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQkxPQ0tIQVNIX05PVF9GT1VORFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0NBTExfQ0hBSU5fVE9PX0RFRVBcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19DTFVTVEVSX01BSU5URU5BTkNFXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fRFVQTElDQVRFX0lOU1RSVUNUSU9OXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5TVUZGSUNJRU5UX0ZVTkRTX0ZPUl9GRUVcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNfRk9SX1JFTlRcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfRk9SX0ZFRVxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9JTkRFWFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUREUkVTU19MT09LVVBfVEFCTEVfREFUQVxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUREUkVTU19MT09LVVBfVEFCTEVfSU5ERVhcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX09XTkVSXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9MT0FERURfQUNDT1VOVFNfREFUQV9TSVpFX0xJTUlUXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9QUk9HUkFNX0ZPUl9FWEVDVVRJT05cbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1JFTlRfUEFZSU5HX0FDQ09VTlRcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1dSSVRBQkxFX0FDQ09VTlRcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19NQVhfTE9BREVEX0FDQ09VTlRTX0RBVEFfU0laRV9FWENFRURFRFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX01JU1NJTkdfU0lHTkFUVVJFX0ZPUl9GRUVcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19QUk9HUkFNX0FDQ09VTlRfTk9UX0ZPVU5EXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUFJPR1JBTV9FWEVDVVRJT05fVEVNUE9SQVJJTFlfUkVTVFJJQ1RFRFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1JFU0FOSVRJWkFUSU9OX05FRURFRFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1NBTklUSVpFX0ZBSUxVUkVcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19TSUdOQVRVUkVfRkFJTFVSRVxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1RPT19NQU5ZX0FDQ09VTlRfTE9DS1NcbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTkJBTEFOQ0VEX1RSQU5TQUNUSU9OXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5LTk9XTlxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1ZFUlNJT05cbiAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfQUNDT1VOVF9EQVRBX0JMT0NLX0xJTUlUXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX0FDQ09VTlRfREFUQV9UT1RBTF9MSU1JVFxuICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9NQVhfQUNDT1VOVF9DT1NUX0xJTUlUXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9CTE9DS19DT1NUX0xJTUlUXG4gICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9WT1RFX0NPU1RfTElNSVQ7XG5cbi8qKlxuICogRXJyb3JzIG9mIHRoaXMgdHlwZSBhcmUgdW5kZXJzdG9vZCB0byBoYXZlIGFuIG9wdGlvbmFsIHtAbGluayBTb2xhbmFFcnJvcn0gbmVzdGVkIGluc2lkZSBhc1xuICogYGNhdXNlYC5cbiAqL1xuZXhwb3J0IHR5cGUgU29sYW5hRXJyb3JDb2RlV2l0aENhdXNlID0gdHlwZW9mIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFO1xuIiwgIi8qKlxuICogVG8gYWRkIGEgbmV3IGVycm9yLCBmb2xsb3cgdGhlIGluc3RydWN0aW9ucyBhdFxuICogaHR0cHM6Ly9naXRodWIuY29tL2FuemEteHl6L2tpdC90cmVlL21haW4vcGFja2FnZXMvZXJyb3JzLyNhZGRpbmctYS1uZXctZXJyb3JcbiAqXG4gKiBAcHJpdmF0ZVJlbWFya3NcbiAqIFdBUk5JTkc6XG4gKiAgIC0gRG9uJ3QgY2hhbmdlIG9yIHJlbW92ZSBtZW1iZXJzIG9mIGFuIGVycm9yJ3MgY29udGV4dC5cbiAqL1xuaW1wb3J0IHtcbiAgICBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19BQ0NPVU5UX05PVF9GT1VORCxcbiAgICBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19FWFBFQ1RFRF9BTExfQUNDT1VOVFNfVE9fQkVfREVDT0RFRCxcbiAgICBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19FWFBFQ1RFRF9ERUNPREVEX0FDQ09VTlQsXG4gICAgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRkFJTEVEX1RPX0RFQ09ERV9BQ0NPVU5ULFxuICAgIFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX09ORV9PUl9NT1JFX0FDQ09VTlRTX05PVF9GT1VORCxcbiAgICBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CQVNFNThfRU5DT0RFRF9BRERSRVNTLFxuICAgIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JZVEVfTEVOR1RILFxuICAgIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfTlVNQkVSX09GX1BEQV9TRUVEU19FWENFRURFRCxcbiAgICBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFYX1BEQV9TRUVEX0xFTkdUSF9FWENFRURFRCxcbiAgICBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0JVTVBfU0VFRF9PVVRfT0ZfUkFOR0UsXG4gICAgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFLFxuICAgIFNPTEFOQV9FUlJPUl9fQkxPQ0tfSEVJR0hUX0VYQ0VFREVELFxuICAgIFNPTEFOQV9FUlJPUl9fQkxPQ0tIQVNIX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFLFxuICAgIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVksXG4gICAgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9VU0VfTEVYSUNBTF9WQUxVRVNfQVNfRU5VTV9ESVNDUklNSU5BVE9SUyxcbiAgICBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMLFxuICAgIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSCxcbiAgICBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX01BWF9TSVpFX01JU01BVENILFxuICAgIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTlVNX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFLFxuICAgIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCxcbiAgICBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfWkVST19WQUxVRV9UT19NQVRDSF9JVEVNX0ZJWEVEX1NJWkUsXG4gICAgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEgsXG4gICAgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQ09OU1RBTlQsXG4gICAgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfRElTQ1JJTUlOQVRFRF9VTklPTl9WQVJJQU5ULFxuICAgIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0VOVU1fVkFSSUFOVCxcbiAgICBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9MSVRFUkFMX1VOSU9OX1ZBUklBTlQsXG4gICAgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfTlVNQkVSX09GX0lURU1TLFxuICAgIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX1NUUklOR19GT1JfQkFTRSxcbiAgICBTT0xBTkFfRVJST1JfX0NPREVDU19fTElURVJBTF9VTklPTl9ESVNDUklNSU5BVE9SX09VVF9PRl9SQU5HRSxcbiAgICBTT0xBTkFfRVJST1JfX0NPREVDU19fTlVNQkVSX09VVF9PRl9SQU5HRSxcbiAgICBTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRSxcbiAgICBTT0xBTkFfRVJST1JfX0NPREVDU19fU0VOVElORUxfTUlTU0lOR19JTl9ERUNPREVEX0JZVEVTLFxuICAgIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19VTklPTl9WQVJJQU5UX09VVF9PRl9SQU5HRSxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19FWFBFQ1RFRF9UT19IQVZFX0FDQ09VTlRTLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX0VYUEVDVEVEX1RPX0hBVkVfREFUQSxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19QUk9HUkFNX0lEX01JU01BVENILFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQUxSRUFEWV9JTklUSUFMSVpFRCxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19GQUlMRUQsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfT1VUU1RBTkRJTkcsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9EQVRBX1NJWkVfQ0hBTkdFRCxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0RBVEFfVE9PX1NNQUxMLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX0VYRUNVVEFCTEUsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfUkVOVF9FWEVNUFQsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQVJJVEhNRVRJQ19PVkVSRkxPVyxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CT1JTSF9JT19FUlJPUixcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CVUlMVElOX1BST0dSQU1TX01VU1RfQ09OU1VNRV9DT01QVVRFX1VOSVRTLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NBTExfREVQVEgsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ09NUFVUQVRJT05BTF9CVURHRVRfRVhDRUVERUQsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ1VTVE9NLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0RVUExJQ0FURV9BQ0NPVU5UX0lOREVYLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0RVUExJQ0FURV9BQ0NPVU5UX09VVF9PRl9TWU5DLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfQUNDT1VOVF9OT1RfUkVOVF9FWEVNUFQsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9EQVRBX01PRElGSUVELFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfTEFNUE9SVF9DSEFOR0UsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9NT0RJRklFRCxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWFRFUk5BTF9BQ0NPVU5UX0RBVEFfTU9ESUZJRUQsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhURVJOQUxfQUNDT1VOVF9MQU1QT1JUX1NQRU5ELFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0dFTkVSSUNfRVJST1IsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSUxMRUdBTF9PV05FUixcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTU1VVEFCTEUsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5DT1JSRUNUX0FVVEhPUklUWSxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTkNPUlJFQ1RfUFJPR1JBTV9JRCxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFMsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0RBVEEsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX09XTkVSLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQVJHVU1FTlQsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9FUlJPUixcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0lOU1RSVUNUSU9OX0RBVEEsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9SRUFMTE9DLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfU0VFRFMsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0FDQ09VTlRTX0RBVEFfQUxMT0NBVElPTlNfRVhDRUVERUQsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0FDQ09VTlRTX0VYQ0VFREVELFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9JTlNUUlVDVElPTl9UUkFDRV9MRU5HVEhfRVhDRUVERUQsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX1NFRURfTEVOR1RIX0VYQ0VFREVELFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01JU1NJTkdfQUNDT1VOVCxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NSVNTSU5HX1JFUVVJUkVEX1NJR05BVFVSRSxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NT0RJRklFRF9QUk9HUkFNX0lELFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX05PVF9FTk9VR0hfQUNDT1VOVF9LRVlTLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BSSVZJTEVHRV9FU0NBTEFUSU9OLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRU5WSVJPTk1FTlRfU0VUVVBfRkFJTFVSRSxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0ZBSUxFRF9UT19DT01QSUxFLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRkFJTEVEX1RPX0NPTVBMRVRFLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFQURPTkxZX0RBVEFfTU9ESUZJRUQsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfTEFNUE9SVF9DSEFOR0UsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVFTlRSQU5DWV9OT1RfQUxMT1dFRCxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRU5UX0VQT0NIX01PRElGSUVELFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOQkFMQU5DRURfSU5TVFJVQ1RJT04sXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5JTklUSUFMSVpFRF9BQ0NPVU5ULFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOS05PV04sXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfUFJPR1JBTV9JRCxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9TWVNWQVIsXG4gICAgU09MQU5BX0VSUk9SX19JTlZBTElEX0JMT0NLSEFTSF9CWVRFX0xFTkdUSCxcbiAgICBTT0xBTkFfRVJST1JfX0lOVkFMSURfTk9OQ0UsXG4gICAgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19DQUNIRURfQUJPUlRBQkxFX0lURVJBQkxFX0NBQ0hFX0VOVFJZX01JU1NJTkcsXG4gICAgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19EQVRBX1BVQkxJU0hFUl9DSEFOTkVMX1VOSU1QTEVNRU5URUQsXG4gICAgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TV0lUQ0hfTVVTVF9CRV9FWEhBVVNUSVZFLFxuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVEVSTkFMX0VSUk9SLFxuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUEFSQU1TLFxuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUkVRVUVTVCxcbiAgICBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19NRVRIT0RfTk9UX0ZPVU5ELFxuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1BBUlNFX0VSUk9SLFxuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NDQU5fRVJST1IsXG4gICAgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVAsXG4gICAgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX05PVF9BVkFJTEFCTEUsXG4gICAgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX1NUQVRVU19OT1RfQVZBSUxBQkxFX1lFVCxcbiAgICBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYLFxuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9MT05HX1RFUk1fU1RPUkFHRV9TTE9UX1NLSVBQRUQsXG4gICAgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX01JTl9DT05URVhUX1NMT1RfTk9UX1JFQUNIRUQsXG4gICAgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX05PREVfVU5IRUFMVEhZLFxuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFLFxuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TTE9UX1NLSVBQRUQsXG4gICAgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1BSRUNPTVBJTEVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkUsXG4gICAgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1VOU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT04sXG4gICAgU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX0tFWV9QQUlSX0JZVEVfTEVOR1RILFxuICAgIFNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9QUklWQVRFX0tFWV9CWVRFX0xFTkdUSCxcbiAgICBTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfU0lHTkFUVVJFX0JZVEVfTEVOR1RILFxuICAgIFNPTEFOQV9FUlJPUl9fS0VZU19fU0lHTkFUVVJFX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFLFxuICAgIFNPTEFOQV9FUlJPUl9fTUFMRk9STUVEX0JJR0lOVF9TVFJJTkcsXG4gICAgU09MQU5BX0VSUk9SX19NQUxGT1JNRURfSlNPTl9SUENfRVJST1IsXG4gICAgU09MQU5BX0VSUk9SX19NQUxGT1JNRURfTlVNQkVSX1NUUklORyxcbiAgICBTT0xBTkFfRVJST1JfX05PTkNFX0FDQ09VTlRfTk9UX0ZPVU5ELFxuICAgIFNPTEFOQV9FUlJPUl9fUlBDX19BUElfUExBTl9NSVNTSU5HX0ZPUl9SUENfTUVUSE9ELFxuICAgIFNPTEFOQV9FUlJPUl9fUlBDX19JTlRFR0VSX09WRVJGTE9XLFxuICAgIFNPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9FUlJPUixcbiAgICBTT0xBTkFfRVJST1JfX1JQQ19fVFJBTlNQT1JUX0hUVFBfSEVBREVSX0ZPUkJJRERFTixcbiAgICBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DQU5OT1RfQ1JFQVRFX1NVQlNDUklQVElPTl9QTEFOLFxuICAgIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfRkFJTEVEX1RPX0NPTk5FQ1QsXG4gICAgU09MQU5BX0VSUk9SX19TSUdORVJfX0FERFJFU1NfQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0lHTkVSUyxcbiAgICBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfS0VZX1BBSVJfU0lHTkVSLFxuICAgIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX01PRElGWUlOR19TSUdORVIsXG4gICAgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfUEFSVElBTF9TSUdORVIsXG4gICAgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfU0lHTkVSLFxuICAgIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9NT0RJRllJTkdfU0lHTkVSLFxuICAgIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9QQVJUSUFMX1NJR05FUixcbiAgICBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fU0VORElOR19TSUdORVIsXG4gICAgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1NJR05FUixcbiAgICBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0NBTk5PVF9FWFBPUlRfTk9OX0VYVFJBQ1RBQkxFX0tFWSxcbiAgICBTT0xBTkFfRVJST1JfX1RJTUVTVEFNUF9PVVRfT0ZfUkFOR0UsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQUREUkVTU19NSVNTSU5HLFxuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0FERFJFU1NFU19DQU5OT1RfU0lHTl9UUkFOU0FDVElPTixcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWENFRURTX1NJWkVfTElNSVQsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9BRERSRVNTX0xPT0tVUF9UQUJMRV9DT05URU5UU19NSVNTSU5HLFxuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfQUREUkVTU19MT09LVVBfVEFCTEVfSU5ERVhfT1VUX09GX1JBTkdFLFxuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfSU5TVFJVQ1RJT05fUFJPR1JBTV9BRERSRVNTX05PVF9GT1VORCxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfV0hFTl9TSU1VTEFUSU5HX1RPX0VTVElNQVRFX0NPTVBVVEVfTElNSVQsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19DQU5OT1RfUEFZX0ZFRVMsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19NVVNUX05PVF9CRV9XUklUQUJMRSxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19NRVNTQUdFX1NJR05BVFVSRVNfTUlTTUFUQ0gsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fU0lHTkFUVVJFU19NSVNTSU5HLFxuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX1ZFUlNJT05fTlVNQkVSX09VVF9PRl9SQU5HRSxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfSU5TVFJVQ1RJT04sXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5TVUZGSUNJRU5UX0ZVTkRTX0ZPUl9SRU5ULFxuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1BST0dSQU1fRVhFQ1VUSU9OX1RFTVBPUkFSSUxZX1JFU1RSSUNURUQsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5LTk9XTixcbiAgICBTb2xhbmFFcnJvckNvZGUsXG59IGZyb20gJy4vY29kZXMnO1xuaW1wb3J0IHsgUnBjU2ltdWxhdGVUcmFuc2FjdGlvblJlc3VsdCB9IGZyb20gJy4vanNvbi1ycGMtZXJyb3InO1xuXG50eXBlIEJhc2ljSW5zdHJ1Y3Rpb25FcnJvckNvbnRleHQ8VCBleHRlbmRzIFNvbGFuYUVycm9yQ29kZT4gPSBSZWFkb25seTx7IFtQIGluIFRdOiB7IGluZGV4OiBudW1iZXIgfSB9PjtcblxudHlwZSBEZWZhdWx0VW5zcGVjaWZpZWRFcnJvckNvbnRleHRUb1VuZGVmaW5lZDxUPiA9IHtcbiAgICBbUCBpbiBTb2xhbmFFcnJvckNvZGVdOiBQIGV4dGVuZHMga2V5b2YgVCA/IFRbUF0gOiB1bmRlZmluZWQ7XG59O1xuXG50eXBlIFR5cGVkQXJyYXlNdXRhYmxlUHJvcGVydGllcyA9ICdjb3B5V2l0aGluJyB8ICdmaWxsJyB8ICdyZXZlcnNlJyB8ICdzZXQnIHwgJ3NvcnQnO1xuaW50ZXJmYWNlIFJlYWRvbmx5VWludDhBcnJheSBleHRlbmRzIE9taXQ8VWludDhBcnJheSwgVHlwZWRBcnJheU11dGFibGVQcm9wZXJ0aWVzPiB7XG4gICAgcmVhZG9ubHkgW246IG51bWJlcl06IG51bWJlcjtcbn1cblxuLyoqIEEgYW1vdW50IG9mIGJ5dGVzLiAqL1xudHlwZSBCeXRlcyA9IG51bWJlcjtcblxuLyoqXG4gKiBBIG1hcCBvZiBldmVyeSB7QGxpbmsgU29sYW5hRXJyb3J9IGNvZGUgdG8gdGhlIHR5cGUgb2YgaXRzIGBjb250ZXh0YCBwcm9wZXJ0eS5cbiAqL1xuZXhwb3J0IHR5cGUgU29sYW5hRXJyb3JDb250ZXh0ID0gRGVmYXVsdFVuc3BlY2lmaWVkRXJyb3JDb250ZXh0VG9VbmRlZmluZWQ8XG4gICAgQmFzaWNJbnN0cnVjdGlvbkVycm9yQ29udGV4dDxcbiAgICAgICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9BTFJFQURZX0lOSVRJQUxJWkVEXG4gICAgICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX0ZBSUxFRFxuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19PVVRTVEFORElOR1xuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0RBVEFfU0laRV9DSEFOR0VEXG4gICAgICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfREFUQV9UT09fU01BTExcbiAgICAgICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfRVhFQ1VUQUJMRVxuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9SRU5UX0VYRU1QVFxuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BUklUSE1FVElDX09WRVJGTE9XXG4gICAgICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0JPUlNIX0lPX0VSUk9SXG4gICAgICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0JVSUxUSU5fUFJPR1JBTVNfTVVTVF9DT05TVU1FX0NPTVBVVEVfVU5JVFNcbiAgICAgICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ0FMTF9ERVBUSFxuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DT01QVVRBVElPTkFMX0JVREdFVF9FWENFRURFRFxuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DVVNUT01cbiAgICAgICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRFVQTElDQVRFX0FDQ09VTlRfSU5ERVhcbiAgICAgICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRFVQTElDQVRFX0FDQ09VTlRfT1VUX09GX1NZTkNcbiAgICAgICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9BQ0NPVU5UX05PVF9SRU5UX0VYRU1QVFxuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0RBVEFfTU9ESUZJRURcbiAgICAgICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9MQU1QT1JUX0NIQU5HRVxuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX01PRElGSUVEXG4gICAgICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYVEVSTkFMX0FDQ09VTlRfREFUQV9NT0RJRklFRFxuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWFRFUk5BTF9BQ0NPVU5UX0xBTVBPUlRfU1BFTkRcbiAgICAgICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fR0VORVJJQ19FUlJPUlxuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTExFR0FMX09XTkVSXG4gICAgICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lNTVVUQUJMRVxuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTkNPUlJFQ1RfQVVUSE9SSVRZXG4gICAgICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9QUk9HUkFNX0lEXG4gICAgICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU1xuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfREFUQVxuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfT1dORVJcbiAgICAgICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BUkdVTUVOVFxuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0VSUk9SXG4gICAgICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfSU5TVFJVQ1RJT05fREFUQVxuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX1JFQUxMT0NcbiAgICAgICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9TRUVEU1xuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfQUNDT1VOVFNfREFUQV9BTExPQ0FUSU9OU19FWENFRURFRFxuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfQUNDT1VOVFNfRVhDRUVERURcbiAgICAgICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0lOU1RSVUNUSU9OX1RSQUNFX0xFTkdUSF9FWENFRURFRFxuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfU0VFRF9MRU5HVEhfRVhDRUVERURcbiAgICAgICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUlTU0lOR19BQ0NPVU5UXG4gICAgICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01JU1NJTkdfUkVRVUlSRURfU0lHTkFUVVJFXG4gICAgICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01PRElGSUVEX1BST0dSQU1fSURcbiAgICAgICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTk9UX0VOT1VHSF9BQ0NPVU5UX0tFWVNcbiAgICAgICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJJVklMRUdFX0VTQ0FMQVRJT05cbiAgICAgICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9FTlZJUk9OTUVOVF9TRVRVUF9GQUlMVVJFXG4gICAgICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRkFJTEVEX1RPX0NPTVBJTEVcbiAgICAgICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9GQUlMRURfVE9fQ09NUExFVEVcbiAgICAgICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfREFUQV9NT0RJRklFRFxuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUFET05MWV9MQU1QT1JUX0NIQU5HRVxuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUVOVFJBTkNZX05PVF9BTExPV0VEXG4gICAgICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFTlRfRVBPQ0hfTU9ESUZJRURcbiAgICAgICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5CQUxBTkNFRF9JTlNUUlVDVElPTlxuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTklOSVRJQUxJWkVEX0FDQ09VTlRcbiAgICAgICAgfCB0eXBlb2YgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5LTk9XTlxuICAgICAgICB8IHR5cGVvZiBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9QUk9HUkFNX0lEXG4gICAgICAgIHwgdHlwZW9mIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1NZU1ZBUlxuICAgID4gJiB7XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19BQ0NPVU5UX05PVF9GT1VORF06IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0VYUEVDVEVEX0FMTF9BQ0NPVU5UU19UT19CRV9ERUNPREVEXToge1xuICAgICAgICAgICAgYWRkcmVzc2VzOiBzdHJpbmdbXTtcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0VYUEVDVEVEX0RFQ09ERURfQUNDT1VOVF06IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0ZBSUxFRF9UT19ERUNPREVfQUNDT1VOVF06IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX09ORV9PUl9NT1JFX0FDQ09VTlRTX05PVF9GT1VORF06IHtcbiAgICAgICAgICAgIGFkZHJlc3Nlczogc3RyaW5nW107XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CQVNFNThfRU5DT0RFRF9BRERSRVNTXToge1xuICAgICAgICAgICAgcHV0YXRpdmVBZGRyZXNzOiBzdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CWVRFX0xFTkdUSF06IHtcbiAgICAgICAgICAgIGFjdHVhbExlbmd0aDogbnVtYmVyO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BWF9OVU1CRVJfT0ZfUERBX1NFRURTX0VYQ0VFREVEXToge1xuICAgICAgICAgICAgYWN0dWFsOiBudW1iZXI7XG4gICAgICAgICAgICBtYXhTZWVkczogbnVtYmVyO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BWF9QREFfU0VFRF9MRU5HVEhfRVhDRUVERURdOiB7XG4gICAgICAgICAgICBhY3R1YWw6IG51bWJlcjtcbiAgICAgICAgICAgIGluZGV4OiBudW1iZXI7XG4gICAgICAgICAgICBtYXhTZWVkTGVuZ3RoOiBudW1iZXI7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0JVTVBfU0VFRF9PVVRfT0ZfUkFOR0VdOiB7XG4gICAgICAgICAgICBidW1wOiBudW1iZXI7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0VdOiB7XG4gICAgICAgICAgICBhY3R1YWxMZW5ndGg6IG51bWJlcjtcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fQkxPQ0tIQVNIX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFXToge1xuICAgICAgICAgICAgYWN0dWFsTGVuZ3RoOiBudW1iZXI7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0JMT0NLX0hFSUdIVF9FWENFRURFRF06IHtcbiAgICAgICAgICAgIGN1cnJlbnRCbG9ja0hlaWdodDogYmlnaW50O1xuICAgICAgICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IGJpZ2ludDtcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVldOiB7XG4gICAgICAgICAgICBjb2RlY0Rlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX1VTRV9MRVhJQ0FMX1ZBTFVFU19BU19FTlVNX0RJU0NSSU1JTkFUT1JTXToge1xuICAgICAgICAgICAgc3RyaW5nVmFsdWVzOiBzdHJpbmdbXTtcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUxdOiB7XG4gICAgICAgICAgICBlbmNvZGVkQnl0ZXM6IFJlYWRvbmx5VWludDhBcnJheTtcbiAgICAgICAgICAgIGhleEVuY29kZWRCeXRlczogc3RyaW5nO1xuICAgICAgICAgICAgaGV4U2VudGluZWw6IHN0cmluZztcbiAgICAgICAgICAgIHNlbnRpbmVsOiBSZWFkb25seVVpbnQ4QXJyYXk7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX0ZJWEVEX1NJWkVfTUlTTUFUQ0hdOiB7XG4gICAgICAgICAgICBkZWNvZGVyRml4ZWRTaXplOiBudW1iZXI7XG4gICAgICAgICAgICBlbmNvZGVyRml4ZWRTaXplOiBudW1iZXI7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX01BWF9TSVpFX01JU01BVENIXToge1xuICAgICAgICAgICAgZGVjb2Rlck1heFNpemU6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGVuY29kZXJNYXhTaXplOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRU5VTV9ESVNDUklNSU5BVE9SX09VVF9PRl9SQU5HRV06IHtcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3I6IGJpZ2ludCB8IG51bWJlcjtcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbGlkRGlzY3JpbWluYXRvcnM6IHN0cmluZztcbiAgICAgICAgICAgIHZhbGlkRGlzY3JpbWluYXRvcnM6IG51bWJlcltdO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RIXToge1xuICAgICAgICAgICAgYnl0ZXNMZW5ndGg6IG51bWJlcjtcbiAgICAgICAgICAgIGNvZGVjRGVzY3JpcHRpb246IHN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9aRVJPX1ZBTFVFX1RPX01BVENIX0lURU1fRklYRURfU0laRV06IHtcbiAgICAgICAgICAgIGNvZGVjRGVzY3JpcHRpb246IHN0cmluZztcbiAgICAgICAgICAgIGV4cGVjdGVkU2l6ZTogbnVtYmVyO1xuICAgICAgICAgICAgaGV4WmVyb1ZhbHVlOiBzdHJpbmc7XG4gICAgICAgICAgICB6ZXJvVmFsdWU6IFJlYWRvbmx5VWludDhBcnJheTtcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0JZVEVfTEVOR1RIXToge1xuICAgICAgICAgICAgYnl0ZXNMZW5ndGg6IG51bWJlcjtcbiAgICAgICAgICAgIGNvZGVjRGVzY3JpcHRpb246IHN0cmluZztcbiAgICAgICAgICAgIGV4cGVjdGVkOiBudW1iZXI7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9DT05TVEFOVF06IHtcbiAgICAgICAgICAgIGNvbnN0YW50OiBSZWFkb25seVVpbnQ4QXJyYXk7XG4gICAgICAgICAgICBkYXRhOiBSZWFkb25seVVpbnQ4QXJyYXk7XG4gICAgICAgICAgICBoZXhDb25zdGFudDogc3RyaW5nO1xuICAgICAgICAgICAgaGV4RGF0YTogc3RyaW5nO1xuICAgICAgICAgICAgb2Zmc2V0OiBudW1iZXI7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9ESVNDUklNSU5BVEVEX1VOSU9OX1ZBUklBTlRdOiB7XG4gICAgICAgICAgICB2YWx1ZTogYmlnaW50IHwgYm9vbGVhbiB8IG51bWJlciB8IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXJpYW50czogcmVhZG9ubHkgKGJpZ2ludCB8IGJvb2xlYW4gfCBudW1iZXIgfCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKVtdO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfRU5VTV9WQVJJQU5UXToge1xuICAgICAgICAgICAgZm9ybWF0dGVkTnVtZXJpY2FsVmFsdWVzOiBzdHJpbmc7XG4gICAgICAgICAgICBudW1lcmljYWxWYWx1ZXM6IG51bWJlcltdO1xuICAgICAgICAgICAgc3RyaW5nVmFsdWVzOiBzdHJpbmdbXTtcbiAgICAgICAgICAgIHZhcmlhbnQ6IG51bWJlciB8IHN0cmluZyB8IHN5bWJvbDtcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0xJVEVSQUxfVU5JT05fVkFSSUFOVF06IHtcbiAgICAgICAgICAgIHZhbHVlOiBiaWdpbnQgfCBib29sZWFuIHwgbnVtYmVyIHwgc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhcmlhbnRzOiByZWFkb25seSAoYmlnaW50IHwgYm9vbGVhbiB8IG51bWJlciB8IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpW107XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9OVU1CRVJfT0ZfSVRFTVNdOiB7XG4gICAgICAgICAgICBhY3R1YWw6IGJpZ2ludCB8IG51bWJlcjtcbiAgICAgICAgICAgIGNvZGVjRGVzY3JpcHRpb246IHN0cmluZztcbiAgICAgICAgICAgIGV4cGVjdGVkOiBiaWdpbnQgfCBudW1iZXI7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9TVFJJTkdfRk9SX0JBU0VdOiB7XG4gICAgICAgICAgICBhbHBoYWJldDogc3RyaW5nO1xuICAgICAgICAgICAgYmFzZTogbnVtYmVyO1xuICAgICAgICAgICAgdmFsdWU6IHN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19MSVRFUkFMX1VOSU9OX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFXToge1xuICAgICAgICAgICAgZGlzY3JpbWluYXRvcjogYmlnaW50IHwgbnVtYmVyO1xuICAgICAgICAgICAgbWF4UmFuZ2U6IG51bWJlcjtcbiAgICAgICAgICAgIG1pblJhbmdlOiBudW1iZXI7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0NPREVDU19fTlVNQkVSX09VVF9PRl9SQU5HRV06IHtcbiAgICAgICAgICAgIGNvZGVjRGVzY3JpcHRpb246IHN0cmluZztcbiAgICAgICAgICAgIG1heDogYmlnaW50IHwgbnVtYmVyO1xuICAgICAgICAgICAgbWluOiBiaWdpbnQgfCBudW1iZXI7XG4gICAgICAgICAgICB2YWx1ZTogYmlnaW50IHwgbnVtYmVyO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX09GRlNFVF9PVVRfT0ZfUkFOR0VdOiB7XG4gICAgICAgICAgICBieXRlc0xlbmd0aDogbnVtYmVyO1xuICAgICAgICAgICAgY29kZWNEZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgICAgICAgICAgb2Zmc2V0OiBudW1iZXI7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0NPREVDU19fU0VOVElORUxfTUlTU0lOR19JTl9ERUNPREVEX0JZVEVTXToge1xuICAgICAgICAgICAgZGVjb2RlZEJ5dGVzOiBSZWFkb25seVVpbnQ4QXJyYXk7XG4gICAgICAgICAgICBoZXhEZWNvZGVkQnl0ZXM6IHN0cmluZztcbiAgICAgICAgICAgIGhleFNlbnRpbmVsOiBzdHJpbmc7XG4gICAgICAgICAgICBzZW50aW5lbDogUmVhZG9ubHlVaW50OEFycmF5O1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX1VOSU9OX1ZBUklBTlRfT1VUX09GX1JBTkdFXToge1xuICAgICAgICAgICAgbWF4UmFuZ2U6IG51bWJlcjtcbiAgICAgICAgICAgIG1pblJhbmdlOiBudW1iZXI7XG4gICAgICAgICAgICB2YXJpYW50OiBudW1iZXI7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CT1JTSF9JT19FUlJPUl06IHtcbiAgICAgICAgICAgIGVuY29kZWREYXRhOiBzdHJpbmc7XG4gICAgICAgICAgICBpbmRleDogbnVtYmVyO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ1VTVE9NXToge1xuICAgICAgICAgICAgY29kZTogbnVtYmVyO1xuICAgICAgICAgICAgaW5kZXg6IG51bWJlcjtcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOS05PV05dOiB7XG4gICAgICAgICAgICBlcnJvck5hbWU6IHN0cmluZztcbiAgICAgICAgICAgIGluZGV4OiBudW1iZXI7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbkVycm9yQ29udGV4dD86IHVua25vd247XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19FWFBFQ1RFRF9UT19IQVZFX0FDQ09VTlRTXToge1xuICAgICAgICAgICAgZGF0YT86IFJlYWRvbmx5VWludDhBcnJheTtcbiAgICAgICAgICAgIHByb2dyYW1BZGRyZXNzOiBzdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19FWFBFQ1RFRF9UT19IQVZFX0RBVEFdOiB7XG4gICAgICAgICAgICBhY2NvdW50QWRkcmVzc2VzPzogc3RyaW5nW107XG4gICAgICAgICAgICBwcm9ncmFtQWRkcmVzczogc3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fUFJPR1JBTV9JRF9NSVNNQVRDSF06IHtcbiAgICAgICAgICAgIGFjdHVhbFByb2dyYW1BZGRyZXNzOiBzdHJpbmc7XG4gICAgICAgICAgICBleHBlY3RlZFByb2dyYW1BZGRyZXNzOiBzdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0lOVkFMSURfQkxPQ0tIQVNIX0JZVEVfTEVOR1RIXToge1xuICAgICAgICAgICAgYWN0dWFsTGVuZ3RoOiBudW1iZXI7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0lOVkFMSURfTk9OQ0VdOiB7XG4gICAgICAgICAgICBhY3R1YWxOb25jZVZhbHVlOiBzdHJpbmc7XG4gICAgICAgICAgICBleHBlY3RlZE5vbmNlVmFsdWU6IHN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fQ0FDSEVEX0FCT1JUQUJMRV9JVEVSQUJMRV9DQUNIRV9FTlRSWV9NSVNTSU5HXToge1xuICAgICAgICAgICAgY2FjaGVLZXk6IHN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fREFUQV9QVUJMSVNIRVJfQ0hBTk5FTF9VTklNUExFTUVOVEVEXToge1xuICAgICAgICAgICAgY2hhbm5lbE5hbWU6IHN0cmluZztcbiAgICAgICAgICAgIHN1cHBvcnRlZENoYW5uZWxOYW1lczogc3RyaW5nW107XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NXSVRDSF9NVVNUX0JFX0VYSEFVU1RJVkVdOiB7XG4gICAgICAgICAgICB1bmV4cGVjdGVkVmFsdWU6IHVua25vd247XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlRFUk5BTF9FUlJPUl06IHtcbiAgICAgICAgICAgIF9fc2VydmVyTWVzc2FnZTogc3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9QQVJBTVNdOiB7XG4gICAgICAgICAgICBfX3NlcnZlck1lc3NhZ2U6IHN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUkVRVUVTVF06IHtcbiAgICAgICAgICAgIF9fc2VydmVyTWVzc2FnZTogc3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fTUVUSE9EX05PVF9GT1VORF06IHtcbiAgICAgICAgICAgIF9fc2VydmVyTWVzc2FnZTogc3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fUEFSU0VfRVJST1JdOiB7XG4gICAgICAgICAgICBfX3NlcnZlck1lc3NhZ2U6IHN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NDQU5fRVJST1JdOiB7XG4gICAgICAgICAgICBfX3NlcnZlck1lc3NhZ2U6IHN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19DTEVBTkVEX1VQXToge1xuICAgICAgICAgICAgX19zZXJ2ZXJNZXNzYWdlOiBzdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfTk9UX0FWQUlMQUJMRV06IHtcbiAgICAgICAgICAgIF9fc2VydmVyTWVzc2FnZTogc3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX1NUQVRVU19OT1RfQVZBSUxBQkxFX1lFVF06IHtcbiAgICAgICAgICAgIF9fc2VydmVyTWVzc2FnZTogc3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0tFWV9FWENMVURFRF9GUk9NX1NFQ09OREFSWV9JTkRFWF06IHtcbiAgICAgICAgICAgIF9fc2VydmVyTWVzc2FnZTogc3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1NMT1RfU0tJUFBFRF06IHtcbiAgICAgICAgICAgIF9fc2VydmVyTWVzc2FnZTogc3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX01JTl9DT05URVhUX1NMT1RfTk9UX1JFQUNIRURdOiB7XG4gICAgICAgICAgICBjb250ZXh0U2xvdDogYmlnaW50O1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX05PREVfVU5IRUFMVEhZXToge1xuICAgICAgICAgICAgbnVtU2xvdHNCZWhpbmQ/OiBudW1iZXI7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0VORF9UUkFOU0FDVElPTl9QUkVGTElHSFRfRkFJTFVSRV06IE9taXQ8XG4gICAgICAgICAgICBScGNTaW11bGF0ZVRyYW5zYWN0aW9uUmVzdWx0LFxuICAgICAgICAgICAgJ2VycidcbiAgICAgICAgPjtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TTE9UX1NLSVBQRURdOiB7XG4gICAgICAgICAgICBfX3NlcnZlck1lc3NhZ2U6IHN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9QUkVDT01QSUxFX1ZFUklGSUNBVElPTl9GQUlMVVJFXToge1xuICAgICAgICAgICAgX19zZXJ2ZXJNZXNzYWdlOiBzdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVU5TVVBQT1JURURfVFJBTlNBQ1RJT05fVkVSU0lPTl06IHtcbiAgICAgICAgICAgIF9fc2VydmVyTWVzc2FnZTogc3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX0tFWV9QQUlSX0JZVEVfTEVOR1RIXToge1xuICAgICAgICAgICAgYnl0ZUxlbmd0aDogbnVtYmVyO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX1BSSVZBVEVfS0VZX0JZVEVfTEVOR1RIXToge1xuICAgICAgICAgICAgYWN0dWFsTGVuZ3RoOiBudW1iZXI7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfU0lHTkFUVVJFX0JZVEVfTEVOR1RIXToge1xuICAgICAgICAgICAgYWN0dWFsTGVuZ3RoOiBudW1iZXI7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX0tFWVNfX1NJR05BVFVSRV9TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRV06IHtcbiAgICAgICAgICAgIGFjdHVhbExlbmd0aDogbnVtYmVyO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19NQUxGT1JNRURfQklHSU5UX1NUUklOR106IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9KU09OX1JQQ19FUlJPUl06IHtcbiAgICAgICAgICAgIGVycm9yOiB1bmtub3duO1xuICAgICAgICAgICAgbWVzc2FnZTogc3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19NQUxGT1JNRURfTlVNQkVSX1NUUklOR106IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX05PTkNFX0FDQ09VTlRfTk9UX0ZPVU5EXToge1xuICAgICAgICAgICAgbm9uY2VBY2NvdW50QWRkcmVzczogc3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0FOTk9UX0NSRUFURV9TVUJTQ1JJUFRJT05fUExBTl06IHtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbk5hbWU6IHN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfRkFJTEVEX1RPX0NPTk5FQ1RdOiB7XG4gICAgICAgICAgICBlcnJvckV2ZW50OiBFdmVudDtcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fUlBDX19BUElfUExBTl9NSVNTSU5HX0ZPUl9SUENfTUVUSE9EXToge1xuICAgICAgICAgICAgbWV0aG9kOiBzdHJpbmc7XG4gICAgICAgICAgICBwYXJhbXM6IHVua25vd25bXTtcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fUlBDX19JTlRFR0VSX09WRVJGTE9XXToge1xuICAgICAgICAgICAgYXJndW1lbnRMYWJlbDogc3RyaW5nO1xuICAgICAgICAgICAga2V5UGF0aDogcmVhZG9ubHkgKG51bWJlciB8IHN0cmluZyB8IHN5bWJvbClbXTtcbiAgICAgICAgICAgIG1ldGhvZE5hbWU6IHN0cmluZztcbiAgICAgICAgICAgIG9wdGlvbmFsUGF0aExhYmVsOiBzdHJpbmc7XG4gICAgICAgICAgICBwYXRoPzogc3RyaW5nO1xuICAgICAgICAgICAgdmFsdWU6IGJpZ2ludDtcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9FUlJPUl06IHtcbiAgICAgICAgICAgIGhlYWRlcnM6IEhlYWRlcnM7XG4gICAgICAgICAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgICAgICAgICBzdGF0dXNDb2RlOiBudW1iZXI7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX1JQQ19fVFJBTlNQT1JUX0hUVFBfSEVBREVSX0ZPUkJJRERFTl06IHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHN0cmluZ1tdO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19TSUdORVJfX0FERFJFU1NfQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0lHTkVSU106IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9LRVlfUEFJUl9TSUdORVJdOiB7XG4gICAgICAgICAgICBhZGRyZXNzOiBzdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9NT0RJRllJTkdfU0lHTkVSXToge1xuICAgICAgICAgICAgYWRkcmVzczogc3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfUEFSVElBTF9TSUdORVJdOiB7XG4gICAgICAgICAgICBhZGRyZXNzOiBzdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9TSUdORVJdOiB7XG4gICAgICAgICAgICBhZGRyZXNzOiBzdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fTU9ESUZZSU5HX1NJR05FUl06IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9QQVJUSUFMX1NJR05FUl06IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUl06IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9TSUdORVJdOiB7XG4gICAgICAgICAgICBhZGRyZXNzOiBzdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0NBTk5PVF9FWFBPUlRfTk9OX0VYVFJBQ1RBQkxFX0tFWV06IHtcbiAgICAgICAgICAgIGtleTogQ3J5cHRvS2V5O1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19USU1FU1RBTVBfT1VUX09GX1JBTkdFXToge1xuICAgICAgICAgICAgdmFsdWU6IGJpZ2ludDtcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0RVUExJQ0FURV9JTlNUUlVDVElPTl06IHtcbiAgICAgICAgICAgIGluZGV4OiBudW1iZXI7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNfRk9SX1JFTlRdOiB7XG4gICAgICAgICAgICBhY2NvdW50SW5kZXg6IG51bWJlcjtcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1BST0dSQU1fRVhFQ1VUSU9OX1RFTVBPUkFSSUxZX1JFU1RSSUNURURdOiB7XG4gICAgICAgICAgICBhY2NvdW50SW5kZXg6IG51bWJlcjtcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOS05PV05dOiB7XG4gICAgICAgICAgICBlcnJvck5hbWU6IHN0cmluZztcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uRXJyb3JDb250ZXh0PzogdW5rbm93bjtcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0FERFJFU1NFU19DQU5OT1RfU0lHTl9UUkFOU0FDVElPTl06IHtcbiAgICAgICAgICAgIGV4cGVjdGVkQWRkcmVzc2VzOiBzdHJpbmdbXTtcbiAgICAgICAgICAgIHVuZXhwZWN0ZWRBZGRyZXNzZXM6IHN0cmluZ1tdO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQUREUkVTU19NSVNTSU5HXToge1xuICAgICAgICAgICAgaW5kZXg6IG51bWJlcjtcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYQ0VFRFNfU0laRV9MSU1JVF06IHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uU2l6ZTogQnl0ZXM7XG4gICAgICAgICAgICB0cmFuc2FjdGlvblNpemVMaW1pdDogQnl0ZXM7XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0FERFJFU1NfTE9PS1VQX1RBQkxFX0NPTlRFTlRTX01JU1NJTkddOiB7XG4gICAgICAgICAgICBsb29rdXBUYWJsZUFkZHJlc3Nlczogc3RyaW5nW107XG4gICAgICAgIH07XG4gICAgICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0FERFJFU1NfTE9PS1VQX1RBQkxFX0lOREVYX09VVF9PRl9SQU5HRV06IHtcbiAgICAgICAgICAgIGhpZ2hlc3RLbm93bkluZGV4OiBudW1iZXI7XG4gICAgICAgICAgICBoaWdoZXN0UmVxdWVzdGVkSW5kZXg6IG51bWJlcjtcbiAgICAgICAgICAgIGxvb2t1cFRhYmxlQWRkcmVzczogc3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9JTlNUUlVDVElPTl9QUk9HUkFNX0FERFJFU1NfTk9UX0ZPVU5EXToge1xuICAgICAgICAgICAgaW5kZXg6IG51bWJlcjtcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9XSEVOX1NJTVVMQVRJTkdfVE9fRVNUSU1BVEVfQ09NUFVURV9MSU1JVF06IHtcbiAgICAgICAgICAgIHVuaXRzQ29uc3VtZWQ6IG51bWJlcjtcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVk9LRURfUFJPR1JBTVNfQ0FOTk9UX1BBWV9GRUVTXToge1xuICAgICAgICAgICAgcHJvZ3JhbUFkZHJlc3M6IHN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVk9LRURfUFJPR1JBTVNfTVVTVF9OT1RfQkVfV1JJVEFCTEVdOiB7XG4gICAgICAgICAgICBwcm9ncmFtQWRkcmVzczogc3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fTUVTU0FHRV9TSUdOQVRVUkVTX01JU01BVENIXToge1xuICAgICAgICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiBudW1iZXI7XG4gICAgICAgICAgICBzaWduYXR1cmVzTGVuZ3RoOiBudW1iZXI7XG4gICAgICAgICAgICBzaWduZXJBZGRyZXNzZXM6IHN0cmluZ1tdO1xuICAgICAgICB9O1xuICAgICAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fU0lHTkFUVVJFU19NSVNTSU5HXToge1xuICAgICAgICAgICAgYWRkcmVzc2VzOiBzdHJpbmdbXTtcbiAgICAgICAgfTtcbiAgICAgICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX1ZFUlNJT05fTlVNQkVSX09VVF9PRl9SQU5HRV06IHtcbiAgICAgICAgICAgIGFjdHVhbFZlcnNpb246IG51bWJlcjtcbiAgICAgICAgfTtcbiAgICB9XG4+O1xuXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlRW5jb2RlZENvbnRleHQoZW5jb2RlZENvbnRleHQ6IHN0cmluZyk6IG9iamVjdCB7XG4gICAgY29uc3QgZGVjb2RlZFVybFN0cmluZyA9IF9fTk9ERUpTX18gPyBCdWZmZXIuZnJvbShlbmNvZGVkQ29udGV4dCwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCd1dGY4JykgOiBhdG9iKGVuY29kZWRDb250ZXh0KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKG5ldyBVUkxTZWFyY2hQYXJhbXMoZGVjb2RlZFVybFN0cmluZykuZW50cmllcygpKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlVmFsdWUodmFsdWU6IHVua25vd24pOiBzdHJpbmcge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBjb21tYVNlcGFyYXRlZFZhbHVlcyA9IHZhbHVlLm1hcChlbmNvZGVWYWx1ZSkuam9pbignJTJDJTIwJyAvKiBcIiwgXCIgKi8pO1xuICAgICAgICByZXR1cm4gJyU1QicgLyogXCJbXCIgKi8gKyBjb21tYVNlcGFyYXRlZFZhbHVlcyArIC8qIFwiXVwiICovICclNUQnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICByZXR1cm4gYCR7dmFsdWV9bmA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgICAgIFN0cmluZyhcbiAgICAgICAgICAgICAgICB2YWx1ZSAhPSBudWxsICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgPyAvLyBQbGFpbiBvYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIGRvbid0IGhhdmUgYSBgdG9TdHJpbmdgIG1ldGhvZC5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZW0gYmVmb3JlIHN0cmluZ2lmeWluZyB0aGVtLlxuICAgICAgICAgICAgICAgICAgICAgIHsgLi4uKHZhbHVlIGFzIG9iamVjdCkgfVxuICAgICAgICAgICAgICAgICAgICA6IHZhbHVlLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGVuY29kZU9iamVjdENvbnRleHRFbnRyeShba2V5LCB2YWx1ZV06IFtzdHJpbmcsIHVua25vd25dKTogYCR7dHlwZW9mIGtleX09JHtzdHJpbmd9YCB7XG4gICAgcmV0dXJuIGAke2tleX09JHtlbmNvZGVWYWx1ZSh2YWx1ZSl9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUNvbnRleHRPYmplY3QoY29udGV4dDogb2JqZWN0KTogc3RyaW5nIHtcbiAgICBjb25zdCBzZWFyY2hQYXJhbXNTdHJpbmcgPSBPYmplY3QuZW50cmllcyhjb250ZXh0KS5tYXAoZW5jb2RlT2JqZWN0Q29udGV4dEVudHJ5KS5qb2luKCcmJyk7XG4gICAgcmV0dXJuIF9fTk9ERUpTX18gPyBCdWZmZXIuZnJvbShzZWFyY2hQYXJhbXNTdHJpbmcsICd1dGY4JykudG9TdHJpbmcoJ2Jhc2U2NCcpIDogYnRvYShzZWFyY2hQYXJhbXNTdHJpbmcpO1xufVxuIiwgIi8qKlxuICogVG8gYWRkIGEgbmV3IGVycm9yLCBmb2xsb3cgdGhlIGluc3RydWN0aW9ucyBhdFxuICogaHR0cHM6Ly9naXRodWIuY29tL2FuemEteHl6L2tpdC90cmVlL21haW4vcGFja2FnZXMvZXJyb3JzI2FkZGluZy1hLW5ldy1lcnJvclxuICpcbiAqIFdBUk5JTkc6XG4gKiAgIC0gRG9uJ3QgY2hhbmdlIHRoZSBtZWFuaW5nIG9mIGFuIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmltcG9ydCB7XG4gICAgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fQUNDT1VOVF9OT1RfRk9VTkQsXG4gICAgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRVhQRUNURURfQUxMX0FDQ09VTlRTX1RPX0JFX0RFQ09ERUQsXG4gICAgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRVhQRUNURURfREVDT0RFRF9BQ0NPVU5ULFxuICAgIFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0ZBSUxFRF9UT19ERUNPREVfQUNDT1VOVCxcbiAgICBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19PTkVfT1JfTU9SRV9BQ0NPVU5UU19OT1RfRk9VTkQsXG4gICAgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0ZBSUxFRF9UT19GSU5EX1ZJQUJMRV9QREFfQlVNUF9TRUVELFxuICAgIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JBU0U1OF9FTkNPREVEX0FERFJFU1MsXG4gICAgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfQllURV9MRU5HVEgsXG4gICAgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfRUQyNTUxOV9QVUJMSUNfS0VZLFxuICAgIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX09GRl9DVVJWRV9BRERSRVNTLFxuICAgIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX1NFRURTX1BPSU5UX09OX0NVUlZFLFxuICAgIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQUxGT1JNRURfUERBLFxuICAgIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfTlVNQkVSX09GX1BEQV9TRUVEU19FWENFRURFRCxcbiAgICBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFYX1BEQV9TRUVEX0xFTkdUSF9FWENFRURFRCxcbiAgICBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0JVTVBfU0VFRF9PVVRfT0ZfUkFOR0UsXG4gICAgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1BEQV9FTkRTX1dJVEhfUERBX01BUktFUixcbiAgICBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0UsXG4gICAgU09MQU5BX0VSUk9SX19CTE9DS19IRUlHSFRfRVhDRUVERUQsXG4gICAgU09MQU5BX0VSUk9SX19CTE9DS0hBU0hfU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0UsXG4gICAgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9ERUNPREVfRU1QVFlfQllURV9BUlJBWSxcbiAgICBTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX1VTRV9MRVhJQ0FMX1ZBTFVFU19BU19FTlVNX0RJU0NSSU1JTkFUT1JTLFxuICAgIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUwsXG4gICAgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENILFxuICAgIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfTUFYX1NJWkVfTUlTTUFUQ0gsXG4gICAgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9TSVpFX0NPTVBBVElCSUxJVFlfTUlTTUFUQ0gsXG4gICAgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOVU1fRElTQ1JJTUlOQVRPUl9PVVRfT0ZfUkFOR0UsXG4gICAgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0ZJWEVEX0xFTkdUSCxcbiAgICBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsXG4gICAgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCxcbiAgICBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfWkVST19WQUxVRV9UT19NQVRDSF9JVEVNX0ZJWEVEX1NJWkUsXG4gICAgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEgsXG4gICAgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQ09OU1RBTlQsXG4gICAgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfRElTQ1JJTUlOQVRFRF9VTklPTl9WQVJJQU5ULFxuICAgIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0VOVU1fVkFSSUFOVCxcbiAgICBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9MSVRFUkFMX1VOSU9OX1ZBUklBTlQsXG4gICAgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfTlVNQkVSX09GX0lURU1TLFxuICAgIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX1NUUklOR19GT1JfQkFTRSxcbiAgICBTT0xBTkFfRVJST1JfX0NPREVDU19fTElURVJBTF9VTklPTl9ESVNDUklNSU5BVE9SX09VVF9PRl9SQU5HRSxcbiAgICBTT0xBTkFfRVJST1JfX0NPREVDU19fTlVNQkVSX09VVF9PRl9SQU5HRSxcbiAgICBTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRSxcbiAgICBTT0xBTkFfRVJST1JfX0NPREVDU19fU0VOVElORUxfTUlTU0lOR19JTl9ERUNPREVEX0JZVEVTLFxuICAgIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19VTklPTl9WQVJJQU5UX09VVF9PRl9SQU5HRSxcbiAgICBTT0xBTkFfRVJST1JfX0NSWVBUT19fUkFORE9NX1ZBTFVFU19GVU5DVElPTl9VTklNUExFTUVOVEVELFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX0VYUEVDVEVEX1RPX0hBVkVfQUNDT1VOVFMsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9EQVRBLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX1BST0dSQU1fSURfTUlTTUFUQ0gsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9BTFJFQURZX0lOSVRJQUxJWkVELFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX0ZBSUxFRCxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19PVVRTVEFORElORyxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0RBVEFfU0laRV9DSEFOR0VELFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfREFUQV9UT09fU01BTEwsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfRVhFQ1VUQUJMRSxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9SRU5UX0VYRU1QVCxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BUklUSE1FVElDX09WRVJGTE9XLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0JPUlNIX0lPX0VSUk9SLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0JVSUxUSU5fUFJPR1JBTVNfTVVTVF9DT05TVU1FX0NPTVBVVEVfVU5JVFMsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ0FMTF9ERVBUSCxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DT01QVVRBVElPTkFMX0JVREdFVF9FWENFRURFRCxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DVVNUT00sXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRFVQTElDQVRFX0FDQ09VTlRfSU5ERVgsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRFVQTElDQVRFX0FDQ09VTlRfT1VUX09GX1NZTkMsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9BQ0NPVU5UX05PVF9SRU5UX0VYRU1QVCxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0RBVEFfTU9ESUZJRUQsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9MQU1QT1JUX0NIQU5HRSxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX01PRElGSUVELFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYVEVSTkFMX0FDQ09VTlRfREFUQV9NT0RJRklFRCxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWFRFUk5BTF9BQ0NPVU5UX0xBTVBPUlRfU1BFTkQsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fR0VORVJJQ19FUlJPUixcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTExFR0FMX09XTkVSLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lNTVVUQUJMRSxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTkNPUlJFQ1RfQVVUSE9SSVRZLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9QUk9HUkFNX0lELFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EUyxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfREFUQSxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfT1dORVIsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BUkdVTUVOVCxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0VSUk9SLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfSU5TVFJVQ1RJT05fREFUQSxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX1JFQUxMT0MsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9TRUVEUyxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfQUNDT1VOVFNfREFUQV9BTExPQ0FUSU9OU19FWENFRURFRCxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfQUNDT1VOVFNfRVhDRUVERUQsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0lOU1RSVUNUSU9OX1RSQUNFX0xFTkdUSF9FWENFRURFRCxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfU0VFRF9MRU5HVEhfRVhDRUVERUQsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUlTU0lOR19BQ0NPVU5ULFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01JU1NJTkdfUkVRVUlSRURfU0lHTkFUVVJFLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01PRElGSUVEX1BST0dSQU1fSUQsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTk9UX0VOT1VHSF9BQ0NPVU5UX0tFWVMsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJJVklMRUdFX0VTQ0FMQVRJT04sXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9FTlZJUk9OTUVOVF9TRVRVUF9GQUlMVVJFLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRkFJTEVEX1RPX0NPTVBJTEUsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9GQUlMRURfVE9fQ09NUExFVEUsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfREFUQV9NT0RJRklFRCxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUFET05MWV9MQU1QT1JUX0NIQU5HRSxcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUVOVFJBTkNZX05PVF9BTExPV0VELFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFTlRfRVBPQ0hfTU9ESUZJRUQsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5CQUxBTkNFRF9JTlNUUlVDVElPTixcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTklOSVRJQUxJWkVEX0FDQ09VTlQsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5LTk9XTixcbiAgICBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9QUk9HUkFNX0lELFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1NZU1ZBUixcbiAgICBTT0xBTkFfRVJST1JfX0lOVkFMSURfQkxPQ0tIQVNIX0JZVEVfTEVOR1RILFxuICAgIFNPTEFOQV9FUlJPUl9fSU5WQUxJRF9OT05DRSxcbiAgICBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0NBQ0hFRF9BQk9SVEFCTEVfSVRFUkFCTEVfQ0FDSEVfRU5UUllfTUlTU0lORyxcbiAgICBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0RBVEFfUFVCTElTSEVSX0NIQU5ORUxfVU5JTVBMRU1FTlRFRCxcbiAgICBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NVQlNDUklQVElPTl9JVEVSQVRPUl9NVVNUX05PVF9QT0xMX0JFRk9SRV9SRVNPTFZJTkdfRVhJU1RJTkdfTUVTU0FHRV9QUk9NSVNFLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fU1VCU0NSSVBUSU9OX0lURVJBVE9SX1NUQVRFX01JU1NJTkcsXG4gICAgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TV0lUQ0hfTVVTVF9CRV9FWEhBVVNUSVZFLFxuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVEVSTkFMX0VSUk9SLFxuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUEFSQU1TLFxuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUkVRVUVTVCxcbiAgICBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19NRVRIT0RfTk9UX0ZPVU5ELFxuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1BBUlNFX0VSUk9SLFxuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NDQU5fRVJST1IsXG4gICAgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVAsXG4gICAgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX05PVF9BVkFJTEFCTEUsXG4gICAgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX1NUQVRVU19OT1RfQVZBSUxBQkxFX1lFVCxcbiAgICBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYLFxuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9MT05HX1RFUk1fU1RPUkFHRV9TTE9UX1NLSVBQRUQsXG4gICAgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX01JTl9DT05URVhUX1NMT1RfTk9UX1JFQUNIRUQsXG4gICAgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX05PX1NOQVBTSE9ULFxuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9OT0RFX1VOSEVBTFRIWSxcbiAgICBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0VORF9UUkFOU0FDVElPTl9QUkVGTElHSFRfRkFJTFVSRSxcbiAgICBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0xPVF9TS0lQUEVELFxuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9ISVNUT1JZX05PVF9BVkFJTEFCTEUsXG4gICAgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1BSRUNPTVBJTEVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkUsXG4gICAgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9MRU5fTUlTTUFUQ0gsXG4gICAgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTFVSRSxcbiAgICBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVU5TVVBQT1JURURfVFJBTlNBQ1RJT05fVkVSU0lPTixcbiAgICBTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfS0VZX1BBSVJfQllURV9MRU5HVEgsXG4gICAgU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX1BSSVZBVEVfS0VZX0JZVEVfTEVOR1RILFxuICAgIFNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9TSUdOQVRVUkVfQllURV9MRU5HVEgsXG4gICAgU09MQU5BX0VSUk9SX19LRVlTX19QVUJMSUNfS0VZX01VU1RfTUFUQ0hfUFJJVkFURV9LRVksXG4gICAgU09MQU5BX0VSUk9SX19LRVlTX19TSUdOQVRVUkVfU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0UsXG4gICAgU09MQU5BX0VSUk9SX19MQU1QT1JUU19PVVRfT0ZfUkFOR0UsXG4gICAgU09MQU5BX0VSUk9SX19NQUxGT1JNRURfQklHSU5UX1NUUklORyxcbiAgICBTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9KU09OX1JQQ19FUlJPUixcbiAgICBTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9OVU1CRVJfU1RSSU5HLFxuICAgIFNPTEFOQV9FUlJPUl9fTk9OQ0VfQUNDT1VOVF9OT1RfRk9VTkQsXG4gICAgU09MQU5BX0VSUk9SX19SUENfX0FQSV9QTEFOX01JU1NJTkdfRk9SX1JQQ19NRVRIT0QsXG4gICAgU09MQU5BX0VSUk9SX19SUENfX0lOVEVHRVJfT1ZFUkZMT1csXG4gICAgU09MQU5BX0VSUk9SX19SUENfX1RSQU5TUE9SVF9IVFRQX0VSUk9SLFxuICAgIFNPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9IRUFERVJfRk9SQklEREVOLFxuICAgIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NBTk5PVF9DUkVBVEVfU1VCU0NSSVBUSU9OX1BMQU4sXG4gICAgU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0hBTk5FTF9DTE9TRURfQkVGT1JFX01FU1NBR0VfQlVGRkVSRUQsXG4gICAgU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0hBTk5FTF9DT05ORUNUSU9OX0NMT1NFRCxcbiAgICBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0ZBSUxFRF9UT19DT05ORUNULFxuICAgIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0VYUEVDVEVEX1NFUlZFUl9TVUJTQ1JJUFRJT05fSUQsXG4gICAgU09MQU5BX0VSUk9SX19TSUdORVJfX0FERFJFU1NfQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0lHTkVSUyxcbiAgICBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfS0VZX1BBSVJfU0lHTkVSLFxuICAgIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX01PRElGWUlOR19TSUdORVIsXG4gICAgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfUEFSVElBTF9TSUdORVIsXG4gICAgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfU0lHTkVSLFxuICAgIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9NT0RJRllJTkdfU0lHTkVSLFxuICAgIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9QQVJUSUFMX1NJR05FUixcbiAgICBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fU0VORElOR19TSUdORVIsXG4gICAgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1NJR05FUixcbiAgICBTT0xBTkFfRVJST1JfX1NJR05FUl9fVFJBTlNBQ1RJT05fQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0VORElOR19TSUdORVJTLFxuICAgIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUl9NSVNTSU5HLFxuICAgIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19XQUxMRVRfTVVMVElTSUdOX1VOSU1QTEVNRU5URUQsXG4gICAgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19DQU5OT1RfRVhQT1JUX05PTl9FWFRSQUNUQUJMRV9LRVksXG4gICAgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19ESUdFU1RfVU5JTVBMRU1FTlRFRCxcbiAgICBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0RJU0FMTE9XRURfSU5fSU5TRUNVUkVfQ09OVEVYVCxcbiAgICBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0VEMjU1MTlfQUxHT1JJVEhNX1VOSU1QTEVNRU5URUQsXG4gICAgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FWFBPUlRfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCxcbiAgICBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0dFTkVSQVRFX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQsXG4gICAgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19TSUdOX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQsXG4gICAgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19WRVJJRllfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCxcbiAgICBTT0xBTkFfRVJST1JfX1RJTUVTVEFNUF9PVVRfT0ZfUkFOR0UsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQUREUkVTU19NSVNTSU5HLFxuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0FERFJFU1NFU19DQU5OT1RfU0lHTl9UUkFOU0FDVElPTixcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19DQU5OT1RfRU5DT0RFX1dJVEhfRU1QVFlfU0lHTkFUVVJFUyxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWENFRURTX1NJWkVfTElNSVQsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfQkxPQ0tIQVNIX0xJRkVUSU1FLFxuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYUEVDVEVEX05PTkNFX0xJRkVUSU1FLFxuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfQUREUkVTU19MT09LVVBfVEFCTEVfQ09OVEVOVFNfTUlTU0lORyxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0FERFJFU1NfTE9PS1VQX1RBQkxFX0lOREVYX09VVF9PRl9SQU5HRSxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0ZFRV9QQVlFUl9NSVNTSU5HLFxuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfSU5TVFJVQ1RJT05fUFJPR1JBTV9BRERSRVNTX05PVF9GT1VORCxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fRVNUSU1BVEVfQ09NUFVURV9MSU1JVCxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfV0hFTl9TSU1VTEFUSU5HX1RPX0VTVElNQVRFX0NPTVBVVEVfTElNSVQsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkVFX1BBWUVSX01JU1NJTkcsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkVFX1BBWUVSX1NJR05BVFVSRV9NSVNTSU5HLFxuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVkFMSURfTk9OQ0VfVFJBTlNBQ1RJT05fRklSU1RfSU5TVFJVQ1RJT05fTVVTVF9CRV9BRFZBTkNFX05PTkNFLFxuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVkFMSURfTk9OQ0VfVFJBTlNBQ1RJT05fSU5TVFJVQ1RJT05TX01JU1NJTkcsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19DQU5OT1RfUEFZX0ZFRVMsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19NVVNUX05PVF9CRV9XUklUQUJMRSxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19NRVNTQUdFX1NJR05BVFVSRVNfTUlTTUFUQ0gsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fU0lHTkFUVVJFU19NSVNTSU5HLFxuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX1ZFUlNJT05fTlVNQkVSX09VVF9PRl9SQU5HRSxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19PVVRTVEFORElORyxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0lOX1VTRSxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0xPQURFRF9UV0lDRSxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9GT1VORCxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BRERSRVNTX0xPT0tVUF9UQUJMRV9OT1RfRk9VTkQsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUxSRUFEWV9QUk9DRVNTRUQsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQkxPQ0tIQVNIX05PVF9GT1VORCxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19DQUxMX0NIQUlOX1RPT19ERUVQLFxuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0NMVVNURVJfTUFJTlRFTkFOQ0UsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fRFVQTElDQVRFX0lOU1RSVUNUSU9OLFxuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfRkVFLFxuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfUkVOVCxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfRk9SX0ZFRSxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfSU5ERVgsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9EQVRBLFxuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUREUkVTU19MT09LVVBfVEFCTEVfSU5ERVgsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9PV05FUixcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0xPQURFRF9BQ0NPVU5UU19EQVRBX1NJWkVfTElNSVQsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9QUk9HUkFNX0ZPUl9FWEVDVVRJT04sXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9SRU5UX1BBWUlOR19BQ0NPVU5ULFxuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfV1JJVEFCTEVfQUNDT1VOVCxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19NQVhfTE9BREVEX0FDQ09VTlRTX0RBVEFfU0laRV9FWENFRURFRCxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19NSVNTSU5HX1NJR05BVFVSRV9GT1JfRkVFLFxuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1BST0dSQU1fQUNDT1VOVF9OT1RfRk9VTkQsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUFJPR1JBTV9FWEVDVVRJT05fVEVNUE9SQVJJTFlfUkVTVFJJQ1RFRCxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19SRVNBTklUSVpBVElPTl9ORUVERUQsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fU0FOSVRJWkVfRkFJTFVSRSxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19TSUdOQVRVUkVfRkFJTFVSRSxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19UT09fTUFOWV9BQ0NPVU5UX0xPQ0tTLFxuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOQkFMQU5DRURfVFJBTlNBQ1RJT04sXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5LTk9XTixcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9WRVJTSU9OLFxuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9BQ0NPVU5UX0RBVEFfQkxPQ0tfTElNSVQsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX0FDQ09VTlRfREFUQV9UT1RBTF9MSU1JVCxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX0FDQ09VTlRfQ09TVF9MSU1JVCxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX0JMT0NLX0NPU1RfTElNSVQsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9WT1RFX0NPU1RfTElNSVQsXG4gICAgU29sYW5hRXJyb3JDb2RlLFxufSBmcm9tICcuL2NvZGVzJztcblxuLyoqXG4gKiBBIG1hcCBvZiBldmVyeSB7QGxpbmsgU29sYW5hRXJyb3J9IGNvZGUgdG8gdGhlIGVycm9yIG1lc3NhZ2Ugc2hvd24gdG8gZGV2ZWxvcGVycyBpbiBkZXZlbG9wbWVudFxuICogbW9kZS5cbiAqL1xuZXhwb3J0IGNvbnN0IFNvbGFuYUVycm9yTWVzc2FnZXM6IFJlYWRvbmx5PHtcbiAgICAvLyBUaGlzIHR5cGUgbWFrZXMgdGhpcyBkYXRhIHN0cnVjdHVyZSBleGhhdXN0aXZlIHdpdGggcmVzcGVjdCB0byBgU29sYW5hRXJyb3JDb2RlYC5cbiAgICAvLyBUeXBlU2NyaXB0IHdpbGwgZmFpbCB0byBidWlsZCB0aGlzIHByb2plY3QgaWYgYWRkIGFuIGVycm9yIGNvZGUgd2l0aG91dCBhIG1lc3NhZ2UuXG4gICAgW1AgaW4gU29sYW5hRXJyb3JDb2RlXTogc3RyaW5nO1xufT4gPSB7XG4gICAgW1NPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0FDQ09VTlRfTk9UX0ZPVU5EXTogJ0FjY291bnQgbm90IGZvdW5kIGF0IGFkZHJlc3M6ICRhZGRyZXNzJyxcbiAgICBbU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRVhQRUNURURfQUxMX0FDQ09VTlRTX1RPX0JFX0RFQ09ERURdOlxuICAgICAgICAnTm90IGFsbCBhY2NvdW50cyB3ZXJlIGRlY29kZWQuIEVuY29kZWQgYWNjb3VudHMgZm91bmQgYXQgYWRkcmVzc2VzOiAkYWRkcmVzc2VzLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0VYUEVDVEVEX0RFQ09ERURfQUNDT1VOVF06ICdFeHBlY3RlZCBkZWNvZGVkIGFjY291bnQgYXQgYWRkcmVzczogJGFkZHJlc3MnLFxuICAgIFtTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19GQUlMRURfVE9fREVDT0RFX0FDQ09VTlRdOiAnRmFpbGVkIHRvIGRlY29kZSBhY2NvdW50IGRhdGEgYXQgYWRkcmVzczogJGFkZHJlc3MnLFxuICAgIFtTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19PTkVfT1JfTU9SRV9BQ0NPVU5UU19OT1RfRk9VTkRdOiAnQWNjb3VudHMgbm90IGZvdW5kIGF0IGFkZHJlc3NlczogJGFkZHJlc3NlcycsXG4gICAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19GQUlMRURfVE9fRklORF9WSUFCTEVfUERBX0JVTVBfU0VFRF06XG4gICAgICAgICdVbmFibGUgdG8gZmluZCBhIHZpYWJsZSBwcm9ncmFtIGFkZHJlc3MgYnVtcCBzZWVkLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JBU0U1OF9FTkNPREVEX0FERFJFU1NdOiAnJHB1dGF0aXZlQWRkcmVzcyBpcyBub3QgYSBiYXNlNTgtZW5jb2RlZCBhZGRyZXNzLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JZVEVfTEVOR1RIXTpcbiAgICAgICAgJ0V4cGVjdGVkIGJhc2U1OCBlbmNvZGVkIGFkZHJlc3MgdG8gZGVjb2RlIHRvIGEgYnl0ZSBhcnJheSBvZiBsZW5ndGggMzIuIEFjdHVhbCBsZW5ndGg6ICRhY3R1YWxMZW5ndGguJyxcbiAgICBbU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfRUQyNTUxOV9QVUJMSUNfS0VZXTogJ1RoZSBgQ3J5cHRvS2V5YCBtdXN0IGJlIGFuIGBFZDI1NTE5YCBwdWJsaWMga2V5LicsXG4gICAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX09GRl9DVVJWRV9BRERSRVNTXTpcbiAgICAgICAgJyRwdXRhdGl2ZU9mZkN1cnZlQWRkcmVzcyBpcyBub3QgYSBiYXNlNTgtZW5jb2RlZCBvZmYtY3VydmUgYWRkcmVzcy4nLFxuICAgIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9TRUVEU19QT0lOVF9PTl9DVVJWRV06ICdJbnZhbGlkIHNlZWRzOyBwb2ludCBtdXN0IGZhbGwgb2ZmIHRoZSBFZDI1NTE5IGN1cnZlLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQUxGT1JNRURfUERBXTpcbiAgICAgICAgJ0V4cGVjdGVkIGdpdmVuIHByb2dyYW0gZGVyaXZlZCBhZGRyZXNzIHRvIGhhdmUgdGhlIGZvbGxvd2luZyBmb3JtYXQ6IFtBZGRyZXNzLCBQcm9ncmFtRGVyaXZlZEFkZHJlc3NCdW1wXS4nLFxuICAgIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFYX05VTUJFUl9PRl9QREFfU0VFRFNfRVhDRUVERURdOlxuICAgICAgICAnQSBtYXhpbXVtIG9mICRtYXhTZWVkcyBzZWVkcywgaW5jbHVkaW5nIHRoZSBidW1wIHNlZWQsIG1heSBiZSBzdXBwbGllZCB3aGVuIGNyZWF0aW5nIGFuIGFkZHJlc3MuIFJlY2VpdmVkOiAkYWN0dWFsLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfUERBX1NFRURfTEVOR1RIX0VYQ0VFREVEXTpcbiAgICAgICAgJ1RoZSBzZWVkIGF0IGluZGV4ICRpbmRleCB3aXRoIGxlbmd0aCAkYWN0dWFsIGV4Y2VlZHMgdGhlIG1heGltdW0gbGVuZ3RoIG9mICRtYXhTZWVkTGVuZ3RoIGJ5dGVzLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19QREFfQlVNUF9TRUVEX09VVF9PRl9SQU5HRV06XG4gICAgICAgICdFeHBlY3RlZCBwcm9ncmFtIGRlcml2ZWQgYWRkcmVzcyBidW1wIHRvIGJlIGluIHRoZSByYW5nZSBbMCwgMjU1XSwgZ290OiAkYnVtcC4nLFxuICAgIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0VORFNfV0lUSF9QREFfTUFSS0VSXTogJ1Byb2dyYW0gYWRkcmVzcyBjYW5ub3QgZW5kIHdpdGggUERBIG1hcmtlci4nLFxuICAgIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0VdOlxuICAgICAgICAnRXhwZWN0ZWQgYmFzZTU4LWVuY29kZWQgYWRkcmVzcyBzdHJpbmcgb2YgbGVuZ3RoIGluIHRoZSByYW5nZSBbMzIsIDQ0XS4gQWN0dWFsIGxlbmd0aDogJGFjdHVhbExlbmd0aC4nLFxuICAgIFtTT0xBTkFfRVJST1JfX0JMT0NLSEFTSF9TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRV06XG4gICAgICAgICdFeHBlY3RlZCBiYXNlNTgtZW5jb2RlZCBibG9ja2FzaCBzdHJpbmcgb2YgbGVuZ3RoIGluIHRoZSByYW5nZSBbMzIsIDQ0XS4gQWN0dWFsIGxlbmd0aDogJGFjdHVhbExlbmd0aC4nLFxuICAgIFtTT0xBTkFfRVJST1JfX0JMT0NLX0hFSUdIVF9FWENFRURFRF06XG4gICAgICAgICdUaGUgbmV0d29yayBoYXMgcHJvZ3Jlc3NlZCBwYXN0IHRoZSBsYXN0IGJsb2NrIGZvciB3aGljaCB0aGlzIHRyYW5zYWN0aW9uIGNvdWxkIGhhdmUgYmVlbiBjb21taXR0ZWQuJyxcbiAgICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9ERUNPREVfRU1QVFlfQllURV9BUlJBWV06XG4gICAgICAgICdDb2RlYyBbJGNvZGVjRGVzY3JpcHRpb25dIGNhbm5vdCBkZWNvZGUgZW1wdHkgYnl0ZSBhcnJheXMuJyxcbiAgICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9VU0VfTEVYSUNBTF9WQUxVRVNfQVNfRU5VTV9ESVNDUklNSU5BVE9SU106XG4gICAgICAgICdFbnVtIGNvZGVjIGNhbm5vdCB1c2UgbGV4aWNhbCB2YWx1ZXMgWyRzdHJpbmdWYWx1ZXNdIGFzIGRpc2NyaW1pbmF0b3JzLiBFaXRoZXIgcmVtb3ZlIGFsbCBsZXhpY2FsIHZhbHVlcyBvciBzZXQgYHVzZVZhbHVlc0FzRGlzY3JpbWluYXRvcnNgIHRvIGBmYWxzZWAuJyxcbiAgICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERURfQllURVNfTVVTVF9OT1RfSU5DTFVERV9TRU5USU5FTF06XG4gICAgICAgICdTZW50aW5lbCBbJGhleFNlbnRpbmVsXSBtdXN0IG5vdCBiZSBwcmVzZW50IGluIGVuY29kZWQgYnl0ZXMgWyRoZXhFbmNvZGVkQnl0ZXNdLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSF06XG4gICAgICAgICdFbmNvZGVyIGFuZCBkZWNvZGVyIG11c3QgaGF2ZSB0aGUgc2FtZSBmaXhlZCBzaXplLCBnb3QgWyRlbmNvZGVyRml4ZWRTaXplXSBhbmQgWyRkZWNvZGVyRml4ZWRTaXplXS4nLFxuICAgIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX01BWF9TSVpFX01JU01BVENIXTpcbiAgICAgICAgJ0VuY29kZXIgYW5kIGRlY29kZXIgbXVzdCBoYXZlIHRoZSBzYW1lIG1heCBzaXplLCBnb3QgWyRlbmNvZGVyTWF4U2l6ZV0gYW5kIFskZGVjb2Rlck1heFNpemVdLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENIXTpcbiAgICAgICAgJ0VuY29kZXIgYW5kIGRlY29kZXIgbXVzdCBlaXRoZXIgYm90aCBiZSBmaXhlZC1zaXplIG9yIHZhcmlhYmxlLXNpemUuJyxcbiAgICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOVU1fRElTQ1JJTUlOQVRPUl9PVVRfT0ZfUkFOR0VdOlxuICAgICAgICAnRW51bSBkaXNjcmltaW5hdG9yIG91dCBvZiByYW5nZS4gRXhwZWN0ZWQgYSBudW1iZXIgaW4gWyRmb3JtYXR0ZWRWYWxpZERpc2NyaW1pbmF0b3JzXSwgZ290ICRkaXNjcmltaW5hdG9yLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9GSVhFRF9MRU5HVEhdOiAnRXhwZWN0ZWQgYSBmaXhlZC1zaXplIGNvZGVjLCBnb3QgYSB2YXJpYWJsZS1zaXplIG9uZS4nLFxuICAgIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEhdOlxuICAgICAgICAnQ29kZWMgWyRjb2RlY0Rlc2NyaXB0aW9uXSBleHBlY3RlZCBhIHBvc2l0aXZlIGJ5dGUgbGVuZ3RoLCBnb3QgJGJ5dGVzTGVuZ3RoLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEhdOiAnRXhwZWN0ZWQgYSB2YXJpYWJsZS1zaXplIGNvZGVjLCBnb3QgYSBmaXhlZC1zaXplIG9uZS4nLFxuICAgIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfWkVST19WQUxVRV9UT19NQVRDSF9JVEVNX0ZJWEVEX1NJWkVdOlxuICAgICAgICAnQ29kZWMgWyRjb2RlY0Rlc2NyaXB0aW9uXSBleHBlY3RlZCB6ZXJvLXZhbHVlIFskaGV4WmVyb1ZhbHVlXSB0byBoYXZlIHRoZSBzYW1lIHNpemUgYXMgdGhlIHByb3ZpZGVkIGZpeGVkLXNpemUgaXRlbSBbJGV4cGVjdGVkU2l6ZSBieXRlc10uJyxcbiAgICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEhdOlxuICAgICAgICAnQ29kZWMgWyRjb2RlY0Rlc2NyaXB0aW9uXSBleHBlY3RlZCAkZXhwZWN0ZWQgYnl0ZXMsIGdvdCAkYnl0ZXNMZW5ndGguJyxcbiAgICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQ09OU1RBTlRdOlxuICAgICAgICAnRXhwZWN0ZWQgYnl0ZSBhcnJheSBjb25zdGFudCBbJGhleENvbnN0YW50XSB0byBiZSBwcmVzZW50IGluIGRhdGEgWyRoZXhEYXRhXSBhdCBvZmZzZXQgWyRvZmZzZXRdLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0RJU0NSSU1JTkFURURfVU5JT05fVkFSSUFOVF06XG4gICAgICAgICdJbnZhbGlkIGRpc2NyaW1pbmF0ZWQgdW5pb24gdmFyaWFudC4gRXhwZWN0ZWQgb25lIG9mIFskdmFyaWFudHNdLCBnb3QgJHZhbHVlLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0VOVU1fVkFSSUFOVF06XG4gICAgICAgICdJbnZhbGlkIGVudW0gdmFyaWFudC4gRXhwZWN0ZWQgb25lIG9mIFskc3RyaW5nVmFsdWVzXSBvciBhIG51bWJlciBpbiBbJGZvcm1hdHRlZE51bWVyaWNhbFZhbHVlc10sIGdvdCAkdmFyaWFudC4nLFxuICAgIFtTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9MSVRFUkFMX1VOSU9OX1ZBUklBTlRdOlxuICAgICAgICAnSW52YWxpZCBsaXRlcmFsIHVuaW9uIHZhcmlhbnQuIEV4cGVjdGVkIG9uZSBvZiBbJHZhcmlhbnRzXSwgZ290ICR2YWx1ZS4nLFxuICAgIFtTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9OVU1CRVJfT0ZfSVRFTVNdOlxuICAgICAgICAnRXhwZWN0ZWQgWyRjb2RlY0Rlc2NyaXB0aW9uXSB0byBoYXZlICRleHBlY3RlZCBpdGVtcywgZ290ICRhY3R1YWwuJyxcbiAgICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfU1RSSU5HX0ZPUl9CQVNFXTogJ0ludmFsaWQgdmFsdWUgJHZhbHVlIGZvciBiYXNlICRiYXNlIHdpdGggYWxwaGFiZXQgJGFscGhhYmV0LicsXG4gICAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19MSVRFUkFMX1VOSU9OX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFXTpcbiAgICAgICAgJ0xpdGVyYWwgdW5pb24gZGlzY3JpbWluYXRvciBvdXQgb2YgcmFuZ2UuIEV4cGVjdGVkIGEgbnVtYmVyIGJldHdlZW4gJG1pblJhbmdlIGFuZCAkbWF4UmFuZ2UsIGdvdCAkZGlzY3JpbWluYXRvci4nLFxuICAgIFtTT0xBTkFfRVJST1JfX0NPREVDU19fTlVNQkVSX09VVF9PRl9SQU5HRV06XG4gICAgICAgICdDb2RlYyBbJGNvZGVjRGVzY3JpcHRpb25dIGV4cGVjdGVkIG51bWJlciB0byBiZSBpbiB0aGUgcmFuZ2UgWyRtaW4sICRtYXhdLCBnb3QgJHZhbHVlLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFXTpcbiAgICAgICAgJ0NvZGVjIFskY29kZWNEZXNjcmlwdGlvbl0gZXhwZWN0ZWQgb2Zmc2V0IHRvIGJlIGluIHRoZSByYW5nZSBbMCwgJGJ5dGVzTGVuZ3RoXSwgZ290ICRvZmZzZXQuJyxcbiAgICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFU106XG4gICAgICAgICdFeHBlY3RlZCBzZW50aW5lbCBbJGhleFNlbnRpbmVsXSB0byBiZSBwcmVzZW50IGluIGRlY29kZWQgYnl0ZXMgWyRoZXhEZWNvZGVkQnl0ZXNdLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19VTklPTl9WQVJJQU5UX09VVF9PRl9SQU5HRV06XG4gICAgICAgICdVbmlvbiB2YXJpYW50IG91dCBvZiByYW5nZS4gRXhwZWN0ZWQgYW4gaW5kZXggYmV0d2VlbiAkbWluUmFuZ2UgYW5kICRtYXhSYW5nZSwgZ290ICR2YXJpYW50LicsXG4gICAgW1NPTEFOQV9FUlJPUl9fQ1JZUFRPX19SQU5ET01fVkFMVUVTX0ZVTkNUSU9OX1VOSU1QTEVNRU5URURdOiAnTm8gcmFuZG9tIHZhbHVlcyBpbXBsZW1lbnRhdGlvbiBjb3VsZCBiZSBmb3VuZC4nLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0FMUkVBRFlfSU5JVElBTElaRURdOiAnaW5zdHJ1Y3Rpb24gcmVxdWlyZXMgYW4gdW5pbml0aWFsaXplZCBhY2NvdW50JyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfRkFJTEVEXTpcbiAgICAgICAgJ2luc3RydWN0aW9uIHRyaWVzIHRvIGJvcnJvdyByZWZlcmVuY2UgZm9yIGFuIGFjY291bnQgd2hpY2ggaXMgYWxyZWFkeSBib3Jyb3dlZCcsXG4gICAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX09VVFNUQU5ESU5HXTpcbiAgICAgICAgJ2luc3RydWN0aW9uIGxlZnQgYWNjb3VudCB3aXRoIGFuIG91dHN0YW5kaW5nIGJvcnJvd2VkIHJlZmVyZW5jZScsXG4gICAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfREFUQV9TSVpFX0NIQU5HRURdOlxuICAgICAgICBcInByb2dyYW0gb3RoZXIgdGhhbiB0aGUgYWNjb3VudCdzIG93bmVyIGNoYW5nZWQgdGhlIHNpemUgb2YgdGhlIGFjY291bnQgZGF0YVwiLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0RBVEFfVE9PX1NNQUxMXTogJ2FjY291bnQgZGF0YSB0b28gc21hbGwgZm9yIGluc3RydWN0aW9uJyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfRVhFQ1VUQUJMRV06ICdpbnN0cnVjdGlvbiBleHBlY3RlZCBhbiBleGVjdXRhYmxlIGFjY291bnQnLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9SRU5UX0VYRU1QVF06XG4gICAgICAgICdBbiBhY2NvdW50IGRvZXMgbm90IGhhdmUgZW5vdWdoIGxhbXBvcnRzIHRvIGJlIHJlbnQtZXhlbXB0JyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQVJJVEhNRVRJQ19PVkVSRkxPV106ICdQcm9ncmFtIGFyaXRobWV0aWMgb3ZlcmZsb3dlZCcsXG4gICAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0JPUlNIX0lPX0VSUk9SXTogJ0ZhaWxlZCB0byBzZXJpYWxpemUgb3IgZGVzZXJpYWxpemUgYWNjb3VudCBkYXRhOiAkZW5jb2RlZERhdGEnLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CVUlMVElOX1BST0dSQU1TX01VU1RfQ09OU1VNRV9DT01QVVRFX1VOSVRTXTpcbiAgICAgICAgJ0J1aWx0aW4gcHJvZ3JhbXMgbXVzdCBjb25zdW1lIGNvbXB1dGUgdW5pdHMnLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DQUxMX0RFUFRIXTogJ0Nyb3NzLXByb2dyYW0gaW52b2NhdGlvbiBjYWxsIGRlcHRoIHRvbyBkZWVwJyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ09NUFVUQVRJT05BTF9CVURHRVRfRVhDRUVERURdOiAnQ29tcHV0YXRpb25hbCBidWRnZXQgZXhjZWVkZWQnLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DVVNUT01dOiAnY3VzdG9tIHByb2dyYW0gZXJyb3I6ICMkY29kZScsXG4gICAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0RVUExJQ0FURV9BQ0NPVU5UX0lOREVYXTogJ2luc3RydWN0aW9uIGNvbnRhaW5zIGR1cGxpY2F0ZSBhY2NvdW50cycsXG4gICAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0RVUExJQ0FURV9BQ0NPVU5UX09VVF9PRl9TWU5DXTpcbiAgICAgICAgJ2luc3RydWN0aW9uIG1vZGlmaWNhdGlvbnMgb2YgbXVsdGlwbHktcGFzc2VkIGFjY291bnQgZGlmZmVyJyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9BQ0NPVU5UX05PVF9SRU5UX0VYRU1QVF06ICdleGVjdXRhYmxlIGFjY291bnRzIG11c3QgYmUgcmVudCBleGVtcHQnLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0RBVEFfTU9ESUZJRURdOiAnaW5zdHJ1Y3Rpb24gY2hhbmdlZCBleGVjdXRhYmxlIGFjY291bnRzIGRhdGEnLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0xBTVBPUlRfQ0hBTkdFXTpcbiAgICAgICAgJ2luc3RydWN0aW9uIGNoYW5nZWQgdGhlIGJhbGFuY2Ugb2YgYW4gZXhlY3V0YWJsZSBhY2NvdW50JyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9NT0RJRklFRF06ICdpbnN0cnVjdGlvbiBjaGFuZ2VkIGV4ZWN1dGFibGUgYml0IG9mIGFuIGFjY291bnQnLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWFRFUk5BTF9BQ0NPVU5UX0RBVEFfTU9ESUZJRURdOlxuICAgICAgICAnaW5zdHJ1Y3Rpb24gbW9kaWZpZWQgZGF0YSBvZiBhbiBhY2NvdW50IGl0IGRvZXMgbm90IG93bicsXG4gICAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYVEVSTkFMX0FDQ09VTlRfTEFNUE9SVF9TUEVORF06XG4gICAgICAgICdpbnN0cnVjdGlvbiBzcGVudCBmcm9tIHRoZSBiYWxhbmNlIG9mIGFuIGFjY291bnQgaXQgZG9lcyBub3Qgb3duJyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fR0VORVJJQ19FUlJPUl06ICdnZW5lcmljIGluc3RydWN0aW9uIGVycm9yJyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSUxMRUdBTF9PV05FUl06ICdQcm92aWRlZCBvd25lciBpcyBub3QgYWxsb3dlZCcsXG4gICAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lNTVVUQUJMRV06ICdBY2NvdW50IGlzIGltbXV0YWJsZScsXG4gICAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9BVVRIT1JJVFldOiAnSW5jb3JyZWN0IGF1dGhvcml0eSBwcm92aWRlZCcsXG4gICAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9QUk9HUkFNX0lEXTogJ2luY29ycmVjdCBwcm9ncmFtIGlkIGZvciBpbnN0cnVjdGlvbicsXG4gICAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU106ICdpbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGluc3RydWN0aW9uJyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0RBVEFdOiAnaW52YWxpZCBhY2NvdW50IGRhdGEgZm9yIGluc3RydWN0aW9uJyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX09XTkVSXTogJ0ludmFsaWQgYWNjb3VudCBvd25lcicsXG4gICAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQVJHVU1FTlRdOiAnaW52YWxpZCBwcm9ncmFtIGFyZ3VtZW50JyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9FUlJPUl06ICdwcm9ncmFtIHJldHVybmVkIGludmFsaWQgZXJyb3IgY29kZScsXG4gICAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfSU5TVFJVQ1RJT05fREFUQV06ICdpbnZhbGlkIGluc3RydWN0aW9uIGRhdGEnLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX1JFQUxMT0NdOiAnRmFpbGVkIHRvIHJlYWxsb2NhdGUgYWNjb3VudCBkYXRhJyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9TRUVEU106ICdQcm92aWRlZCBzZWVkcyBkbyBub3QgcmVzdWx0IGluIGEgdmFsaWQgYWRkcmVzcycsXG4gICAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9BQ0NPVU5UU19EQVRBX0FMTE9DQVRJT05TX0VYQ0VFREVEXTpcbiAgICAgICAgJ0FjY291bnRzIGRhdGEgYWxsb2NhdGlvbnMgZXhjZWVkZWQgdGhlIG1heGltdW0gYWxsb3dlZCBwZXIgdHJhbnNhY3Rpb24nLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfQUNDT1VOVFNfRVhDRUVERURdOiAnTWF4IGFjY291bnRzIGV4Y2VlZGVkJyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0lOU1RSVUNUSU9OX1RSQUNFX0xFTkdUSF9FWENFRURFRF06ICdNYXggaW5zdHJ1Y3Rpb24gdHJhY2UgbGVuZ3RoIGV4Y2VlZGVkJyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX1NFRURfTEVOR1RIX0VYQ0VFREVEXTpcbiAgICAgICAgJ0xlbmd0aCBvZiB0aGUgc2VlZCBpcyB0b28gbG9uZyBmb3IgYWRkcmVzcyBnZW5lcmF0aW9uJyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUlTU0lOR19BQ0NPVU5UXTogJ0FuIGFjY291bnQgcmVxdWlyZWQgYnkgdGhlIGluc3RydWN0aW9uIGlzIG1pc3NpbmcnLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NSVNTSU5HX1JFUVVJUkVEX1NJR05BVFVSRV06ICdtaXNzaW5nIHJlcXVpcmVkIHNpZ25hdHVyZSBmb3IgaW5zdHJ1Y3Rpb24nLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NT0RJRklFRF9QUk9HUkFNX0lEXTpcbiAgICAgICAgJ2luc3RydWN0aW9uIGlsbGVnYWxseSBtb2RpZmllZCB0aGUgcHJvZ3JhbSBpZCBvZiBhbiBhY2NvdW50JyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTk9UX0VOT1VHSF9BQ0NPVU5UX0tFWVNdOiAnaW5zdWZmaWNpZW50IGFjY291bnQga2V5cyBmb3IgaW5zdHJ1Y3Rpb24nLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUklWSUxFR0VfRVNDQUxBVElPTl06XG4gICAgICAgICdDcm9zcy1wcm9ncmFtIGludm9jYXRpb24gd2l0aCB1bmF1dGhvcml6ZWQgc2lnbmVyIG9yIHdyaXRhYmxlIGFjY291bnQnLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0VOVklST05NRU5UX1NFVFVQX0ZBSUxVUkVdOlxuICAgICAgICAnRmFpbGVkIHRvIGNyZWF0ZSBwcm9ncmFtIGV4ZWN1dGlvbiBlbnZpcm9ubWVudCcsXG4gICAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRkFJTEVEX1RPX0NPTVBJTEVdOiAnUHJvZ3JhbSBmYWlsZWQgdG8gY29tcGlsZScsXG4gICAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRkFJTEVEX1RPX0NPTVBMRVRFXTogJ1Byb2dyYW0gZmFpbGVkIHRvIGNvbXBsZXRlJyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfREFUQV9NT0RJRklFRF06ICdpbnN0cnVjdGlvbiBtb2RpZmllZCBkYXRhIG9mIGEgcmVhZC1vbmx5IGFjY291bnQnLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUFET05MWV9MQU1QT1JUX0NIQU5HRV06XG4gICAgICAgICdpbnN0cnVjdGlvbiBjaGFuZ2VkIHRoZSBiYWxhbmNlIG9mIGEgcmVhZC1vbmx5IGFjY291bnQnLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUVOVFJBTkNZX05PVF9BTExPV0VEXTpcbiAgICAgICAgJ0Nyb3NzLXByb2dyYW0gaW52b2NhdGlvbiByZWVudHJhbmN5IG5vdCBhbGxvd2VkIGZvciB0aGlzIGluc3RydWN0aW9uJyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVOVF9FUE9DSF9NT0RJRklFRF06ICdpbnN0cnVjdGlvbiBtb2RpZmllZCByZW50IGVwb2NoIG9mIGFuIGFjY291bnQnLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTkJBTEFOQ0VEX0lOU1RSVUNUSU9OXTpcbiAgICAgICAgJ3N1bSBvZiBhY2NvdW50IGJhbGFuY2VzIGJlZm9yZSBhbmQgYWZ0ZXIgaW5zdHJ1Y3Rpb24gZG8gbm90IG1hdGNoJyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5JTklUSUFMSVpFRF9BQ0NPVU5UXTogJ2luc3RydWN0aW9uIHJlcXVpcmVzIGFuIGluaXRpYWxpemVkIGFjY291bnQnLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTktOT1dOXTogJycsXG4gICAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1BST0dSQU1fSURdOiAnVW5zdXBwb3J0ZWQgcHJvZ3JhbSBpZCcsXG4gICAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1NZU1ZBUl06ICdVbnN1cHBvcnRlZCBzeXN2YXInLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19FWFBFQ1RFRF9UT19IQVZFX0FDQ09VTlRTXTogJ1RoZSBpbnN0cnVjdGlvbiBkb2VzIG5vdCBoYXZlIGFueSBhY2NvdW50cy4nLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19FWFBFQ1RFRF9UT19IQVZFX0RBVEFdOiAnVGhlIGluc3RydWN0aW9uIGRvZXMgbm90IGhhdmUgYW55IGRhdGEuJyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fUFJPR1JBTV9JRF9NSVNNQVRDSF06XG4gICAgICAgICdFeHBlY3RlZCBpbnN0cnVjdGlvbiB0byBoYXZlIHByb2dyZXNzIGFkZHJlc3MgJGV4cGVjdGVkUHJvZ3JhbUFkZHJlc3MsIGdvdCAkYWN0dWFsUHJvZ3JhbUFkZHJlc3MuJyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlZBTElEX0JMT0NLSEFTSF9CWVRFX0xFTkdUSF06XG4gICAgICAgICdFeHBlY3RlZCBiYXNlNTggZW5jb2RlZCBibG9ja2hhc2ggdG8gZGVjb2RlIHRvIGEgYnl0ZSBhcnJheSBvZiBsZW5ndGggMzIuIEFjdHVhbCBsZW5ndGg6ICRhY3R1YWxMZW5ndGguJyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlZBTElEX05PTkNFXTpcbiAgICAgICAgJ1RoZSBub25jZSBgJGV4cGVjdGVkTm9uY2VWYWx1ZWAgaXMgbm8gbG9uZ2VyIHZhbGlkLiBJdCBoYXMgYWR2YW5jZWQgdG8gYCRhY3R1YWxOb25jZVZhbHVlYCcsXG4gICAgW1NPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fQ0FDSEVEX0FCT1JUQUJMRV9JVEVSQUJMRV9DQUNIRV9FTlRSWV9NSVNTSU5HXTpcbiAgICAgICAgJ0ludmFyaWFudCB2aW9sYXRpb246IEZvdW5kIG5vIGFib3J0YWJsZSBpdGVyYWJsZSBjYWNoZSBlbnRyeSBmb3Iga2V5IGAkY2FjaGVLZXlgLiBJdCAnICtcbiAgICAgICAgJ3Nob3VsZCBiZSBpbXBvc3NpYmxlIHRvIGhpdCB0aGlzIGVycm9yOyBwbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCAnICtcbiAgICAgICAgJ2h0dHBzOi8vc29sYS5uYS93ZWIzaW52YXJpYW50JyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19EQVRBX1BVQkxJU0hFUl9DSEFOTkVMX1VOSU1QTEVNRU5URURdOlxuICAgICAgICAnSW52YXJpYW50IHZpb2xhdGlvbjogVGhpcyBkYXRhIHB1Ymxpc2hlciBkb2VzIG5vdCBwdWJsaXNoIHRvIHRoZSBjaGFubmVsIG5hbWVkICcgK1xuICAgICAgICAnYCRjaGFubmVsTmFtZWAuIFN1cHBvcnRlZCBjaGFubmVscyBpbmNsdWRlICRzdXBwb3J0ZWRDaGFubmVsTmFtZXMuJyxcbiAgICBbU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TVUJTQ1JJUFRJT05fSVRFUkFUT1JfTVVTVF9OT1RfUE9MTF9CRUZPUkVfUkVTT0xWSU5HX0VYSVNUSU5HX01FU1NBR0VfUFJPTUlTRV06XG4gICAgICAgICdJbnZhcmlhbnQgdmlvbGF0aW9uOiBXZWJTb2NrZXQgbWVzc2FnZSBpdGVyYXRvciBzdGF0ZSBpcyBjb3JydXB0OyBpdGVyYXRlZCB3aXRob3V0IGZpcnN0ICcgK1xuICAgICAgICAncmVzb2x2aW5nIGV4aXN0aW5nIG1lc3NhZ2UgcHJvbWlzZS4gSXQgc2hvdWxkIGJlIGltcG9zc2libGUgdG8gaGl0IHRoaXMgZXJyb3I7IHBsZWFzZSAnICtcbiAgICAgICAgJ2ZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9zb2xhLm5hL3dlYjNpbnZhcmlhbnQnLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NVQlNDUklQVElPTl9JVEVSQVRPUl9TVEFURV9NSVNTSU5HXTpcbiAgICAgICAgJ0ludmFyaWFudCB2aW9sYXRpb246IFdlYlNvY2tldCBtZXNzYWdlIGl0ZXJhdG9yIGlzIG1pc3Npbmcgc3RhdGUgc3RvcmFnZS4gSXQgc2hvdWxkIGJlICcgK1xuICAgICAgICAnaW1wb3NzaWJsZSB0byBoaXQgdGhpcyBlcnJvcjsgcGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9zb2xhLm5hL3dlYjNpbnZhcmlhbnQnLFxuICAgIFtTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NXSVRDSF9NVVNUX0JFX0VYSEFVU1RJVkVdOlxuICAgICAgICAnSW52YXJpYW50IHZpb2xhdGlvbjogU3dpdGNoIHN0YXRlbWVudCBub24tZXhoYXVzdGl2ZS4gUmVjZWl2ZWQgdW5leHBlY3RlZCB2YWx1ZSAnICtcbiAgICAgICAgJ2AkdW5leHBlY3RlZFZhbHVlYC4gSXQgc2hvdWxkIGJlIGltcG9zc2libGUgdG8gaGl0IHRoaXMgZXJyb3I7IHBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0ICcgK1xuICAgICAgICAnaHR0cHM6Ly9zb2xhLm5hL3dlYjNpbnZhcmlhbnQnLFxuICAgIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlRFUk5BTF9FUlJPUl06ICdKU09OLVJQQyBlcnJvcjogSW50ZXJuYWwgSlNPTi1SUEMgZXJyb3IgKCRfX3NlcnZlck1lc3NhZ2UpJyxcbiAgICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9QQVJBTVNdOiAnSlNPTi1SUEMgZXJyb3I6IEludmFsaWQgbWV0aG9kIHBhcmFtZXRlcihzKSAoJF9fc2VydmVyTWVzc2FnZSknLFxuICAgIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlZBTElEX1JFUVVFU1RdOlxuICAgICAgICAnSlNPTi1SUEMgZXJyb3I6IFRoZSBKU09OIHNlbnQgaXMgbm90IGEgdmFsaWQgYFJlcXVlc3RgIG9iamVjdCAoJF9fc2VydmVyTWVzc2FnZSknLFxuICAgIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19NRVRIT0RfTk9UX0ZPVU5EXTpcbiAgICAgICAgJ0pTT04tUlBDIGVycm9yOiBUaGUgbWV0aG9kIGRvZXMgbm90IGV4aXN0IC8gaXMgbm90IGF2YWlsYWJsZSAoJF9fc2VydmVyTWVzc2FnZSknLFxuICAgIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19QQVJTRV9FUlJPUl06XG4gICAgICAgICdKU09OLVJQQyBlcnJvcjogQW4gZXJyb3Igb2NjdXJyZWQgb24gdGhlIHNlcnZlciB3aGlsZSBwYXJzaW5nIHRoZSBKU09OIHRleHQgKCRfX3NlcnZlck1lc3NhZ2UpJyxcbiAgICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0NBTl9FUlJPUl06ICckX19zZXJ2ZXJNZXNzYWdlJyxcbiAgICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVBdOiAnJF9fc2VydmVyTWVzc2FnZScsXG4gICAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19OT1RfQVZBSUxBQkxFXTogJyRfX3NlcnZlck1lc3NhZ2UnLFxuICAgIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVUXTogJyRfX3NlcnZlck1lc3NhZ2UnLFxuICAgIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYXTogJyRfX3NlcnZlck1lc3NhZ2UnLFxuICAgIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTE9OR19URVJNX1NUT1JBR0VfU0xPVF9TS0lQUEVEXTogJyRfX3NlcnZlck1lc3NhZ2UnLFxuICAgIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTUlOX0NPTlRFWFRfU0xPVF9OT1RfUkVBQ0hFRF06ICdNaW5pbXVtIGNvbnRleHQgc2xvdCBoYXMgbm90IGJlZW4gcmVhY2hlZCcsXG4gICAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9OT0RFX1VOSEVBTFRIWV06ICdOb2RlIGlzIHVuaGVhbHRoeTsgYmVoaW5kIGJ5ICRudW1TbG90c0JlaGluZCBzbG90cycsXG4gICAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9OT19TTkFQU0hPVF06ICdObyBzbmFwc2hvdCcsXG4gICAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFXTogJ1RyYW5zYWN0aW9uIHNpbXVsYXRpb24gZmFpbGVkJyxcbiAgICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NMT1RfU0tJUFBFRF06ICckX19zZXJ2ZXJNZXNzYWdlJyxcbiAgICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX0hJU1RPUllfTk9UX0FWQUlMQUJMRV06XG4gICAgICAgICdUcmFuc2FjdGlvbiBoaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUgZnJvbSB0aGlzIG5vZGUnLFxuICAgIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRV06ICckX19zZXJ2ZXJNZXNzYWdlJyxcbiAgICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9MRU5fTUlTTUFUQ0hdOiAnVHJhbnNhY3Rpb24gc2lnbmF0dXJlIGxlbmd0aCBtaXNtYXRjaCcsXG4gICAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkVdOlxuICAgICAgICAnVHJhbnNhY3Rpb24gc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsdXJlJyxcbiAgICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1VOU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT05dOiAnJF9fc2VydmVyTWVzc2FnZScsXG4gICAgW1NPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9LRVlfUEFJUl9CWVRFX0xFTkdUSF06ICdLZXkgcGFpciBieXRlcyBtdXN0IGJlIG9mIGxlbmd0aCA2NCwgZ290ICRieXRlTGVuZ3RoLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9QUklWQVRFX0tFWV9CWVRFX0xFTkdUSF06XG4gICAgICAgICdFeHBlY3RlZCBwcml2YXRlIGtleSBieXRlcyB3aXRoIGxlbmd0aCAzMi4gQWN0dWFsIGxlbmd0aDogJGFjdHVhbExlbmd0aC4nLFxuICAgIFtTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfU0lHTkFUVVJFX0JZVEVfTEVOR1RIXTpcbiAgICAgICAgJ0V4cGVjdGVkIGJhc2U1OC1lbmNvZGVkIHNpZ25hdHVyZSB0byBkZWNvZGUgdG8gYSBieXRlIGFycmF5IG9mIGxlbmd0aCA2NC4gQWN0dWFsIGxlbmd0aDogJGFjdHVhbExlbmd0aC4nLFxuICAgIFtTT0xBTkFfRVJST1JfX0tFWVNfX1BVQkxJQ19LRVlfTVVTVF9NQVRDSF9QUklWQVRFX0tFWV06XG4gICAgICAgICdUaGUgcHJvdmlkZWQgcHJpdmF0ZSBrZXkgZG9lcyBub3QgbWF0Y2ggdGhlIHByb3ZpZGVkIHB1YmxpYyBrZXkuJyxcbiAgICBbU09MQU5BX0VSUk9SX19LRVlTX19TSUdOQVRVUkVfU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0VdOlxuICAgICAgICAnRXhwZWN0ZWQgYmFzZTU4LWVuY29kZWQgc2lnbmF0dXJlIHN0cmluZyBvZiBsZW5ndGggaW4gdGhlIHJhbmdlIFs2NCwgODhdLiBBY3R1YWwgbGVuZ3RoOiAkYWN0dWFsTGVuZ3RoLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fTEFNUE9SVFNfT1VUX09GX1JBTkdFXTogJ0xhbXBvcnRzIHZhbHVlIG11c3QgYmUgaW4gdGhlIHJhbmdlIFswLCAyZTY0LTFdJyxcbiAgICBbU09MQU5BX0VSUk9SX19NQUxGT1JNRURfQklHSU5UX1NUUklOR106ICdgJHZhbHVlYCBjYW5ub3QgYmUgcGFyc2VkIGFzIGEgYEJpZ0ludGAnLFxuICAgIFtTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9KU09OX1JQQ19FUlJPUl06ICckbWVzc2FnZScsXG4gICAgW1NPTEFOQV9FUlJPUl9fTUFMRk9STUVEX05VTUJFUl9TVFJJTkddOiAnYCR2YWx1ZWAgY2Fubm90IGJlIHBhcnNlZCBhcyBhIGBOdW1iZXJgJyxcbiAgICBbU09MQU5BX0VSUk9SX19OT05DRV9BQ0NPVU5UX05PVF9GT1VORF06ICdObyBub25jZSBhY2NvdW50IGNvdWxkIGJlIGZvdW5kIGF0IGFkZHJlc3MgYCRub25jZUFjY291bnRBZGRyZXNzYCcsXG4gICAgW1NPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NBTk5PVF9DUkVBVEVfU1VCU0NSSVBUSU9OX1BMQU5dOlxuICAgICAgICBcIlRoZSBub3RpZmljYXRpb24gbmFtZSBtdXN0IGVuZCBpbiAnTm90aWZpY2F0aW9ucycgYW5kIHRoZSBBUEkgbXVzdCBzdXBwbHkgYSBcIiArXG4gICAgICAgIFwic3Vic2NyaXB0aW9uIHBsYW4gY3JlYXRvciBmdW5jdGlvbiBmb3IgdGhlIG5vdGlmaWNhdGlvbiAnJG5vdGlmaWNhdGlvbk5hbWUnLlwiLFxuICAgIFtTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0NMT1NFRF9CRUZPUkVfTUVTU0FHRV9CVUZGRVJFRF06XG4gICAgICAgICdXZWJTb2NrZXQgd2FzIGNsb3NlZCBiZWZvcmUgcGF5bG9hZCBjb3VsZCBiZSBhZGRlZCB0byB0aGUgc2VuZCBidWZmZXInLFxuICAgIFtTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0NPTk5FQ1RJT05fQ0xPU0VEXTogJ1dlYlNvY2tldCBjb25uZWN0aW9uIGNsb3NlZCcsXG4gICAgW1NPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfRkFJTEVEX1RPX0NPTk5FQ1RdOiAnV2ViU29ja2V0IGZhaWxlZCB0byBjb25uZWN0JyxcbiAgICBbU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fRVhQRUNURURfU0VSVkVSX1NVQlNDUklQVElPTl9JRF06XG4gICAgICAgICdGYWlsZWQgdG8gb2J0YWluIGEgc3Vic2NyaXB0aW9uIGlkIGZyb20gdGhlIHNlcnZlcicsXG4gICAgW1NPTEFOQV9FUlJPUl9fUlBDX19BUElfUExBTl9NSVNTSU5HX0ZPUl9SUENfTUVUSE9EXTogJ0NvdWxkIG5vdCBmaW5kIGFuIEFQSSBwbGFuIGZvciBSUEMgbWV0aG9kOiBgJG1ldGhvZGAnLFxuICAgIFtTT0xBTkFfRVJST1JfX1JQQ19fSU5URUdFUl9PVkVSRkxPV106XG4gICAgICAgICdUaGUgJGFyZ3VtZW50TGFiZWwgYXJndW1lbnQgdG8gdGhlIGAkbWV0aG9kTmFtZWAgUlBDIG1ldGhvZCRvcHRpb25hbFBhdGhMYWJlbCB3YXMgJyArXG4gICAgICAgICdgJHZhbHVlYC4gVGhpcyBudW1iZXIgaXMgdW5zYWZlIGZvciB1c2Ugd2l0aCB0aGUgU29sYW5hIEpTT04tUlBDIGJlY2F1c2UgaXQgZXhjZWVkcyAnICtcbiAgICAgICAgJ2BOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuJyxcbiAgICBbU09MQU5BX0VSUk9SX19SUENfX1RSQU5TUE9SVF9IVFRQX0VSUk9SXTogJ0hUVFAgZXJyb3IgKCRzdGF0dXNDb2RlKTogJG1lc3NhZ2UnLFxuICAgIFtTT0xBTkFfRVJST1JfX1JQQ19fVFJBTlNQT1JUX0hUVFBfSEVBREVSX0ZPUkJJRERFTl06XG4gICAgICAgICdIVFRQIGhlYWRlcihzKSBmb3JiaWRkZW46ICRoZWFkZXJzLiBMZWFybiBtb3JlIGF0ICcgK1xuICAgICAgICAnaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9HbG9zc2FyeS9Gb3JiaWRkZW5faGVhZGVyX25hbWUuJyxcbiAgICBbU09MQU5BX0VSUk9SX19TSUdORVJfX0FERFJFU1NfQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0lHTkVSU106XG4gICAgICAgICdNdWx0aXBsZSBkaXN0aW5jdCBzaWduZXJzIHdlcmUgaWRlbnRpZmllZCBmb3IgYWRkcmVzcyBgJGFkZHJlc3NgLiBQbGVhc2UgZW5zdXJlIHRoYXQgJyArXG4gICAgICAgICd5b3UgYXJlIHVzaW5nIHRoZSBzYW1lIHNpZ25lciBpbnN0YW5jZSBmb3IgZWFjaCBhZGRyZXNzLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9LRVlfUEFJUl9TSUdORVJdOlxuICAgICAgICAnVGhlIHByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGltcGxlbWVudCB0aGUgYEtleVBhaXJTaWduZXJgIGludGVyZmFjZScsXG4gICAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX01PRElGWUlOR19TSUdORVJdOlxuICAgICAgICAnVGhlIHByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGltcGxlbWVudCB0aGUgYE1lc3NhZ2VNb2RpZnlpbmdTaWduZXJgIGludGVyZmFjZScsXG4gICAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX1BBUlRJQUxfU0lHTkVSXTpcbiAgICAgICAgJ1RoZSBwcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGBNZXNzYWdlUGFydGlhbFNpZ25lcmAgaW50ZXJmYWNlJyxcbiAgICBbU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfU0lHTkVSXTpcbiAgICAgICAgJ1RoZSBwcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBpbXBsZW1lbnQgYW55IG9mIHRoZSBgTWVzc2FnZVNpZ25lcmAgaW50ZXJmYWNlcycsXG4gICAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9NT0RJRllJTkdfU0lHTkVSXTpcbiAgICAgICAgJ1RoZSBwcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGBUcmFuc2FjdGlvbk1vZGlmeWluZ1NpZ25lcmAgaW50ZXJmYWNlJyxcbiAgICBbU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1BBUlRJQUxfU0lHTkVSXTpcbiAgICAgICAgJ1RoZSBwcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGBUcmFuc2FjdGlvblBhcnRpYWxTaWduZXJgIGludGVyZmFjZScsXG4gICAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUl06XG4gICAgICAgICdUaGUgcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBgVHJhbnNhY3Rpb25TZW5kaW5nU2lnbmVyYCBpbnRlcmZhY2UnLFxuICAgIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fU0lHTkVSXTpcbiAgICAgICAgJ1RoZSBwcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBpbXBsZW1lbnQgYW55IG9mIHRoZSBgVHJhbnNhY3Rpb25TaWduZXJgIGludGVyZmFjZXMnLFxuICAgIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fVFJBTlNBQ1RJT05fQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0VORElOR19TSUdORVJTXTpcbiAgICAgICAgJ01vcmUgdGhhbiBvbmUgYFRyYW5zYWN0aW9uU2VuZGluZ1NpZ25lcmAgd2FzIGlkZW50aWZpZWQuJyxcbiAgICBbU09MQU5BX0VSUk9SX19TSUdORVJfX1RSQU5TQUNUSU9OX1NFTkRJTkdfU0lHTkVSX01JU1NJTkddOlxuICAgICAgICAnTm8gYFRyYW5zYWN0aW9uU2VuZGluZ1NpZ25lcmAgd2FzIGlkZW50aWZpZWQuIFBsZWFzZSBwcm92aWRlIGEgdmFsaWQgJyArXG4gICAgICAgICdgVHJhbnNhY3Rpb25XaXRoU2luZ2xlU2VuZGluZ1NpZ25lcmAgdHJhbnNhY3Rpb24uJyxcbiAgICBbU09MQU5BX0VSUk9SX19TSUdORVJfX1dBTExFVF9NVUxUSVNJR05fVU5JTVBMRU1FTlRFRF06XG4gICAgICAgICdXYWxsZXQgYWNjb3VudCBzaWduZXJzIGRvIG5vdCBzdXBwb3J0IHNpZ25pbmcgbXVsdGlwbGUgbWVzc2FnZXMvdHJhbnNhY3Rpb25zIGluIGEgc2luZ2xlIG9wZXJhdGlvbicsXG4gICAgW1NPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fQ0FOTk9UX0VYUE9SVF9OT05fRVhUUkFDVEFCTEVfS0VZXTogJ0Nhbm5vdCBleHBvcnQgYSBub24tZXh0cmFjdGFibGUga2V5LicsXG4gICAgW1NPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRElHRVNUX1VOSU1QTEVNRU5URURdOiAnTm8gZGlnZXN0IGltcGxlbWVudGF0aW9uIGNvdWxkIGJlIGZvdW5kLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRElTQUxMT1dFRF9JTl9JTlNFQ1VSRV9DT05URVhUXTpcbiAgICAgICAgJ0NyeXB0b2dyYXBoaWMgb3BlcmF0aW9ucyBhcmUgb25seSBhbGxvd2VkIGluIHNlY3VyZSBicm93c2VyIGNvbnRleHRzLiBSZWFkIG1vcmUgJyArXG4gICAgICAgICdoZXJlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TZWN1cml0eS9TZWN1cmVfQ29udGV4dHMuJyxcbiAgICBbU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FRDI1NTE5X0FMR09SSVRITV9VTklNUExFTUVOVEVEXTpcbiAgICAgICAgJ1RoaXMgcnVudGltZSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBnZW5lcmF0aW9uIG9mIEVkMjU1MTkga2V5IHBhaXJzLlxcblxcbkluc3RhbGwgJyArXG4gICAgICAgICdAc29sYW5hL3dlYmNyeXB0by1lZDI1NTE5LXBvbHlmaWxsIGFuZCBjYWxsIGl0cyBgaW5zdGFsbGAgZnVuY3Rpb24gYmVmb3JlIGdlbmVyYXRpbmcga2V5cyBpbiAnICtcbiAgICAgICAgJ2Vudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IEVkMjU1MTkuXFxuXFxuRm9yIGEgbGlzdCBvZiBydW50aW1lcyB0aGF0ICcgK1xuICAgICAgICAnY3VycmVudGx5IHN1cHBvcnQgRWQyNTUxOSBvcGVyYXRpb25zLCB2aXNpdCAnICtcbiAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL3dlYmNyeXB0by1zZWN1cmUtY3VydmVzL2lzc3Vlcy8yMC4nLFxuICAgIFtTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0VYUE9SVF9GVU5DVElPTl9VTklNUExFTUVOVEVEXTpcbiAgICAgICAgJ05vIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gaW1wbGVtZW50YXRpb24gY291bGQgYmUgZm91bmQuJyxcbiAgICBbU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19HRU5FUkFURV9GVU5DVElPTl9VTklNUExFTUVOVEVEXTogJ05vIGtleSBnZW5lcmF0aW9uIGltcGxlbWVudGF0aW9uIGNvdWxkIGJlIGZvdW5kLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fU0lHTl9GVU5DVElPTl9VTklNUExFTUVOVEVEXTogJ05vIHNpZ25pbmcgaW1wbGVtZW50YXRpb24gY291bGQgYmUgZm91bmQuJyxcbiAgICBbU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19WRVJJRllfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRF06ICdObyBrZXkgZXhwb3J0IGltcGxlbWVudGF0aW9uIGNvdWxkIGJlIGZvdW5kLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fVElNRVNUQU1QX09VVF9PRl9SQU5HRV06XG4gICAgICAgICdUaW1lc3RhbXAgdmFsdWUgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWy0oMm4gKiogNjNuKSwgKDJuICoqIDYzbikgLSAxXS4gYCR2YWx1ZWAgZ2l2ZW4nLFxuICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19PVVRTVEFORElOR106XG4gICAgICAgICdUcmFuc2FjdGlvbiBwcm9jZXNzaW5nIGxlZnQgYW4gYWNjb3VudCB3aXRoIGFuIG91dHN0YW5kaW5nIGJvcnJvd2VkIHJlZmVyZW5jZScsXG4gICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfSU5fVVNFXTogJ0FjY291bnQgaW4gdXNlJyxcbiAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9MT0FERURfVFdJQ0VdOiAnQWNjb3VudCBsb2FkZWQgdHdpY2UnLFxuICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9GT1VORF06XG4gICAgICAgICdBdHRlbXB0IHRvIGRlYml0IGFuIGFjY291bnQgYnV0IGZvdW5kIG5vIHJlY29yZCBvZiBhIHByaW9yIGNyZWRpdC4nLFxuICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BRERSRVNTX0xPT0tVUF9UQUJMRV9OT1RfRk9VTkRdOlxuICAgICAgICBcIlRyYW5zYWN0aW9uIGxvYWRzIGFuIGFkZHJlc3MgdGFibGUgYWNjb3VudCB0aGF0IGRvZXNuJ3QgZXhpc3RcIixcbiAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUxSRUFEWV9QUk9DRVNTRURdOiAnVGhpcyB0cmFuc2FjdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCcsXG4gICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0JMT0NLSEFTSF9OT1RfRk9VTkRdOiAnQmxvY2toYXNoIG5vdCBmb3VuZCcsXG4gICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0NBTExfQ0hBSU5fVE9PX0RFRVBdOiAnTG9hZGVyIGNhbGwgY2hhaW4gaXMgdG9vIGRlZXAnLFxuICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19DTFVTVEVSX01BSU5URU5BTkNFXTpcbiAgICAgICAgJ1RyYW5zYWN0aW9ucyBhcmUgY3VycmVudGx5IGRpc2FibGVkIGR1ZSB0byBjbHVzdGVyIG1haW50ZW5hbmNlJyxcbiAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fRFVQTElDQVRFX0lOU1RSVUNUSU9OXTpcbiAgICAgICAgJ1RyYW5zYWN0aW9uIGNvbnRhaW5zIGEgZHVwbGljYXRlIGluc3RydWN0aW9uICgkaW5kZXgpIHRoYXQgaXMgbm90IGFsbG93ZWQnLFxuICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNfRk9SX0ZFRV06ICdJbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGZlZScsXG4gICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfUkVOVF06XG4gICAgICAgICdUcmFuc2FjdGlvbiByZXN1bHRzIGluIGFuIGFjY291bnQgKCRhY2NvdW50SW5kZXgpIHdpdGggaW5zdWZmaWNpZW50IGZ1bmRzIGZvciByZW50JyxcbiAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0ZPUl9GRUVdOiAnVGhpcyBhY2NvdW50IG1heSBub3QgYmUgdXNlZCB0byBwYXkgdHJhbnNhY3Rpb24gZmVlcycsXG4gICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9JTkRFWF06ICdUcmFuc2FjdGlvbiBjb250YWlucyBhbiBpbnZhbGlkIGFjY291bnQgcmVmZXJlbmNlJyxcbiAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9EQVRBXTpcbiAgICAgICAgJ1RyYW5zYWN0aW9uIGxvYWRzIGFuIGFkZHJlc3MgdGFibGUgYWNjb3VudCB3aXRoIGludmFsaWQgZGF0YScsXG4gICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUREUkVTU19MT09LVVBfVEFCTEVfSU5ERVhdOlxuICAgICAgICAnVHJhbnNhY3Rpb24gYWRkcmVzcyB0YWJsZSBsb29rdXAgdXNlcyBhbiBpbnZhbGlkIGluZGV4JyxcbiAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9PV05FUl06XG4gICAgICAgICdUcmFuc2FjdGlvbiBsb2FkcyBhbiBhZGRyZXNzIHRhYmxlIGFjY291bnQgd2l0aCBhbiBpbnZhbGlkIG93bmVyJyxcbiAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9MT0FERURfQUNDT1VOVFNfREFUQV9TSVpFX0xJTUlUXTpcbiAgICAgICAgJ0xvYWRlZEFjY291bnRzRGF0YVNpemVMaW1pdCBzZXQgZm9yIHRyYW5zYWN0aW9uIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAuJyxcbiAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9QUk9HUkFNX0ZPUl9FWEVDVVRJT05dOlxuICAgICAgICAnVGhpcyBwcm9ncmFtIG1heSBub3QgYmUgdXNlZCBmb3IgZXhlY3V0aW5nIGluc3RydWN0aW9ucycsXG4gICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfUkVOVF9QQVlJTkdfQUNDT1VOVF06XG4gICAgICAgICdUcmFuc2FjdGlvbiBsZWF2ZXMgYW4gYWNjb3VudCB3aXRoIGEgbG93ZXIgYmFsYW5jZSB0aGFuIHJlbnQtZXhlbXB0IG1pbmltdW0nLFxuICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1dSSVRBQkxFX0FDQ09VTlRdOlxuICAgICAgICAnVHJhbnNhY3Rpb24gbG9hZHMgYSB3cml0YWJsZSBhY2NvdW50IHRoYXQgY2Fubm90IGJlIHdyaXR0ZW4nLFxuICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19NQVhfTE9BREVEX0FDQ09VTlRTX0RBVEFfU0laRV9FWENFRURFRF06XG4gICAgICAgICdUcmFuc2FjdGlvbiBleGNlZWRlZCBtYXggbG9hZGVkIGFjY291bnRzIGRhdGEgc2l6ZSBjYXAnLFxuICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19NSVNTSU5HX1NJR05BVFVSRV9GT1JfRkVFXTpcbiAgICAgICAgJ1RyYW5zYWN0aW9uIHJlcXVpcmVzIGEgZmVlIGJ1dCBoYXMgbm8gc2lnbmF0dXJlIHByZXNlbnQnLFxuICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19QUk9HUkFNX0FDQ09VTlRfTk9UX0ZPVU5EXTogJ0F0dGVtcHQgdG8gbG9hZCBhIHByb2dyYW0gdGhhdCBkb2VzIG5vdCBleGlzdCcsXG4gICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1BST0dSQU1fRVhFQ1VUSU9OX1RFTVBPUkFSSUxZX1JFU1RSSUNURURdOlxuICAgICAgICAnRXhlY3V0aW9uIG9mIHRoZSBwcm9ncmFtIHJlZmVyZW5jZWQgYnkgYWNjb3VudCBhdCBpbmRleCAkYWNjb3VudEluZGV4IGlzIHRlbXBvcmFyaWx5IHJlc3RyaWN0ZWQuJyxcbiAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUkVTQU5JVElaQVRJT05fTkVFREVEXTogJ1Jlc2FuaXRpemF0aW9uTmVlZGVkJyxcbiAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fU0FOSVRJWkVfRkFJTFVSRV06ICdUcmFuc2FjdGlvbiBmYWlsZWQgdG8gc2FuaXRpemUgYWNjb3VudHMgb2Zmc2V0cyBjb3JyZWN0bHknLFxuICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19TSUdOQVRVUkVfRkFJTFVSRV06ICdUcmFuc2FjdGlvbiBkaWQgbm90IHBhc3Mgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbicsXG4gICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1RPT19NQU5ZX0FDQ09VTlRfTE9DS1NdOiAnVHJhbnNhY3Rpb24gbG9ja2VkIHRvbyBtYW55IGFjY291bnRzJyxcbiAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5CQUxBTkNFRF9UUkFOU0FDVElPTl06XG4gICAgICAgICdTdW0gb2YgYWNjb3VudCBiYWxhbmNlcyBiZWZvcmUgYW5kIGFmdGVyIHRyYW5zYWN0aW9uIGRvIG5vdCBtYXRjaCcsXG4gICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOS05PV05dOiAnVGhlIHRyYW5zYWN0aW9uIGZhaWxlZCB3aXRoIHRoZSBlcnJvciBgJGVycm9yTmFtZWAnLFxuICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9WRVJTSU9OXTogJ1RyYW5zYWN0aW9uIHZlcnNpb24gaXMgdW5zdXBwb3J0ZWQnLFxuICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfQUNDT1VOVF9EQVRBX0JMT0NLX0xJTUlUXTpcbiAgICAgICAgJ1RyYW5zYWN0aW9uIHdvdWxkIGV4Y2VlZCBhY2NvdW50IGRhdGEgbGltaXQgd2l0aGluIHRoZSBibG9jaycsXG4gICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9BQ0NPVU5UX0RBVEFfVE9UQUxfTElNSVRdOlxuICAgICAgICAnVHJhbnNhY3Rpb24gd291bGQgZXhjZWVkIHRvdGFsIGFjY291bnQgZGF0YSBsaW1pdCcsXG4gICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9NQVhfQUNDT1VOVF9DT1NUX0xJTUlUXTpcbiAgICAgICAgJ1RyYW5zYWN0aW9uIHdvdWxkIGV4Y2VlZCBtYXggYWNjb3VudCBsaW1pdCB3aXRoaW4gdGhlIGJsb2NrJyxcbiAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9CTE9DS19DT1NUX0xJTUlUXTpcbiAgICAgICAgJ1RyYW5zYWN0aW9uIHdvdWxkIGV4Y2VlZCBtYXggQmxvY2sgQ29zdCBMaW1pdCcsXG4gICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9NQVhfVk9URV9DT1NUX0xJTUlUXTogJ1RyYW5zYWN0aW9uIHdvdWxkIGV4Y2VlZCBtYXggVm90ZSBDb3N0IExpbWl0JyxcbiAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQUREUkVTU0VTX0NBTk5PVF9TSUdOX1RSQU5TQUNUSU9OXTpcbiAgICAgICAgJ0F0dGVtcHRlZCB0byBzaWduIGEgdHJhbnNhY3Rpb24gd2l0aCBhbiBhZGRyZXNzIHRoYXQgaXMgbm90IGEgc2lnbmVyIGZvciBpdCcsXG4gICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0FERFJFU1NfTUlTU0lOR106ICdUcmFuc2FjdGlvbiBpcyBtaXNzaW5nIGFuIGFkZHJlc3MgYXQgaW5kZXg6ICRpbmRleC4nLFxuICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19DQU5OT1RfRU5DT0RFX1dJVEhfRU1QVFlfU0lHTkFUVVJFU106XG4gICAgICAgICdUcmFuc2FjdGlvbiBoYXMgbm8gZXhwZWN0ZWQgc2lnbmVycyB0aGVyZWZvcmUgaXQgY2Fubm90IGJlIGVuY29kZWQnLFxuICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWENFRURTX1NJWkVfTElNSVRdOlxuICAgICAgICAnVHJhbnNhY3Rpb24gc2l6ZSAkdHJhbnNhY3Rpb25TaXplIGV4Y2VlZHMgbGltaXQgb2YgJHRyYW5zYWN0aW9uU2l6ZUxpbWl0IGJ5dGVzJyxcbiAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfQkxPQ0tIQVNIX0xJRkVUSU1FXTogJ1RyYW5zYWN0aW9uIGRvZXMgbm90IGhhdmUgYSBibG9ja2hhc2ggbGlmZXRpbWUnLFxuICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWFBFQ1RFRF9OT05DRV9MSUZFVElNRV06ICdUcmFuc2FjdGlvbiBpcyBub3QgYSBkdXJhYmxlIG5vbmNlIHRyYW5zYWN0aW9uJyxcbiAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9BRERSRVNTX0xPT0tVUF9UQUJMRV9DT05URU5UU19NSVNTSU5HXTpcbiAgICAgICAgJ0NvbnRlbnRzIG9mIHRoZXNlIGFkZHJlc3MgbG9va3VwIHRhYmxlcyB1bmtub3duOiAkbG9va3VwVGFibGVBZGRyZXNzZXMnLFxuICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0FERFJFU1NfTE9PS1VQX1RBQkxFX0lOREVYX09VVF9PRl9SQU5HRV06XG4gICAgICAgICdMb29rdXAgb2YgYWRkcmVzcyBhdCBpbmRleCAkaGlnaGVzdFJlcXVlc3RlZEluZGV4IGZhaWxlZCBmb3IgbG9va3VwIHRhYmxlICcgK1xuICAgICAgICAnYCRsb29rdXBUYWJsZUFkZHJlc3NgLiBIaWdoZXN0IGtub3duIGluZGV4IGlzICRoaWdoZXN0S25vd25JbmRleC4gVGhlIGxvb2t1cCB0YWJsZSAnICtcbiAgICAgICAgJ21heSBoYXZlIGJlZW4gZXh0ZW5kZWQgc2luY2UgaXRzIGNvbnRlbnRzIHdlcmUgcmV0cmlldmVkJyxcbiAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9GRUVfUEFZRVJfTUlTU0lOR106ICdObyBmZWUgcGF5ZXIgc2V0IGluIENvbXBpbGVkVHJhbnNhY3Rpb24nLFxuICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0lOU1RSVUNUSU9OX1BST0dSQU1fQUREUkVTU19OT1RfRk9VTkRdOlxuICAgICAgICAnQ291bGQgbm90IGZpbmQgcHJvZ3JhbSBhZGRyZXNzIGF0IGluZGV4ICRpbmRleCcsXG4gICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19FU1RJTUFURV9DT01QVVRFX0xJTUlUXTpcbiAgICAgICAgJ0ZhaWxlZCB0byBlc3RpbWF0ZSB0aGUgY29tcHV0ZSB1bml0IGNvbnN1bXB0aW9uIGZvciB0aGlzIHRyYW5zYWN0aW9uIG1lc3NhZ2UuIFRoaXMgaXMgJyArXG4gICAgICAgICdsaWtlbHkgYmVjYXVzZSBzaW11bGF0aW5nIHRoZSB0cmFuc2FjdGlvbiBmYWlsZWQuIEluc3BlY3QgdGhlIGBjYXVzZWAgcHJvcGVydHkgb2YgdGhpcyAnICtcbiAgICAgICAgJ2Vycm9yIHRvIGxlYXJuIG1vcmUnLFxuICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfV0hFTl9TSU1VTEFUSU5HX1RPX0VTVElNQVRFX0NPTVBVVEVfTElNSVRdOlxuICAgICAgICAnVHJhbnNhY3Rpb24gZmFpbGVkIHdoZW4gaXQgd2FzIHNpbXVsYXRlZCBpbiBvcmRlciB0byBlc3RpbWF0ZSB0aGUgY29tcHV0ZSB1bml0IGNvbnN1bXB0aW9uLiAnICtcbiAgICAgICAgJ1RoZSBjb21wdXRlIHVuaXQgZXN0aW1hdGUgcHJvdmlkZWQgaXMgZm9yIGEgdHJhbnNhY3Rpb24gdGhhdCBmYWlsZWQgd2hlbiBzaW11bGF0ZWQgYW5kIG1heSBub3QgJyArXG4gICAgICAgICdiZSByZXByZXNlbnRhdGl2ZSBvZiB0aGUgY29tcHV0ZSB1bml0cyB0aGlzIHRyYW5zYWN0aW9uIHdvdWxkIGNvbnN1bWUgaWYgc3VjY2Vzc2Z1bC4gSW5zcGVjdCB0aGUgJyArXG4gICAgICAgICdgY2F1c2VgIHByb3BlcnR5IG9mIHRoaXMgZXJyb3IgdG8gbGVhcm4gbW9yZScsXG4gICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZFRV9QQVlFUl9NSVNTSU5HXTogJ1RyYW5zYWN0aW9uIGlzIG1pc3NpbmcgYSBmZWUgcGF5ZXIuJyxcbiAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkVFX1BBWUVSX1NJR05BVFVSRV9NSVNTSU5HXTpcbiAgICAgICAgXCJDb3VsZCBub3QgZGV0ZXJtaW5lIHRoaXMgdHJhbnNhY3Rpb24ncyBzaWduYXR1cmUuIE1ha2Ugc3VyZSB0aGF0IHRoZSB0cmFuc2FjdGlvbiBoYXMgXCIgK1xuICAgICAgICAnYmVlbiBzaWduZWQgYnkgaXRzIGZlZSBwYXllci4nLFxuICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZBTElEX05PTkNFX1RSQU5TQUNUSU9OX0ZJUlNUX0lOU1RSVUNUSU9OX01VU1RfQkVfQURWQU5DRV9OT05DRV06XG4gICAgICAgICdUcmFuc2FjdGlvbiBmaXJzdCBpbnN0cnVjdGlvbiBpcyBub3QgYWR2YW5jZSBub25jZSBhY2NvdW50IGluc3RydWN0aW9uLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVkFMSURfTk9OQ0VfVFJBTlNBQ1RJT05fSU5TVFJVQ1RJT05TX01JU1NJTkddOlxuICAgICAgICAnVHJhbnNhY3Rpb24gd2l0aCBubyBpbnN0cnVjdGlvbnMgY2Fubm90IGJlIGR1cmFibGUgbm9uY2UgdHJhbnNhY3Rpb24uJyxcbiAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19DQU5OT1RfUEFZX0ZFRVNdOlxuICAgICAgICAnVGhpcyB0cmFuc2FjdGlvbiBpbmNsdWRlcyBhbiBhZGRyZXNzIChgJHByb2dyYW1BZGRyZXNzYCkgd2hpY2ggaXMgYm90aCAnICtcbiAgICAgICAgJ2ludm9rZWQgYW5kIHNldCBhcyB0aGUgZmVlIHBheWVyLiBQcm9ncmFtIGFkZHJlc3NlcyBtYXkgbm90IHBheSBmZWVzJyxcbiAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19NVVNUX05PVF9CRV9XUklUQUJMRV06XG4gICAgICAgICdUaGlzIHRyYW5zYWN0aW9uIGluY2x1ZGVzIGFuIGFkZHJlc3MgKGAkcHJvZ3JhbUFkZHJlc3NgKSB3aGljaCBpcyBib3RoIGludm9rZWQgYW5kICcgK1xuICAgICAgICAnbWFya2VkIHdyaXRhYmxlLiBQcm9ncmFtIGFkZHJlc3NlcyBtYXkgbm90IGJlIHdyaXRhYmxlJyxcbiAgICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fTUVTU0FHRV9TSUdOQVRVUkVTX01JU01BVENIXTpcbiAgICAgICAgJ1RoZSB0cmFuc2FjdGlvbiBtZXNzYWdlIGV4cGVjdGVkIHRoZSB0cmFuc2FjdGlvbiB0byBoYXZlICRzaWduZXJBZGRyZXNzZXNMZW5ndGggc2lnbmF0dXJlcywgZ290ICRzaWduYXR1cmVzTGVuZ3RoLicsXG4gICAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX1NJR05BVFVSRVNfTUlTU0lOR106ICdUcmFuc2FjdGlvbiBpcyBtaXNzaW5nIHNpZ25hdHVyZXMgZm9yIGFkZHJlc3NlczogJGFkZHJlc3Nlcy4nLFxuICAgIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19WRVJTSU9OX05VTUJFUl9PVVRfT0ZfUkFOR0VdOlxuICAgICAgICAnVHJhbnNhY3Rpb24gdmVyc2lvbiBtdXN0IGJlIGluIHRoZSByYW5nZSBbMCwgMTI3XS4gYCRhY3R1YWxWZXJzaW9uYCBnaXZlbicsXG59O1xuIiwgImltcG9ydCB7IFNvbGFuYUVycm9yQ29kZSB9IGZyb20gJy4vY29kZXMnO1xuaW1wb3J0IHsgZW5jb2RlQ29udGV4dE9iamVjdCB9IGZyb20gJy4vY29udGV4dCc7XG5pbXBvcnQgeyBTb2xhbmFFcnJvck1lc3NhZ2VzIH0gZnJvbSAnLi9tZXNzYWdlcyc7XG5cbmNvbnN0IGVudW0gU3RhdGVUeXBlIHtcbiAgICBFc2NhcGVTZXF1ZW5jZSxcbiAgICBUZXh0LFxuICAgIFZhcmlhYmxlLFxufVxudHlwZSBTdGF0ZSA9IFJlYWRvbmx5PHtcbiAgICBbU1RBUlRfSU5ERVhdOiBudW1iZXI7XG4gICAgW1RZUEVdOiBTdGF0ZVR5cGU7XG59PjtcbmNvbnN0IFNUQVJUX0lOREVYID0gJ2knO1xuY29uc3QgVFlQRSA9ICd0JztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEh1bWFuUmVhZGFibGVFcnJvck1lc3NhZ2U8VEVycm9yQ29kZSBleHRlbmRzIFNvbGFuYUVycm9yQ29kZT4oXG4gICAgY29kZTogVEVycm9yQ29kZSxcbiAgICBjb250ZXh0OiBvYmplY3QgPSB7fSxcbik6IHN0cmluZyB7XG4gICAgY29uc3QgbWVzc2FnZUZvcm1hdFN0cmluZyA9IFNvbGFuYUVycm9yTWVzc2FnZXNbY29kZV07XG4gICAgaWYgKG1lc3NhZ2VGb3JtYXRTdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgbGV0IHN0YXRlOiBTdGF0ZTtcbiAgICBmdW5jdGlvbiBjb21taXRTdGF0ZVVwVG8oZW5kSW5kZXg/OiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHN0YXRlW1RZUEVdID09PSBTdGF0ZVR5cGUuVmFyaWFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IG1lc3NhZ2VGb3JtYXRTdHJpbmcuc2xpY2Uoc3RhdGVbU1RBUlRfSU5ERVhdICsgMSwgZW5kSW5kZXgpO1xuXG4gICAgICAgICAgICBmcmFnbWVudHMucHVzaChcbiAgICAgICAgICAgICAgICB2YXJpYWJsZU5hbWUgaW4gY29udGV4dFxuICAgICAgICAgICAgICAgICAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICBgJHtjb250ZXh0W3ZhcmlhYmxlTmFtZSBhcyBrZXlvZiB0eXBlb2YgY29udGV4dF19YFxuICAgICAgICAgICAgICAgICAgICA6IGAkJHt2YXJpYWJsZU5hbWV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGVbVFlQRV0gPT09IFN0YXRlVHlwZS5UZXh0KSB7XG4gICAgICAgICAgICBmcmFnbWVudHMucHVzaChtZXNzYWdlRm9ybWF0U3RyaW5nLnNsaWNlKHN0YXRlW1NUQVJUX0lOREVYXSwgZW5kSW5kZXgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcmFnbWVudHM6IHN0cmluZ1tdID0gW107XG4gICAgbWVzc2FnZUZvcm1hdFN0cmluZy5zcGxpdCgnJykuZm9yRWFjaCgoY2hhciwgaWkpID0+IHtcbiAgICAgICAgaWYgKGlpID09PSAwKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBbU1RBUlRfSU5ERVhdOiAwLFxuICAgICAgICAgICAgICAgIFtUWVBFXTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUZvcm1hdFN0cmluZ1swXSA9PT0gJ1xcXFwnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFN0YXRlVHlwZS5Fc2NhcGVTZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBtZXNzYWdlRm9ybWF0U3RyaW5nWzBdID09PSAnJCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBTdGF0ZVR5cGUuVmFyaWFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBTdGF0ZVR5cGUuVGV4dCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRTdGF0ZTtcbiAgICAgICAgc3dpdGNoIChzdGF0ZVtUWVBFXSkge1xuICAgICAgICAgICAgY2FzZSBTdGF0ZVR5cGUuRXNjYXBlU2VxdWVuY2U6XG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlID0geyBbU1RBUlRfSU5ERVhdOiBpaSwgW1RZUEVdOiBTdGF0ZVR5cGUuVGV4dCB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTdGF0ZVR5cGUuVGV4dDpcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSA9IHsgW1NUQVJUX0lOREVYXTogaWksIFtUWVBFXTogU3RhdGVUeXBlLkVzY2FwZVNlcXVlbmNlIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnJCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlID0geyBbU1RBUlRfSU5ERVhdOiBpaSwgW1RZUEVdOiBTdGF0ZVR5cGUuVmFyaWFibGUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFN0YXRlVHlwZS5WYXJpYWJsZTpcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZSA9IHsgW1NUQVJUX0lOREVYXTogaWksIFtUWVBFXTogU3RhdGVUeXBlLkVzY2FwZVNlcXVlbmNlIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnJCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlID0geyBbU1RBUlRfSU5ERVhdOiBpaSwgW1RZUEVdOiBTdGF0ZVR5cGUuVmFyaWFibGUgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFjaGFyLm1hdGNoKC9cXHcvKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUgPSB7IFtTVEFSVF9JTkRFWF06IGlpLCBbVFlQRV06IFN0YXRlVHlwZS5UZXh0IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0U3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY29tbWl0U3RhdGVVcFRvKGlpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29tbWl0U3RhdGVVcFRvKCk7XG4gICAgcmV0dXJuIGZyYWdtZW50cy5qb2luKCcnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZTxURXJyb3JDb2RlIGV4dGVuZHMgU29sYW5hRXJyb3JDb2RlPihcbiAgICBjb2RlOiBURXJyb3JDb2RlLFxuICAgIGNvbnRleHQ6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge30sXG4pOiBzdHJpbmcge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGdldEh1bWFuUmVhZGFibGVFcnJvck1lc3NhZ2UoY29kZSwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGRlY29kaW5nQWR2aWNlTWVzc2FnZSA9IGBTb2xhbmEgZXJyb3IgIyR7Y29kZX07IERlY29kZSB0aGlzIGVycm9yIGJ5IHJ1bm5pbmcgXFxgbnB4IEBzb2xhbmEvZXJyb3JzIGRlY29kZSAtLSAke2NvZGV9YDtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGNvbnRleHQpLmxlbmd0aCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEQU5HRVI6IEJlIHN1cmUgdGhhdCB0aGUgc2hlbGwgY29tbWFuZCBpcyBlc2NhcGVkIGluIHN1Y2ggYSB3YXkgdGhhdCBtYWtlcyBpdFxuICAgICAgICAgICAgICogICAgICAgICBpbXBvc3NpYmxlIGZvciBzb21lb25lIHRvIGNyYWZ0IG1hbGljaW91cyBjb250ZXh0IHZhbHVlcyB0aGF0IHdvdWxkIHJlc3VsdCBpblxuICAgICAgICAgICAgICogICAgICAgICBhbiBleHBsb2l0IGFnYWluc3QgYW55b25lIHdobyBiaW5kbHkgY29weS9wYXN0ZXMgaXQgaW50byB0aGVpciB0ZXJtaW5hbC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZGVjb2RpbmdBZHZpY2VNZXNzYWdlICs9IGAgJyR7ZW5jb2RlQ29udGV4dE9iamVjdChjb250ZXh0KX0nYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7ZGVjb2RpbmdBZHZpY2VNZXNzYWdlfVxcYGA7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFNvbGFuYUVycm9yQ29kZSwgU29sYW5hRXJyb3JDb2RlV2l0aENhdXNlIH0gZnJvbSAnLi9jb2Rlcyc7XG5pbXBvcnQgeyBTb2xhbmFFcnJvckNvbnRleHQgfSBmcm9tICcuL2NvbnRleHQnO1xuaW1wb3J0IHsgZ2V0RXJyb3JNZXNzYWdlIH0gZnJvbSAnLi9tZXNzYWdlLWZvcm1hdHRlcic7XG5cbi8qKlxuICogQSB0eXBlIGd1YXJkIHRoYXQgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGlucHV0IGlzIGEge0BsaW5rIFNvbGFuYUVycm9yfSwgb3B0aW9uYWxseSB3aXRoIGFcbiAqIHBhcnRpY3VsYXIgZXJyb3IgY29kZS5cbiAqXG4gKiBXaGVuIHRoZSBgY29kZWAgYXJndW1lbnQgaXMgc3VwcGxpZWQgYW5kIHRoZSBpbnB1dCBpcyBhIHtAbGluayBTb2xhbmFFcnJvcn0sIFR5cGVTY3JpcHQgd2lsbFxuICogcmVmaW5lIHRoZSBlcnJvcidzIHtAbGluayBTb2xhbmFFcnJvciNjb250ZXh0IHwgYGNvbnRleHRgfSBwcm9wZXJ0eSB0byB0aGUgdHlwZSBhc3NvY2lhdGVkIHdpdGhcbiAqIHRoYXQgZXJyb3IgY29kZS4gWW91IGNhbiB1c2UgdGhhdCBjb250ZXh0IHRvIHJlbmRlciB1c2VmdWwgZXJyb3IgbWVzc2FnZXMsIG9yIHRvIG1ha2VcbiAqIGNvbnRleHQtYXdhcmUgZGVjaXNpb25zIHRoYXQgaGVscCB5b3VyIGFwcGxpY2F0aW9uIHRvIHJlY292ZXIgZnJvbSB0aGUgZXJyb3IuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQge1xuICogICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX01JU1NJTkdfU0lHTkFUVVJFLFxuICogICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZFRV9QQVlFUl9TSUdOQVRVUkVfTUlTU0lORyxcbiAqICAgICBpc1NvbGFuYUVycm9yLFxuICogfSBmcm9tICdAc29sYW5hL2Vycm9ycyc7XG4gKiBpbXBvcnQgeyBhc3NlcnRJc0Z1bGx5U2lnbmVkVHJhbnNhY3Rpb24sIGdldFNpZ25hdHVyZUZyb21UcmFuc2FjdGlvbiB9IGZyb20gJ0Bzb2xhbmEvdHJhbnNhY3Rpb25zJztcbiAqXG4gKiB0cnkge1xuICogICAgIGNvbnN0IHRyYW5zYWN0aW9uU2lnbmF0dXJlID0gZ2V0U2lnbmF0dXJlRnJvbVRyYW5zYWN0aW9uKHR4KTtcbiAqICAgICBhc3NlcnRJc0Z1bGx5U2lnbmVkVHJhbnNhY3Rpb24odHgpO1xuICogICAgIC8qIC4uLiAqXFwvXG4gKiB9IGNhdGNoIChlKSB7XG4gKiAgICAgaWYgKGlzU29sYW5hRXJyb3IoZSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fU0lHTkFUVVJFU19NSVNTSU5HKSkge1xuICogICAgICAgICBkaXNwbGF5RXJyb3IoXG4gKiAgICAgICAgICAgICBcIldlIGNhbid0IHNlbmQgdGhpcyB0cmFuc2FjdGlvbiB3aXRob3V0IHNpZ25hdHVyZXMgZm9yIHRoZXNlIGFkZHJlc3NlczpcXG4tICVzXCIsXG4gKiAgICAgICAgICAgICAvLyBUaGUgdHlwZSBvZiB0aGUgYGNvbnRleHRgIG9iamVjdCBpcyBub3cgcmVmaW5lZCB0byBjb250YWluIGBhZGRyZXNzZXNgLlxuICogICAgICAgICAgICAgZS5jb250ZXh0LmFkZHJlc3Nlcy5qb2luKCdcXG4tICcpLFxuICogICAgICAgICApO1xuICogICAgICAgICByZXR1cm47XG4gKiAgICAgfSBlbHNlIGlmIChpc1NvbGFuYUVycm9yKGUsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZFRV9QQVlFUl9TSUdOQVRVUkVfTUlTU0lORykpIHtcbiAqICAgICAgICAgaWYgKCF0eC5mZWVQYXllcikge1xuICogICAgICAgICAgICAgZGlzcGxheUVycm9yKCdDaG9vc2UgYSBmZWUgcGF5ZXIgZm9yIHRoaXMgdHJhbnNhY3Rpb24gYmVmb3JlIHNlbmRpbmcgaXQnKTtcbiAqICAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgICAgIGRpc3BsYXlFcnJvcignVGhlIGZlZSBwYXllciBzdGlsbCBuZWVkcyB0byBzaWduIGZvciB0aGlzIHRyYW5zYWN0aW9uJyk7XG4gKiAgICAgICAgIH1cbiAqICAgICAgICAgcmV0dXJuO1xuICogICAgIH1cbiAqICAgICB0aHJvdyBlO1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NvbGFuYUVycm9yPFRFcnJvckNvZGUgZXh0ZW5kcyBTb2xhbmFFcnJvckNvZGU+KFxuICAgIGU6IHVua25vd24sXG4gICAgLyoqXG4gICAgICogV2hlbiBzdXBwbGllZCwgdGhpcyBmdW5jdGlvbiB3aWxsIHJlcXVpcmUgdGhhdCB0aGUgaW5wdXQgaXMgYSB7QGxpbmsgU29sYW5hRXJyb3J9IF9hbmRfIHRoYXRcbiAgICAgKiBpdHMgZXJyb3IgY29kZSBpcyBleGFjdGx5IHRoaXMgdmFsdWUuXG4gICAgICovXG4gICAgY29kZT86IFRFcnJvckNvZGUsXG4pOiBlIGlzIFNvbGFuYUVycm9yPFRFcnJvckNvZGU+IHtcbiAgICBjb25zdCBpc1NvbGFuYUVycm9yID0gZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubmFtZSA9PT0gJ1NvbGFuYUVycm9yJztcbiAgICBpZiAoaXNTb2xhbmFFcnJvcikge1xuICAgICAgICBpZiAoY29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gKGUgYXMgU29sYW5hRXJyb3I8VEVycm9yQ29kZT4pLmNvbnRleHQuX19jb2RlID09PSBjb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnR5cGUgU29sYW5hRXJyb3JDb2RlZENvbnRleHQgPSBSZWFkb25seTx7XG4gICAgW1AgaW4gU29sYW5hRXJyb3JDb2RlXTogKFNvbGFuYUVycm9yQ29udGV4dFtQXSBleHRlbmRzIHVuZGVmaW5lZCA/IG9iamVjdCA6IFNvbGFuYUVycm9yQ29udGV4dFtQXSkgJiB7XG4gICAgICAgIF9fY29kZTogUDtcbiAgICB9O1xufT47XG5cbi8qKlxuICogRW5jYXBzdWxhdGVzIGFuIGVycm9yJ3Mgc3RhY2t0cmFjZSwgYSBTb2xhbmEtc3BlY2lmaWMgbnVtZXJpYyBjb2RlIHRoYXQgaW5kaWNhdGVzIHdoYXQgd2VudFxuICogd3JvbmcsIGFuZCBvcHRpb25hbCBjb250ZXh0IGlmIHRoZSB0eXBlIG9mIGVycm9yIGluZGljYXRlZCBieSB0aGUgY29kZSBzdXBwb3J0cyBpdC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNvbGFuYUVycm9yPFRFcnJvckNvZGUgZXh0ZW5kcyBTb2xhbmFFcnJvckNvZGUgPSBTb2xhbmFFcnJvckNvZGU+IGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgcm9vdCBjYXVzZSBvZiB0aGlzIHtAbGluayBTb2xhbmFFcnJvcn0sIGlmIGFueS5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLCBhIHRyYW5zYWN0aW9uIGVycm9yIG1pZ2h0IGhhdmUgYW4gaW5zdHJ1Y3Rpb24gZXJyb3IgYXMgaXRzIHJvb3QgY2F1c2UuIEluIHRoaXNcbiAgICAgKiBjYXNlLCB5b3Ugd2lsbCBiZSBhYmxlIHRvIGFjY2VzcyB0aGUgaW5zdHJ1Y3Rpb24gZXJyb3Igb24gdGhlIHRyYW5zYWN0aW9uIGVycm9yIGFzIGBjYXVzZWAuXG4gICAgICovXG4gICAgcmVhZG9ubHkgY2F1c2U/OiBURXJyb3JDb2RlIGV4dGVuZHMgU29sYW5hRXJyb3JDb2RlV2l0aENhdXNlID8gU29sYW5hRXJyb3IgOiB1bmtub3duID0gdGhpcy5jYXVzZTtcbiAgICAvKipcbiAgICAgKiBDb250YWlucyBjb250ZXh0IHRoYXQgY2FuIGFzc2lzdCBpbiB1bmRlcnN0YW5kaW5nIG9yIHJlY292ZXJpbmcgZnJvbSBhIHtAbGluayBTb2xhbmFFcnJvcn0uXG4gICAgICovXG4gICAgcmVhZG9ubHkgY29udGV4dDogU29sYW5hRXJyb3JDb2RlZENvbnRleHRbVEVycm9yQ29kZV07XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIC4uLltjb2RlLCBjb250ZXh0QW5kRXJyb3JPcHRpb25zXTogU29sYW5hRXJyb3JDb250ZXh0W1RFcnJvckNvZGVdIGV4dGVuZHMgdW5kZWZpbmVkXG4gICAgICAgICAgICA/IFtjb2RlOiBURXJyb3JDb2RlLCBlcnJvck9wdGlvbnM/OiBFcnJvck9wdGlvbnMgfCB1bmRlZmluZWRdXG4gICAgICAgICAgICA6IFtjb2RlOiBURXJyb3JDb2RlLCBjb250ZXh0QW5kRXJyb3JPcHRpb25zOiBTb2xhbmFFcnJvckNvbnRleHRbVEVycm9yQ29kZV0gJiAoRXJyb3JPcHRpb25zIHwgdW5kZWZpbmVkKV1cbiAgICApIHtcbiAgICAgICAgbGV0IGNvbnRleHQ6IFNvbGFuYUVycm9yQ29udGV4dFtURXJyb3JDb2RlXSB8IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGVycm9yT3B0aW9uczogRXJyb3JPcHRpb25zIHwgdW5kZWZpbmVkO1xuICAgICAgICBpZiAoY29udGV4dEFuZEVycm9yT3B0aW9ucykge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGBFcnJvck9wdGlvbnNgIHR5cGUgZXZlciBjaGFuZ2VzLCB1cGRhdGUgdGhpcyBjb2RlLlxuICAgICAgICAgICAgY29uc3QgeyBjYXVzZSwgLi4uY29udGV4dFJlc3QgfSA9IGNvbnRleHRBbmRFcnJvck9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY2F1c2UpIHtcbiAgICAgICAgICAgICAgICBlcnJvck9wdGlvbnMgPSB7IGNhdXNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoY29udGV4dFJlc3QpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dFJlc3QgYXMgU29sYW5hRXJyb3JDb250ZXh0W1RFcnJvckNvZGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2UoY29kZSwgY29udGV4dCk7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIGVycm9yT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IHtcbiAgICAgICAgICAgIF9fY29kZTogY29kZSxcbiAgICAgICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgIH0gYXMgU29sYW5hRXJyb3JDb2RlZENvbnRleHRbVEVycm9yQ29kZV07XG4gICAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IHNvIHRoYXQgYGlzU29sYW5hRXJyb3IoKWAgY2FuIGlkZW50aWZ5IGEgYFNvbGFuYUVycm9yYCB3aXRob3V0IGhhdmluZ1xuICAgICAgICAvLyB0byBpbXBvcnQgdGhlIGNsYXNzIGZvciB1c2UgaW4gYW4gYGluc3RhbmNlb2ZgIGNoZWNrLlxuICAgICAgICB0aGlzLm5hbWUgPSAnU29sYW5hRXJyb3InO1xuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gc2FmZUNhcHR1cmVTdGFja1RyYWNlKC4uLmFyZ3M6IFBhcmFtZXRlcnM8dHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlPik6IHZvaWQge1xuICAgIGlmICgnY2FwdHVyZVN0YWNrVHJhY2UnIGluIEVycm9yICYmIHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSguLi5hcmdzKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgU29sYW5hRXJyb3JDb2RlIH0gZnJvbSAnLi9jb2Rlcyc7XG5pbXBvcnQgeyBTb2xhbmFFcnJvckNvbnRleHQgfSBmcm9tICcuL2NvbnRleHQnO1xuaW1wb3J0IHsgU29sYW5hRXJyb3IgfSBmcm9tICcuL2Vycm9yJztcbmltcG9ydCB7IHNhZmVDYXB0dXJlU3RhY2tUcmFjZSB9IGZyb20gJy4vc3RhY2stdHJhY2UnO1xuXG50eXBlIENvbmZpZyA9IFJlYWRvbmx5PHtcbiAgICAvKipcbiAgICAgKiBPaCwgaGVsbG8uIFlvdSBtaWdodCB3b25kZXIgd2hhdCBpbiB0YXJuYXRpb24gaXMgZ29pbmcgb24gaGVyZS4gQWxsb3cgdXMgdG8gZXhwbGFpbi5cbiAgICAgKlxuICAgICAqIE9uZSBvZiB0aGUgZ29hbHMgb2YgYEBzb2xhbmEvZXJyb3JzYCBpcyB0byBhbGxvdyBlcnJvcnMgdGhhdCBhcmUgbm90IGludGVyZXN0aW5nIHRvIHlvdXJcbiAgICAgKiBhcHBsaWNhdGlvbiB0byBzaGFrZSBvdXQgb2YgeW91ciBhcHAgYnVuZGxlIGluIHByb2R1Y3Rpb24uIFRoaXMgbWVhbnMgdGhhdCB3ZSBtdXN0IG5ldmVyXG4gICAgICogZXhwb3J0IGxhcmdlIGhhcmRjb2RlZCBtYXBzIG9mIGVycm9yIGNvZGVzL21lc3NhZ2VzLlxuICAgICAqXG4gICAgICogVW5mb3J0dW5hdGVseSwgd2hlcmUgaW5zdHJ1Y3Rpb24gYW5kIHRyYW5zYWN0aW9uIGVycm9ycyBmcm9tIHRoZSBSUEMgYXJlIGNvbmNlcm5lZCwgd2UgaGF2ZVxuICAgICAqIG5vIGNob2ljZSBidXQgdG8ga2VlcCBhIG1hcCBiZXR3ZWVuIHRoZSBSUEMgYHJwY0VudW1FcnJvcmAgZW51bSBuYW1lIGFuZCBpdHMgY29ycmVzcG9uZGluZ1xuICAgICAqIGBTb2xhbmFFcnJvcmAgY29kZS4gSW4gdGhlIGludGVyZXN0IG9mIGltcGxlbWVudGluZyB0aGF0IG1hcCBpbiBhcyBmZXcgYnl0ZXMgb2Ygc291cmNlIGNvZGVcbiAgICAgKiBhcyBwb3NzaWJsZSwgd2UgZG8gdGhlIGZvbGxvd2luZzpcbiAgICAgKlxuICAgICAqICAgMS4gUmVzZXJ2ZSBhIGJsb2NrIG9mIHNlcXVlbnRpYWwgZXJyb3IgY29kZXMgZm9yIHRoZSBlbnVtIGluIHF1ZXN0aW9uXG4gICAgICogICAyLiBIYXJkY29kZSB0aGUgbGlzdCBvZiBlbnVtIG5hbWVzIGluIHRoYXQgc2FtZSBvcmRlclxuICAgICAqICAgMy4gTWF0Y2ggdGhlIGVudW0gZXJyb3IgbmFtZSBmcm9tIHRoZSBSUEMgd2l0aCBpdHMgaW5kZXggaW4gdGhhdCBsaXN0LCBhbmQgcmVjb25zdHJ1Y3QgdGhlXG4gICAgICogICAgICBgU29sYW5hRXJyb3JgIGNvZGUgYnkgYWRkaW5nIHRoZSBgZXJyb3JDb2RlQmFzZU9mZnNldGAgdG8gdGhhdCBpbmRleFxuICAgICAqL1xuICAgIGVycm9yQ29kZUJhc2VPZmZzZXQ6IG51bWJlcjtcbiAgICBnZXRFcnJvckNvbnRleHQ6IChcbiAgICAgICAgZXJyb3JDb2RlOiBTb2xhbmFFcnJvckNvZGUsXG4gICAgICAgIHJwY0Vycm9yTmFtZTogc3RyaW5nLFxuICAgICAgICBycGNFcnJvckNvbnRleHQ/OiB1bmtub3duLFxuICAgICkgPT4gU29sYW5hRXJyb3JDb250ZXh0W1NvbGFuYUVycm9yQ29kZV07XG4gICAgb3JkZXJlZEVycm9yTmFtZXM6IHN0cmluZ1tdO1xuICAgIHJwY0VudW1FcnJvcjogc3RyaW5nIHwgeyBba2V5OiBzdHJpbmddOiB1bmtub3duIH07XG59PjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNvbGFuYUVycm9yRnJvbVJwY0Vycm9yKFxuICAgIHsgZXJyb3JDb2RlQmFzZU9mZnNldCwgZ2V0RXJyb3JDb250ZXh0LCBvcmRlcmVkRXJyb3JOYW1lcywgcnBjRW51bUVycm9yIH06IENvbmZpZyxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1mdW5jdGlvbi10eXBlXG4gICAgY29uc3RydWN0b3JPcHQ6IEZ1bmN0aW9uLFxuKTogU29sYW5hRXJyb3Ige1xuICAgIGxldCBycGNFcnJvck5hbWU7XG4gICAgbGV0IHJwY0Vycm9yQ29udGV4dDtcbiAgICBpZiAodHlwZW9mIHJwY0VudW1FcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcnBjRXJyb3JOYW1lID0gcnBjRW51bUVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJwY0Vycm9yTmFtZSA9IE9iamVjdC5rZXlzKHJwY0VudW1FcnJvcilbMF07XG4gICAgICAgIHJwY0Vycm9yQ29udGV4dCA9IHJwY0VudW1FcnJvcltycGNFcnJvck5hbWVdO1xuICAgIH1cbiAgICBjb25zdCBjb2RlT2Zmc2V0ID0gb3JkZXJlZEVycm9yTmFtZXMuaW5kZXhPZihycGNFcnJvck5hbWUpO1xuICAgIGNvbnN0IGVycm9yQ29kZSA9IChlcnJvckNvZGVCYXNlT2Zmc2V0ICsgY29kZU9mZnNldCkgYXMgU29sYW5hRXJyb3JDb2RlO1xuICAgIGNvbnN0IGVycm9yQ29udGV4dCA9IGdldEVycm9yQ29udGV4dChlcnJvckNvZGUsIHJwY0Vycm9yTmFtZSwgcnBjRXJyb3JDb250ZXh0KTtcbiAgICBjb25zdCBlcnIgPSBuZXcgU29sYW5hRXJyb3IoZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpO1xuICAgIHNhZmVDYXB0dXJlU3RhY2tUcmFjZShlcnIsIGNvbnN0cnVjdG9yT3B0KTtcbiAgICByZXR1cm4gZXJyO1xufVxuIiwgImltcG9ydCB7XG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQk9SU0hfSU9fRVJST1IsXG4gICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ1VTVE9NLFxuICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOS05PV04sXG59IGZyb20gJy4vY29kZXMnO1xuaW1wb3J0IHsgU29sYW5hRXJyb3IgfSBmcm9tICcuL2Vycm9yJztcbmltcG9ydCB7IGdldFNvbGFuYUVycm9yRnJvbVJwY0Vycm9yIH0gZnJvbSAnLi9ycGMtZW51bS1lcnJvcnMnO1xuXG5jb25zdCBPUkRFUkVEX0VSUk9SX05BTUVTID0gW1xuICAgIC8vIEtlZXAgc3luY2VkIHdpdGggUlBDIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FuemEteHl6L2FnYXZlL2Jsb2IvbWFzdGVyL3Nkay9wcm9ncmFtL3NyYy9pbnN0cnVjdGlvbi5yc1xuICAgIC8vIElmIHRoaXMgbGlzdCBldmVyIGdldHMgdG9vIGxhcmdlLCBjb25zaWRlciBpbXBsZW1lbnRpbmcgYSBjb21wcmVzc2lvbiBzdHJhdGVneSBsaWtlIHRoaXM6XG4gICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vc3RldmVsdXNjaGVyL2FhYTdjYmJiNTQzM2IxMTk3OTgzOTA4YTQwODYwYzQ3XG4gICAgJ0dlbmVyaWNFcnJvcicsXG4gICAgJ0ludmFsaWRBcmd1bWVudCcsXG4gICAgJ0ludmFsaWRJbnN0cnVjdGlvbkRhdGEnLFxuICAgICdJbnZhbGlkQWNjb3VudERhdGEnLFxuICAgICdBY2NvdW50RGF0YVRvb1NtYWxsJyxcbiAgICAnSW5zdWZmaWNpZW50RnVuZHMnLFxuICAgICdJbmNvcnJlY3RQcm9ncmFtSWQnLFxuICAgICdNaXNzaW5nUmVxdWlyZWRTaWduYXR1cmUnLFxuICAgICdBY2NvdW50QWxyZWFkeUluaXRpYWxpemVkJyxcbiAgICAnVW5pbml0aWFsaXplZEFjY291bnQnLFxuICAgICdVbmJhbGFuY2VkSW5zdHJ1Y3Rpb24nLFxuICAgICdNb2RpZmllZFByb2dyYW1JZCcsXG4gICAgJ0V4dGVybmFsQWNjb3VudExhbXBvcnRTcGVuZCcsXG4gICAgJ0V4dGVybmFsQWNjb3VudERhdGFNb2RpZmllZCcsXG4gICAgJ1JlYWRvbmx5TGFtcG9ydENoYW5nZScsXG4gICAgJ1JlYWRvbmx5RGF0YU1vZGlmaWVkJyxcbiAgICAnRHVwbGljYXRlQWNjb3VudEluZGV4JyxcbiAgICAnRXhlY3V0YWJsZU1vZGlmaWVkJyxcbiAgICAnUmVudEVwb2NoTW9kaWZpZWQnLFxuICAgICdOb3RFbm91Z2hBY2NvdW50S2V5cycsXG4gICAgJ0FjY291bnREYXRhU2l6ZUNoYW5nZWQnLFxuICAgICdBY2NvdW50Tm90RXhlY3V0YWJsZScsXG4gICAgJ0FjY291bnRCb3Jyb3dGYWlsZWQnLFxuICAgICdBY2NvdW50Qm9ycm93T3V0c3RhbmRpbmcnLFxuICAgICdEdXBsaWNhdGVBY2NvdW50T3V0T2ZTeW5jJyxcbiAgICAnQ3VzdG9tJyxcbiAgICAnSW52YWxpZEVycm9yJyxcbiAgICAnRXhlY3V0YWJsZURhdGFNb2RpZmllZCcsXG4gICAgJ0V4ZWN1dGFibGVMYW1wb3J0Q2hhbmdlJyxcbiAgICAnRXhlY3V0YWJsZUFjY291bnROb3RSZW50RXhlbXB0JyxcbiAgICAnVW5zdXBwb3J0ZWRQcm9ncmFtSWQnLFxuICAgICdDYWxsRGVwdGgnLFxuICAgICdNaXNzaW5nQWNjb3VudCcsXG4gICAgJ1JlZW50cmFuY3lOb3RBbGxvd2VkJyxcbiAgICAnTWF4U2VlZExlbmd0aEV4Y2VlZGVkJyxcbiAgICAnSW52YWxpZFNlZWRzJyxcbiAgICAnSW52YWxpZFJlYWxsb2MnLFxuICAgICdDb21wdXRhdGlvbmFsQnVkZ2V0RXhjZWVkZWQnLFxuICAgICdQcml2aWxlZ2VFc2NhbGF0aW9uJyxcbiAgICAnUHJvZ3JhbUVudmlyb25tZW50U2V0dXBGYWlsdXJlJyxcbiAgICAnUHJvZ3JhbUZhaWxlZFRvQ29tcGxldGUnLFxuICAgICdQcm9ncmFtRmFpbGVkVG9Db21waWxlJyxcbiAgICAnSW1tdXRhYmxlJyxcbiAgICAnSW5jb3JyZWN0QXV0aG9yaXR5JyxcbiAgICAnQm9yc2hJb0Vycm9yJyxcbiAgICAnQWNjb3VudE5vdFJlbnRFeGVtcHQnLFxuICAgICdJbnZhbGlkQWNjb3VudE93bmVyJyxcbiAgICAnQXJpdGhtZXRpY092ZXJmbG93JyxcbiAgICAnVW5zdXBwb3J0ZWRTeXN2YXInLFxuICAgICdJbGxlZ2FsT3duZXInLFxuICAgICdNYXhBY2NvdW50c0RhdGFBbGxvY2F0aW9uc0V4Y2VlZGVkJyxcbiAgICAnTWF4QWNjb3VudHNFeGNlZWRlZCcsXG4gICAgJ01heEluc3RydWN0aW9uVHJhY2VMZW5ndGhFeGNlZWRlZCcsXG4gICAgJ0J1aWx0aW5Qcm9ncmFtc011c3RDb25zdW1lQ29tcHV0ZVVuaXRzJyxcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTb2xhbmFFcnJvckZyb21JbnN0cnVjdGlvbkVycm9yKFxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgaW5zdHJ1Y3Rpb24gaW5zaWRlIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBpbmRleDogYmlnaW50IHwgbnVtYmVyLFxuICAgIGluc3RydWN0aW9uRXJyb3I6IHN0cmluZyB8IHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9LFxuKTogU29sYW5hRXJyb3Ige1xuICAgIGNvbnN0IG51bWJlckluZGV4ID0gTnVtYmVyKGluZGV4KTtcbiAgICByZXR1cm4gZ2V0U29sYW5hRXJyb3JGcm9tUnBjRXJyb3IoXG4gICAgICAgIHtcbiAgICAgICAgICAgIGVycm9yQ29kZUJhc2VPZmZzZXQ6IDQ2MTUwMDEsXG4gICAgICAgICAgICBnZXRFcnJvckNvbnRleHQoZXJyb3JDb2RlLCBycGNFcnJvck5hbWUsIHJwY0Vycm9yQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvckNvZGUgPT09IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOS05PV04pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTmFtZTogcnBjRXJyb3JOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IG51bWJlckluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKHJwY0Vycm9yQ29udGV4dCAhPT0gdW5kZWZpbmVkID8geyBpbnN0cnVjdGlvbkVycm9yQ29udGV4dDogcnBjRXJyb3JDb250ZXh0IH0gOiBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yQ29kZSA9PT0gU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ1VTVE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBOdW1iZXIocnBjRXJyb3JDb250ZXh0IGFzIGJpZ2ludCB8IG51bWJlciksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogbnVtYmVySW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvckNvZGUgPT09IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0JPUlNIX0lPX0VSUk9SKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVkRGF0YTogcnBjRXJyb3JDb250ZXh0IGFzIHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBudW1iZXJJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaW5kZXg6IG51bWJlckluZGV4IH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3JkZXJlZEVycm9yTmFtZXM6IE9SREVSRURfRVJST1JfTkFNRVMsXG4gICAgICAgICAgICBycGNFbnVtRXJyb3I6IGluc3RydWN0aW9uRXJyb3IsXG4gICAgICAgIH0sXG4gICAgICAgIGdldFNvbGFuYUVycm9yRnJvbUluc3RydWN0aW9uRXJyb3IsXG4gICAgKTtcbn1cbiIsICJpbXBvcnQge1xuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0RVUExJQ0FURV9JTlNUUlVDVElPTixcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNfRk9SX1JFTlQsXG4gICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUFJPR1JBTV9FWEVDVVRJT05fVEVNUE9SQVJJTFlfUkVTVFJJQ1RFRCxcbiAgICBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTktOT1dOLFxufSBmcm9tICcuL2NvZGVzJztcbmltcG9ydCB7IFNvbGFuYUVycm9yIH0gZnJvbSAnLi9lcnJvcic7XG5pbXBvcnQgeyBnZXRTb2xhbmFFcnJvckZyb21JbnN0cnVjdGlvbkVycm9yIH0gZnJvbSAnLi9pbnN0cnVjdGlvbi1lcnJvcic7XG5pbXBvcnQgeyBnZXRTb2xhbmFFcnJvckZyb21ScGNFcnJvciB9IGZyb20gJy4vcnBjLWVudW0tZXJyb3JzJztcblxuLyoqXG4gKiBIb3cgdG8gYWRkIGFuIGVycm9yIHdoZW4gYW4gZW50cnkgaXMgYWRkZWQgdG8gdGhlIFJQQyBgVHJhbnNhY3Rpb25FcnJvcmAgZW51bTpcbiAqXG4gKiAgIDEuIEZvbGxvdyB0aGUgaW5zdHJ1Y3Rpb25zIGluIGAuL2NvZGVzLnRzYCB0byBhZGQgYSBjb3JyZXNwb25kaW5nIFNvbGFuYSBlcnJvciBjb2RlXG4gKiAgIDIuIEFkZCB0aGUgYFRyYW5zYWN0aW9uRXJyb3JgIGVudW0gbmFtZSBpbiB0aGUgc2FtZSBvcmRlciBhcyBpdCBhcHBlYXJzIGluIGAuL2NvZGVzLnRzYFxuICogICAzLiBBZGQgdGhlIG5ldyBlcnJvciBuYW1lL2NvZGUgbWFwcGluZyB0byBgLi9fX3Rlc3RzX18vdHJhbnNhY3Rpb24tZXJyb3ItdGVzdC50c2BcbiAqL1xuY29uc3QgT1JERVJFRF9FUlJPUl9OQU1FUyA9IFtcbiAgICAvLyBLZWVwIHN5bmNlZCB3aXRoIFJQQyBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbnphLXh5ei9hZ2F2ZS9ibG9iL21hc3Rlci9zZGsvc3JjL3RyYW5zYWN0aW9uL2Vycm9yLnJzXG4gICAgLy8gSWYgdGhpcyBsaXN0IGV2ZXIgZ2V0cyB0b28gbGFyZ2UsIGNvbnNpZGVyIGltcGxlbWVudGluZyBhIGNvbXByZXNzaW9uIHN0cmF0ZWd5IGxpa2UgdGhpczpcbiAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9zdGV2ZWx1c2NoZXIvYWFhN2NiYmI1NDMzYjExOTc5ODM5MDhhNDA4NjBjNDdcbiAgICAnQWNjb3VudEluVXNlJyxcbiAgICAnQWNjb3VudExvYWRlZFR3aWNlJyxcbiAgICAnQWNjb3VudE5vdEZvdW5kJyxcbiAgICAnUHJvZ3JhbUFjY291bnROb3RGb3VuZCcsXG4gICAgJ0luc3VmZmljaWVudEZ1bmRzRm9yRmVlJyxcbiAgICAnSW52YWxpZEFjY291bnRGb3JGZWUnLFxuICAgICdBbHJlYWR5UHJvY2Vzc2VkJyxcbiAgICAnQmxvY2toYXNoTm90Rm91bmQnLFxuICAgIC8vIGBJbnN0cnVjdGlvbkVycm9yYCBpbnRlbnRpb25hbGx5IG9taXR0ZWQ7IGRlbGVnYXRlZCB0byBgZ2V0U29sYW5hRXJyb3JGcm9tSW5zdHJ1Y3Rpb25FcnJvcmBcbiAgICAnQ2FsbENoYWluVG9vRGVlcCcsXG4gICAgJ01pc3NpbmdTaWduYXR1cmVGb3JGZWUnLFxuICAgICdJbnZhbGlkQWNjb3VudEluZGV4JyxcbiAgICAnU2lnbmF0dXJlRmFpbHVyZScsXG4gICAgJ0ludmFsaWRQcm9ncmFtRm9yRXhlY3V0aW9uJyxcbiAgICAnU2FuaXRpemVGYWlsdXJlJyxcbiAgICAnQ2x1c3Rlck1haW50ZW5hbmNlJyxcbiAgICAnQWNjb3VudEJvcnJvd091dHN0YW5kaW5nJyxcbiAgICAnV291bGRFeGNlZWRNYXhCbG9ja0Nvc3RMaW1pdCcsXG4gICAgJ1Vuc3VwcG9ydGVkVmVyc2lvbicsXG4gICAgJ0ludmFsaWRXcml0YWJsZUFjY291bnQnLFxuICAgICdXb3VsZEV4Y2VlZE1heEFjY291bnRDb3N0TGltaXQnLFxuICAgICdXb3VsZEV4Y2VlZEFjY291bnREYXRhQmxvY2tMaW1pdCcsXG4gICAgJ1Rvb01hbnlBY2NvdW50TG9ja3MnLFxuICAgICdBZGRyZXNzTG9va3VwVGFibGVOb3RGb3VuZCcsXG4gICAgJ0ludmFsaWRBZGRyZXNzTG9va3VwVGFibGVPd25lcicsXG4gICAgJ0ludmFsaWRBZGRyZXNzTG9va3VwVGFibGVEYXRhJyxcbiAgICAnSW52YWxpZEFkZHJlc3NMb29rdXBUYWJsZUluZGV4JyxcbiAgICAnSW52YWxpZFJlbnRQYXlpbmdBY2NvdW50JyxcbiAgICAnV291bGRFeGNlZWRNYXhWb3RlQ29zdExpbWl0JyxcbiAgICAnV291bGRFeGNlZWRBY2NvdW50RGF0YVRvdGFsTGltaXQnLFxuICAgICdEdXBsaWNhdGVJbnN0cnVjdGlvbicsXG4gICAgJ0luc3VmZmljaWVudEZ1bmRzRm9yUmVudCcsXG4gICAgJ01heExvYWRlZEFjY291bnRzRGF0YVNpemVFeGNlZWRlZCcsXG4gICAgJ0ludmFsaWRMb2FkZWRBY2NvdW50c0RhdGFTaXplTGltaXQnLFxuICAgICdSZXNhbml0aXphdGlvbk5lZWRlZCcsXG4gICAgJ1Byb2dyYW1FeGVjdXRpb25UZW1wb3JhcmlseVJlc3RyaWN0ZWQnLFxuICAgICdVbmJhbGFuY2VkVHJhbnNhY3Rpb24nLFxuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNvbGFuYUVycm9yRnJvbVRyYW5zYWN0aW9uRXJyb3IodHJhbnNhY3Rpb25FcnJvcjogc3RyaW5nIHwgeyBba2V5OiBzdHJpbmddOiB1bmtub3duIH0pOiBTb2xhbmFFcnJvciB7XG4gICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbkVycm9yID09PSAnb2JqZWN0JyAmJiAnSW5zdHJ1Y3Rpb25FcnJvcicgaW4gdHJhbnNhY3Rpb25FcnJvcikge1xuICAgICAgICByZXR1cm4gZ2V0U29sYW5hRXJyb3JGcm9tSW5zdHJ1Y3Rpb25FcnJvcihcbiAgICAgICAgICAgIC4uLih0cmFuc2FjdGlvbkVycm9yLkluc3RydWN0aW9uRXJyb3IgYXMgUGFyYW1ldGVyczx0eXBlb2YgZ2V0U29sYW5hRXJyb3JGcm9tSW5zdHJ1Y3Rpb25FcnJvcj4pLFxuICAgICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0U29sYW5hRXJyb3JGcm9tUnBjRXJyb3IoXG4gICAgICAgIHtcbiAgICAgICAgICAgIGVycm9yQ29kZUJhc2VPZmZzZXQ6IDcwNTAwMDEsXG4gICAgICAgICAgICBnZXRFcnJvckNvbnRleHQoZXJyb3JDb2RlLCBycGNFcnJvck5hbWUsIHJwY0Vycm9yQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvckNvZGUgPT09IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOS05PV04pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTmFtZTogcnBjRXJyb3JOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKHJwY0Vycm9yQ29udGV4dCAhPT0gdW5kZWZpbmVkID8geyB0cmFuc2FjdGlvbkVycm9yQ29udGV4dDogcnBjRXJyb3JDb250ZXh0IH0gOiBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yQ29kZSA9PT0gU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fRFVQTElDQVRFX0lOU1RSVUNUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogTnVtYmVyKHJwY0Vycm9yQ29udGV4dCBhcyBiaWdpbnQgfCBudW1iZXIpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9PT0gU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5TVUZGSUNJRU5UX0ZVTkRTX0ZPUl9SRU5UIHx8XG4gICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9PT0gU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUFJPR1JBTV9FWEVDVVRJT05fVEVNUE9SQVJJTFlfUkVTVFJJQ1RFRFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudEluZGV4OiBOdW1iZXIoKHJwY0Vycm9yQ29udGV4dCBhcyB7IGFjY291bnRfaW5kZXg6IGJpZ2ludCB8IG51bWJlciB9KS5hY2NvdW50X2luZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3JkZXJlZEVycm9yTmFtZXM6IE9SREVSRURfRVJST1JfTkFNRVMsXG4gICAgICAgICAgICBycGNFbnVtRXJyb3I6IHRyYW5zYWN0aW9uRXJyb3IsXG4gICAgICAgIH0sXG4gICAgICAgIGdldFNvbGFuYUVycm9yRnJvbVRyYW5zYWN0aW9uRXJyb3IsXG4gICAgKTtcbn1cbiIsICJpbXBvcnQge1xuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVEVSTkFMX0VSUk9SLFxuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUEFSQU1TLFxuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUkVRVUVTVCxcbiAgICBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19NRVRIT0RfTk9UX0ZPVU5ELFxuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1BBUlNFX0VSUk9SLFxuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NDQU5fRVJST1IsXG4gICAgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVAsXG4gICAgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX05PVF9BVkFJTEFCTEUsXG4gICAgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX1NUQVRVU19OT1RfQVZBSUxBQkxFX1lFVCxcbiAgICBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYLFxuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9MT05HX1RFUk1fU1RPUkFHRV9TTE9UX1NLSVBQRUQsXG4gICAgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkUsXG4gICAgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NMT1RfU0tJUFBFRCxcbiAgICBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRSxcbiAgICBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVU5TVVBQT1JURURfVFJBTlNBQ1RJT05fVkVSU0lPTixcbiAgICBTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9KU09OX1JQQ19FUlJPUixcbiAgICBTb2xhbmFFcnJvckNvZGUsXG59IGZyb20gJy4vY29kZXMnO1xuaW1wb3J0IHsgU29sYW5hRXJyb3JDb250ZXh0IH0gZnJvbSAnLi9jb250ZXh0JztcbmltcG9ydCB7IFNvbGFuYUVycm9yIH0gZnJvbSAnLi9lcnJvcic7XG5pbXBvcnQgeyBzYWZlQ2FwdHVyZVN0YWNrVHJhY2UgfSBmcm9tICcuL3N0YWNrLXRyYWNlJztcbmltcG9ydCB7IGdldFNvbGFuYUVycm9yRnJvbVRyYW5zYWN0aW9uRXJyb3IgfSBmcm9tICcuL3RyYW5zYWN0aW9uLWVycm9yJztcblxuaW50ZXJmYWNlIFJwY0Vycm9yUmVzcG9uc2Uge1xuICAgIGNvZGU6IGJpZ2ludCB8IG51bWJlcjtcbiAgICBkYXRhPzogdW5rbm93bjtcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG59XG5cbnR5cGUgVHJhbnNhY3Rpb25FcnJvciA9IHN0cmluZyB8IHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9O1xuXG4vKipcbiAqIEtlZXAgaW4gc3luYyB3aXRoIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnphLXh5ei9hZ2F2ZS9ibG9iL21hc3Rlci9ycGMtY2xpZW50LXR5cGVzL3NyYy9yZXNwb25zZS5yc1xuICogQGhpZGRlblxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJwY1NpbXVsYXRlVHJhbnNhY3Rpb25SZXN1bHQge1xuICAgIGFjY291bnRzOlxuICAgICAgICB8ICh7XG4gICAgICAgICAgICAgIGRhdGE6XG4gICAgICAgICAgICAgICAgICB8IHN0cmluZyAvLyBMZWdhY3lCaW5hcnlcbiAgICAgICAgICAgICAgICAgIHwge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnNvblxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkOiB1bmtub3duO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbTogc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2U6IG51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gQmluYXJ5XG4gICAgICAgICAgICAgICAgICB8IFtlbmNvZGVkQnl0ZXM6IHN0cmluZywgZW5jb2Rpbmc6ICdiYXNlNTgnIHwgJ2Jhc2U2NCcgfCAnYmFzZTY0K3pzdGQnIHwgJ2JpbmFyeScgfCAnanNvblBhcnNlZCddO1xuICAgICAgICAgICAgICBleGVjdXRhYmxlOiBib29sZWFuO1xuICAgICAgICAgICAgICBsYW1wb3J0czogbnVtYmVyO1xuICAgICAgICAgICAgICBvd25lcjogc3RyaW5nO1xuICAgICAgICAgICAgICByZW50RXBvY2g6IG51bWJlcjtcbiAgICAgICAgICAgICAgc3BhY2U/OiBudW1iZXI7XG4gICAgICAgICAgfSB8IG51bGwpW11cbiAgICAgICAgfCBudWxsO1xuICAgIGVycjogVHJhbnNhY3Rpb25FcnJvciB8IG51bGw7XG4gICAgLy8gRW5hYmxlZCBieSBgZW5hYmxlX2NwaV9yZWNvcmRpbmdgXG4gICAgaW5uZXJJbnN0cnVjdGlvbnM/OlxuICAgICAgICB8IHtcbiAgICAgICAgICAgICAgaW5kZXg6IG51bWJlcjtcbiAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zOiAoXG4gICAgICAgICAgICAgICAgICB8IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXBpbGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50czogbnVtYmVyW107XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBzdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmFtSWRJbmRleDogbnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tIZWlnaHQ/OiBudW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHwge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQ6IHVua25vd247XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmFtOiBzdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmFtSWQ6IHN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrSGVpZ2h0PzogbnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB8IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhcnRpYWxseURlY29kZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRzOiBzdHJpbmdbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyYW1JZDogc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tIZWlnaHQ/OiBudW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKVtdO1xuICAgICAgICAgIH1bXVxuICAgICAgICB8IG51bGw7XG4gICAgbG9nczogc3RyaW5nW10gfCBudWxsO1xuICAgIHJlcGxhY2VtZW50QmxvY2toYXNoOiBzdHJpbmcgfCBudWxsO1xuICAgIHJldHVybkRhdGE6IHtcbiAgICAgICAgZGF0YTogW3N0cmluZywgJ2Jhc2U2NCddO1xuICAgICAgICBwcm9ncmFtSWQ6IHN0cmluZztcbiAgICB9IHwgbnVsbDtcbiAgICB1bml0c0NvbnN1bWVkOiBiaWdpbnQgfCBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U29sYW5hRXJyb3JGcm9tSnNvblJwY0Vycm9yKHB1dGF0aXZlRXJyb3JSZXNwb25zZTogdW5rbm93bik6IFNvbGFuYUVycm9yIHtcbiAgICBsZXQgb3V0OiBTb2xhbmFFcnJvcjtcbiAgICBpZiAoaXNScGNFcnJvclJlc3BvbnNlKHB1dGF0aXZlRXJyb3JSZXNwb25zZSkpIHtcbiAgICAgICAgY29uc3QgeyBjb2RlOiByYXdDb2RlLCBkYXRhLCBtZXNzYWdlIH0gPSBwdXRhdGl2ZUVycm9yUmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBOdW1iZXIocmF3Q29kZSk7XG4gICAgICAgIGlmIChjb2RlID09PSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0VORF9UUkFOU0FDVElPTl9QUkVGTElHSFRfRkFJTFVSRSkge1xuICAgICAgICAgICAgY29uc3QgeyBlcnIsIC4uLnByZWZsaWdodEVycm9yQ29udGV4dCB9ID0gZGF0YSBhcyBScGNTaW11bGF0ZVRyYW5zYWN0aW9uUmVzdWx0O1xuICAgICAgICAgICAgY29uc3QgY2F1c2VPYmplY3QgPSBlcnIgPyB7IGNhdXNlOiBnZXRTb2xhbmFFcnJvckZyb21UcmFuc2FjdGlvbkVycm9yKGVycikgfSA6IG51bGw7XG4gICAgICAgICAgICBvdXQgPSBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkUsIHtcbiAgICAgICAgICAgICAgICAuLi5wcmVmbGlnaHRFcnJvckNvbnRleHQsXG4gICAgICAgICAgICAgICAgLi4uY2F1c2VPYmplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBlcnJvckNvbnRleHQ7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVEVSTkFMX0VSUk9SOlxuICAgICAgICAgICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9QQVJBTVM6XG4gICAgICAgICAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlZBTElEX1JFUVVFU1Q6XG4gICAgICAgICAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19NRVRIT0RfTk9UX0ZPVU5EOlxuICAgICAgICAgICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fUEFSU0VfRVJST1I6XG4gICAgICAgICAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TQ0FOX0VSUk9SOlxuICAgICAgICAgICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVA6XG4gICAgICAgICAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfTk9UX0FWQUlMQUJMRTpcbiAgICAgICAgICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19TVEFUVVNfTk9UX0FWQUlMQUJMRV9ZRVQ6XG4gICAgICAgICAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYOlxuICAgICAgICAgICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1NMT1RfU0tJUFBFRDpcbiAgICAgICAgICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TTE9UX1NLSVBQRUQ6XG4gICAgICAgICAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRTpcbiAgICAgICAgICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9VTlNVUFBPUlRFRF9UUkFOU0FDVElPTl9WRVJTSU9OOlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc2VydmVyIHN1cHBsaWVzIG5vIHN0cnVjdHVyZWQgZGF0YSwgYnV0IHJhdGhlciBhIHByZS1mb3JtYXR0ZWQgbWVzc2FnZS4gUHV0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzZXJ2ZXIgbWVzc2FnZSBpbiBgY29udGV4dGAgc28gYXMgbm90IHRvIGNvbXBsZXRlbHkgbG9zZSB0aGUgZGF0YS4gVGhlIGxvbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gdGVybSBmaXggZm9yIHRoaXMgaXMgdG8gYWRkIGRhdGEgdG8gdGhlIHNlcnZlciByZXNwb25zZXMgYW5kIG1vZGlmeSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gbWVzc2FnZXMgaW4gYEBzb2xhbmEvZXJyb3JzYCB0byBiZSBhY3R1YWwgZm9ybWF0IHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIGVycm9yQ29udGV4dCA9IHsgX19zZXJ2ZXJNZXNzYWdlOiBtZXNzYWdlIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29udGV4dCA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCA9IG5ldyBTb2xhbmFFcnJvcihjb2RlIGFzIFNvbGFuYUVycm9yQ29kZSwgZXJyb3JDb250ZXh0IGFzIFNvbGFuYUVycm9yQ29udGV4dFtTb2xhbmFFcnJvckNvZGVdKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAgICAgdHlwZW9mIHB1dGF0aXZlRXJyb3JSZXNwb25zZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHB1dGF0aXZlRXJyb3JSZXNwb25zZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgJ21lc3NhZ2UnIGluIHB1dGF0aXZlRXJyb3JSZXNwb25zZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHB1dGF0aXZlRXJyb3JSZXNwb25zZS5tZXNzYWdlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gcHV0YXRpdmVFcnJvclJlc3BvbnNlLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICA6ICdNYWxmb3JtZWQgSlNPTi1SUEMgZXJyb3Igd2l0aCBubyBtZXNzYWdlIGF0dHJpYnV0ZSc7XG4gICAgICAgIG91dCA9IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9KU09OX1JQQ19FUlJPUiwgeyBlcnJvcjogcHV0YXRpdmVFcnJvclJlc3BvbnNlLCBtZXNzYWdlIH0pO1xuICAgIH1cbiAgICBzYWZlQ2FwdHVyZVN0YWNrVHJhY2Uob3V0LCBnZXRTb2xhbmFFcnJvckZyb21Kc29uUnBjRXJyb3IpO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGlzUnBjRXJyb3JSZXNwb25zZSh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFJwY0Vycm9yUmVzcG9uc2Uge1xuICAgIHJldHVybiAoXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgJ2NvZGUnIGluIHZhbHVlICYmXG4gICAgICAgICdtZXNzYWdlJyBpbiB2YWx1ZSAmJlxuICAgICAgICAodHlwZW9mIHZhbHVlLmNvZGUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZS5jb2RlID09PSAnYmlnaW50JykgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT09ICdzdHJpbmcnXG4gICAgKTtcbn1cbiIsICJpbXBvcnQgeyBSZWFkb25seVVpbnQ4QXJyYXkgfSBmcm9tICcuL3JlYWRvbmx5LXVpbnQ4YXJyYXknO1xuXG4vKipcbiAqIENvbmNhdGVuYXRlcyBhbiBhcnJheSBvZiBgVWludDhBcnJheWBzIGludG8gYSBzaW5nbGUgYFVpbnQ4QXJyYXlgLlxuICogUmV1c2VzIHRoZSBvcmlnaW5hbCBieXRlIGFycmF5IHdoZW4gYXBwbGljYWJsZS5cbiAqXG4gKiBAcGFyYW0gYnl0ZUFycmF5cyAtIFRoZSBhcnJheSBvZiBieXRlIGFycmF5cyB0byBjb25jYXRlbmF0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGJ5dGVzMSA9IG5ldyBVaW50OEFycmF5KFsweDAxLCAweDAyXSk7XG4gKiBjb25zdCBieXRlczIgPSBuZXcgVWludDhBcnJheShbXSk7XG4gKiBjb25zdCBieXRlczMgPSBuZXcgVWludDhBcnJheShbMHgwMywgMHgwNF0pO1xuICogY29uc3QgYnl0ZXMgPSBtZXJnZUJ5dGVzKFtieXRlczEsIGJ5dGVzMiwgYnl0ZXMzXSk7XG4gKiAvLyAgICBeIFsweDAxLCAweDAyLCAweDAzLCAweDA0XVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBtZXJnZUJ5dGVzID0gKGJ5dGVBcnJheXM6IFVpbnQ4QXJyYXlbXSk6IFVpbnQ4QXJyYXkgPT4ge1xuICAgIGNvbnN0IG5vbkVtcHR5Qnl0ZUFycmF5cyA9IGJ5dGVBcnJheXMuZmlsdGVyKGFyciA9PiBhcnIubGVuZ3RoKTtcbiAgICBpZiAobm9uRW1wdHlCeXRlQXJyYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYnl0ZUFycmF5cy5sZW5ndGggPyBieXRlQXJyYXlzWzBdIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB9XG5cbiAgICBpZiAobm9uRW1wdHlCeXRlQXJyYXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbm9uRW1wdHlCeXRlQXJyYXlzWzBdO1xuICAgIH1cblxuICAgIGNvbnN0IHRvdGFsTGVuZ3RoID0gbm9uRW1wdHlCeXRlQXJyYXlzLnJlZHVjZSgodG90YWwsIGFycikgPT4gdG90YWwgKyBhcnIubGVuZ3RoLCAwKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgbm9uRW1wdHlCeXRlQXJyYXlzLmZvckVhY2goYXJyID0+IHtcbiAgICAgICAgcmVzdWx0LnNldChhcnIsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBhcnIubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFBhZHMgYSBgVWludDhBcnJheWAgd2l0aCB6ZXJvZXMgdG8gdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gKiBJZiB0aGUgYXJyYXkgaXMgbG9uZ2VyIHRoYW4gdGhlIHNwZWNpZmllZCBsZW5ndGgsIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlIGFycmF5IHRvIHBhZC5cbiAqIEBwYXJhbSBsZW5ndGggLSBUaGUgZGVzaXJlZCBsZW5ndGggb2YgdGhlIGJ5dGUgYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIEFkZHMgemVyb2VzIHRvIHRoZSBlbmQgb2YgdGhlIGJ5dGUgYXJyYXkgdG8gcmVhY2ggdGhlIGRlc2lyZWQgbGVuZ3RoLlxuICogYGBgdHNcbiAqIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDEsIDB4MDJdKTtcbiAqIGNvbnN0IHBhZGRlZEJ5dGVzID0gcGFkQnl0ZXMoYnl0ZXMsIDQpO1xuICogLy8gICAgXiBbMHgwMSwgMHgwMiwgMHgwMCwgMHgwMF1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBieXRlIGFycmF5IGlmIGl0IGlzIGFscmVhZHkgYXQgdGhlIGRlc2lyZWQgbGVuZ3RoLlxuICogYGBgdHNcbiAqIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDEsIDB4MDJdKTtcbiAqIGNvbnN0IHBhZGRlZEJ5dGVzID0gcGFkQnl0ZXMoYnl0ZXMsIDIpO1xuICogLy8gYnl0ZXMgPT09IHBhZGRlZEJ5dGVzXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IHBhZEJ5dGVzID0gKGJ5dGVzOiBSZWFkb25seVVpbnQ4QXJyYXkgfCBVaW50OEFycmF5LCBsZW5ndGg6IG51bWJlcik6IFJlYWRvbmx5VWludDhBcnJheSB8IFVpbnQ4QXJyYXkgPT4ge1xuICAgIGlmIChieXRlcy5sZW5ndGggPj0gbGVuZ3RoKSByZXR1cm4gYnl0ZXM7XG4gICAgY29uc3QgcGFkZGVkQnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpLmZpbGwoMCk7XG4gICAgcGFkZGVkQnl0ZXMuc2V0KGJ5dGVzKTtcbiAgICByZXR1cm4gcGFkZGVkQnl0ZXM7XG59O1xuXG4vKipcbiAqIEZpeGVzIGEgYFVpbnQ4QXJyYXlgIHRvIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICogSWYgdGhlIGFycmF5IGlzIGxvbmdlciB0aGFuIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLCBpdCBpcyB0cnVuY2F0ZWQuXG4gKiBJZiB0aGUgYXJyYXkgaXMgc2hvcnRlciB0aGFuIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLCBpdCBpcyBwYWRkZWQgd2l0aCB6ZXJvZXMuXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGUgYXJyYXkgdG8gdHJ1bmNhdGUgb3IgcGFkLlxuICogQHBhcmFtIGxlbmd0aCAtIFRoZSBkZXNpcmVkIGxlbmd0aCBvZiB0aGUgYnl0ZSBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogVHJ1bmNhdGVzIHRoZSBieXRlIGFycmF5IHRvIHRoZSBkZXNpcmVkIGxlbmd0aC5cbiAqIGBgYHRzXG4gKiBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KFsweDAxLCAweDAyLCAweDAzLCAweDA0XSk7XG4gKiBjb25zdCBmaXhlZEJ5dGVzID0gZml4Qnl0ZXMoYnl0ZXMsIDIpO1xuICogLy8gICAgXiBbMHgwMSwgMHgwMl1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBBZGRzIHplcm9lcyB0byB0aGUgZW5kIG9mIHRoZSBieXRlIGFycmF5IHRvIHJlYWNoIHRoZSBkZXNpcmVkIGxlbmd0aC5cbiAqIGBgYHRzXG4gKiBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KFsweDAxLCAweDAyXSk7XG4gKiBjb25zdCBmaXhlZEJ5dGVzID0gZml4Qnl0ZXMoYnl0ZXMsIDQpO1xuICogLy8gICAgXiBbMHgwMSwgMHgwMiwgMHgwMCwgMHgwMF1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBieXRlIGFycmF5IGlmIGl0IGlzIGFscmVhZHkgYXQgdGhlIGRlc2lyZWQgbGVuZ3RoLlxuICogYGBgdHNcbiAqIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDEsIDB4MDJdKTtcbiAqIGNvbnN0IGZpeGVkQnl0ZXMgPSBmaXhCeXRlcyhieXRlcywgMik7XG4gKiAvLyBieXRlcyA9PT0gZml4ZWRCeXRlc1xuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBmaXhCeXRlcyA9IChieXRlczogUmVhZG9ubHlVaW50OEFycmF5IHwgVWludDhBcnJheSwgbGVuZ3RoOiBudW1iZXIpOiBSZWFkb25seVVpbnQ4QXJyYXkgfCBVaW50OEFycmF5ID0+XG4gICAgcGFkQnl0ZXMoYnl0ZXMubGVuZ3RoIDw9IGxlbmd0aCA/IGJ5dGVzIDogYnl0ZXMuc2xpY2UoMCwgbGVuZ3RoKSwgbGVuZ3RoKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIHByb3ZpZGVkIGBkYXRhYCBieXRlIGFycmF5IGNvbnRhaW5zXG4gKiB0aGUgcHJvdmlkZWQgYGJ5dGVzYCBieXRlIGFycmF5IGF0IHRoZSBzcGVjaWZpZWQgYG9mZnNldGAuXG4gKlxuICogQHBhcmFtIGRhdGEgLSBUaGUgYnl0ZSBzZXF1ZW5jZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGUgYXJyYXkgaW4gd2hpY2ggdG8gc2VhcmNoIGZvciBgZGF0YWAuXG4gKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIHBvc2l0aW9uIGluIGBieXRlc2Agd2hlcmUgdGhlIHNlYXJjaCBiZWdpbnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KFsweDAxLCAweDAyLCAweDAzLCAweDA0XSk7XG4gKiBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDIsIDB4MDNdKTtcbiAqIGNvbnRhaW5zQnl0ZXMoYnl0ZXMsIGRhdGEsIDEpOyAvLyB0cnVlXG4gKiBjb250YWluc0J5dGVzKGJ5dGVzLCBkYXRhLCAyKTsgLy8gZmFsc2VcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNCeXRlcyhcbiAgICBkYXRhOiBSZWFkb25seVVpbnQ4QXJyYXkgfCBVaW50OEFycmF5LFxuICAgIGJ5dGVzOiBSZWFkb25seVVpbnQ4QXJyYXkgfCBVaW50OEFycmF5LFxuICAgIG9mZnNldDogbnVtYmVyLFxuKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgc2xpY2UgPSBvZmZzZXQgPT09IDAgJiYgZGF0YS5sZW5ndGggPT09IGJ5dGVzLmxlbmd0aCA/IGRhdGEgOiBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYnl0ZXMubGVuZ3RoKTtcbiAgICBpZiAoc2xpY2UubGVuZ3RoICE9PSBieXRlcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gYnl0ZXMuZXZlcnkoKGIsIGkpID0+IGIgPT09IHNsaWNlW2ldKTtcbn1cbiIsICJpbXBvcnQge1xuICAgIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9GSVhFRF9MRU5HVEgsXG4gICAgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCxcbiAgICBTb2xhbmFFcnJvcixcbn0gZnJvbSAnQHNvbGFuYS9lcnJvcnMnO1xuXG5pbXBvcnQgeyBSZWFkb25seVVpbnQ4QXJyYXkgfSBmcm9tICcuL3JlYWRvbmx5LXVpbnQ4YXJyYXknO1xuXG4vKipcbiAqIERlZmluZXMgYW4gb2Zmc2V0IGluIGJ5dGVzLlxuICovXG5leHBvcnQgdHlwZSBPZmZzZXQgPSBudW1iZXI7XG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgY2FuIGVuY29kZSBhIHZhbHVlIG9mIHR5cGUge0BsaW5rIFRGcm9tfSBpbnRvIGEge0BsaW5rIFJlYWRvbmx5VWludDhBcnJheX0uXG4gKlxuICogVGhpcyBpcyBhIGNvbW1vbiBpbnRlcmZhY2UgZm9yIHtAbGluayBGaXhlZFNpemVFbmNvZGVyfSBhbmQge0BsaW5rIFZhcmlhYmxlU2l6ZUVuY29kZXJ9LlxuICpcbiAqIEBpbnRlcmZhY2VcbiAqIEB0eXBlUGFyYW0gVEZyb20gLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gZW5jb2RlLlxuICpcbiAqIEBzZWUge0BsaW5rIEZpeGVkU2l6ZUVuY29kZXJ9XG4gKiBAc2VlIHtAbGluayBWYXJpYWJsZVNpemVFbmNvZGVyfVxuICovXG50eXBlIEJhc2VFbmNvZGVyPFRGcm9tPiA9IHtcbiAgICAvKiogRW5jb2RlIHRoZSBwcm92aWRlZCB2YWx1ZSBhbmQgcmV0dXJuIHRoZSBlbmNvZGVkIGJ5dGVzIGRpcmVjdGx5LiAqL1xuICAgIHJlYWRvbmx5IGVuY29kZTogKHZhbHVlOiBURnJvbSkgPT4gUmVhZG9ubHlVaW50OEFycmF5O1xuICAgIC8qKlxuICAgICAqIFdyaXRlcyB0aGUgZW5jb2RlZCB2YWx1ZSBpbnRvIHRoZSBwcm92aWRlZCBieXRlIGFycmF5IGF0IHRoZSBnaXZlbiBvZmZzZXQuXG4gICAgICogUmV0dXJucyB0aGUgb2Zmc2V0IG9mIHRoZSBuZXh0IGJ5dGUgYWZ0ZXIgdGhlIGVuY29kZWQgdmFsdWUuXG4gICAgICovXG4gICAgcmVhZG9ubHkgd3JpdGU6ICh2YWx1ZTogVEZyb20sIGJ5dGVzOiBVaW50OEFycmF5LCBvZmZzZXQ6IE9mZnNldCkgPT4gT2Zmc2V0O1xufTtcblxuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBjYW4gZW5jb2RlIGEgdmFsdWUgb2YgdHlwZSB7QGxpbmsgVEZyb219IGludG8gYSBmaXhlZC1zaXplIHtAbGluayBSZWFkb25seVVpbnQ4QXJyYXl9LlxuICpcbiAqIFNlZSB7QGxpbmsgRW5jb2Rlcn0gdG8gbGVhcm4gbW9yZSBhYm91dCBjcmVhdGluZyBhbmQgY29tcG9zaW5nIGVuY29kZXJzLlxuICpcbiAqIEBpbnRlcmZhY2VcbiAqIEB0eXBlUGFyYW0gVEZyb20gLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gZW5jb2RlLlxuICogQHR5cGVQYXJhbSBUU2l6ZSAtIFRoZSBmaXhlZCBzaXplIG9mIHRoZSBlbmNvZGVkIHZhbHVlIGluIGJ5dGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlcjogRml4ZWRTaXplRW5jb2RlcjxudW1iZXIsIDQ+O1xuICogY29uc3QgYnl0ZXMgPSBlbmNvZGVyLmVuY29kZSg0Mik7XG4gKiBjb25zdCBzaXplID0gZW5jb2Rlci5maXhlZFNpemU7IC8vIDRcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIEVuY29kZXJ9XG4gKiBAc2VlIHtAbGluayBWYXJpYWJsZVNpemVFbmNvZGVyfVxuICovXG5leHBvcnQgdHlwZSBGaXhlZFNpemVFbmNvZGVyPFRGcm9tLCBUU2l6ZSBleHRlbmRzIG51bWJlciA9IG51bWJlcj4gPSBCYXNlRW5jb2RlcjxURnJvbT4gJiB7XG4gICAgLyoqIFRoZSBmaXhlZCBzaXplIG9mIHRoZSBlbmNvZGVkIHZhbHVlIGluIGJ5dGVzLiAqL1xuICAgIHJlYWRvbmx5IGZpeGVkU2l6ZTogVFNpemU7XG59O1xuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNhbiBlbmNvZGUgYSB2YWx1ZSBvZiB0eXBlIHtAbGluayBURnJvbX0gaW50byBhIHZhcmlhYmxlLXNpemUge0BsaW5rIFJlYWRvbmx5VWludDhBcnJheX0uXG4gKlxuICogU2VlIHtAbGluayBFbmNvZGVyfSB0byBsZWFybiBtb3JlIGFib3V0IGNyZWF0aW5nIGFuZCBjb21wb3NpbmcgZW5jb2RlcnMuXG4gKlxuICogQGludGVyZmFjZVxuICogQHR5cGVQYXJhbSBURnJvbSAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBlbmNvZGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBlbmNvZGVyOiBWYXJpYWJsZVNpemVFbmNvZGVyPHN0cmluZz47XG4gKiBjb25zdCBieXRlcyA9IGVuY29kZXIuZW5jb2RlKCdoZWxsbycpO1xuICogY29uc3Qgc2l6ZSA9IGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSgnaGVsbG8nKTtcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIEVuY29kZXJ9XG4gKiBAc2VlIHtAbGluayBGaXhlZFNpemVFbmNvZGVyfVxuICovXG5leHBvcnQgdHlwZSBWYXJpYWJsZVNpemVFbmNvZGVyPFRGcm9tPiA9IEJhc2VFbmNvZGVyPFRGcm9tPiAmIHtcbiAgICAvKiogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgZW5jb2RlZCB2YWx1ZSBpbiBieXRlcyBmb3IgYSBnaXZlbiBpbnB1dC4gKi9cbiAgICByZWFkb25seSBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWU6IFRGcm9tKSA9PiBudW1iZXI7XG4gICAgLyoqIFRoZSBtYXhpbXVtIHBvc3NpYmxlIHNpemUgb2YgYW4gZW5jb2RlZCB2YWx1ZSBpbiBieXRlcywgaWYgYXBwbGljYWJsZS4gKi9cbiAgICByZWFkb25seSBtYXhTaXplPzogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBjYW4gZW5jb2RlIGEgdmFsdWUgb2YgdHlwZSB7QGxpbmsgVEZyb219IGludG8gYSB7QGxpbmsgUmVhZG9ubHlVaW50OEFycmF5fS5cbiAqXG4gKiBBbiBgRW5jb2RlcmAgY2FuIGJlIGVpdGhlcjpcbiAqIC0gQSB7QGxpbmsgRml4ZWRTaXplRW5jb2Rlcn0sIHdoZXJlIGFsbCBlbmNvZGVkIHZhbHVlcyBoYXZlIHRoZSBzYW1lIGZpeGVkIHNpemUuXG4gKiAtIEEge0BsaW5rIFZhcmlhYmxlU2l6ZUVuY29kZXJ9LCB3aGVyZSBlbmNvZGVkIHZhbHVlcyBjYW4gdmFyeSBpbiBzaXplLlxuICpcbiAqIEB0eXBlUGFyYW0gVEZyb20gLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gZW5jb2RlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBFbmNvZGluZyBhIHZhbHVlIGludG8gYSBuZXcgYnl0ZSBhcnJheS5cbiAqIGBgYHRzXG4gKiBjb25zdCBlbmNvZGVyOiBFbmNvZGVyPHN0cmluZz47XG4gKiBjb25zdCBieXRlcyA9IGVuY29kZXIuZW5jb2RlKCdoZWxsbycpO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIFdyaXRpbmcgdGhlIGVuY29kZWQgdmFsdWUgaW50byBhbiBleGlzdGluZyBieXRlIGFycmF5LlxuICogYGBgdHNcbiAqIGNvbnN0IGVuY29kZXI6IEVuY29kZXI8c3RyaW5nPjtcbiAqIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTAwKTtcbiAqIGNvbnN0IG5leHRPZmZzZXQgPSBlbmNvZGVyLndyaXRlKCdoZWxsbycsIGJ5dGVzLCAyMCk7XG4gKiBgYGBcbiAqXG4gKiBAcmVtYXJrc1xuICogWW91IG1heSBjcmVhdGUgYEVuY29kZXJzYCBtYW51YWxseSB1c2luZyB0aGUge0BsaW5rIGNyZWF0ZUVuY29kZXJ9IGZ1bmN0aW9uIGJ1dCBpdCBpcyBtb3JlIGNvbW1vblxuICogdG8gY29tcG9zZSBtdWx0aXBsZSBgRW5jb2RlcnNgIHRvZ2V0aGVyIHVzaW5nIHRoZSB2YXJpb3VzIGhlbHBlcnMgb2YgdGhlIGBAc29sYW5hL2NvZGVjc2AgcGFja2FnZS5cbiAqXG4gKiBGb3IgaW5zdGFuY2UsIGhlcmUncyBob3cgeW91IG1pZ2h0IGNyZWF0ZSBhbiBgRW5jb2RlcmAgZm9yIGEgYFBlcnNvbmAgb2JqZWN0IHR5cGUgdGhhdCBjb250YWluc1xuICogYSBgbmFtZWAgc3RyaW5nIGFuZCBhbiBgYWdlYCBudW1iZXI6XG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGdldFN0cnVjdEVuY29kZXIsIGFkZEVuY29kZXJTaXplUHJlZml4LCBnZXRVdGY4RW5jb2RlciwgZ2V0VTMyRW5jb2RlciB9IGZyb20gJ0Bzb2xhbmEvY29kZWNzJztcbiAqXG4gKiB0eXBlIFBlcnNvbiA9IHsgbmFtZTogc3RyaW5nOyBhZ2U6IG51bWJlciB9O1xuICogY29uc3QgZ2V0UGVyc29uRW5jb2RlciA9ICgpOiBFbmNvZGVyPFBlcnNvbj4gPT5cbiAqICAgICBnZXRTdHJ1Y3RFbmNvZGVyKFtcbiAqICAgICAgICAgWyduYW1lJywgYWRkRW5jb2RlclNpemVQcmVmaXgoZ2V0VXRmOEVuY29kZXIoKSwgZ2V0VTMyRW5jb2RlcigpKV0sXG4gKiAgICAgICAgIFsnYWdlJywgZ2V0VTMyRW5jb2RlcigpXSxcbiAqICAgICBdKTtcbiAqIGBgYFxuICpcbiAqIE5vdGUgdGhhdCBjb21wb3NlZCBgRW5jb2RlcmAgdHlwZXMgYXJlIGNsZXZlciBlbm91Z2ggdG8gdW5kZXJzdGFuZCB3aGV0aGVyXG4gKiB0aGV5IGFyZSBmaXhlZC1zaXplIG9yIHZhcmlhYmxlLXNpemUuIEluIHRoZSBleGFtcGxlIGFib3ZlLCBgZ2V0VTMyRW5jb2RlcigpYCBpc1xuICogYSBmaXhlZC1zaXplIGVuY29kZXIsIHdoaWxlIGBhZGRFbmNvZGVyU2l6ZVByZWZpeChnZXRVdGY4RW5jb2RlcigpLCBnZXRVMzJFbmNvZGVyKCkpYFxuICogaXMgYSB2YXJpYWJsZS1zaXplIGVuY29kZXIuIFRoaXMgbWFrZXMgdGhlIGZpbmFsIGBQZXJzb25gIGVuY29kZXIgYSB2YXJpYWJsZS1zaXplIGVuY29kZXIuXG4gKlxuICogQHNlZSB7QGxpbmsgRml4ZWRTaXplRW5jb2Rlcn1cbiAqIEBzZWUge0BsaW5rIFZhcmlhYmxlU2l6ZUVuY29kZXJ9XG4gKiBAc2VlIHtAbGluayBjcmVhdGVFbmNvZGVyfVxuICovXG5leHBvcnQgdHlwZSBFbmNvZGVyPFRGcm9tPiA9IEZpeGVkU2l6ZUVuY29kZXI8VEZyb20+IHwgVmFyaWFibGVTaXplRW5jb2RlcjxURnJvbT47XG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgY2FuIGRlY29kZSBhIGJ5dGUgYXJyYXkgaW50byBhIHZhbHVlIG9mIHR5cGUge0BsaW5rIFRUb30uXG4gKlxuICogVGhpcyBpcyBhIGNvbW1vbiBpbnRlcmZhY2UgZm9yIHtAbGluayBGaXhlZFNpemVEZWNvZGVyfSBhbmQge0BsaW5rIFZhcmlhYmxlU2l6ZURlY29kZXJ9LlxuICpcbiAqIEBpbnRlcmZhY2VcbiAqIEB0eXBlUGFyYW0gVFRvIC0gVGhlIHR5cGUgb2YgdGhlIGRlY29kZWQgdmFsdWUuXG4gKlxuICogQHNlZSB7QGxpbmsgRml4ZWRTaXplRGVjb2Rlcn1cbiAqIEBzZWUge0BsaW5rIFZhcmlhYmxlU2l6ZURlY29kZXJ9XG4gKi9cbnR5cGUgQmFzZURlY29kZXI8VFRvPiA9IHtcbiAgICAvKiogRGVjb2RlcyB0aGUgcHJvdmlkZWQgYnl0ZSBhcnJheSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IChvciB6ZXJvKSBhbmQgcmV0dXJucyB0aGUgdmFsdWUgZGlyZWN0bHkuICovXG4gICAgcmVhZG9ubHkgZGVjb2RlOiAoYnl0ZXM6IFJlYWRvbmx5VWludDhBcnJheSB8IFVpbnQ4QXJyYXksIG9mZnNldD86IE9mZnNldCkgPT4gVFRvO1xuICAgIC8qKlxuICAgICAqIFJlYWRzIHRoZSBlbmNvZGVkIHZhbHVlIGZyb20gdGhlIHByb3ZpZGVkIGJ5dGUgYXJyYXkgYXQgdGhlIGdpdmVuIG9mZnNldC5cbiAgICAgKiBSZXR1cm5zIHRoZSBkZWNvZGVkIHZhbHVlIGFuZCB0aGUgb2Zmc2V0IG9mIHRoZSBuZXh0IGJ5dGUgYWZ0ZXIgdGhlIGVuY29kZWQgdmFsdWUuXG4gICAgICovXG4gICAgcmVhZG9ubHkgcmVhZDogKGJ5dGVzOiBSZWFkb25seVVpbnQ4QXJyYXkgfCBVaW50OEFycmF5LCBvZmZzZXQ6IE9mZnNldCkgPT4gW1RUbywgT2Zmc2V0XTtcbn07XG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgY2FuIGRlY29kZSBhIGZpeGVkLXNpemUgYnl0ZSBhcnJheSBpbnRvIGEgdmFsdWUgb2YgdHlwZSB7QGxpbmsgVFRvfS5cbiAqXG4gKiBTZWUge0BsaW5rIERlY29kZXJ9IHRvIGxlYXJuIG1vcmUgYWJvdXQgY3JlYXRpbmcgYW5kIGNvbXBvc2luZyBkZWNvZGVycy5cbiAqXG4gKiBAaW50ZXJmYWNlXG4gKiBAdHlwZVBhcmFtIFRUbyAtIFRoZSB0eXBlIG9mIHRoZSBkZWNvZGVkIHZhbHVlLlxuICogQHR5cGVQYXJhbSBUU2l6ZSAtIFRoZSBmaXhlZCBzaXplIG9mIHRoZSBlbmNvZGVkIHZhbHVlIGluIGJ5dGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3QgZGVjb2RlcjogRml4ZWRTaXplRGVjb2RlcjxudW1iZXIsIDQ+O1xuICogY29uc3QgdmFsdWUgPSBkZWNvZGVyLmRlY29kZShieXRlcyk7XG4gKiBjb25zdCBzaXplID0gZGVjb2Rlci5maXhlZFNpemU7IC8vIDRcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIERlY29kZXJ9XG4gKiBAc2VlIHtAbGluayBWYXJpYWJsZVNpemVEZWNvZGVyfVxuICovXG5leHBvcnQgdHlwZSBGaXhlZFNpemVEZWNvZGVyPFRUbywgVFNpemUgZXh0ZW5kcyBudW1iZXIgPSBudW1iZXI+ID0gQmFzZURlY29kZXI8VFRvPiAmIHtcbiAgICAvKiogVGhlIGZpeGVkIHNpemUgb2YgdGhlIGVuY29kZWQgdmFsdWUgaW4gYnl0ZXMuICovXG4gICAgcmVhZG9ubHkgZml4ZWRTaXplOiBUU2l6ZTtcbn07XG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgY2FuIGRlY29kZSBhIHZhcmlhYmxlLXNpemUgYnl0ZSBhcnJheSBpbnRvIGEgdmFsdWUgb2YgdHlwZSB7QGxpbmsgVFRvfS5cbiAqXG4gKiBTZWUge0BsaW5rIERlY29kZXJ9IHRvIGxlYXJuIG1vcmUgYWJvdXQgY3JlYXRpbmcgYW5kIGNvbXBvc2luZyBkZWNvZGVycy5cbiAqXG4gKiBAaW50ZXJmYWNlXG4gKiBAdHlwZVBhcmFtIFRUbyAtIFRoZSB0eXBlIG9mIHRoZSBkZWNvZGVkIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3QgZGVjb2RlcjogVmFyaWFibGVTaXplRGVjb2RlcjxudW1iZXI+O1xuICogY29uc3QgdmFsdWUgPSBkZWNvZGVyLmRlY29kZShieXRlcyk7XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBEZWNvZGVyfVxuICogQHNlZSB7QGxpbmsgVmFyaWFibGVTaXplRGVjb2Rlcn1cbiAqL1xuZXhwb3J0IHR5cGUgVmFyaWFibGVTaXplRGVjb2RlcjxUVG8+ID0gQmFzZURlY29kZXI8VFRvPiAmIHtcbiAgICAvKiogVGhlIG1heGltdW0gcG9zc2libGUgc2l6ZSBvZiBhbiBlbmNvZGVkIHZhbHVlIGluIGJ5dGVzLCBpZiBhcHBsaWNhYmxlLiAqL1xuICAgIHJlYWRvbmx5IG1heFNpemU/OiBudW1iZXI7XG59O1xuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNhbiBkZWNvZGUgYSBieXRlIGFycmF5IGludG8gYSB2YWx1ZSBvZiB0eXBlIHtAbGluayBUVG99LlxuICpcbiAqIEFuIGBEZWNvZGVyYCBjYW4gYmUgZWl0aGVyOlxuICogLSBBIHtAbGluayBGaXhlZFNpemVEZWNvZGVyfSwgd2hlcmUgYWxsIGJ5dGUgYXJyYXlzIGhhdmUgdGhlIHNhbWUgZml4ZWQgc2l6ZS5cbiAqIC0gQSB7QGxpbmsgVmFyaWFibGVTaXplRGVjb2Rlcn0sIHdoZXJlIGJ5dGUgYXJyYXlzIGNhbiB2YXJ5IGluIHNpemUuXG4gKlxuICogQHR5cGVQYXJhbSBUVG8gLSBUaGUgdHlwZSBvZiB0aGUgZGVjb2RlZCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogR2V0dGluZyB0aGUgZGVjb2RlZCB2YWx1ZSBmcm9tIGEgYnl0ZSBhcnJheS5cbiAqIGBgYHRzXG4gKiBjb25zdCBkZWNvZGVyOiBEZWNvZGVyPHN0cmluZz47XG4gKiBjb25zdCB2YWx1ZSA9IGRlY29kZXIuZGVjb2RlKGJ5dGVzKTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBSZWFkaW5nIHRoZSBkZWNvZGVkIHZhbHVlIGZyb20gYSBieXRlIGFycmF5IGF0IGEgc3BlY2lmaWMgb2Zmc2V0XG4gKiBhbmQgZ2V0dGluZyB0aGUgb2Zmc2V0IG9mIHRoZSBuZXh0IGJ5dGUgdG8gcmVhZC5cbiAqIGBgYHRzXG4gKiBjb25zdCBkZWNvZGVyOiBEZWNvZGVyPHN0cmluZz47XG4gKiBjb25zdCBbdmFsdWUsIG5leHRPZmZzZXRdID0gZGVjb2Rlci5yZWFkKCdoZWxsbycsIGJ5dGVzLCAyMCk7XG4gKiBgYGBcbiAqXG4gKiBAcmVtYXJrc1xuICogWW91IG1heSBjcmVhdGUgYERlY29kZXJzYCBtYW51YWxseSB1c2luZyB0aGUge0BsaW5rIGNyZWF0ZURlY29kZXJ9IGZ1bmN0aW9uIGJ1dCBpdCBpcyBtb3JlIGNvbW1vblxuICogdG8gY29tcG9zZSBtdWx0aXBsZSBgRGVjb2RlcnNgIHRvZ2V0aGVyIHVzaW5nIHRoZSB2YXJpb3VzIGhlbHBlcnMgb2YgdGhlIGBAc29sYW5hL2NvZGVjc2AgcGFja2FnZS5cbiAqXG4gKiBGb3IgaW5zdGFuY2UsIGhlcmUncyBob3cgeW91IG1pZ2h0IGNyZWF0ZSBhbiBgRGVjb2RlcmAgZm9yIGEgYFBlcnNvbmAgb2JqZWN0IHR5cGUgdGhhdCBjb250YWluc1xuICogYSBgbmFtZWAgc3RyaW5nIGFuZCBhbiBgYWdlYCBudW1iZXI6XG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGdldFN0cnVjdERlY29kZXIsIGFkZERlY29kZXJTaXplUHJlZml4LCBnZXRVdGY4RGVjb2RlciwgZ2V0VTMyRGVjb2RlciB9IGZyb20gJ0Bzb2xhbmEvY29kZWNzJztcbiAqXG4gKiB0eXBlIFBlcnNvbiA9IHsgbmFtZTogc3RyaW5nOyBhZ2U6IG51bWJlciB9O1xuICogY29uc3QgZ2V0UGVyc29uRGVjb2RlciA9ICgpOiBEZWNvZGVyPFBlcnNvbj4gPT5cbiAqICAgICBnZXRTdHJ1Y3REZWNvZGVyKFtcbiAqICAgICAgICAgWyduYW1lJywgYWRkRGVjb2RlclNpemVQcmVmaXgoZ2V0VXRmOERlY29kZXIoKSwgZ2V0VTMyRGVjb2RlcigpKV0sXG4gKiAgICAgICAgIFsnYWdlJywgZ2V0VTMyRGVjb2RlcigpXSxcbiAqICAgICBdKTtcbiAqIGBgYFxuICpcbiAqIE5vdGUgdGhhdCBjb21wb3NlZCBgRGVjb2RlcmAgdHlwZXMgYXJlIGNsZXZlciBlbm91Z2ggdG8gdW5kZXJzdGFuZCB3aGV0aGVyXG4gKiB0aGV5IGFyZSBmaXhlZC1zaXplIG9yIHZhcmlhYmxlLXNpemUuIEluIHRoZSBleGFtcGxlIGFib3ZlLCBgZ2V0VTMyRGVjb2RlcigpYCBpc1xuICogYSBmaXhlZC1zaXplIGRlY29kZXIsIHdoaWxlIGBhZGREZWNvZGVyU2l6ZVByZWZpeChnZXRVdGY4RGVjb2RlcigpLCBnZXRVMzJEZWNvZGVyKCkpYFxuICogaXMgYSB2YXJpYWJsZS1zaXplIGRlY29kZXIuIFRoaXMgbWFrZXMgdGhlIGZpbmFsIGBQZXJzb25gIGRlY29kZXIgYSB2YXJpYWJsZS1zaXplIGRlY29kZXIuXG4gKlxuICogQHNlZSB7QGxpbmsgRml4ZWRTaXplRGVjb2Rlcn1cbiAqIEBzZWUge0BsaW5rIFZhcmlhYmxlU2l6ZURlY29kZXJ9XG4gKiBAc2VlIHtAbGluayBjcmVhdGVEZWNvZGVyfVxuICovXG5leHBvcnQgdHlwZSBEZWNvZGVyPFRUbz4gPSBGaXhlZFNpemVEZWNvZGVyPFRUbz4gfCBWYXJpYWJsZVNpemVEZWNvZGVyPFRUbz47XG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgY2FuIGVuY29kZSBhbmQgZGVjb2RlIGEgdmFsdWUgdG8gYW5kIGZyb20gYSBmaXhlZC1zaXplIGJ5dGUgYXJyYXkuXG4gKlxuICogU2VlIHtAbGluayBDb2RlY30gdG8gbGVhcm4gbW9yZSBhYm91dCBjcmVhdGluZyBhbmQgY29tcG9zaW5nIGNvZGVjcy5cbiAqXG4gKiBAaW50ZXJmYWNlXG4gKiBAdHlwZVBhcmFtIFRGcm9tIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIGVuY29kZS5cbiAqIEB0eXBlUGFyYW0gVFRvIC0gVGhlIHR5cGUgb2YgdGhlIGRlY29kZWQgdmFsdWUuXG4gKiBAdHlwZVBhcmFtIFRTaXplIC0gVGhlIGZpeGVkIHNpemUgb2YgdGhlIGVuY29kZWQgdmFsdWUgaW4gYnl0ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBjb2RlYzogRml4ZWRTaXplQ29kZWM8bnVtYmVyIHwgYmlnaW50LCBiaWdpbnQsIDg+O1xuICogY29uc3QgYnl0ZXMgPSBjb2RlYy5lbmNvZGUoNDIpO1xuICogY29uc3QgdmFsdWUgPSBjb2RlYy5kZWNvZGUoYnl0ZXMpOyAvLyA0Mm5cbiAqIGNvbnN0IHNpemUgPSBjb2RlYy5maXhlZFNpemU7IC8vIDhcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIENvZGVjfVxuICogQHNlZSB7QGxpbmsgVmFyaWFibGVTaXplQ29kZWN9XG4gKi9cbmV4cG9ydCB0eXBlIEZpeGVkU2l6ZUNvZGVjPFRGcm9tLCBUVG8gZXh0ZW5kcyBURnJvbSA9IFRGcm9tLCBUU2l6ZSBleHRlbmRzIG51bWJlciA9IG51bWJlcj4gPSBGaXhlZFNpemVEZWNvZGVyPFxuICAgIFRUbyxcbiAgICBUU2l6ZVxuPiAmXG4gICAgRml4ZWRTaXplRW5jb2RlcjxURnJvbSwgVFNpemU+O1xuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNhbiBlbmNvZGUgYW5kIGRlY29kZSBhIHZhbHVlIHRvIGFuZCBmcm9tIGEgdmFyaWFibGUtc2l6ZSBieXRlIGFycmF5LlxuICpcbiAqIFNlZSB7QGxpbmsgQ29kZWN9IHRvIGxlYXJuIG1vcmUgYWJvdXQgY3JlYXRpbmcgYW5kIGNvbXBvc2luZyBjb2RlY3MuXG4gKlxuICogQGludGVyZmFjZVxuICogQHR5cGVQYXJhbSBURnJvbSAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAdHlwZVBhcmFtIFRUbyAtIFRoZSB0eXBlIG9mIHRoZSBkZWNvZGVkIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3QgY29kZWM6IFZhcmlhYmxlU2l6ZUNvZGVjPG51bWJlciB8IGJpZ2ludCwgYmlnaW50PjtcbiAqIGNvbnN0IGJ5dGVzID0gY29kZWMuZW5jb2RlKDQyKTtcbiAqIGNvbnN0IHZhbHVlID0gY29kZWMuZGVjb2RlKGJ5dGVzKTsgLy8gNDJuXG4gKiBjb25zdCBzaXplID0gY29kZWMuZ2V0U2l6ZUZyb21WYWx1ZSg0Mik7XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBDb2RlY31cbiAqIEBzZWUge0BsaW5rIEZpeGVkU2l6ZUNvZGVjfVxuICovXG5leHBvcnQgdHlwZSBWYXJpYWJsZVNpemVDb2RlYzxURnJvbSwgVFRvIGV4dGVuZHMgVEZyb20gPSBURnJvbT4gPSBWYXJpYWJsZVNpemVEZWNvZGVyPFRUbz4gJiBWYXJpYWJsZVNpemVFbmNvZGVyPFRGcm9tPjtcblxuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBjYW4gZW5jb2RlIGFuZCBkZWNvZGUgYSB2YWx1ZSB0byBhbmQgZnJvbSBhIGJ5dGUgYXJyYXkuXG4gKlxuICogQSBgQ29kZWNgIGNhbiBiZSBlaXRoZXI6XG4gKiAtIEEge0BsaW5rIEZpeGVkU2l6ZUNvZGVjfSwgd2hlcmUgYWxsIGVuY29kZWQgdmFsdWVzIGhhdmUgdGhlIHNhbWUgZml4ZWQgc2l6ZS5cbiAqIC0gQSB7QGxpbmsgVmFyaWFibGVTaXplQ29kZWN9LCB3aGVyZSBlbmNvZGVkIHZhbHVlcyBjYW4gdmFyeSBpbiBzaXplLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3QgY29kZWM6IENvZGVjPHN0cmluZz47XG4gKiBjb25zdCBieXRlcyA9IGNvZGVjLmVuY29kZSgnaGVsbG8nKTtcbiAqIGNvbnN0IHZhbHVlID0gY29kZWMuZGVjb2RlKGJ5dGVzKTsgLy8gJ2hlbGxvJ1xuICogYGBgXG4gKlxuICogQHJlbWFya3NcbiAqIEZvciBjb252ZW5pZW5jZSwgY29kZWNzIGNhbiBlbmNvZGUgbG9vc2VyIHR5cGVzIHRoYW4gdGhleSBkZWNvZGUuXG4gKiBUaGF0IGlzLCB0eXBlIHtAbGluayBURnJvbX0gY2FuIGJlIGEgc3VwZXJzZXQgb2YgdHlwZSB7QGxpbmsgVFRvfS5cbiAqIEZvciBpbnN0YW5jZSwgYSBgQ29kZWM8YmlnaW50IHwgbnVtYmVyLCBiaWdpbnQ+YCBjYW4gZW5jb2RlIGJvdGhcbiAqIGBiaWdpbnRgIGFuZCBgbnVtYmVyYCB2YWx1ZXMsIGJ1dCB3aWxsIGFsd2F5cyBkZWNvZGUgdG8gYSBgYmlnaW50YC5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgY29kZWM6IENvZGVjPGJpZ2ludCB8IG51bWJlciwgYmlnaW50PjtcbiAqIGNvbnN0IGJ5dGVzID0gY29kZWMuZW5jb2RlKDQyKTtcbiAqIGNvbnN0IHZhbHVlID0gY29kZWMuZGVjb2RlKGJ5dGVzKTsgLy8gNDJuXG4gKiBgYGBcbiAqXG4gKiBJdCBpcyB3b3J0aCBub3RpbmcgdGhhdCBjb2RlY3MgYXJlIHRoZSB1bmlvbiBvZiBlbmNvZGVycyBhbmQgZGVjb2RlcnMuXG4gKiBUaGlzIG1lYW5zIHRoYXQgYSBgQ29kZWM8VEZyb20sIFRUbz5gIGNhbiBiZSBjb21iaW5lZCBmcm9tIGFuIGBFbmNvZGVyPFRGcm9tPmBcbiAqIGFuZCBhIGBEZWNvZGVyPFRUbz5gIHVzaW5nIHRoZSB7QGxpbmsgY29tYmluZUNvZGVjfSBmdW5jdGlvbi4gVGhpcyBpcyBwYXJ0aWN1bGFybHlcbiAqIHVzZWZ1bCBmb3IgbGlicmFyeSBhdXRob3JzIHdobyB3YW50IHRvIGV4cG9zZSBhbGwgdGhyZWUgdHlwZXMgb2Ygb2JqZWN0cyB0byB0aGVpciB1c2Vycy5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlcjogRW5jb2RlcjxiaWdpbnQgfCBudW1iZXI+O1xuICogY29uc3QgZGVjb2RlcjogRGVjb2RlcjxiaWdpbnQ+O1xuICogY29uc3QgY29kZWM6IENvZGVjPGJpZ2ludCB8IG51bWJlciwgYmlnaW50PiA9IGNvbWJpbmVDb2RlYyhlbmNvZGVyLCBkZWNvZGVyKTtcbiAqIGBgYFxuICpcbiAqIEFzaWRlIGZyb20gY29tYmluaW5nIGVuY29kZXJzIGFuZCBkZWNvZGVycywgY29kZWNzIGNhbiBhbHNvIGJlIGNyZWF0ZWQgZnJvbSBzY3JhdGNoIHVzaW5nXG4gKiB0aGUge0BsaW5rIGNyZWF0ZUNvZGVjfSBmdW5jdGlvbiBidXQgaXQgaXMgbW9yZSBjb21tb24gdG8gY29tcG9zZSBtdWx0aXBsZSBjb2RlY3MgdG9nZXRoZXJcbiAqIHVzaW5nIHRoZSB2YXJpb3VzIGhlbHBlcnMgb2YgdGhlIGBAc29sYW5hL2NvZGVjc2AgcGFja2FnZS5cbiAqXG4gKiBGb3IgaW5zdGFuY2UsIGhlcmUncyBob3cgeW91IG1pZ2h0IGNyZWF0ZSBhIGBDb2RlY2AgZm9yIGEgYFBlcnNvbmAgb2JqZWN0IHR5cGUgdGhhdCBjb250YWluc1xuICogYSBgbmFtZWAgc3RyaW5nIGFuZCBhbiBgYWdlYCBudW1iZXI6XG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGdldFN0cnVjdENvZGVjLCBhZGRDb2RlY1NpemVQcmVmaXgsIGdldFV0ZjhDb2RlYywgZ2V0VTMyQ29kZWMgfSBmcm9tICdAc29sYW5hL2NvZGVjcyc7XG4gKlxuICogdHlwZSBQZXJzb24gPSB7IG5hbWU6IHN0cmluZzsgYWdlOiBudW1iZXIgfTtcbiAqIGNvbnN0IGdldFBlcnNvbkNvZGVjID0gKCk6IENvZGVjPFBlcnNvbj4gPT5cbiAqICAgICBnZXRTdHJ1Y3RDb2RlYyhbXG4gKiAgICAgICAgIFsnbmFtZScsIGFkZENvZGVjU2l6ZVByZWZpeChnZXRVdGY4Q29kZWMoKSwgZ2V0VTMyQ29kZWMoKSldLFxuICogICAgICAgICBbJ2FnZScsIGdldFUzMkNvZGVjKCldLFxuICogICAgIF0pO1xuICogYGBgXG4gKlxuICogTm90ZSB0aGF0IGNvbXBvc2VkIGBDb2RlY2AgdHlwZXMgYXJlIGNsZXZlciBlbm91Z2ggdG8gdW5kZXJzdGFuZCB3aGV0aGVyXG4gKiB0aGV5IGFyZSBmaXhlZC1zaXplIG9yIHZhcmlhYmxlLXNpemUuIEluIHRoZSBleGFtcGxlIGFib3ZlLCBgZ2V0VTMyQ29kZWMoKWAgaXNcbiAqIGEgZml4ZWQtc2l6ZSBjb2RlYywgd2hpbGUgYGFkZENvZGVjU2l6ZVByZWZpeChnZXRVdGY4Q29kZWMoKSwgZ2V0VTMyQ29kZWMoKSlgXG4gKiBpcyBhIHZhcmlhYmxlLXNpemUgY29kZWMuIFRoaXMgbWFrZXMgdGhlIGZpbmFsIGBQZXJzb25gIGNvZGVjIGEgdmFyaWFibGUtc2l6ZSBjb2RlYy5cbiAqXG4gKiBAc2VlIHtAbGluayBGaXhlZFNpemVDb2RlY31cbiAqIEBzZWUge0BsaW5rIFZhcmlhYmxlU2l6ZUNvZGVjfVxuICogQHNlZSB7QGxpbmsgY29tYmluZUNvZGVjfVxuICogQHNlZSB7QGxpbmsgY3JlYXRlQ29kZWN9XG4gKi9cbmV4cG9ydCB0eXBlIENvZGVjPFRGcm9tLCBUVG8gZXh0ZW5kcyBURnJvbSA9IFRGcm9tPiA9IEZpeGVkU2l6ZUNvZGVjPFRGcm9tLCBUVG8+IHwgVmFyaWFibGVTaXplQ29kZWM8VEZyb20sIFRUbz47XG5cbi8qKlxuICogR2V0cyB0aGUgZW5jb2RlZCBzaXplIG9mIGEgZ2l2ZW4gdmFsdWUgaW4gYnl0ZXMgdXNpbmcgdGhlIHByb3ZpZGVkIGVuY29kZXIuXG4gKlxuICogQHR5cGVQYXJhbSBURnJvbSAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgZW5jb2RlZC5cbiAqIEBwYXJhbSBlbmNvZGVyIC0gVGhlIGVuY29kZXIgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGVuY29kZWQgc2l6ZS5cbiAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSBlbmNvZGVkIHZhbHVlIGluIGJ5dGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3QgZml4ZWRTaXplRW5jb2RlciA9IHsgZml4ZWRTaXplOiA0IH07XG4gKiBnZXRFbmNvZGVkU2l6ZSgxMjMsIGZpeGVkU2l6ZUVuY29kZXIpOyAvLyBSZXR1cm5zIDQuXG4gKlxuICogY29uc3QgdmFyaWFibGVTaXplRW5jb2RlciA9IHsgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlOiBzdHJpbmcpID0+IHZhbHVlLmxlbmd0aCB9O1xuICogZ2V0RW5jb2RlZFNpemUoXCJoZWxsb1wiLCB2YXJpYWJsZVNpemVFbmNvZGVyKTsgLy8gUmV0dXJucyA1LlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgRW5jb2Rlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVuY29kZWRTaXplPFRGcm9tPihcbiAgICB2YWx1ZTogVEZyb20sXG4gICAgZW5jb2RlcjogeyBmaXhlZFNpemU6IG51bWJlciB9IHwgeyBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWU6IFRGcm9tKSA9PiBudW1iZXIgfSxcbik6IG51bWJlciB7XG4gICAgcmV0dXJuICdmaXhlZFNpemUnIGluIGVuY29kZXIgPyBlbmNvZGVyLmZpeGVkU2l6ZSA6IGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBgRW5jb2RlcmAgYnkgZmlsbGluZyBpbiB0aGUgbWlzc2luZyBgZW5jb2RlYCBmdW5jdGlvbiB1c2luZyB0aGUgcHJvdmlkZWQgYHdyaXRlYCBmdW5jdGlvbiBhbmRcbiAqIGVpdGhlciB0aGUgYGZpeGVkU2l6ZWAgcHJvcGVydHkgKGZvciB7QGxpbmsgRml4ZWRTaXplRW5jb2RlciB8IEZpeGVkU2l6ZUVuY29kZXJzfSkgb3JcbiAqIHRoZSBgZ2V0U2l6ZUZyb21WYWx1ZWAgZnVuY3Rpb24gKGZvciB7QGxpbmsgVmFyaWFibGVTaXplRW5jb2RlciB8IFZhcmlhYmxlU2l6ZUVuY29kZXJzfSkuXG4gKlxuICogSW5zdGVhZCBvZiBtYW51YWxseSBpbXBsZW1lbnRpbmcgYGVuY29kZWAsIHRoaXMgdXRpbGl0eSBsZXZlcmFnZXMgdGhlIGV4aXN0aW5nIGB3cml0ZWAgZnVuY3Rpb25cbiAqIGFuZCB0aGUgc2l6ZSBoZWxwZXJzIHRvIGdlbmVyYXRlIGEgY29tcGxldGUgZW5jb2Rlci4gVGhlIHByb3ZpZGVkIGBlbmNvZGVgIG1ldGhvZCB3aWxsIGFsbG9jYXRlXG4gKiBhIG5ldyBgVWludDhBcnJheWAgb2YgdGhlIGNvcnJlY3Qgc2l6ZSBhbmQgdXNlIGB3cml0ZWAgdG8gcG9wdWxhdGUgaXQuXG4gKlxuICogQHR5cGVQYXJhbSBURnJvbSAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAdHlwZVBhcmFtIFRTaXplIC0gVGhlIGZpeGVkIHNpemUgb2YgdGhlIGVuY29kZWQgdmFsdWUgaW4gYnl0ZXMgKGZvciBmaXhlZC1zaXplIGVuY29kZXJzKS5cbiAqXG4gKiBAcGFyYW0gZW5jb2RlciAtIEFuIGVuY29kZXIgb2JqZWN0IHRoYXQgaW1wbGVtZW50cyBgd3JpdGVgLCBidXQgbm90IGBlbmNvZGVgLlxuICogLSBJZiB0aGUgZW5jb2RlciBoYXMgYSBgZml4ZWRTaXplYCBwcm9wZXJ0eSwgaXQgaXMgdHJlYXRlZCBhcyBhIHtAbGluayBGaXhlZFNpemVFbmNvZGVyfS5cbiAqIC0gT3RoZXJ3aXNlLCBpdCBpcyB0cmVhdGVkIGFzIGEge0BsaW5rIFZhcmlhYmxlU2l6ZUVuY29kZXJ9LlxuICpcbiAqIEByZXR1cm5zIEEgZnVsbHkgZnVuY3Rpb25hbCBgRW5jb2RlcmAgd2l0aCBib3RoIGB3cml0ZWAgYW5kIGBlbmNvZGVgIG1ldGhvZHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIENyZWF0aW5nIGEgY3VzdG9tIGZpeGVkLXNpemUgZW5jb2Rlci5cbiAqIGBgYHRzXG4gKiBjb25zdCBlbmNvZGVyID0gY3JlYXRlRW5jb2Rlcih7XG4gKiAgICAgZml4ZWRTaXplOiA0LFxuICogICAgIHdyaXRlOiAodmFsdWU6IG51bWJlciwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICogICAgICAgICBieXRlcy5zZXQobmV3IFVpbnQ4QXJyYXkoW3ZhbHVlXSksIG9mZnNldCk7XG4gKiAgICAgICAgIHJldHVybiBvZmZzZXQgKyA0O1xuICogICAgIH0sXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBieXRlcyA9IGVuY29kZXIuZW5jb2RlKDQyKTtcbiAqIC8vIDB4MmEwMDAwMDBcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBDcmVhdGluZyBhIGN1c3RvbSB2YXJpYWJsZS1zaXplIGVuY29kZXI6XG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlciA9IGNyZWF0ZUVuY29kZXIoe1xuICogICAgIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZTogc3RyaW5nKSA9PiB2YWx1ZS5sZW5ndGgsXG4gKiAgICAgd3JpdGU6ICh2YWx1ZTogc3RyaW5nLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gKiAgICAgICAgIGNvbnN0IGVuY29kZWRWYWx1ZSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG4gKiAgICAgICAgIGJ5dGVzLnNldChlbmNvZGVkVmFsdWUsIG9mZnNldCk7XG4gKiAgICAgICAgIHJldHVybiBvZmZzZXQgKyBlbmNvZGVkVmFsdWUubGVuZ3RoO1xuICogICAgIH0sXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBieXRlcyA9IGVuY29kZXIuZW5jb2RlKFwiaGVsbG9cIik7XG4gKiAvLyAweDY4NjU2YzZjNmZcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKiBOb3RlIHRoYXQsIHdoaWxlIGBjcmVhdGVFbmNvZGVyYCBpcyB1c2VmdWwgZm9yIGRlZmluaW5nIG1vcmUgY29tcGxleCBlbmNvZGVycywgaXQgaXMgbW9yZSBjb21tb24gdG8gY29tcG9zZVxuICogZW5jb2RlcnMgdG9nZXRoZXIgdXNpbmcgdGhlIHZhcmlvdXMgaGVscGVycyBhbmQgcHJpbWl0aXZlcyBvZiB0aGUgYEBzb2xhbmEvY29kZWNzYCBwYWNrYWdlLlxuICpcbiAqIEhlcmUgYXJlIHNvbWUgYWx0ZXJuYXRpdmUgZXhhbXBsZXMgdXNpbmcgY29kZWMgcHJpbWl0aXZlcyBpbnN0ZWFkIG9mIGBjcmVhdGVFbmNvZGVyYC5cbiAqXG4gKiBgYGB0c1xuICogLy8gRml4ZWQtc2l6ZSBlbmNvZGVyIGZvciB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlcnMuXG4gKiBjb25zdCBlbmNvZGVyID0gZ2V0VTMyRW5jb2RlcigpO1xuICogY29uc3QgYnl0ZXMgPSBlbmNvZGVyLmVuY29kZSg0Mik7XG4gKiAvLyAweDJhMDAwMDAwXG4gKlxuICogLy8gVmFyaWFibGUtc2l6ZSBlbmNvZGVyIGZvciAzMi1ieXRlcyBwcmVmaXhlZCBVVEYtOCBzdHJpbmdzLlxuICogY29uc3QgZW5jb2RlciA9IGFkZEVuY29kZXJTaXplUHJlZml4KGdldFV0ZjhFbmNvZGVyKCksIGdldFUzMkVuY29kZXIoKSk7XG4gKiBjb25zdCBieXRlcyA9IGVuY29kZXIuZW5jb2RlKFwiaGVsbG9cIik7XG4gKiAvLyAweDA1MDAwMDAwNjg2NTZjNmM2ZlxuICpcbiAqIC8vIFZhcmlhYmxlLXNpemUgZW5jb2RlciBmb3IgY3VzdG9tIG9iamVjdHMuXG4gKiB0eXBlIFBlcnNvbiA9IHsgbmFtZTogc3RyaW5nOyBhZ2U6IG51bWJlciB9O1xuICogY29uc3QgZW5jb2RlcjogRW5jb2RlcjxQZXJzb24+ID0gZ2V0U3RydWN0RW5jb2RlcihbXG4gKiAgICAgWyduYW1lJywgYWRkRW5jb2RlclNpemVQcmVmaXgoZ2V0VXRmOEVuY29kZXIoKSwgZ2V0VTMyRW5jb2RlcigpKV0sXG4gKiAgICAgWydhZ2UnLCBnZXRVMzJFbmNvZGVyKCldLFxuICogXSk7XG4gKiBjb25zdCBieXRlcyA9IGVuY29kZXIuZW5jb2RlKHsgbmFtZTogXCJCb2JcIiwgYWdlOiA0MiB9KTtcbiAqIC8vIDB4MDMwMDAwMDA0MjZmNjIyYTAwMDAwMFxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgRW5jb2Rlcn1cbiAqIEBzZWUge0BsaW5rIEZpeGVkU2l6ZUVuY29kZXJ9XG4gKiBAc2VlIHtAbGluayBWYXJpYWJsZVNpemVFbmNvZGVyfVxuICogQHNlZSB7QGxpbmsgZ2V0U3RydWN0RW5jb2Rlcn1cbiAqIEBzZWUge0BsaW5rIGdldFUzMkVuY29kZXJ9XG4gKiBAc2VlIHtAbGluayBnZXRVdGY4RW5jb2Rlcn1cbiAqIEBzZWUge0BsaW5rIGFkZEVuY29kZXJTaXplUHJlZml4fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW5jb2RlcjxURnJvbSwgVFNpemUgZXh0ZW5kcyBudW1iZXI+KFxuICAgIGVuY29kZXI6IE9taXQ8Rml4ZWRTaXplRW5jb2RlcjxURnJvbSwgVFNpemU+LCAnZW5jb2RlJz4sXG4pOiBGaXhlZFNpemVFbmNvZGVyPFRGcm9tLCBUU2l6ZT47XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW5jb2RlcjxURnJvbT4oZW5jb2RlcjogT21pdDxWYXJpYWJsZVNpemVFbmNvZGVyPFRGcm9tPiwgJ2VuY29kZSc+KTogVmFyaWFibGVTaXplRW5jb2RlcjxURnJvbT47XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW5jb2RlcjxURnJvbT4oXG4gICAgZW5jb2RlcjogT21pdDxGaXhlZFNpemVFbmNvZGVyPFRGcm9tPiwgJ2VuY29kZSc+IHwgT21pdDxWYXJpYWJsZVNpemVFbmNvZGVyPFRGcm9tPiwgJ2VuY29kZSc+LFxuKTogRW5jb2RlcjxURnJvbT47XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW5jb2RlcjxURnJvbT4oXG4gICAgZW5jb2RlcjogT21pdDxGaXhlZFNpemVFbmNvZGVyPFRGcm9tPiwgJ2VuY29kZSc+IHwgT21pdDxWYXJpYWJsZVNpemVFbmNvZGVyPFRGcm9tPiwgJ2VuY29kZSc+LFxuKTogRW5jb2RlcjxURnJvbT4ge1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4uZW5jb2RlcixcbiAgICAgICAgZW5jb2RlOiB2YWx1ZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGdldEVuY29kZWRTaXplKHZhbHVlLCBlbmNvZGVyKSk7XG4gICAgICAgICAgICBlbmNvZGVyLndyaXRlKHZhbHVlLCBieXRlcywgMCk7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBEZWNvZGVyYCBieSBmaWxsaW5nIGluIHRoZSBtaXNzaW5nIGBkZWNvZGVgIGZ1bmN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZCBgcmVhZGAgZnVuY3Rpb24uXG4gKlxuICogSW5zdGVhZCBvZiBtYW51YWxseSBpbXBsZW1lbnRpbmcgYGRlY29kZWAsIHRoaXMgdXRpbGl0eSBsZXZlcmFnZXMgdGhlIGV4aXN0aW5nIGByZWFkYCBmdW5jdGlvblxuICogYW5kIHRoZSBzaXplIHByb3BlcnRpZXMgdG8gZ2VuZXJhdGUgYSBjb21wbGV0ZSBkZWNvZGVyLiBUaGUgcHJvdmlkZWQgYGRlY29kZWAgbWV0aG9kIHdpbGwgcmVhZFxuICogZnJvbSBhIGBVaW50OEFycmF5YCBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IGFuZCByZXR1cm4gdGhlIGRlY29kZWQgdmFsdWUuXG4gKlxuICogSWYgdGhlIGBmaXhlZFNpemVgIHByb3BlcnR5IGlzIHByb3ZpZGVkLCBhIHtAbGluayBGaXhlZFNpemVEZWNvZGVyfSB3aWxsIGJlIGNyZWF0ZWQsIG90aGVyd2lzZVxuICogYSB7QGxpbmsgVmFyaWFibGVTaXplRGVjb2Rlcn0gd2lsbCBiZSBjcmVhdGVkLlxuICpcbiAqIEB0eXBlUGFyYW0gVFRvIC0gVGhlIHR5cGUgb2YgdGhlIGRlY29kZWQgdmFsdWUuXG4gKiBAdHlwZVBhcmFtIFRTaXplIC0gVGhlIGZpeGVkIHNpemUgb2YgdGhlIGVuY29kZWQgdmFsdWUgaW4gYnl0ZXMgKGZvciBmaXhlZC1zaXplIGRlY29kZXJzKS5cbiAqXG4gKiBAcGFyYW0gZGVjb2RlciAtIEEgZGVjb2RlciBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIGByZWFkYCwgYnV0IG5vdCBgZGVjb2RlYC5cbiAqIC0gSWYgdGhlIGRlY29kZXIgaGFzIGEgYGZpeGVkU2l6ZWAgcHJvcGVydHksIGl0IGlzIHRyZWF0ZWQgYXMgYSB7QGxpbmsgRml4ZWRTaXplRGVjb2Rlcn0uXG4gKiAtIE90aGVyd2lzZSwgaXQgaXMgdHJlYXRlZCBhcyBhIHtAbGluayBWYXJpYWJsZVNpemVEZWNvZGVyfS5cbiAqXG4gKiBAcmV0dXJucyBBIGZ1bGx5IGZ1bmN0aW9uYWwgYERlY29kZXJgIHdpdGggYm90aCBgcmVhZGAgYW5kIGBkZWNvZGVgIG1ldGhvZHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIENyZWF0aW5nIGEgY3VzdG9tIGZpeGVkLXNpemUgZGVjb2Rlci5cbiAqIGBgYHRzXG4gKiBjb25zdCBkZWNvZGVyID0gY3JlYXRlRGVjb2Rlcih7XG4gKiAgICAgZml4ZWRTaXplOiA0LFxuICogICAgIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gKiAgICAgICAgIGNvbnN0IHZhbHVlID0gYnl0ZXNbb2Zmc2V0XTtcbiAqICAgICAgICAgcmV0dXJuIFt2YWx1ZSwgb2Zmc2V0ICsgNF07XG4gKiAgICAgfSxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHZhbHVlID0gZGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoWzQyLCAwLCAwLCAwXSkpO1xuICogLy8gNDJcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBDcmVhdGluZyBhIGN1c3RvbSB2YXJpYWJsZS1zaXplIGRlY29kZXI6XG4gKiBgYGB0c1xuICogY29uc3QgZGVjb2RlciA9IGNyZWF0ZURlY29kZXIoe1xuICogICAgIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gKiAgICAgICAgIGNvbnN0IGRlY29kZWRWYWx1ZSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShieXRlcy5zdWJhcnJheShvZmZzZXQpKTtcbiAqICAgICAgICAgcmV0dXJuIFtkZWNvZGVkVmFsdWUsIGJ5dGVzLmxlbmd0aF07XG4gKiAgICAgfSxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHZhbHVlID0gZGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoWzEwNCwgMTAxLCAxMDgsIDEwOCwgMTExXSkpO1xuICogLy8gXCJoZWxsb1wiXG4gKiBgYGBcbiAqXG4gKiBAcmVtYXJrc1xuICogTm90ZSB0aGF0LCB3aGlsZSBgY3JlYXRlRGVjb2RlcmAgaXMgdXNlZnVsIGZvciBkZWZpbmluZyBtb3JlIGNvbXBsZXggZGVjb2RlcnMsIGl0IGlzIG1vcmUgY29tbW9uIHRvIGNvbXBvc2VcbiAqIGRlY29kZXJzIHRvZ2V0aGVyIHVzaW5nIHRoZSB2YXJpb3VzIGhlbHBlcnMgYW5kIHByaW1pdGl2ZXMgb2YgdGhlIGBAc29sYW5hL2NvZGVjc2AgcGFja2FnZS5cbiAqXG4gKiBIZXJlIGFyZSBzb21lIGFsdGVybmF0aXZlIGV4YW1wbGVzIHVzaW5nIGNvZGVjIHByaW1pdGl2ZXMgaW5zdGVhZCBvZiBgY3JlYXRlRGVjb2RlcmAuXG4gKlxuICogYGBgdHNcbiAqIC8vIEZpeGVkLXNpemUgZGVjb2RlciBmb3IgdW5zaWduZWQgMzItYml0IGludGVnZXJzLlxuICogY29uc3QgZGVjb2RlciA9IGdldFUzMkRlY29kZXIoKTtcbiAqIGNvbnN0IHZhbHVlID0gZGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoWzQyLCAwLCAwLCAwXSkpO1xuICogLy8gNDJcbiAqXG4gKiAvLyBWYXJpYWJsZS1zaXplIGRlY29kZXIgZm9yIDMyLWJ5dGVzIHByZWZpeGVkIFVURi04IHN0cmluZ3MuXG4gKiBjb25zdCBkZWNvZGVyID0gYWRkRGVjb2RlclNpemVQcmVmaXgoZ2V0VXRmOERlY29kZXIoKSwgZ2V0VTMyRGVjb2RlcigpKTtcbiAqIGNvbnN0IHZhbHVlID0gZGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoWzUsIDAsIDAsIDAsIDEwNCwgMTAxLCAxMDgsIDEwOCwgMTExXSkpO1xuICogLy8gXCJoZWxsb1wiXG4gKlxuICogLy8gVmFyaWFibGUtc2l6ZSBkZWNvZGVyIGZvciBjdXN0b20gb2JqZWN0cy5cbiAqIHR5cGUgUGVyc29uID0geyBuYW1lOiBzdHJpbmc7IGFnZTogbnVtYmVyIH07XG4gKiBjb25zdCBkZWNvZGVyOiBEZWNvZGVyPFBlcnNvbj4gPSBnZXRTdHJ1Y3REZWNvZGVyKFtcbiAqICAgICBbJ25hbWUnLCBhZGREZWNvZGVyU2l6ZVByZWZpeChnZXRVdGY4RGVjb2RlcigpLCBnZXRVMzJEZWNvZGVyKCkpXSxcbiAqICAgICBbJ2FnZScsIGdldFUzMkRlY29kZXIoKV0sXG4gKiBdKTtcbiAqIGNvbnN0IHZhbHVlID0gZGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoWzMsIDAsIDAsIDAsIDY2LCAxMTEsIDk4LCA0MiwgMCwgMCwgMF0pKTtcbiAqIC8vIHsgbmFtZTogXCJCb2JcIiwgYWdlOiA0MiB9XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBEZWNvZGVyfVxuICogQHNlZSB7QGxpbmsgRml4ZWRTaXplRGVjb2Rlcn1cbiAqIEBzZWUge0BsaW5rIFZhcmlhYmxlU2l6ZURlY29kZXJ9XG4gKiBAc2VlIHtAbGluayBnZXRTdHJ1Y3REZWNvZGVyfVxuICogQHNlZSB7QGxpbmsgZ2V0VTMyRGVjb2Rlcn1cbiAqIEBzZWUge0BsaW5rIGdldFV0ZjhEZWNvZGVyfVxuICogQHNlZSB7QGxpbmsgYWRkRGVjb2RlclNpemVQcmVmaXh9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEZWNvZGVyPFRUbywgVFNpemUgZXh0ZW5kcyBudW1iZXI+KFxuICAgIGRlY29kZXI6IE9taXQ8Rml4ZWRTaXplRGVjb2RlcjxUVG8sIFRTaXplPiwgJ2RlY29kZSc+LFxuKTogRml4ZWRTaXplRGVjb2RlcjxUVG8sIFRTaXplPjtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEZWNvZGVyPFRUbz4oZGVjb2RlcjogT21pdDxWYXJpYWJsZVNpemVEZWNvZGVyPFRUbz4sICdkZWNvZGUnPik6IFZhcmlhYmxlU2l6ZURlY29kZXI8VFRvPjtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEZWNvZGVyPFRUbz4oXG4gICAgZGVjb2RlcjogT21pdDxGaXhlZFNpemVEZWNvZGVyPFRUbz4sICdkZWNvZGUnPiB8IE9taXQ8VmFyaWFibGVTaXplRGVjb2RlcjxUVG8+LCAnZGVjb2RlJz4sXG4pOiBEZWNvZGVyPFRUbz47XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGVjb2RlcjxUVG8+KFxuICAgIGRlY29kZXI6IE9taXQ8Rml4ZWRTaXplRGVjb2RlcjxUVG8+LCAnZGVjb2RlJz4gfCBPbWl0PFZhcmlhYmxlU2l6ZURlY29kZXI8VFRvPiwgJ2RlY29kZSc+LFxuKTogRGVjb2RlcjxUVG8+IHtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLmRlY29kZXIsXG4gICAgICAgIGRlY29kZTogKGJ5dGVzLCBvZmZzZXQgPSAwKSA9PiBkZWNvZGVyLnJlYWQoYnl0ZXMsIG9mZnNldClbMF0sXG4gICAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBDb2RlY2AgYnkgZmlsbGluZyBpbiB0aGUgbWlzc2luZyBgZW5jb2RlYCBhbmQgYGRlY29kZWAgZnVuY3Rpb25zIHVzaW5nIHRoZSBwcm92aWRlZCBgd3JpdGVgIGFuZCBgcmVhZGAgZnVuY3Rpb25zLlxuICpcbiAqIFRoaXMgdXRpbGl0eSBjb21iaW5lcyB0aGUgYmVoYXZpb3Igb2Yge0BsaW5rIGNyZWF0ZUVuY29kZXJ9IGFuZCB7QGxpbmsgY3JlYXRlRGVjb2Rlcn0gdG8gcHJvZHVjZSBhIGZ1bGx5IGZ1bmN0aW9uYWwgYENvZGVjYC5cbiAqIFRoZSBgZW5jb2RlYCBtZXRob2QgaXMgZGVyaXZlZCBmcm9tIHRoZSBgd3JpdGVgIGZ1bmN0aW9uLCB3aGlsZSB0aGUgYGRlY29kZWAgbWV0aG9kIGlzIGRlcml2ZWQgZnJvbSB0aGUgYHJlYWRgIGZ1bmN0aW9uLlxuICpcbiAqIElmIHRoZSBgZml4ZWRTaXplYCBwcm9wZXJ0eSBpcyBwcm92aWRlZCwgYSB7QGxpbmsgRml4ZWRTaXplQ29kZWN9IHdpbGwgYmUgY3JlYXRlZCwgb3RoZXJ3aXNlXG4gKiBhIHtAbGluayBWYXJpYWJsZVNpemVDb2RlY30gd2lsbCBiZSBjcmVhdGVkLlxuICpcbiAqIEB0eXBlUGFyYW0gVEZyb20gLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gZW5jb2RlLlxuICogQHR5cGVQYXJhbSBUVG8gLSBUaGUgdHlwZSBvZiB0aGUgZGVjb2RlZCB2YWx1ZS5cbiAqIEB0eXBlUGFyYW0gVFNpemUgLSBUaGUgZml4ZWQgc2l6ZSBvZiB0aGUgZW5jb2RlZCB2YWx1ZSBpbiBieXRlcyAoZm9yIGZpeGVkLXNpemUgY29kZWNzKS5cbiAqXG4gKiBAcGFyYW0gY29kZWMgLSBBIGNvZGVjIG9iamVjdCB0aGF0IGltcGxlbWVudHMgYHdyaXRlYCBhbmQgYHJlYWRgLCBidXQgbm90IGBlbmNvZGVgIG9yIGBkZWNvZGVgLlxuICogLSBJZiB0aGUgY29kZWMgaGFzIGEgYGZpeGVkU2l6ZWAgcHJvcGVydHksIGl0IGlzIHRyZWF0ZWQgYXMgYSB7QGxpbmsgRml4ZWRTaXplQ29kZWN9LlxuICogLSBPdGhlcndpc2UsIGl0IGlzIHRyZWF0ZWQgYXMgYSB7QGxpbmsgVmFyaWFibGVTaXplQ29kZWN9LlxuICpcbiAqIEByZXR1cm5zIEEgZnVsbHkgZnVuY3Rpb25hbCBgQ29kZWNgIHdpdGggYHdyaXRlYCwgYHJlYWRgLCBgZW5jb2RlYCwgYW5kIGBkZWNvZGVgIG1ldGhvZHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIENyZWF0aW5nIGEgY3VzdG9tIGZpeGVkLXNpemUgY29kZWMuXG4gKiBgYGB0c1xuICogY29uc3QgY29kZWMgPSBjcmVhdGVDb2RlYyh7XG4gKiAgICAgZml4ZWRTaXplOiA0LFxuICogICAgIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gKiAgICAgICAgIGNvbnN0IHZhbHVlID0gYnl0ZXNbb2Zmc2V0XTtcbiAqICAgICAgICAgcmV0dXJuIFt2YWx1ZSwgb2Zmc2V0ICsgNF07XG4gKiAgICAgfSxcbiAqICAgICB3cml0ZTogKHZhbHVlOiBudW1iZXIsIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAqICAgICAgICAgYnl0ZXMuc2V0KG5ldyBVaW50OEFycmF5KFt2YWx1ZV0pLCBvZmZzZXQpO1xuICogICAgICAgICByZXR1cm4gb2Zmc2V0ICsgNDtcbiAqICAgICB9LFxuICogfSk7XG4gKlxuICogY29uc3QgYnl0ZXMgPSBjb2RlYy5lbmNvZGUoNDIpO1xuICogLy8gMHgyYTAwMDAwMFxuICogY29uc3QgdmFsdWUgPSBjb2RlYy5kZWNvZGUoYnl0ZXMpO1xuICogLy8gNDJcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBDcmVhdGluZyBhIGN1c3RvbSB2YXJpYWJsZS1zaXplIGNvZGVjOlxuICogYGBgdHNcbiAqIGNvbnN0IGNvZGVjID0gY3JlYXRlQ29kZWMoe1xuICogICAgIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZTogc3RyaW5nKSA9PiB2YWx1ZS5sZW5ndGgsXG4gKiAgICAgcmVhZDogKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAqICAgICAgICAgY29uc3QgZGVjb2RlZFZhbHVlID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzLnN1YmFycmF5KG9mZnNldCkpO1xuICogICAgICAgICByZXR1cm4gW2RlY29kZWRWYWx1ZSwgYnl0ZXMubGVuZ3RoXTtcbiAqICAgICB9LFxuICogICAgIHdyaXRlOiAodmFsdWU6IHN0cmluZywgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICogICAgICAgICBjb25zdCBlbmNvZGVkVmFsdWUgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpO1xuICogICAgICAgICBieXRlcy5zZXQoZW5jb2RlZFZhbHVlLCBvZmZzZXQpO1xuICogICAgICAgICByZXR1cm4gb2Zmc2V0ICsgZW5jb2RlZFZhbHVlLmxlbmd0aDtcbiAqICAgICB9LFxuICogfSk7XG4gKlxuICogY29uc3QgYnl0ZXMgPSBjb2RlYy5lbmNvZGUoXCJoZWxsb1wiKTtcbiAqIC8vIDB4Njg2NTZjNmM2ZlxuICogY29uc3QgdmFsdWUgPSBjb2RlYy5kZWNvZGUoYnl0ZXMpO1xuICogLy8gXCJoZWxsb1wiXG4gKiBgYGBcbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBmdW5jdGlvbiBlZmZlY3RpdmVseSBjb21iaW5lcyB0aGUgYmVoYXZpb3Igb2Yge0BsaW5rIGNyZWF0ZUVuY29kZXJ9IGFuZCB7QGxpbmsgY3JlYXRlRGVjb2Rlcn0uXG4gKiBJZiB5b3Ugb25seSBuZWVkIHRvIGVuY29kZSBvciBkZWNvZGUgKGJ1dCBub3QgYm90aCksIGNvbnNpZGVyIHVzaW5nIHRob3NlIGZ1bmN0aW9ucyBpbnN0ZWFkLlxuICpcbiAqIEhlcmUgYXJlIHNvbWUgYWx0ZXJuYXRpdmUgZXhhbXBsZXMgdXNpbmcgY29kZWMgcHJpbWl0aXZlcyBpbnN0ZWFkIG9mIGBjcmVhdGVDb2RlY2AuXG4gKlxuICogYGBgdHNcbiAqIC8vIEZpeGVkLXNpemUgY29kZWMgZm9yIHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2Vycy5cbiAqIGNvbnN0IGNvZGVjID0gZ2V0VTMyQ29kZWMoKTtcbiAqIGNvbnN0IGJ5dGVzID0gY29kZWMuZW5jb2RlKDQyKTtcbiAqIC8vIDB4MmEwMDAwMDBcbiAqIGNvbnN0IHZhbHVlID0gY29kZWMuZGVjb2RlKGJ5dGVzKTtcbiAqIC8vIDQyXG4gKlxuICogLy8gVmFyaWFibGUtc2l6ZSBjb2RlYyBmb3IgMzItYnl0ZXMgcHJlZml4ZWQgVVRGLTggc3RyaW5ncy5cbiAqIGNvbnN0IGNvZGVjID0gYWRkQ29kZWNTaXplUHJlZml4KGdldFV0ZjhDb2RlYygpLCBnZXRVMzJDb2RlYygpKTtcbiAqIGNvbnN0IGJ5dGVzID0gY29kZWMuZW5jb2RlKFwiaGVsbG9cIik7XG4gKiAvLyAweDA1MDAwMDAwNjg2NTZjNmM2ZlxuICogY29uc3QgdmFsdWUgPSBjb2RlYy5kZWNvZGUoYnl0ZXMpO1xuICogLy8gXCJoZWxsb1wiXG4gKlxuICogLy8gVmFyaWFibGUtc2l6ZSBjb2RlYyBmb3IgY3VzdG9tIG9iamVjdHMuXG4gKiB0eXBlIFBlcnNvbiA9IHsgbmFtZTogc3RyaW5nOyBhZ2U6IG51bWJlciB9O1xuICogY29uc3QgY29kZWM6IENvZGVjPFBlcnNvbklucHV0LCBQZXJzb24+ID0gZ2V0U3RydWN0Q29kZWMoW1xuICogICAgIFsnbmFtZScsIGFkZENvZGVjU2l6ZVByZWZpeChnZXRVdGY4Q29kZWMoKSwgZ2V0VTMyQ29kZWMoKSldLFxuICogICAgIFsnYWdlJywgZ2V0VTMyQ29kZWMoKV0sXG4gKiBdKTtcbiAqIGNvbnN0IGJ5dGVzID0gY29kZWMuZW5jb2RlKHsgbmFtZTogXCJCb2JcIiwgYWdlOiA0MiB9KTtcbiAqIC8vIDB4MDMwMDAwMDA0MjZmNjIyYTAwMDAwMFxuICogY29uc3QgdmFsdWUgPSBjb2RlYy5kZWNvZGUoYnl0ZXMpO1xuICogLy8geyBuYW1lOiBcIkJvYlwiLCBhZ2U6IDQyIH1cbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIENvZGVjfVxuICogQHNlZSB7QGxpbmsgRml4ZWRTaXplQ29kZWN9XG4gKiBAc2VlIHtAbGluayBWYXJpYWJsZVNpemVDb2RlY31cbiAqIEBzZWUge0BsaW5rIGNyZWF0ZUVuY29kZXJ9XG4gKiBAc2VlIHtAbGluayBjcmVhdGVEZWNvZGVyfVxuICogQHNlZSB7QGxpbmsgZ2V0U3RydWN0Q29kZWN9XG4gKiBAc2VlIHtAbGluayBnZXRVMzJDb2RlY31cbiAqIEBzZWUge0BsaW5rIGdldFV0ZjhDb2RlY31cbiAqIEBzZWUge0BsaW5rIGFkZENvZGVjU2l6ZVByZWZpeH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvZGVjPFRGcm9tLCBUVG8gZXh0ZW5kcyBURnJvbSA9IFRGcm9tLCBUU2l6ZSBleHRlbmRzIG51bWJlciA9IG51bWJlcj4oXG4gICAgY29kZWM6IE9taXQ8Rml4ZWRTaXplQ29kZWM8VEZyb20sIFRUbywgVFNpemU+LCAnZGVjb2RlJyB8ICdlbmNvZGUnPixcbik6IEZpeGVkU2l6ZUNvZGVjPFRGcm9tLCBUVG8sIFRTaXplPjtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb2RlYzxURnJvbSwgVFRvIGV4dGVuZHMgVEZyb20gPSBURnJvbT4oXG4gICAgY29kZWM6IE9taXQ8VmFyaWFibGVTaXplQ29kZWM8VEZyb20sIFRUbz4sICdkZWNvZGUnIHwgJ2VuY29kZSc+LFxuKTogVmFyaWFibGVTaXplQ29kZWM8VEZyb20sIFRUbz47XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29kZWM8VEZyb20sIFRUbyBleHRlbmRzIFRGcm9tID0gVEZyb20+KFxuICAgIGNvZGVjOlxuICAgICAgICB8IE9taXQ8Rml4ZWRTaXplQ29kZWM8VEZyb20sIFRUbz4sICdkZWNvZGUnIHwgJ2VuY29kZSc+XG4gICAgICAgIHwgT21pdDxWYXJpYWJsZVNpemVDb2RlYzxURnJvbSwgVFRvPiwgJ2RlY29kZScgfCAnZW5jb2RlJz4sXG4pOiBDb2RlYzxURnJvbSwgVFRvPjtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb2RlYzxURnJvbSwgVFRvIGV4dGVuZHMgVEZyb20gPSBURnJvbT4oXG4gICAgY29kZWM6XG4gICAgICAgIHwgT21pdDxGaXhlZFNpemVDb2RlYzxURnJvbSwgVFRvPiwgJ2RlY29kZScgfCAnZW5jb2RlJz5cbiAgICAgICAgfCBPbWl0PFZhcmlhYmxlU2l6ZUNvZGVjPFRGcm9tLCBUVG8+LCAnZGVjb2RlJyB8ICdlbmNvZGUnPixcbik6IENvZGVjPFRGcm9tLCBUVG8+IHtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLmNvZGVjLFxuICAgICAgICBkZWNvZGU6IChieXRlcywgb2Zmc2V0ID0gMCkgPT4gY29kZWMucmVhZChieXRlcywgb2Zmc2V0KVswXSxcbiAgICAgICAgZW5jb2RlOiB2YWx1ZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGdldEVuY29kZWRTaXplKHZhbHVlLCBjb2RlYykpO1xuICAgICAgICAgICAgY29kZWMud3JpdGUodmFsdWUsIGJ5dGVzLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBieXRlcztcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIGNvZGVjLCBlbmNvZGVyLCBvciBkZWNvZGVyIGlzIGZpeGVkLXNpemUuXG4gKlxuICogQSBmaXhlZC1zaXplIG9iamVjdCBpcyBpZGVudGlmaWVkIGJ5IHRoZSBwcmVzZW5jZSBvZiBhIGBmaXhlZFNpemVgIHByb3BlcnR5LlxuICogSWYgdGhpcyBwcm9wZXJ0eSBleGlzdHMsIHRoZSBvYmplY3QgaXMgY29uc2lkZXJlZCBhIHtAbGluayBGaXhlZFNpemVDb2RlY30sXG4gKiB7QGxpbmsgRml4ZWRTaXplRW5jb2Rlcn0sIG9yIHtAbGluayBGaXhlZFNpemVEZWNvZGVyfS5cbiAqIE90aGVyd2lzZSwgaXQgaXMgYXNzdW1lZCB0byBiZSBhIHtAbGluayBWYXJpYWJsZVNpemVDb2RlY30sXG4gKiB7QGxpbmsgVmFyaWFibGVTaXplRW5jb2Rlcn0sIG9yIHtAbGluayBWYXJpYWJsZVNpemVEZWNvZGVyfS5cbiAqXG4gKiBAdHlwZVBhcmFtIFRGcm9tIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIGVuY29kZS5cbiAqIEB0eXBlUGFyYW0gVFRvIC0gVGhlIHR5cGUgb2YgdGhlIGRlY29kZWQgdmFsdWUuXG4gKiBAdHlwZVBhcmFtIFRTaXplIC0gVGhlIGZpeGVkIHNpemUgb2YgdGhlIGVuY29kZWQgdmFsdWUgaW4gYnl0ZXMuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdCBpcyBmaXhlZC1zaXplLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogQ2hlY2tpbmcgYSBmaXhlZC1zaXplIGVuY29kZXIuXG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlciA9IGdldFUzMkVuY29kZXIoKTtcbiAqIGlzRml4ZWRTaXplKGVuY29kZXIpOyAvLyB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogQ2hlY2tpbmcgYSB2YXJpYWJsZS1zaXplIGVuY29kZXIuXG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlciA9IGFkZEVuY29kZXJTaXplUHJlZml4KGdldFV0ZjhFbmNvZGVyKCksIGdldFUzMkVuY29kZXIoKSk7XG4gKiBpc0ZpeGVkU2l6ZShlbmNvZGVyKTsgLy8gZmFsc2VcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGNvbW1vbmx5IHVzZWQgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBmaXhlZC1zaXplIGFuZCB2YXJpYWJsZS1zaXplIG9iamVjdHMgYXQgcnVudGltZS5cbiAqIElmIHlvdSBuZWVkIHRvIGVuZm9yY2UgdGhpcyBkaXN0aW5jdGlvbiB3aXRoIHR5cGUgYXNzZXJ0aW9ucywgY29uc2lkZXIgdXNpbmcge0BsaW5rIGFzc2VydElzRml4ZWRTaXplfS5cbiAqXG4gKiBAc2VlIHtAbGluayBhc3NlcnRJc0ZpeGVkU2l6ZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRml4ZWRTaXplPFRGcm9tLCBUU2l6ZSBleHRlbmRzIG51bWJlcj4oXG4gICAgZW5jb2RlcjogRml4ZWRTaXplRW5jb2RlcjxURnJvbSwgVFNpemU+IHwgVmFyaWFibGVTaXplRW5jb2RlcjxURnJvbT4sXG4pOiBlbmNvZGVyIGlzIEZpeGVkU2l6ZUVuY29kZXI8VEZyb20sIFRTaXplPjtcbmV4cG9ydCBmdW5jdGlvbiBpc0ZpeGVkU2l6ZTxUVG8sIFRTaXplIGV4dGVuZHMgbnVtYmVyPihcbiAgICBkZWNvZGVyOiBGaXhlZFNpemVEZWNvZGVyPFRUbywgVFNpemU+IHwgVmFyaWFibGVTaXplRGVjb2RlcjxUVG8+LFxuKTogZGVjb2RlciBpcyBGaXhlZFNpemVEZWNvZGVyPFRUbywgVFNpemU+O1xuZXhwb3J0IGZ1bmN0aW9uIGlzRml4ZWRTaXplPFRGcm9tLCBUVG8gZXh0ZW5kcyBURnJvbSwgVFNpemUgZXh0ZW5kcyBudW1iZXI+KFxuICAgIGNvZGVjOiBGaXhlZFNpemVDb2RlYzxURnJvbSwgVFRvLCBUU2l6ZT4gfCBWYXJpYWJsZVNpemVDb2RlYzxURnJvbSwgVFRvPixcbik6IGNvZGVjIGlzIEZpeGVkU2l6ZUNvZGVjPFRGcm9tLCBUVG8sIFRTaXplPjtcbmV4cG9ydCBmdW5jdGlvbiBpc0ZpeGVkU2l6ZTxUU2l6ZSBleHRlbmRzIG51bWJlcj4oXG4gICAgY29kZWM6IHsgZml4ZWRTaXplOiBUU2l6ZSB9IHwgeyBtYXhTaXplPzogbnVtYmVyIH0sXG4pOiBjb2RlYyBpcyB7IGZpeGVkU2l6ZTogVFNpemUgfTtcbmV4cG9ydCBmdW5jdGlvbiBpc0ZpeGVkU2l6ZShjb2RlYzogeyBmaXhlZFNpemU6IG51bWJlciB9IHwgeyBtYXhTaXplPzogbnVtYmVyIH0pOiBjb2RlYyBpcyB7IGZpeGVkU2l6ZTogbnVtYmVyIH0ge1xuICAgIHJldHVybiAnZml4ZWRTaXplJyBpbiBjb2RlYyAmJiB0eXBlb2YgY29kZWMuZml4ZWRTaXplID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGNvZGVjLCBlbmNvZGVyLCBvciBkZWNvZGVyIGlzIGZpeGVkLXNpemUuXG4gKlxuICogSWYgdGhlIG9iamVjdCBpcyBub3QgZml4ZWQtc2l6ZSAoaS5lLiwgaXQgbGFja3MgYSBgZml4ZWRTaXplYCBwcm9wZXJ0eSksXG4gKiB0aGlzIGZ1bmN0aW9uIHRocm93cyBhIHtAbGluayBTb2xhbmFFcnJvcn0gd2l0aCB0aGUgY29kZSBgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0ZJWEVEX0xFTkdUSGAuXG4gKlxuICogQHR5cGVQYXJhbSBURnJvbSAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAdHlwZVBhcmFtIFRUbyAtIFRoZSB0eXBlIG9mIHRoZSBkZWNvZGVkIHZhbHVlLlxuICogQHR5cGVQYXJhbSBUU2l6ZSAtIFRoZSBmaXhlZCBzaXplIG9mIHRoZSBlbmNvZGVkIHZhbHVlIGluIGJ5dGVzLlxuICogQHRocm93cyB7U29sYW5hRXJyb3J9IElmIHRoZSBvYmplY3QgaXMgbm90IGZpeGVkLXNpemUuXG4gKlxuICogQGV4YW1wbGVcbiAqIEFzc2VydGluZyBhIGZpeGVkLXNpemUgZW5jb2Rlci5cbiAqIGBgYHRzXG4gKiBjb25zdCBlbmNvZGVyID0gZ2V0VTMyRW5jb2RlcigpO1xuICogYXNzZXJ0SXNGaXhlZFNpemUoZW5jb2Rlcik7IC8vIFBhc3Nlc1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIEF0dGVtcHRpbmcgdG8gYXNzZXJ0IGEgdmFyaWFibGUtc2l6ZSBlbmNvZGVyLlxuICogYGBgdHNcbiAqIGNvbnN0IGVuY29kZXIgPSBhZGRFbmNvZGVyU2l6ZVByZWZpeChnZXRVdGY4RW5jb2RlcigpLCBnZXRVMzJFbmNvZGVyKCkpO1xuICogYXNzZXJ0SXNGaXhlZFNpemUoZW5jb2Rlcik7IC8vIFRocm93cyBTb2xhbmFFcnJvclxuICogYGBgXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdGhlIGFzc2VydGlvbi1iYXNlZCBjb3VudGVycGFydCBvZiB7QGxpbmsgaXNGaXhlZFNpemV9LlxuICogSWYgeW91IG9ubHkgbmVlZCB0byBjaGVjayB3aGV0aGVyIGFuIG9iamVjdCBpcyBmaXhlZC1zaXplIHdpdGhvdXQgdGhyb3dpbmcgYW4gZXJyb3IsIHVzZSB7QGxpbmsgaXNGaXhlZFNpemV9IGluc3RlYWQuXG4gKlxuICogQHNlZSB7QGxpbmsgaXNGaXhlZFNpemV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRJc0ZpeGVkU2l6ZTxURnJvbSwgVFNpemUgZXh0ZW5kcyBudW1iZXI+KFxuICAgIGVuY29kZXI6IEZpeGVkU2l6ZUVuY29kZXI8VEZyb20sIFRTaXplPiB8IFZhcmlhYmxlU2l6ZUVuY29kZXI8VEZyb20+LFxuKTogYXNzZXJ0cyBlbmNvZGVyIGlzIEZpeGVkU2l6ZUVuY29kZXI8VEZyb20sIFRTaXplPjtcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRJc0ZpeGVkU2l6ZTxUVG8sIFRTaXplIGV4dGVuZHMgbnVtYmVyPihcbiAgICBkZWNvZGVyOiBGaXhlZFNpemVEZWNvZGVyPFRUbywgVFNpemU+IHwgVmFyaWFibGVTaXplRGVjb2RlcjxUVG8+LFxuKTogYXNzZXJ0cyBkZWNvZGVyIGlzIEZpeGVkU2l6ZURlY29kZXI8VFRvLCBUU2l6ZT47XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SXNGaXhlZFNpemU8VEZyb20sIFRUbyBleHRlbmRzIFRGcm9tLCBUU2l6ZSBleHRlbmRzIG51bWJlcj4oXG4gICAgY29kZWM6IEZpeGVkU2l6ZUNvZGVjPFRGcm9tLCBUVG8sIFRTaXplPiB8IFZhcmlhYmxlU2l6ZUNvZGVjPFRGcm9tLCBUVG8+LFxuKTogYXNzZXJ0cyBjb2RlYyBpcyBGaXhlZFNpemVDb2RlYzxURnJvbSwgVFRvLCBUU2l6ZT47XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SXNGaXhlZFNpemU8VFNpemUgZXh0ZW5kcyBudW1iZXI+KFxuICAgIGNvZGVjOiB7IGZpeGVkU2l6ZTogVFNpemUgfSB8IHsgbWF4U2l6ZT86IG51bWJlciB9LFxuKTogYXNzZXJ0cyBjb2RlYyBpcyB7IGZpeGVkU2l6ZTogVFNpemUgfTtcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRJc0ZpeGVkU2l6ZShcbiAgICBjb2RlYzogeyBmaXhlZFNpemU6IG51bWJlciB9IHwgeyBtYXhTaXplPzogbnVtYmVyIH0sXG4pOiBhc3NlcnRzIGNvZGVjIGlzIHsgZml4ZWRTaXplOiBudW1iZXIgfSB7XG4gICAgaWYgKCFpc0ZpeGVkU2l6ZShjb2RlYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9GSVhFRF9MRU5HVEgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIGNvZGVjLCBlbmNvZGVyLCBvciBkZWNvZGVyIGlzIHZhcmlhYmxlLXNpemUuXG4gKlxuICogQSB2YXJpYWJsZS1zaXplIG9iamVjdCBpcyBpZGVudGlmaWVkIGJ5IHRoZSBhYnNlbmNlIG9mIGEgYGZpeGVkU2l6ZWAgcHJvcGVydHkuXG4gKiBJZiB0aGlzIHByb3BlcnR5IGlzIG1pc3NpbmcsIHRoZSBvYmplY3QgaXMgY29uc2lkZXJlZCBhIHtAbGluayBWYXJpYWJsZVNpemVDb2RlY30sXG4gKiB7QGxpbmsgVmFyaWFibGVTaXplRW5jb2Rlcn0sIG9yIHtAbGluayBWYXJpYWJsZVNpemVEZWNvZGVyfS5cbiAqXG4gKiBAdHlwZVBhcmFtIFRGcm9tIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIGVuY29kZS5cbiAqIEB0eXBlUGFyYW0gVFRvIC0gVGhlIHR5cGUgb2YgdGhlIGRlY29kZWQgdmFsdWUuXG4gKiBAdHlwZVBhcmFtIFRTaXplIC0gVGhlIGZpeGVkIHNpemUgb2YgdGhlIGVuY29kZWQgdmFsdWUgaW4gYnl0ZXMuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdCBpcyB2YXJpYWJsZS1zaXplLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogQ2hlY2tpbmcgYSB2YXJpYWJsZS1zaXplIGVuY29kZXIuXG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlciA9IGFkZEVuY29kZXJTaXplUHJlZml4KGdldFV0ZjhFbmNvZGVyKCksIGdldFUzMkVuY29kZXIoKSk7XG4gKiBpc1ZhcmlhYmxlU2l6ZShlbmNvZGVyKTsgLy8gdHJ1ZVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIENoZWNraW5nIGEgZml4ZWQtc2l6ZSBlbmNvZGVyLlxuICogYGBgdHNcbiAqIGNvbnN0IGVuY29kZXIgPSBnZXRVMzJFbmNvZGVyKCk7XG4gKiBpc1ZhcmlhYmxlU2l6ZShlbmNvZGVyKTsgLy8gZmFsc2VcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHRoZSBpbnZlcnNlIG9mIHtAbGluayBpc0ZpeGVkU2l6ZX0uXG4gKlxuICogQHNlZSB7QGxpbmsgaXNGaXhlZFNpemV9XG4gKiBAc2VlIHtAbGluayBhc3NlcnRJc1ZhcmlhYmxlU2l6ZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFyaWFibGVTaXplPFRGcm9tPihlbmNvZGVyOiBFbmNvZGVyPFRGcm9tPik6IGVuY29kZXIgaXMgVmFyaWFibGVTaXplRW5jb2RlcjxURnJvbT47XG5leHBvcnQgZnVuY3Rpb24gaXNWYXJpYWJsZVNpemU8VFRvPihkZWNvZGVyOiBEZWNvZGVyPFRUbz4pOiBkZWNvZGVyIGlzIFZhcmlhYmxlU2l6ZURlY29kZXI8VFRvPjtcbmV4cG9ydCBmdW5jdGlvbiBpc1ZhcmlhYmxlU2l6ZTxURnJvbSwgVFRvIGV4dGVuZHMgVEZyb20+KFxuICAgIGNvZGVjOiBDb2RlYzxURnJvbSwgVFRvPixcbik6IGNvZGVjIGlzIFZhcmlhYmxlU2l6ZUNvZGVjPFRGcm9tLCBUVG8+O1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFyaWFibGVTaXplKGNvZGVjOiB7IGZpeGVkU2l6ZTogbnVtYmVyIH0gfCB7IG1heFNpemU/OiBudW1iZXIgfSk6IGNvZGVjIGlzIHsgbWF4U2l6ZT86IG51bWJlciB9O1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFyaWFibGVTaXplKGNvZGVjOiB7IGZpeGVkU2l6ZTogbnVtYmVyIH0gfCB7IG1heFNpemU/OiBudW1iZXIgfSk6IGNvZGVjIGlzIHsgbWF4U2l6ZT86IG51bWJlciB9IHtcbiAgICByZXR1cm4gIWlzRml4ZWRTaXplKGNvZGVjKTtcbn1cblxuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGNvZGVjLCBlbmNvZGVyLCBvciBkZWNvZGVyIGlzIHZhcmlhYmxlLXNpemUuXG4gKlxuICogSWYgdGhlIG9iamVjdCBpcyBub3QgdmFyaWFibGUtc2l6ZSAoaS5lLiwgaXQgaGFzIGEgYGZpeGVkU2l6ZWAgcHJvcGVydHkpLFxuICogdGhpcyBmdW5jdGlvbiB0aHJvd3MgYSB7QGxpbmsgU29sYW5hRXJyb3J9IHdpdGggdGhlIGNvZGUgYFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEhgLlxuICpcbiAqIEB0eXBlUGFyYW0gVEZyb20gLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gZW5jb2RlLlxuICogQHR5cGVQYXJhbSBUVG8gLSBUaGUgdHlwZSBvZiB0aGUgZGVjb2RlZCB2YWx1ZS5cbiAqIEB0eXBlUGFyYW0gVFNpemUgLSBUaGUgZml4ZWQgc2l6ZSBvZiB0aGUgZW5jb2RlZCB2YWx1ZSBpbiBieXRlcy5cbiAqIEB0aHJvd3Mge1NvbGFuYUVycm9yfSBJZiB0aGUgb2JqZWN0IGlzIG5vdCB2YXJpYWJsZS1zaXplLlxuICpcbiAqIEBleGFtcGxlXG4gKiBBc3NlcnRpbmcgYSB2YXJpYWJsZS1zaXplIGVuY29kZXIuXG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlciA9IGFkZEVuY29kZXJTaXplUHJlZml4KGdldFV0ZjhFbmNvZGVyKCksIGdldFUzMkVuY29kZXIoKSk7XG4gKiBhc3NlcnRJc1ZhcmlhYmxlU2l6ZShlbmNvZGVyKTsgLy8gUGFzc2VzXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogQXR0ZW1wdGluZyB0byBhc3NlcnQgYSBmaXhlZC1zaXplIGVuY29kZXIuXG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlciA9IGdldFUzMkVuY29kZXIoKTtcbiAqIGFzc2VydElzVmFyaWFibGVTaXplKGVuY29kZXIpOyAvLyBUaHJvd3MgU29sYW5hRXJyb3JcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHRoZSBhc3NlcnRpb24tYmFzZWQgY291bnRlcnBhcnQgb2Yge0BsaW5rIGlzVmFyaWFibGVTaXplfS5cbiAqIElmIHlvdSBvbmx5IG5lZWQgdG8gY2hlY2sgd2hldGhlciBhbiBvYmplY3QgaXMgdmFyaWFibGUtc2l6ZSB3aXRob3V0IHRocm93aW5nIGFuIGVycm9yLCB1c2Uge0BsaW5rIGlzVmFyaWFibGVTaXplfSBpbnN0ZWFkLlxuICpcbiAqIEFsc28gbm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdGhlIGludmVyc2Ugb2Yge0BsaW5rIGFzc2VydElzRml4ZWRTaXplfS5cbiAqXG4gKiBAc2VlIHtAbGluayBpc1ZhcmlhYmxlU2l6ZX1cbiAqIEBzZWUge0BsaW5rIGFzc2VydElzRml4ZWRTaXplfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SXNWYXJpYWJsZVNpemU8VEZyb20+KGVuY29kZXI6IEVuY29kZXI8VEZyb20+KTogYXNzZXJ0cyBlbmNvZGVyIGlzIFZhcmlhYmxlU2l6ZUVuY29kZXI8VEZyb20+O1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydElzVmFyaWFibGVTaXplPFRUbz4oZGVjb2RlcjogRGVjb2RlcjxUVG8+KTogYXNzZXJ0cyBkZWNvZGVyIGlzIFZhcmlhYmxlU2l6ZURlY29kZXI8VFRvPjtcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRJc1ZhcmlhYmxlU2l6ZTxURnJvbSwgVFRvIGV4dGVuZHMgVEZyb20+KFxuICAgIGNvZGVjOiBDb2RlYzxURnJvbSwgVFRvPixcbik6IGFzc2VydHMgY29kZWMgaXMgVmFyaWFibGVTaXplQ29kZWM8VEZyb20sIFRUbz47XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SXNWYXJpYWJsZVNpemUoXG4gICAgY29kZWM6IHsgZml4ZWRTaXplOiBudW1iZXIgfSB8IHsgbWF4U2l6ZT86IG51bWJlciB9LFxuKTogYXNzZXJ0cyBjb2RlYyBpcyB7IG1heFNpemU/OiBudW1iZXIgfTtcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRJc1ZhcmlhYmxlU2l6ZShcbiAgICBjb2RlYzogeyBmaXhlZFNpemU6IG51bWJlciB9IHwgeyBtYXhTaXplPzogbnVtYmVyIH0sXG4pOiBhc3NlcnRzIGNvZGVjIGlzIHsgbWF4U2l6ZT86IG51bWJlciB9IHtcbiAgICBpZiAoIWlzVmFyaWFibGVTaXplKGNvZGVjKSkge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCk7XG4gICAgfVxufVxuIiwgImltcG9ydCB7XG4gICAgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENILFxuICAgIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfTUFYX1NJWkVfTUlTTUFUQ0gsXG4gICAgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9TSVpFX0NPTVBBVElCSUxJVFlfTUlTTUFUQ0gsXG4gICAgU29sYW5hRXJyb3IsXG59IGZyb20gJ0Bzb2xhbmEvZXJyb3JzJztcblxuaW1wb3J0IHtcbiAgICBDb2RlYyxcbiAgICBEZWNvZGVyLFxuICAgIEVuY29kZXIsXG4gICAgRml4ZWRTaXplQ29kZWMsXG4gICAgRml4ZWRTaXplRGVjb2RlcixcbiAgICBGaXhlZFNpemVFbmNvZGVyLFxuICAgIGlzRml4ZWRTaXplLFxuICAgIFZhcmlhYmxlU2l6ZUNvZGVjLFxuICAgIFZhcmlhYmxlU2l6ZURlY29kZXIsXG4gICAgVmFyaWFibGVTaXplRW5jb2Rlcixcbn0gZnJvbSAnLi9jb2RlYyc7XG5cbi8qKlxuICogQ29tYmluZXMgYW4gYEVuY29kZXJgIGFuZCBhIGBEZWNvZGVyYCBpbnRvIGEgYENvZGVjYC5cbiAqXG4gKiBUaGF0IGlzLCBnaXZlbiBhIGBFbmNvZGVyPFRGcm9tPmAgYW5kIGEgYERlY29kZXI8VFRvPmAsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIGBDb2RlYzxURnJvbSwgVFRvPmAuXG4gKlxuICogVGhpcyBhbGxvd3MgZm9yIG1vZHVsYXIgY29tcG9zaXRpb24gYnkga2VlcGluZyBlbmNvZGluZyBhbmQgZGVjb2RpbmcgbG9naWMgc2VwYXJhdGVcbiAqIHdoaWxlIHN0aWxsIG9mZmVyaW5nIGEgY29udmVuaWVudCB3YXkgdG8gYnVuZGxlIHRoZW0gaW50byBhIHNpbmdsZSBgQ29kZWNgLlxuICogVGhpcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBsaWJyYXJ5IG1haW50YWluZXJzIHdobyB3YW50IHRvIGV4cG9zZSBgRW5jb2RlcnNgLFxuICogYERlY29kZXJzYCwgYW5kIGBDb2RlY3NgIHNlcGFyYXRlbHksIGVuYWJsaW5nIHRyZWUtc2hha2luZyBvZiB1bnVzZWQgbG9naWMuXG4gKlxuICogVGhlIHByb3ZpZGVkIGBFbmNvZGVyYCBhbmQgYERlY29kZXJgIG11c3QgYmUgY29tcGF0aWJsZSBpbiB0ZXJtcyBvZjpcbiAqIC0gKipGaXhlZCBTaXplOioqIElmIGJvdGggYXJlIGZpeGVkLXNpemUsIHRoZXkgbXVzdCBoYXZlIHRoZSBzYW1lIGBmaXhlZFNpemVgIHZhbHVlLlxuICogLSAqKlZhcmlhYmxlIFNpemU6KiogSWYgZWl0aGVyIGhhcyBhIGBtYXhTaXplYCBhdHRyaWJ1dGUsIGl0IG11c3QgbWF0Y2ggdGhlIG90aGVyLlxuICpcbiAqIElmIHRoZXNlIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQsIGEge0BsaW5rIFNvbGFuYUVycm9yfSB3aWxsIGJlIHRocm93bi5cbiAqXG4gKiBAdHlwZVBhcmFtIFRGcm9tIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIGVuY29kZS5cbiAqIEB0eXBlUGFyYW0gVFRvIC0gVGhlIHR5cGUgb2YgdGhlIGRlY29kZWQgdmFsdWUuXG4gKiBAdHlwZVBhcmFtIFRTaXplIC0gVGhlIGZpeGVkIHNpemUgb2YgdGhlIGVuY29kZWQgdmFsdWUgaW4gYnl0ZXMgKGZvciBmaXhlZC1zaXplIGNvZGVjcykuXG4gKlxuICogQHBhcmFtIGVuY29kZXIgLSBUaGUgYEVuY29kZXJgIHRvIGNvbWJpbmUuXG4gKiBAcGFyYW0gZGVjb2RlciAtIFRoZSBgRGVjb2RlcmAgdG8gY29tYmluZS5cbiAqIEByZXR1cm5zIEEgYENvZGVjYCB0aGF0IHByb3ZpZGVzIGJvdGggYGVuY29kZWAgYW5kIGBkZWNvZGVgIG1ldGhvZHMuXG4gKlxuICogQHRocm93cyB7U29sYW5hRXJyb3J9XG4gKiAtIGBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX1NJWkVfQ09NUEFUSUJJTElUWV9NSVNNQVRDSGBcbiAqICAgVGhyb3duIGlmIHRoZSBlbmNvZGVyIGFuZCBkZWNvZGVyIGhhdmUgbWlzbWF0Y2hlZCBzaXplIHR5cGVzIChmaXhlZCB2cy4gdmFyaWFibGUpLlxuICogLSBgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENIYFxuICogICBUaHJvd24gaWYgYm90aCBhcmUgZml4ZWQtc2l6ZSBidXQgaGF2ZSBkaWZmZXJlbnQgYGZpeGVkU2l6ZWAgdmFsdWVzLlxuICogLSBgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSGBcbiAqICAgVGhyb3duIGlmIHRoZSBgbWF4U2l6ZWAgYXR0cmlidXRlcyBkbyBub3QgbWF0Y2guXG4gKlxuICogQGV4YW1wbGVcbiAqIENyZWF0aW5nIGEgZml4ZWQtc2l6ZSBgQ29kZWNgIGZyb20gYW4gZW5jb2RlciBhbmQgYSBkZWNvZGVyLlxuICogYGBgdHNcbiAqIGNvbnN0IGVuY29kZXIgPSBnZXRVMzJFbmNvZGVyKCk7XG4gKiBjb25zdCBkZWNvZGVyID0gZ2V0VTMyRGVjb2RlcigpO1xuICogY29uc3QgY29kZWMgPSBjb21iaW5lQ29kZWMoZW5jb2RlciwgZGVjb2Rlcik7XG4gKlxuICogY29uc3QgYnl0ZXMgPSBjb2RlYy5lbmNvZGUoNDIpOyAvLyAweDJhMDAwMDAwXG4gKiBjb25zdCB2YWx1ZSA9IGNvZGVjLmRlY29kZShieXRlcyk7IC8vIDQyXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogQ3JlYXRpbmcgYSB2YXJpYWJsZS1zaXplIGBDb2RlY2AgZnJvbSBhbiBlbmNvZGVyIGFuZCBhIGRlY29kZXIuXG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlciA9IGFkZEVuY29kZXJTaXplUHJlZml4KGdldFV0ZjhFbmNvZGVyKCksIGdldFUzMkVuY29kZXIoKSk7XG4gKiBjb25zdCBkZWNvZGVyID0gYWRkRGVjb2RlclNpemVQcmVmaXgoZ2V0VXRmOERlY29kZXIoKSwgZ2V0VTMyRGVjb2RlcigpKTtcbiAqIGNvbnN0IGNvZGVjID0gY29tYmluZUNvZGVjKGVuY29kZXIsIGRlY29kZXIpO1xuICpcbiAqIGNvbnN0IGJ5dGVzID0gY29kZWMuZW5jb2RlKFwiaGVsbG9cIik7IC8vIDB4MDUwMDAwMDA2ODY1NmM2YzZmXG4gKiBjb25zdCB2YWx1ZSA9IGNvZGVjLmRlY29kZShieXRlcyk7IC8vIFwiaGVsbG9cIlxuICogYGBgXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSByZWNvbW1lbmRlZCBwYXR0ZXJuIGZvciBkZWZpbmluZyBjb2RlY3MgaW4gbGlicmFyaWVzIGlzIHRvIGV4cG9zZSBzZXBhcmF0ZSBmdW5jdGlvbnMgZm9yIHRoZSBlbmNvZGVyLCBkZWNvZGVyLCBhbmQgY29kZWMuXG4gKiBUaGlzIGFsbG93cyB1c2VycyB0byBpbXBvcnQgb25seSB3aGF0IHRoZXkgbmVlZCwgaW1wcm92aW5nIHRyZWUtc2hha2luZyBlZmZpY2llbmN5LlxuICpcbiAqIGBgYHRzXG4gKiB0eXBlIE15VHlwZSA9IFxcLyogLi4uICpcXC87XG4gKiBjb25zdCBnZXRNeVR5cGVFbmNvZGVyID0gKCk6IEVuY29kZXI8TXlUeXBlPiA9PiB7IFxcLyogLi4uICpcXC8gfTtcbiAqIGNvbnN0IGdldE15VHlwZURlY29kZXIgPSAoKTogRGVjb2RlcjxNeVR5cGU+ID0+IHsgXFwvKiAuLi4gKlxcLyB9O1xuICogY29uc3QgZ2V0TXlUeXBlQ29kZWMgPSAoKTogQ29kZWM8TXlUeXBlPiA9PlxuICogICAgIGNvbWJpbmVDb2RlYyhnZXRNeVR5cGVFbmNvZGVyKCksIGdldE15VHlwZURlY29kZXIoKSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBDb2RlY31cbiAqIEBzZWUge0BsaW5rIEVuY29kZXJ9XG4gKiBAc2VlIHtAbGluayBEZWNvZGVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZUNvZGVjPFRGcm9tLCBUVG8gZXh0ZW5kcyBURnJvbSwgVFNpemUgZXh0ZW5kcyBudW1iZXI+KFxuICAgIGVuY29kZXI6IEZpeGVkU2l6ZUVuY29kZXI8VEZyb20sIFRTaXplPixcbiAgICBkZWNvZGVyOiBGaXhlZFNpemVEZWNvZGVyPFRUbywgVFNpemU+LFxuKTogRml4ZWRTaXplQ29kZWM8VEZyb20sIFRUbywgVFNpemU+O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVDb2RlYzxURnJvbSwgVFRvIGV4dGVuZHMgVEZyb20+KFxuICAgIGVuY29kZXI6IFZhcmlhYmxlU2l6ZUVuY29kZXI8VEZyb20+LFxuICAgIGRlY29kZXI6IFZhcmlhYmxlU2l6ZURlY29kZXI8VFRvPixcbik6IFZhcmlhYmxlU2l6ZUNvZGVjPFRGcm9tLCBUVG8+O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVDb2RlYzxURnJvbSwgVFRvIGV4dGVuZHMgVEZyb20+KFxuICAgIGVuY29kZXI6IEVuY29kZXI8VEZyb20+LFxuICAgIGRlY29kZXI6IERlY29kZXI8VFRvPixcbik6IENvZGVjPFRGcm9tLCBUVG8+O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVDb2RlYzxURnJvbSwgVFRvIGV4dGVuZHMgVEZyb20+KFxuICAgIGVuY29kZXI6IEVuY29kZXI8VEZyb20+LFxuICAgIGRlY29kZXI6IERlY29kZXI8VFRvPixcbik6IENvZGVjPFRGcm9tLCBUVG8+IHtcbiAgICBpZiAoaXNGaXhlZFNpemUoZW5jb2RlcikgIT09IGlzRml4ZWRTaXplKGRlY29kZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX1NJWkVfQ09NUEFUSUJJTElUWV9NSVNNQVRDSCk7XG4gICAgfVxuXG4gICAgaWYgKGlzRml4ZWRTaXplKGVuY29kZXIpICYmIGlzRml4ZWRTaXplKGRlY29kZXIpICYmIGVuY29kZXIuZml4ZWRTaXplICE9PSBkZWNvZGVyLmZpeGVkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENILCB7XG4gICAgICAgICAgICBkZWNvZGVyRml4ZWRTaXplOiBkZWNvZGVyLmZpeGVkU2l6ZSxcbiAgICAgICAgICAgIGVuY29kZXJGaXhlZFNpemU6IGVuY29kZXIuZml4ZWRTaXplLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWlzRml4ZWRTaXplKGVuY29kZXIpICYmICFpc0ZpeGVkU2l6ZShkZWNvZGVyKSAmJiBlbmNvZGVyLm1heFNpemUgIT09IGRlY29kZXIubWF4U2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCwge1xuICAgICAgICAgICAgZGVjb2Rlck1heFNpemU6IGRlY29kZXIubWF4U2l6ZSxcbiAgICAgICAgICAgIGVuY29kZXJNYXhTaXplOiBlbmNvZGVyLm1heFNpemUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmRlY29kZXIsXG4gICAgICAgIC4uLmVuY29kZXIsXG4gICAgICAgIGRlY29kZTogZGVjb2Rlci5kZWNvZGUsXG4gICAgICAgIGVuY29kZTogZW5jb2Rlci5lbmNvZGUsXG4gICAgICAgIHJlYWQ6IGRlY29kZXIucmVhZCxcbiAgICAgICAgd3JpdGU6IGVuY29kZXIud3JpdGUsXG4gICAgfTtcbn1cbiIsICJpbXBvcnQge1xuICAgIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUwsXG4gICAgU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFUyxcbiAgICBTb2xhbmFFcnJvcixcbn0gZnJvbSAnQHNvbGFuYS9lcnJvcnMnO1xuXG5pbXBvcnQgeyBjb250YWluc0J5dGVzIH0gZnJvbSAnLi9ieXRlcyc7XG5pbXBvcnQge1xuICAgIENvZGVjLFxuICAgIGNyZWF0ZURlY29kZXIsXG4gICAgY3JlYXRlRW5jb2RlcixcbiAgICBEZWNvZGVyLFxuICAgIEVuY29kZXIsXG4gICAgRml4ZWRTaXplQ29kZWMsXG4gICAgRml4ZWRTaXplRGVjb2RlcixcbiAgICBGaXhlZFNpemVFbmNvZGVyLFxuICAgIGlzRml4ZWRTaXplLFxuICAgIFZhcmlhYmxlU2l6ZUNvZGVjLFxuICAgIFZhcmlhYmxlU2l6ZURlY29kZXIsXG4gICAgVmFyaWFibGVTaXplRW5jb2Rlcixcbn0gZnJvbSAnLi9jb2RlYyc7XG5pbXBvcnQgeyBjb21iaW5lQ29kZWMgfSBmcm9tICcuL2NvbWJpbmUtY29kZWMnO1xuaW1wb3J0IHsgUmVhZG9ubHlVaW50OEFycmF5IH0gZnJvbSAnLi9yZWFkb25seS11aW50OGFycmF5JztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVuY29kZXIgdGhhdCB3cml0ZXMgYSBgVWludDhBcnJheWAgc2VudGluZWwgYWZ0ZXIgdGhlIGVuY29kZWQgdmFsdWUuXG4gKiBUaGlzIGlzIHVzZWZ1bCB0byBkZWxpbWl0IHRoZSBlbmNvZGVkIHZhbHVlIHdoZW4gYmVpbmcgcmVhZCBieSBhIGRlY29kZXIuXG4gKlxuICogU2VlIHtAbGluayBhZGRDb2RlY1NlbnRpbmVsfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAdHlwZVBhcmFtIFRGcm9tIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIGVuY29kZS5cbiAqXG4gKiBAc2VlIHtAbGluayBhZGRDb2RlY1NlbnRpbmVsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkRW5jb2RlclNlbnRpbmVsPFRGcm9tPihcbiAgICBlbmNvZGVyOiBGaXhlZFNpemVFbmNvZGVyPFRGcm9tPixcbiAgICBzZW50aW5lbDogUmVhZG9ubHlVaW50OEFycmF5LFxuKTogRml4ZWRTaXplRW5jb2RlcjxURnJvbT47XG5leHBvcnQgZnVuY3Rpb24gYWRkRW5jb2RlclNlbnRpbmVsPFRGcm9tPihcbiAgICBlbmNvZGVyOiBFbmNvZGVyPFRGcm9tPixcbiAgICBzZW50aW5lbDogUmVhZG9ubHlVaW50OEFycmF5LFxuKTogVmFyaWFibGVTaXplRW5jb2RlcjxURnJvbT47XG5leHBvcnQgZnVuY3Rpb24gYWRkRW5jb2RlclNlbnRpbmVsPFRGcm9tPihlbmNvZGVyOiBFbmNvZGVyPFRGcm9tPiwgc2VudGluZWw6IFJlYWRvbmx5VWludDhBcnJheSk6IEVuY29kZXI8VEZyb20+IHtcbiAgICBjb25zdCB3cml0ZSA9ICgodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgICAgLy8gSGVyZSB3ZSBleGNlcHRpb25hbGx5IHVzZSB0aGUgYGVuY29kZWAgZnVuY3Rpb24gaW5zdGVhZCBvZiB0aGUgYHdyaXRlYFxuICAgICAgICAvLyBmdW5jdGlvbiB0byBjb250YWluIHRoZSBjb250ZW50IG9mIHRoZSBlbmNvZGVyIHdpdGhpbiBpdHMgb3duIGJvdW5kc1xuICAgICAgICAvLyBhbmQgdG8gYXZvaWQgd3JpdGluZyB0aGUgc2VudGluZWwgYXMgcGFydCBvZiB0aGUgZW5jb2RlZCB2YWx1ZS5cbiAgICAgICAgY29uc3QgZW5jb2RlckJ5dGVzID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgICAgICBpZiAoZmluZFNlbnRpbmVsSW5kZXgoZW5jb2RlckJ5dGVzLCBzZW50aW5lbCkgPj0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUwsIHtcbiAgICAgICAgICAgICAgICBlbmNvZGVkQnl0ZXM6IGVuY29kZXJCeXRlcyxcbiAgICAgICAgICAgICAgICBoZXhFbmNvZGVkQnl0ZXM6IGhleEJ5dGVzKGVuY29kZXJCeXRlcyksXG4gICAgICAgICAgICAgICAgaGV4U2VudGluZWw6IGhleEJ5dGVzKHNlbnRpbmVsKSxcbiAgICAgICAgICAgICAgICBzZW50aW5lbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVzLnNldChlbmNvZGVyQnl0ZXMsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBlbmNvZGVyQnl0ZXMubGVuZ3RoO1xuICAgICAgICBieXRlcy5zZXQoc2VudGluZWwsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBzZW50aW5lbC5sZW5ndGg7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfSkgYXMgRW5jb2RlcjxURnJvbT5bJ3dyaXRlJ107XG5cbiAgICBpZiAoaXNGaXhlZFNpemUoZW5jb2RlcikpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoeyAuLi5lbmNvZGVyLCBmaXhlZFNpemU6IGVuY29kZXIuZml4ZWRTaXplICsgc2VudGluZWwubGVuZ3RoLCB3cml0ZSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgICAgIC4uLmVuY29kZXIsXG4gICAgICAgIC4uLihlbmNvZGVyLm1heFNpemUgIT0gbnVsbCA/IHsgbWF4U2l6ZTogZW5jb2Rlci5tYXhTaXplICsgc2VudGluZWwubGVuZ3RoIH0gOiB7fSksXG4gICAgICAgIGdldFNpemVGcm9tVmFsdWU6IHZhbHVlID0+IGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSh2YWx1ZSkgKyBzZW50aW5lbC5sZW5ndGgsXG4gICAgICAgIHdyaXRlLFxuICAgIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWNvZGVyIHRoYXQgY29udGludWVzIHJlYWRpbmcgdW50aWxcbiAqIGEgZ2l2ZW4gYFVpbnQ4QXJyYXlgIHNlbnRpbmVsIGlzIGZvdW5kLlxuICpcbiAqIFNlZSB7QGxpbmsgYWRkQ29kZWNTZW50aW5lbH0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHR5cGVQYXJhbSBUVG8gLSBUaGUgdHlwZSBvZiB0aGUgZGVjb2RlZCB2YWx1ZS5cbiAqXG4gKiBAc2VlIHtAbGluayBhZGRDb2RlY1NlbnRpbmVsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkRGVjb2RlclNlbnRpbmVsPFRUbz4oXG4gICAgZGVjb2RlcjogRml4ZWRTaXplRGVjb2RlcjxUVG8+LFxuICAgIHNlbnRpbmVsOiBSZWFkb25seVVpbnQ4QXJyYXksXG4pOiBGaXhlZFNpemVEZWNvZGVyPFRUbz47XG5leHBvcnQgZnVuY3Rpb24gYWRkRGVjb2RlclNlbnRpbmVsPFRUbz4oZGVjb2RlcjogRGVjb2RlcjxUVG8+LCBzZW50aW5lbDogUmVhZG9ubHlVaW50OEFycmF5KTogVmFyaWFibGVTaXplRGVjb2RlcjxUVG8+O1xuZXhwb3J0IGZ1bmN0aW9uIGFkZERlY29kZXJTZW50aW5lbDxUVG8+KGRlY29kZXI6IERlY29kZXI8VFRvPiwgc2VudGluZWw6IFJlYWRvbmx5VWludDhBcnJheSk6IERlY29kZXI8VFRvPiB7XG4gICAgY29uc3QgcmVhZCA9ICgoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGVCeXRlcyA9IG9mZnNldCA9PT0gMCA/IGJ5dGVzIDogYnl0ZXMuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgY29uc3Qgc2VudGluZWxJbmRleCA9IGZpbmRTZW50aW5lbEluZGV4KGNhbmRpZGF0ZUJ5dGVzLCBzZW50aW5lbCk7XG4gICAgICAgIGlmIChzZW50aW5lbEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19TRU5USU5FTF9NSVNTSU5HX0lOX0RFQ09ERURfQllURVMsIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVkQnl0ZXM6IGNhbmRpZGF0ZUJ5dGVzLFxuICAgICAgICAgICAgICAgIGhleERlY29kZWRCeXRlczogaGV4Qnl0ZXMoY2FuZGlkYXRlQnl0ZXMpLFxuICAgICAgICAgICAgICAgIGhleFNlbnRpbmVsOiBoZXhCeXRlcyhzZW50aW5lbCksXG4gICAgICAgICAgICAgICAgc2VudGluZWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVTZW50aW5lbEJ5dGVzID0gY2FuZGlkYXRlQnl0ZXMuc2xpY2UoMCwgc2VudGluZWxJbmRleCk7XG4gICAgICAgIC8vIEhlcmUgd2UgZXhjZXB0aW9uYWxseSB1c2UgdGhlIGBkZWNvZGVgIGZ1bmN0aW9uIGluc3RlYWQgb2YgdGhlIGByZWFkYFxuICAgICAgICAvLyBmdW5jdGlvbiB0byBjb250YWluIHRoZSBjb250ZW50IG9mIHRoZSBkZWNvZGVyIHdpdGhpbiBpdHMgb3duIGJvdW5kc1xuICAgICAgICAvLyBhbmQgZW5zdXJlIHRoYXQgdGhlIHNlbnRpbmVsIGlzIG5vdCBwYXJ0IG9mIHRoZSBkZWNvZGVkIHZhbHVlLlxuICAgICAgICByZXR1cm4gW2RlY29kZXIuZGVjb2RlKHByZVNlbnRpbmVsQnl0ZXMpLCBvZmZzZXQgKyBwcmVTZW50aW5lbEJ5dGVzLmxlbmd0aCArIHNlbnRpbmVsLmxlbmd0aF07XG4gICAgfSkgYXMgRGVjb2RlcjxUVG8+WydyZWFkJ107XG5cbiAgICBpZiAoaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURlY29kZXIoeyAuLi5kZWNvZGVyLCBmaXhlZFNpemU6IGRlY29kZXIuZml4ZWRTaXplICsgc2VudGluZWwubGVuZ3RoLCByZWFkIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICAgICAgLi4uZGVjb2RlcixcbiAgICAgICAgLi4uKGRlY29kZXIubWF4U2l6ZSAhPSBudWxsID8geyBtYXhTaXplOiBkZWNvZGVyLm1heFNpemUgKyBzZW50aW5lbC5sZW5ndGggfSA6IHt9KSxcbiAgICAgICAgcmVhZCxcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgQ29kZWMgdGhhdCB3cml0ZXMgYSBnaXZlbiBgVWludDhBcnJheWAgc2VudGluZWwgYWZ0ZXIgdGhlIGVuY29kZWRcbiAqIHZhbHVlIGFuZCwgd2hlbiBkZWNvZGluZywgY29udGludWVzIHJlYWRpbmcgdW50aWwgdGhlIHNlbnRpbmVsIGlzIGZvdW5kLlxuICpcbiAqIFRoaXMgc2V0cyBhIGxpbWl0IG9uIHZhcmlhYmxlLXNpemUgY29kZWNzIGFuZCB0ZWxscyB1cyB3aGVuIHRvIHN0b3AgZGVjb2RpbmcuXG4gKlxuICogQHR5cGVQYXJhbSBURnJvbSAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAdHlwZVBhcmFtIFRUbyAtIFRoZSB0eXBlIG9mIHRoZSBkZWNvZGVkIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3QgY29kZWMgPSBhZGRDb2RlY1NlbnRpbmVsKGdldFV0ZjhDb2RlYygpLCBuZXcgVWludDhBcnJheShbMjU1LCAyNTVdKSk7XG4gKiBjb2RlYy5lbmNvZGUoJ2hlbGxvJyk7XG4gKiAvLyAweDY4NjU2YzZjNmZmZmZmXG4gKiAvLyAgIHwgICAgICAgIOKUlC0tIE91ciBzZW50aW5lbC5cbiAqIC8vICAg4pSULS0gT3VyIGVuY29kZWQgc3RyaW5nLlxuICogYGBgXG4gKlxuICogQHJlbWFya3NcbiAqIE5vdGUgdGhhdCB0aGUgc2VudGluZWwgX211c3Qgbm90XyBiZSBwcmVzZW50IGluIHRoZSBlbmNvZGVkIGRhdGEgYW5kXG4gKiBfbXVzdF8gYmUgcHJlc2VudCBpbiB0aGUgZGVjb2RlZCBkYXRhIGZvciB0aGlzIHRvIHdvcmsuXG4gKiBJZiB0aGlzIGlzIG5vdCB0aGUgY2FzZSwgZGVkaWNhdGVkIGVycm9ycyB3aWxsIGJlIHRocm93bi5cbiAqXG4gKiBgYGB0c1xuICogY29uc3Qgc2VudGluZWwgPSBuZXcgVWludDhBcnJheShbMTA4LCAxMDhdKTsgLy8gJ2xsJ1xuICogY29uc3QgY29kZWMgPSBhZGRDb2RlY1NlbnRpbmVsKGdldFV0ZjhDb2RlYygpLCBzZW50aW5lbCk7XG4gKlxuICogY29kZWMuZW5jb2RlKCdoZWxsbycpOyAvLyBUaHJvd3M6IHNlbnRpbmVsIGlzIGluIGVuY29kZWQgZGF0YS5cbiAqIGNvZGVjLmRlY29kZShuZXcgVWludDhBcnJheShbMSwgMiwgM10pKTsgLy8gVGhyb3dzOiBzZW50aW5lbCBtaXNzaW5nIGluIGRlY29kZWQgZGF0YS5cbiAqIGBgYFxuICpcbiAqIFNlcGFyYXRlIHtAbGluayBhZGRFbmNvZGVyU2VudGluZWx9IGFuZCB7QGxpbmsgYWRkRGVjb2RlclNlbnRpbmVsfSBmdW5jdGlvbnMgYXJlIGFsc28gYXZhaWxhYmxlLlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBieXRlcyA9IGFkZEVuY29kZXJTZW50aW5lbChnZXRVdGY4RW5jb2RlcigpLCBzZW50aW5lbCkuZW5jb2RlKCdoZWxsbycpO1xuICogY29uc3QgdmFsdWUgPSBhZGREZWNvZGVyU2VudGluZWwoZ2V0VXRmOERlY29kZXIoKSwgc2VudGluZWwpLmRlY29kZShieXRlcyk7XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBhZGRFbmNvZGVyU2VudGluZWx9XG4gKiBAc2VlIHtAbGluayBhZGREZWNvZGVyU2VudGluZWx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRDb2RlY1NlbnRpbmVsPFRGcm9tLCBUVG8gZXh0ZW5kcyBURnJvbT4oXG4gICAgY29kZWM6IEZpeGVkU2l6ZUNvZGVjPFRGcm9tLCBUVG8+LFxuICAgIHNlbnRpbmVsOiBSZWFkb25seVVpbnQ4QXJyYXksXG4pOiBGaXhlZFNpemVDb2RlYzxURnJvbSwgVFRvPjtcbmV4cG9ydCBmdW5jdGlvbiBhZGRDb2RlY1NlbnRpbmVsPFRGcm9tLCBUVG8gZXh0ZW5kcyBURnJvbT4oXG4gICAgY29kZWM6IENvZGVjPFRGcm9tLCBUVG8+LFxuICAgIHNlbnRpbmVsOiBSZWFkb25seVVpbnQ4QXJyYXksXG4pOiBWYXJpYWJsZVNpemVDb2RlYzxURnJvbSwgVFRvPjtcbmV4cG9ydCBmdW5jdGlvbiBhZGRDb2RlY1NlbnRpbmVsPFRGcm9tLCBUVG8gZXh0ZW5kcyBURnJvbT4oXG4gICAgY29kZWM6IENvZGVjPFRGcm9tLCBUVG8+LFxuICAgIHNlbnRpbmVsOiBSZWFkb25seVVpbnQ4QXJyYXksXG4pOiBDb2RlYzxURnJvbSwgVFRvPiB7XG4gICAgcmV0dXJuIGNvbWJpbmVDb2RlYyhhZGRFbmNvZGVyU2VudGluZWwoY29kZWMsIHNlbnRpbmVsKSwgYWRkRGVjb2RlclNlbnRpbmVsKGNvZGVjLCBzZW50aW5lbCkpO1xufVxuXG5mdW5jdGlvbiBmaW5kU2VudGluZWxJbmRleChieXRlczogUmVhZG9ubHlVaW50OEFycmF5LCBzZW50aW5lbDogUmVhZG9ubHlVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGJ5dGVzLmZpbmRJbmRleCgoYnl0ZSwgaW5kZXgsIGFycikgPT4ge1xuICAgICAgICBpZiAoc2VudGluZWwubGVuZ3RoID09PSAxKSByZXR1cm4gYnl0ZSA9PT0gc2VudGluZWxbMF07XG4gICAgICAgIHJldHVybiBjb250YWluc0J5dGVzKGFyciwgc2VudGluZWwsIGluZGV4KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaGV4Qnl0ZXMoYnl0ZXM6IFJlYWRvbmx5VWludDhBcnJheSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGJ5dGVzLnJlZHVjZSgoc3RyLCBieXRlKSA9PiBzdHIgKyBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpLCAnJyk7XG59XG4iLCAiaW1wb3J0IHtcbiAgICBTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX0RFQ09ERV9FTVBUWV9CWVRFX0FSUkFZLFxuICAgIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0JZVEVfTEVOR1RILFxuICAgIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFLFxuICAgIFNvbGFuYUVycm9yLFxufSBmcm9tICdAc29sYW5hL2Vycm9ycyc7XG5cbmltcG9ydCB7IFJlYWRvbmx5VWludDhBcnJheSB9IGZyb20gJy4vcmVhZG9ubHktdWludDhhcnJheSc7XG5cbi8qKlxuICogQXNzZXJ0cyB0aGF0IGEgZ2l2ZW4gYnl0ZSBhcnJheSBpcyBub3QgZW1wdHkgKGFmdGVyIHRoZSBvcHRpb25hbCBwcm92aWRlZCBvZmZzZXQpLlxuICpcbiAqIFJldHVybnMgdm9pZCBpZiB0aGUgYnl0ZSBhcnJheSBpcyBub3QgZW1wdHkgYnV0IHRocm93cyBhIHtAbGluayBTb2xhbmFFcnJvcn0gb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSBjb2RlY0Rlc2NyaXB0aW9uIC0gQSBkZXNjcmlwdGlvbiBvZiB0aGUgY29kZWMgdXNlZCBieSB0aGUgYXNzZXJ0aW9uIGVycm9yLlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGUgYXJyYXkgdG8gY2hlY2suXG4gKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIG9mZnNldCBmcm9tIHdoaWNoIHRvIHN0YXJ0IGNoZWNraW5nIHRoZSBieXRlIGFycmF5LlxuICogSWYgcHJvdmlkZWQsIHRoZSBieXRlIGFycmF5IGlzIGNvbnNpZGVyZWQgZW1wdHkgaWYgaXQgaGFzIG5vIGJ5dGVzIGFmdGVyIHRoZSBvZmZzZXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KFsweDAxLCAweDAyLCAweDAzXSk7XG4gKiBhc3NlcnRCeXRlQXJyYXlJc05vdEVtcHR5Rm9yQ29kZWMoJ215Q29kZWMnLCBieXRlcyk7IC8vIE9LXG4gKiBhc3NlcnRCeXRlQXJyYXlJc05vdEVtcHR5Rm9yQ29kZWMoJ215Q29kZWMnLCBieXRlcywgMSk7IC8vIE9LXG4gKiBhc3NlcnRCeXRlQXJyYXlJc05vdEVtcHR5Rm9yQ29kZWMoJ215Q29kZWMnLCBieXRlcywgMyk7IC8vIFRocm93c1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRCeXRlQXJyYXlJc05vdEVtcHR5Rm9yQ29kZWMoXG4gICAgY29kZWNEZXNjcmlwdGlvbjogc3RyaW5nLFxuICAgIGJ5dGVzOiBSZWFkb25seVVpbnQ4QXJyYXkgfCBVaW50OEFycmF5LFxuICAgIG9mZnNldCA9IDAsXG4pIHtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoIC0gb2Zmc2V0IDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVksIHtcbiAgICAgICAgICAgIGNvZGVjRGVzY3JpcHRpb24sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBc3NlcnRzIHRoYXQgYSBnaXZlbiBieXRlIGFycmF5IGhhcyBlbm91Z2ggYnl0ZXMgdG8gZGVjb2RlXG4gKiAoYWZ0ZXIgdGhlIG9wdGlvbmFsIHByb3ZpZGVkIG9mZnNldCkuXG4gKlxuICogUmV0dXJucyB2b2lkIGlmIHRoZSBieXRlIGFycmF5IGhhcyBhdCBsZWFzdCB0aGUgZXhwZWN0ZWQgbnVtYmVyXG4gKiBvZiBieXRlcyBidXQgdGhyb3dzIGEge0BsaW5rIFNvbGFuYUVycm9yfSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIGNvZGVjRGVzY3JpcHRpb24gLSBBIGRlc2NyaXB0aW9uIG9mIHRoZSBjb2RlYyB1c2VkIGJ5IHRoZSBhc3NlcnRpb24gZXJyb3IuXG4gKiBAcGFyYW0gZXhwZWN0ZWQgLSBUaGUgbWluaW11bSBudW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgaW4gdGhlIGJ5dGUgYXJyYXkuXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZSBhcnJheSB0byBjaGVjay5cbiAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGZyb20gd2hpY2ggdG8gc3RhcnQgY2hlY2tpbmcgdGhlIGJ5dGUgYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KFsweDAxLCAweDAyLCAweDAzXSk7XG4gKiBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjKCdteUNvZGVjJywgMywgYnl0ZXMpOyAvLyBPS1xuICogYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYygnbXlDb2RlYycsIDQsIGJ5dGVzKTsgLy8gVGhyb3dzXG4gKiBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjKCdteUNvZGVjJywgMiwgYnl0ZXMsIDEpOyAvLyBPS1xuICogYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYygnbXlDb2RlYycsIDMsIGJ5dGVzLCAxKTsgLy8gVGhyb3dzXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMoXG4gICAgY29kZWNEZXNjcmlwdGlvbjogc3RyaW5nLFxuICAgIGV4cGVjdGVkOiBudW1iZXIsXG4gICAgYnl0ZXM6IFJlYWRvbmx5VWludDhBcnJheSB8IFVpbnQ4QXJyYXksXG4gICAgb2Zmc2V0ID0gMCxcbikge1xuICAgIGNvbnN0IGJ5dGVzTGVuZ3RoID0gYnl0ZXMubGVuZ3RoIC0gb2Zmc2V0O1xuICAgIGlmIChieXRlc0xlbmd0aCA8IGV4cGVjdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9CWVRFX0xFTkdUSCwge1xuICAgICAgICAgICAgYnl0ZXNMZW5ndGgsXG4gICAgICAgICAgICBjb2RlY0Rlc2NyaXB0aW9uLFxuICAgICAgICAgICAgZXhwZWN0ZWQsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBc3NlcnRzIHRoYXQgYSBnaXZlbiBvZmZzZXQgaXMgd2l0aGluIHRoZSBieXRlIGFycmF5IGJvdW5kcy5cbiAqIFRoaXMgcmFuZ2UgaXMgYmV0d2VlbiAwIGFuZCB0aGUgYnl0ZSBhcnJheSBsZW5ndGggYW5kIGlzIGluY2x1c2l2ZS5cbiAqIEFuIG9mZnNldCBlcXVhbHMgdG8gdGhlIGJ5dGUgYXJyYXkgbGVuZ3RoIGlzIGNvbnNpZGVyZWQgYSB2YWxpZCBvZmZzZXRcbiAqIGFzIGl0IGFsbG93cyB0aGUgcG9zdC1vZmZzZXQgb2YgY29kZWNzIHRvIHNpZ25hbCB0aGUgZW5kIG9mIHRoZSBieXRlIGFycmF5LlxuICpcbiAqIEBwYXJhbSBjb2RlY0Rlc2NyaXB0aW9uIC0gQSBkZXNjcmlwdGlvbiBvZiB0aGUgY29kZWMgdXNlZCBieSB0aGUgYXNzZXJ0aW9uIGVycm9yLlxuICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgdG8gY2hlY2suXG4gKiBAcGFyYW0gYnl0ZXNMZW5ndGggLSBUaGUgbGVuZ3RoIG9mIHRoZSBieXRlIGFycmF5IGZyb20gd2hpY2ggdGhlIG9mZnNldCBzaG91bGQgYmUgd2l0aGluIGJvdW5kcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDEsIDB4MDIsIDB4MDNdKTtcbiAqIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZSgnbXlDb2RlYycsIDAsIGJ5dGVzLmxlbmd0aCk7IC8vIE9LXG4gKiBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoJ215Q29kZWMnLCAzLCBieXRlcy5sZW5ndGgpOyAvLyBPS1xuICogYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlKCdteUNvZGVjJywgNCwgYnl0ZXMubGVuZ3RoKTsgLy8gVGhyb3dzXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShjb2RlY0Rlc2NyaXB0aW9uOiBzdHJpbmcsIG9mZnNldDogbnVtYmVyLCBieXRlc0xlbmd0aDogbnVtYmVyKSB7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnl0ZXNMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFLCB7XG4gICAgICAgICAgICBieXRlc0xlbmd0aCxcbiAgICAgICAgICAgIGNvZGVjRGVzY3JpcHRpb24sXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjIH0gZnJvbSAnLi9hc3NlcnRpb25zJztcbmltcG9ydCB7XG4gICAgQ29kZWMsXG4gICAgY3JlYXRlRGVjb2RlcixcbiAgICBjcmVhdGVFbmNvZGVyLFxuICAgIERlY29kZXIsXG4gICAgRW5jb2RlcixcbiAgICBGaXhlZFNpemVDb2RlYyxcbiAgICBGaXhlZFNpemVEZWNvZGVyLFxuICAgIEZpeGVkU2l6ZUVuY29kZXIsXG4gICAgZ2V0RW5jb2RlZFNpemUsXG4gICAgaXNGaXhlZFNpemUsXG4gICAgVmFyaWFibGVTaXplQ29kZWMsXG4gICAgVmFyaWFibGVTaXplRGVjb2RlcixcbiAgICBWYXJpYWJsZVNpemVFbmNvZGVyLFxufSBmcm9tICcuL2NvZGVjJztcbmltcG9ydCB7IGNvbWJpbmVDb2RlYyB9IGZyb20gJy4vY29tYmluZS1jb2RlYyc7XG5cbnR5cGUgTnVtYmVyRW5jb2RlciA9IEVuY29kZXI8YmlnaW50IHwgbnVtYmVyPiB8IEVuY29kZXI8bnVtYmVyPjtcbnR5cGUgRml4ZWRTaXplTnVtYmVyRW5jb2RlcjxUU2l6ZSBleHRlbmRzIG51bWJlciA9IG51bWJlcj4gPVxuICAgIHwgRml4ZWRTaXplRW5jb2RlcjxiaWdpbnQgfCBudW1iZXIsIFRTaXplPlxuICAgIHwgRml4ZWRTaXplRW5jb2RlcjxudW1iZXIsIFRTaXplPjtcbnR5cGUgTnVtYmVyRGVjb2RlciA9IERlY29kZXI8YmlnaW50PiB8IERlY29kZXI8bnVtYmVyPjtcbnR5cGUgRml4ZWRTaXplTnVtYmVyRGVjb2RlcjxUU2l6ZSBleHRlbmRzIG51bWJlciA9IG51bWJlcj4gPVxuICAgIHwgRml4ZWRTaXplRGVjb2RlcjxiaWdpbnQsIFRTaXplPlxuICAgIHwgRml4ZWRTaXplRGVjb2RlcjxudW1iZXIsIFRTaXplPjtcbnR5cGUgTnVtYmVyQ29kZWMgPSBDb2RlYzxiaWdpbnQgfCBudW1iZXIsIGJpZ2ludD4gfCBDb2RlYzxudW1iZXI+O1xudHlwZSBGaXhlZFNpemVOdW1iZXJDb2RlYzxUU2l6ZSBleHRlbmRzIG51bWJlciA9IG51bWJlcj4gPVxuICAgIHwgRml4ZWRTaXplQ29kZWM8YmlnaW50IHwgbnVtYmVyLCBiaWdpbnQsIFRTaXplPlxuICAgIHwgRml4ZWRTaXplQ29kZWM8bnVtYmVyLCBudW1iZXIsIFRTaXplPjtcblxuLyoqXG4gKiBTdG9yZXMgdGhlIHNpemUgb2YgdGhlIGBlbmNvZGVyYCBpbiBieXRlcyBhcyBhIHByZWZpeCB1c2luZyB0aGUgYHByZWZpeGAgZW5jb2Rlci5cbiAqXG4gKiBTZWUge0BsaW5rIGFkZENvZGVjU2l6ZVByZWZpeH0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHR5cGVQYXJhbSBURnJvbSAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBlbmNvZGUuXG4gKlxuICogQHNlZSB7QGxpbmsgYWRkQ29kZWNTaXplUHJlZml4fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkRW5jb2RlclNpemVQcmVmaXg8VEZyb20+KFxuICAgIGVuY29kZXI6IEZpeGVkU2l6ZUVuY29kZXI8VEZyb20+LFxuICAgIHByZWZpeDogRml4ZWRTaXplTnVtYmVyRW5jb2Rlcixcbik6IEZpeGVkU2l6ZUVuY29kZXI8VEZyb20+O1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEVuY29kZXJTaXplUHJlZml4PFRGcm9tPihlbmNvZGVyOiBFbmNvZGVyPFRGcm9tPiwgcHJlZml4OiBOdW1iZXJFbmNvZGVyKTogVmFyaWFibGVTaXplRW5jb2RlcjxURnJvbT47XG5leHBvcnQgZnVuY3Rpb24gYWRkRW5jb2RlclNpemVQcmVmaXg8VEZyb20+KGVuY29kZXI6IEVuY29kZXI8VEZyb20+LCBwcmVmaXg6IE51bWJlckVuY29kZXIpOiBFbmNvZGVyPFRGcm9tPiB7XG4gICAgY29uc3Qgd3JpdGUgPSAoKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICAgIC8vIEhlcmUgd2UgZXhjZXB0aW9uYWxseSB1c2UgdGhlIGBlbmNvZGVgIGZ1bmN0aW9uIGluc3RlYWQgb2YgdGhlIGB3cml0ZWBcbiAgICAgICAgLy8gZnVuY3Rpb24gdG8gY29udGFpbiB0aGUgY29udGVudCBvZiB0aGUgZW5jb2RlciB3aXRoaW4gaXRzIG93biBib3VuZHMuXG4gICAgICAgIGNvbnN0IGVuY29kZXJCeXRlcyA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgb2Zmc2V0ID0gcHJlZml4LndyaXRlKGVuY29kZXJCeXRlcy5sZW5ndGgsIGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgICBieXRlcy5zZXQoZW5jb2RlckJ5dGVzLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgZW5jb2RlckJ5dGVzLmxlbmd0aDtcbiAgICB9KSBhcyBFbmNvZGVyPFRGcm9tPlsnd3JpdGUnXTtcblxuICAgIGlmIChpc0ZpeGVkU2l6ZShwcmVmaXgpICYmIGlzRml4ZWRTaXplKGVuY29kZXIpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbmNvZGVyKHsgLi4uZW5jb2RlciwgZml4ZWRTaXplOiBwcmVmaXguZml4ZWRTaXplICsgZW5jb2Rlci5maXhlZFNpemUsIHdyaXRlIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHByZWZpeE1heFNpemUgPSBpc0ZpeGVkU2l6ZShwcmVmaXgpID8gcHJlZml4LmZpeGVkU2l6ZSA6IChwcmVmaXgubWF4U2l6ZSA/PyBudWxsKTtcbiAgICBjb25zdCBlbmNvZGVyTWF4U2l6ZSA9IGlzRml4ZWRTaXplKGVuY29kZXIpID8gZW5jb2Rlci5maXhlZFNpemUgOiAoZW5jb2Rlci5tYXhTaXplID8/IG51bGwpO1xuICAgIGNvbnN0IG1heFNpemUgPSBwcmVmaXhNYXhTaXplICE9PSBudWxsICYmIGVuY29kZXJNYXhTaXplICE9PSBudWxsID8gcHJlZml4TWF4U2l6ZSArIGVuY29kZXJNYXhTaXplIDogbnVsbDtcblxuICAgIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAgICAgLi4uZW5jb2RlcixcbiAgICAgICAgLi4uKG1heFNpemUgIT09IG51bGwgPyB7IG1heFNpemUgfSA6IHt9KSxcbiAgICAgICAgZ2V0U2l6ZUZyb21WYWx1ZTogdmFsdWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlclNpemUgPSBnZXRFbmNvZGVkU2l6ZSh2YWx1ZSwgZW5jb2Rlcik7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RW5jb2RlZFNpemUoZW5jb2RlclNpemUsIHByZWZpeCkgKyBlbmNvZGVyU2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGUsXG4gICAgfSk7XG59XG5cbi8qKlxuICogQm91bmRzIHRoZSBzaXplIG9mIHRoZSBuZXN0ZWQgYGRlY29kZXJgIGJ5IHJlYWRpbmcgaXRzIGVuY29kZWQgYHByZWZpeGAuXG4gKlxuICogU2VlIHtAbGluayBhZGRDb2RlY1NpemVQcmVmaXh9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEB0eXBlUGFyYW0gVFRvIC0gVGhlIHR5cGUgb2YgdGhlIGRlY29kZWQgdmFsdWUuXG4gKlxuICogQHNlZSB7QGxpbmsgYWRkQ29kZWNTaXplUHJlZml4fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkRGVjb2RlclNpemVQcmVmaXg8VFRvPihcbiAgICBkZWNvZGVyOiBGaXhlZFNpemVEZWNvZGVyPFRUbz4sXG4gICAgcHJlZml4OiBGaXhlZFNpemVOdW1iZXJEZWNvZGVyLFxuKTogRml4ZWRTaXplRGVjb2RlcjxUVG8+O1xuZXhwb3J0IGZ1bmN0aW9uIGFkZERlY29kZXJTaXplUHJlZml4PFRUbz4oZGVjb2RlcjogRGVjb2RlcjxUVG8+LCBwcmVmaXg6IE51bWJlckRlY29kZXIpOiBWYXJpYWJsZVNpemVEZWNvZGVyPFRUbz47XG5leHBvcnQgZnVuY3Rpb24gYWRkRGVjb2RlclNpemVQcmVmaXg8VFRvPihkZWNvZGVyOiBEZWNvZGVyPFRUbz4sIHByZWZpeDogTnVtYmVyRGVjb2Rlcik6IERlY29kZXI8VFRvPiB7XG4gICAgY29uc3QgcmVhZCA9ICgoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgICBjb25zdCBbYmlnaW50U2l6ZSwgZGVjb2Rlck9mZnNldF0gPSBwcmVmaXgucmVhZChieXRlcywgb2Zmc2V0KTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IE51bWJlcihiaWdpbnRTaXplKTtcbiAgICAgICAgb2Zmc2V0ID0gZGVjb2Rlck9mZnNldDtcbiAgICAgICAgLy8gU2xpY2UgdGhlIGJ5dGUgYXJyYXkgdG8gdGhlIGNvbnRhaW5lZCBzaXplIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgaWYgKG9mZnNldCA+IDAgfHwgYnl0ZXMubGVuZ3RoID4gc2l6ZSkge1xuICAgICAgICAgICAgYnl0ZXMgPSBieXRlcy5zbGljZShvZmZzZXQsIG9mZnNldCArIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMoJ2FkZERlY29kZXJTaXplUHJlZml4Jywgc2l6ZSwgYnl0ZXMpO1xuICAgICAgICAvLyBIZXJlIHdlIGV4Y2VwdGlvbmFsbHkgdXNlIHRoZSBgZGVjb2RlYCBmdW5jdGlvbiBpbnN0ZWFkIG9mIHRoZSBgcmVhZGBcbiAgICAgICAgLy8gZnVuY3Rpb24gdG8gY29udGFpbiB0aGUgY29udGVudCBvZiB0aGUgZGVjb2RlciB3aXRoaW4gaXRzIG93biBib3VuZHMuXG4gICAgICAgIHJldHVybiBbZGVjb2Rlci5kZWNvZGUoYnl0ZXMpLCBvZmZzZXQgKyBzaXplXTtcbiAgICB9KSBhcyBEZWNvZGVyPFRUbz5bJ3JlYWQnXTtcblxuICAgIGlmIChpc0ZpeGVkU2l6ZShwcmVmaXgpICYmIGlzRml4ZWRTaXplKGRlY29kZXIpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEZWNvZGVyKHsgLi4uZGVjb2RlciwgZml4ZWRTaXplOiBwcmVmaXguZml4ZWRTaXplICsgZGVjb2Rlci5maXhlZFNpemUsIHJlYWQgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJlZml4TWF4U2l6ZSA9IGlzRml4ZWRTaXplKHByZWZpeCkgPyBwcmVmaXguZml4ZWRTaXplIDogKHByZWZpeC5tYXhTaXplID8/IG51bGwpO1xuICAgIGNvbnN0IGRlY29kZXJNYXhTaXplID0gaXNGaXhlZFNpemUoZGVjb2RlcikgPyBkZWNvZGVyLmZpeGVkU2l6ZSA6IChkZWNvZGVyLm1heFNpemUgPz8gbnVsbCk7XG4gICAgY29uc3QgbWF4U2l6ZSA9IHByZWZpeE1heFNpemUgIT09IG51bGwgJiYgZGVjb2Rlck1heFNpemUgIT09IG51bGwgPyBwcmVmaXhNYXhTaXplICsgZGVjb2Rlck1heFNpemUgOiBudWxsO1xuICAgIHJldHVybiBjcmVhdGVEZWNvZGVyKHsgLi4uZGVjb2RlciwgLi4uKG1heFNpemUgIT09IG51bGwgPyB7IG1heFNpemUgfSA6IHt9KSwgcmVhZCB9KTtcbn1cblxuLyoqXG4gKiBTdG9yZXMgdGhlIGJ5dGUgc2l6ZSBvZiBhbnkgZ2l2ZW4gY29kZWMgYXMgYW4gZW5jb2RlZCBudW1iZXIgcHJlZml4LlxuICpcbiAqIFRoaXMgc2V0cyBhIGxpbWl0IG9uIHZhcmlhYmxlLXNpemUgY29kZWNzIGFuZCB0ZWxscyB1cyB3aGVuIHRvIHN0b3AgZGVjb2RpbmcuXG4gKiBXaGVuIGVuY29kaW5nLCB0aGUgc2l6ZSBvZiB0aGUgZW5jb2RlZCBkYXRhIGlzIHN0b3JlZCBiZWZvcmUgdGhlIGVuY29kZWQgZGF0YSBpdHNlbGYuXG4gKiBXaGVuIGRlY29kaW5nLCB0aGUgc2l6ZSBpcyByZWFkIGZpcnN0IHRvIGtub3cgaG93IG1hbnkgYnl0ZXMgdG8gcmVhZCBuZXh0LlxuICpcbiAqIEB0eXBlUGFyYW0gVEZyb20gLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gZW5jb2RlLlxuICogQHR5cGVQYXJhbSBUVG8gLSBUaGUgdHlwZSBvZiB0aGUgZGVjb2RlZCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogRm9yIGV4YW1wbGUsIHNheSB3ZSB3YW50IHRvIGJvdW5kIGEgdmFyaWFibGUtc2l6ZSBiYXNlLTU4IHN0cmluZyB1c2luZyBhIGB1MzJgIHNpemUgcHJlZml4LlxuICogSGVyZeKAmXMgaG93IHlvdSBjYW4gdXNlIHRoZSBgYWRkQ29kZWNTaXplUHJlZml4YCBmdW5jdGlvbiB0byBhY2hpZXZlIHRoYXQuXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IGdldFUzMkJhc2U1OENvZGVjID0gKCkgPT4gYWRkQ29kZWNTaXplUHJlZml4KGdldEJhc2U1OENvZGVjKCksIGdldFUzMkNvZGVjKCkpO1xuICpcbiAqIGdldFUzMkJhc2U1OENvZGVjKCkuZW5jb2RlKCdoZWxsbyB3b3JsZCcpO1xuICogLy8gMHgwYjAwMDAwMDY4NjU2YzZjNmYyMDc3NmY3MjZjNjRcbiAqIC8vICAgfCAgICAgICDilJQtLSBPdXIgZW5jb2RlZCBiYXNlLTU4IHN0cmluZy5cbiAqIC8vICAg4pSULS0gT3VyIGVuY29kZWQgdTMyIHNpemUgcHJlZml4LlxuICogYGBgXG4gKlxuICogQHJlbWFya3NcbiAqIFNlcGFyYXRlIHtAbGluayBhZGRFbmNvZGVyU2l6ZVByZWZpeH0gYW5kIHtAbGluayBhZGREZWNvZGVyU2l6ZVByZWZpeH0gZnVuY3Rpb25zIGFyZSBhbHNvIGF2YWlsYWJsZS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgYnl0ZXMgPSBhZGRFbmNvZGVyU2l6ZVByZWZpeChnZXRCYXNlNThFbmNvZGVyKCksIGdldFUzMkVuY29kZXIoKSkuZW5jb2RlKCdoZWxsbycpO1xuICogY29uc3QgdmFsdWUgPSBhZGREZWNvZGVyU2l6ZVByZWZpeChnZXRCYXNlNThEZWNvZGVyKCksIGdldFUzMkRlY29kZXIoKSkuZGVjb2RlKGJ5dGVzKTtcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGFkZEVuY29kZXJTaXplUHJlZml4fVxuICogQHNlZSB7QGxpbmsgYWRkRGVjb2RlclNpemVQcmVmaXh9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRDb2RlY1NpemVQcmVmaXg8VEZyb20sIFRUbyBleHRlbmRzIFRGcm9tPihcbiAgICBjb2RlYzogRml4ZWRTaXplQ29kZWM8VEZyb20sIFRUbz4sXG4gICAgcHJlZml4OiBGaXhlZFNpemVOdW1iZXJDb2RlYyxcbik6IEZpeGVkU2l6ZUNvZGVjPFRGcm9tLCBUVG8+O1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENvZGVjU2l6ZVByZWZpeDxURnJvbSwgVFRvIGV4dGVuZHMgVEZyb20+KFxuICAgIGNvZGVjOiBDb2RlYzxURnJvbSwgVFRvPixcbiAgICBwcmVmaXg6IE51bWJlckNvZGVjLFxuKTogVmFyaWFibGVTaXplQ29kZWM8VEZyb20sIFRUbz47XG5leHBvcnQgZnVuY3Rpb24gYWRkQ29kZWNTaXplUHJlZml4PFRGcm9tLCBUVG8gZXh0ZW5kcyBURnJvbT4oXG4gICAgY29kZWM6IENvZGVjPFRGcm9tLCBUVG8+LFxuICAgIHByZWZpeDogTnVtYmVyQ29kZWMsXG4pOiBDb2RlYzxURnJvbSwgVFRvPiB7XG4gICAgcmV0dXJuIGNvbWJpbmVDb2RlYyhhZGRFbmNvZGVyU2l6ZVByZWZpeChjb2RlYywgcHJlZml4KSwgYWRkRGVjb2RlclNpemVQcmVmaXgoY29kZWMsIHByZWZpeCkpO1xufVxuIiwgImltcG9ydCB7IGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMgfSBmcm9tICcuL2Fzc2VydGlvbnMnO1xuaW1wb3J0IHsgZml4Qnl0ZXMgfSBmcm9tICcuL2J5dGVzJztcbmltcG9ydCB7XG4gICAgQ29kZWMsXG4gICAgY3JlYXRlRGVjb2RlcixcbiAgICBjcmVhdGVFbmNvZGVyLFxuICAgIERlY29kZXIsXG4gICAgRW5jb2RlcixcbiAgICBGaXhlZFNpemVDb2RlYyxcbiAgICBGaXhlZFNpemVEZWNvZGVyLFxuICAgIEZpeGVkU2l6ZUVuY29kZXIsXG4gICAgaXNGaXhlZFNpemUsXG4gICAgT2Zmc2V0LFxufSBmcm9tICcuL2NvZGVjJztcbmltcG9ydCB7IGNvbWJpbmVDb2RlYyB9IGZyb20gJy4vY29tYmluZS1jb2RlYyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZpeGVkLXNpemUgZW5jb2RlciBmcm9tIGEgZ2l2ZW4gZW5jb2Rlci5cbiAqXG4gKiBUaGUgcmVzdWx0aW5nIGVuY29kZXIgZW5zdXJlcyB0aGF0IGVuY29kZWQgdmFsdWVzIGFsd2F5cyBoYXZlIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJ5dGVzLlxuICogSWYgdGhlIG9yaWdpbmFsIGVuY29kZWQgdmFsdWUgaXMgbGFyZ2VyIHRoYW4gYGZpeGVkQnl0ZXNgLCBpdCBpcyB0cnVuY2F0ZWQuXG4gKiBJZiBpdCBpcyBzbWFsbGVyLCBpdCBpcyBwYWRkZWQgd2l0aCB0cmFpbGluZyB6ZXJvZXMuXG4gKlxuICogRm9yIG1vcmUgZGV0YWlscywgc2VlIHtAbGluayBmaXhDb2RlY1NpemV9LlxuICpcbiAqIEB0eXBlUGFyYW0gVEZyb20gLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gZW5jb2RlLlxuICogQHR5cGVQYXJhbSBUU2l6ZSAtIFRoZSBmaXhlZCBzaXplIG9mIHRoZSBlbmNvZGVkIHZhbHVlIGluIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBlbmNvZGVyIC0gVGhlIGVuY29kZXIgdG8gd3JhcCBpbnRvIGEgZml4ZWQtc2l6ZSBlbmNvZGVyLlxuICogQHBhcmFtIGZpeGVkQnl0ZXMgLSBUaGUgZml4ZWQgbnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlLlxuICogQHJldHVybnMgQSBgRml4ZWRTaXplRW5jb2RlcmAgdGhhdCBlbnN1cmVzIGEgY29uc2lzdGVudCBvdXRwdXQgc2l6ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGVuY29kZXIgPSBmaXhFbmNvZGVyU2l6ZShnZXRVdGY4RW5jb2RlcigpLCA0KTtcbiAqIGVuY29kZXIuZW5jb2RlKFwiSGVsbG9cIik7IC8vIDB4NDg2NTZjNmMgKHRydW5jYXRlZClcbiAqIGVuY29kZXIuZW5jb2RlKFwiSGlcIik7ICAgIC8vIDB4NDg2OTAwMDAgKHBhZGRlZClcbiAqIGVuY29kZXIuZW5jb2RlKFwiSGl5YVwiKTsgIC8vIDB4NDg2OTc5NjEgKHNhbWUgbGVuZ3RoKVxuICogYGBgXG4gKlxuICogQHJlbWFya3NcbiAqIElmIHlvdSBuZWVkIGEgZnVsbCBjb2RlYyB3aXRoIGJvdGggZW5jb2RpbmcgYW5kIGRlY29kaW5nLCB1c2Uge0BsaW5rIGZpeENvZGVjU2l6ZX0uXG4gKlxuICogQHNlZSB7QGxpbmsgZml4Q29kZWNTaXplfVxuICogQHNlZSB7QGxpbmsgZml4RGVjb2RlclNpemV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXhFbmNvZGVyU2l6ZTxURnJvbSwgVFNpemUgZXh0ZW5kcyBudW1iZXI+KFxuICAgIGVuY29kZXI6IEVuY29kZXI8VEZyb20+LFxuICAgIGZpeGVkQnl0ZXM6IFRTaXplLFxuKTogRml4ZWRTaXplRW5jb2RlcjxURnJvbSwgVFNpemU+IHtcbiAgICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgICAgIGZpeGVkU2l6ZTogZml4ZWRCeXRlcyxcbiAgICAgICAgd3JpdGU6ICh2YWx1ZTogVEZyb20sIGJ5dGVzOiBVaW50OEFycmF5LCBvZmZzZXQ6IE9mZnNldCkgPT4ge1xuICAgICAgICAgICAgLy8gSGVyZSB3ZSBleGNlcHRpb25hbGx5IHVzZSB0aGUgYGVuY29kZWAgZnVuY3Rpb24gaW5zdGVhZCBvZiB0aGUgYHdyaXRlYFxuICAgICAgICAgICAgLy8gZnVuY3Rpb24gYXMgdXNpbmcgdGhlIG5lc3RlZCBgd3JpdGVgIGZ1bmN0aW9uIG9uIGEgZml4ZWQtc2l6ZWQgYnl0ZVxuICAgICAgICAgICAgLy8gYXJyYXkgbWF5IHJlc3VsdCBpbiBhIG91dC1vZi1ib3VuZHMgZXJyb3Igb24gdGhlIG5lc3RlZCBlbmNvZGVyLlxuICAgICAgICAgICAgY29uc3QgdmFyaWFibGVCeXRlQXJyYXkgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBmaXhlZEJ5dGVBcnJheSA9XG4gICAgICAgICAgICAgICAgdmFyaWFibGVCeXRlQXJyYXkubGVuZ3RoID4gZml4ZWRCeXRlcyA/IHZhcmlhYmxlQnl0ZUFycmF5LnNsaWNlKDAsIGZpeGVkQnl0ZXMpIDogdmFyaWFibGVCeXRlQXJyYXk7XG4gICAgICAgICAgICBieXRlcy5zZXQoZml4ZWRCeXRlQXJyYXksIG9mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0ICsgZml4ZWRCeXRlcztcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZml4ZWQtc2l6ZSBkZWNvZGVyIGZyb20gYSBnaXZlbiBkZWNvZGVyLlxuICpcbiAqIFRoZSByZXN1bHRpbmcgZGVjb2RlciBhbHdheXMgcmVhZHMgZXhhY3RseSBgZml4ZWRCeXRlc2AgYnl0ZXMgZnJvbSB0aGUgaW5wdXQuXG4gKiBJZiB0aGUgbmVzdGVkIGRlY29kZXIgaXMgYWxzbyBmaXhlZC1zaXplLCB0aGUgYnl0ZXMgYXJlIHRydW5jYXRlZCBvciBwYWRkZWQgYXMgbmVlZGVkLlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB7QGxpbmsgZml4Q29kZWNTaXplfS5cbiAqXG4gKiBAdHlwZVBhcmFtIFRUbyAtIFRoZSB0eXBlIG9mIHRoZSBkZWNvZGVkIHZhbHVlLlxuICogQHR5cGVQYXJhbSBUU2l6ZSAtIFRoZSBmaXhlZCBzaXplIG9mIHRoZSBlbmNvZGVkIHZhbHVlIGluIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBkZWNvZGVyIC0gVGhlIGRlY29kZXIgdG8gd3JhcCBpbnRvIGEgZml4ZWQtc2l6ZSBkZWNvZGVyLlxuICogQHBhcmFtIGZpeGVkQnl0ZXMgLSBUaGUgZml4ZWQgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gKiBAcmV0dXJucyBBIGBGaXhlZFNpemVEZWNvZGVyYCB0aGF0IGVuc3VyZXMgYSBjb25zaXN0ZW50IGlucHV0IHNpemUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBkZWNvZGVyID0gZml4RGVjb2RlclNpemUoZ2V0VXRmOERlY29kZXIoKSwgNCk7XG4gKiBkZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMV0pKTsgLy8gXCJIZWxsXCIgKHRydW5jYXRlZClcbiAqIGRlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KFs3MiwgMTA1LCAwLCAwXSkpOyAgICAgICAgICAvLyBcIkhpXCIgKHplcm9lcyBpZ25vcmVkKVxuICogZGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoWzcyLCAxMDUsIDEyMSwgOTddKSk7ICAgICAgIC8vIFwiSGl5YVwiIChzYW1lIGxlbmd0aClcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKiBJZiB5b3UgbmVlZCBhIGZ1bGwgY29kZWMgd2l0aCBib3RoIGVuY29kaW5nIGFuZCBkZWNvZGluZywgdXNlIHtAbGluayBmaXhDb2RlY1NpemV9LlxuICpcbiAqIEBzZWUge0BsaW5rIGZpeENvZGVjU2l6ZX1cbiAqIEBzZWUge0BsaW5rIGZpeEVuY29kZXJTaXplfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZml4RGVjb2RlclNpemU8VFRvLCBUU2l6ZSBleHRlbmRzIG51bWJlcj4oXG4gICAgZGVjb2RlcjogRGVjb2RlcjxUVG8+LFxuICAgIGZpeGVkQnl0ZXM6IFRTaXplLFxuKTogRml4ZWRTaXplRGVjb2RlcjxUVG8sIFRTaXplPiB7XG4gICAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgICAgICBmaXhlZFNpemU6IGZpeGVkQnl0ZXMsXG4gICAgICAgIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjKCdmaXhDb2RlY1NpemUnLCBmaXhlZEJ5dGVzLCBieXRlcywgb2Zmc2V0KTtcbiAgICAgICAgICAgIC8vIFNsaWNlIHRoZSBieXRlIGFycmF5IHRvIHRoZSBmaXhlZCBzaXplIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiAwIHx8IGJ5dGVzLmxlbmd0aCA+IGZpeGVkQnl0ZXMpIHtcbiAgICAgICAgICAgICAgICBieXRlcyA9IGJ5dGVzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZml4ZWRCeXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgbmVzdGVkIGRlY29kZXIgaXMgZml4ZWQtc2l6ZSwgcGFkIGFuZCB0cnVuY2F0ZSB0aGUgYnl0ZSBhcnJheSBhY2NvcmRpbmdseS5cbiAgICAgICAgICAgIGlmIChpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgICAgICAgICAgICAgIGJ5dGVzID0gZml4Qnl0ZXMoYnl0ZXMsIGRlY29kZXIuZml4ZWRTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlY29kZSB0aGUgdmFsdWUgdXNpbmcgdGhlIG5lc3RlZCBkZWNvZGVyLlxuICAgICAgICAgICAgY29uc3QgW3ZhbHVlXSA9IGRlY29kZXIucmVhZChieXRlcywgMCk7XG4gICAgICAgICAgICByZXR1cm4gW3ZhbHVlLCBvZmZzZXQgKyBmaXhlZEJ5dGVzXTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZml4ZWQtc2l6ZSBjb2RlYyBmcm9tIGEgZ2l2ZW4gY29kZWMuXG4gKlxuICogVGhlIHJlc3VsdGluZyBjb2RlYyBlbnN1cmVzIHRoYXQgYm90aCBlbmNvZGluZyBhbmQgZGVjb2Rpbmcgb3BlcmF0ZSBvbiBhIGZpeGVkIG51bWJlciBvZiBieXRlcy5cbiAqIFdoZW4gZW5jb2Rpbmc6XG4gKiAtIElmIHRoZSBlbmNvZGVkIHZhbHVlIGlzIGxhcmdlciB0aGFuIGBmaXhlZEJ5dGVzYCwgaXQgaXMgdHJ1bmNhdGVkLlxuICogLSBJZiBpdCBpcyBzbWFsbGVyLCBpdCBpcyBwYWRkZWQgd2l0aCB0cmFpbGluZyB6ZXJvZXMuXG4gKiAtIElmIGl0IGlzIGV4YWN0bHkgYGZpeGVkQnl0ZXNgLCBpdCByZW1haW5zIHVuY2hhbmdlZC5cbiAqXG4gKiBXaGVuIGRlY29kaW5nOlxuICogLSBFeGFjdGx5IGBmaXhlZEJ5dGVzYCBieXRlcyBhcmUgcmVhZCBmcm9tIHRoZSBpbnB1dC5cbiAqIC0gSWYgdGhlIG5lc3RlZCBkZWNvZGVyIGhhcyBhIHNtYWxsZXIgZml4ZWQgc2l6ZSwgYnl0ZXMgYXJlIHRydW5jYXRlZCBvciBwYWRkZWQgYXMgbmVjZXNzYXJ5LlxuICpcbiAqIEB0eXBlUGFyYW0gVEZyb20gLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gZW5jb2RlLlxuICogQHR5cGVQYXJhbSBUVG8gLSBUaGUgdHlwZSBvZiB0aGUgZGVjb2RlZCB2YWx1ZS5cbiAqIEB0eXBlUGFyYW0gVFNpemUgLSBUaGUgZml4ZWQgc2l6ZSBvZiB0aGUgZW5jb2RlZCB2YWx1ZSBpbiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gY29kZWMgLSBUaGUgY29kZWMgdG8gd3JhcCBpbnRvIGEgZml4ZWQtc2l6ZSBjb2RlYy5cbiAqIEBwYXJhbSBmaXhlZEJ5dGVzIC0gVGhlIGZpeGVkIG51bWJlciBvZiBieXRlcyB0byByZWFkL3dyaXRlLlxuICogQHJldHVybnMgQSBgRml4ZWRTaXplQ29kZWNgIHRoYXQgZW5zdXJlcyBib3RoIGVuY29kaW5nIGFuZCBkZWNvZGluZyBjb25mb3JtIHRvIGEgZml4ZWQgc2l6ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGNvZGVjID0gZml4Q29kZWNTaXplKGdldFV0ZjhDb2RlYygpLCA0KTtcbiAqXG4gKiBjb25zdCBieXRlczEgPSBjb2RlYy5lbmNvZGUoXCJIZWxsb1wiKTsgLy8gMHg0ODY1NmM2YyAodHJ1bmNhdGVkKVxuICogY29uc3QgdmFsdWUxID0gY29kZWMuZGVjb2RlKGJ5dGVzMSk7ICAvLyBcIkhlbGxcIlxuICpcbiAqIGNvbnN0IGJ5dGVzMiA9IGNvZGVjLmVuY29kZShcIkhpXCIpOyAgICAvLyAweDQ4NjkwMDAwIChwYWRkZWQpXG4gKiBjb25zdCB2YWx1ZTIgPSBjb2RlYy5kZWNvZGUoYnl0ZXMyKTsgIC8vIFwiSGlcIlxuICpcbiAqIGNvbnN0IGJ5dGVzMyA9IGNvZGVjLmVuY29kZShcIkhpeWFcIik7ICAvLyAweDQ4Njk3OTYxIChzYW1lIGxlbmd0aClcbiAqIGNvbnN0IHZhbHVlMyA9IGNvZGVjLmRlY29kZShieXRlczMpOyAgLy8gXCJIaXlhXCJcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKiBJZiB5b3Ugb25seSBuZWVkIHRvIGVuZm9yY2UgYSBmaXhlZCBzaXplIGZvciBlbmNvZGluZywgdXNlIHtAbGluayBmaXhFbmNvZGVyU2l6ZX0uXG4gKiBJZiB5b3Ugb25seSBuZWVkIHRvIGVuZm9yY2UgYSBmaXhlZCBzaXplIGZvciBkZWNvZGluZywgdXNlIHtAbGluayBmaXhEZWNvZGVyU2l6ZX0uXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IGJ5dGVzID0gZml4RW5jb2RlclNpemUoZ2V0VXRmOEVuY29kZXIoKSwgNCkuZW5jb2RlKFwiSGl5YVwiKTtcbiAqIGNvbnN0IHZhbHVlID0gZml4RGVjb2RlclNpemUoZ2V0VXRmOERlY29kZXIoKSwgNCkuZGVjb2RlKGJ5dGVzKTtcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGZpeEVuY29kZXJTaXplfVxuICogQHNlZSB7QGxpbmsgZml4RGVjb2RlclNpemV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXhDb2RlY1NpemU8VEZyb20sIFRUbyBleHRlbmRzIFRGcm9tLCBUU2l6ZSBleHRlbmRzIG51bWJlcj4oXG4gICAgY29kZWM6IENvZGVjPFRGcm9tLCBUVG8+LFxuICAgIGZpeGVkQnl0ZXM6IFRTaXplLFxuKTogRml4ZWRTaXplQ29kZWM8VEZyb20sIFRUbywgVFNpemU+IHtcbiAgICByZXR1cm4gY29tYmluZUNvZGVjKGZpeEVuY29kZXJTaXplKGNvZGVjLCBmaXhlZEJ5dGVzKSwgZml4RGVjb2RlclNpemUoY29kZWMsIGZpeGVkQnl0ZXMpKTtcbn1cbiIsICJpbXBvcnQgeyBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UgfSBmcm9tICcuL2Fzc2VydGlvbnMnO1xuaW1wb3J0IHsgQ29kZWMsIGNyZWF0ZURlY29kZXIsIGNyZWF0ZUVuY29kZXIsIERlY29kZXIsIEVuY29kZXIsIE9mZnNldCB9IGZyb20gJy4vY29kZWMnO1xuaW1wb3J0IHsgY29tYmluZUNvZGVjIH0gZnJvbSAnLi9jb21iaW5lLWNvZGVjJztcbmltcG9ydCB7IFJlYWRvbmx5VWludDhBcnJheSB9IGZyb20gJy4vcmVhZG9ubHktdWludDhhcnJheSc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG50eXBlIEFueUVuY29kZXIgPSBFbmNvZGVyPGFueT47XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxudHlwZSBBbnlEZWNvZGVyID0gRGVjb2Rlcjxhbnk+O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnR5cGUgQW55Q29kZWMgPSBDb2RlYzxhbnk+O1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBtb2RpZnlpbmcgdGhlIG9mZnNldCBvZiBhbiBlbmNvZGVyLCBkZWNvZGVyLCBvciBjb2RlYy5cbiAqXG4gKiBUaGlzIHR5cGUgZGVmaW5lcyBvcHRpb25hbCBmdW5jdGlvbnMgZm9yIGFkanVzdGluZyB0aGUgKipwcmUtb2Zmc2V0KiogKGJlZm9yZSBlbmNvZGluZy9kZWNvZGluZylcbiAqIGFuZCB0aGUgKipwb3N0LW9mZnNldCoqIChhZnRlciBlbmNvZGluZy9kZWNvZGluZykuIFRoZXNlIGZ1bmN0aW9ucyBhbGxvdyBwcmVjaXNlIGNvbnRyb2xcbiAqIG92ZXIgd2hlcmUgZGF0YSBpcyB3cml0dGVuIG9yIHJlYWQgd2l0aGluIGEgYnl0ZSBhcnJheS5cbiAqXG4gKiBAcHJvcGVydHkgcHJlT2Zmc2V0IC0gQSBmdW5jdGlvbiB0aGF0IG1vZGlmaWVzIHRoZSBvZmZzZXQgYmVmb3JlIGVuY29kaW5nIG9yIGRlY29kaW5nLlxuICogQHByb3BlcnR5IHBvc3RPZmZzZXQgLSBBIGZ1bmN0aW9uIHRoYXQgbW9kaWZpZXMgdGhlIG9mZnNldCBhZnRlciBlbmNvZGluZyBvciBkZWNvZGluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogTW92aW5nIHRoZSBwcmUtb2Zmc2V0IGZvcndhcmQgYnkgMiBieXRlcy5cbiAqIGBgYHRzXG4gKiBjb25zdCBjb25maWc6IE9mZnNldENvbmZpZyA9IHtcbiAqICAgICBwcmVPZmZzZXQ6ICh7IHByZU9mZnNldCB9KSA9PiBwcmVPZmZzZXQgKyAyLFxuICogfTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBNb3ZpbmcgdGhlIHBvc3Qtb2Zmc2V0IGZvcndhcmQgYnkgMiBieXRlcy5cbiAqIGBgYHRzXG4gKiBjb25zdCBjb25maWc6IE9mZnNldENvbmZpZyA9IHtcbiAqICAgICBwb3N0T2Zmc2V0OiAoeyBwb3N0T2Zmc2V0IH0pID0+IHBvc3RPZmZzZXQgKyAyLFxuICogfTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBVc2luZyBib3RoIHByZS1vZmZzZXQgYW5kIHBvc3Qtb2Zmc2V0IHRvZ2V0aGVyLlxuICogYGBgdHNcbiAqIGNvbnN0IGNvbmZpZzogT2Zmc2V0Q29uZmlnID0ge1xuICogICAgIHByZU9mZnNldDogKHsgcHJlT2Zmc2V0IH0pID0+IHByZU9mZnNldCArIDIsXG4gKiAgICAgcG9zdE9mZnNldDogKHsgcG9zdE9mZnNldCB9KSA9PiBwb3N0T2Zmc2V0ICsgNCxcbiAqIH07XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBvZmZzZXRFbmNvZGVyfVxuICogQHNlZSB7QGxpbmsgb2Zmc2V0RGVjb2Rlcn1cbiAqIEBzZWUge0BsaW5rIG9mZnNldENvZGVjfVxuICovXG50eXBlIE9mZnNldENvbmZpZyA9IHtcbiAgICBwb3N0T2Zmc2V0PzogUG9zdE9mZnNldEZ1bmN0aW9uO1xuICAgIHByZU9mZnNldD86IFByZU9mZnNldEZ1bmN0aW9uO1xufTtcblxuLyoqXG4gKiBTY29wZSBwcm92aWRlZCB0byB0aGUgYHByZU9mZnNldGAgYW5kIGBwb3N0T2Zmc2V0YCBmdW5jdGlvbnMsXG4gKiBjb250YWluaW5nIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgZW5jb2Rpbmcgb3IgZGVjb2RpbmcgcHJvY2Vzcy5cbiAqXG4gKiBUaGUgcHJlLW9mZnNldCBmdW5jdGlvbiBtb2RpZmllcyB3aGVyZSBlbmNvZGluZyBvciBkZWNvZGluZyBiZWdpbnMsXG4gKiB3aGlsZSB0aGUgcG9zdC1vZmZzZXQgZnVuY3Rpb24gbW9kaWZpZXMgd2hlcmUgdGhlIG5leHQgb3BlcmF0aW9uIGNvbnRpbnVlcy5cbiAqXG4gKiBAcHJvcGVydHkgYnl0ZXMgLSBUaGUgZW50aXJlIGJ5dGUgYXJyYXkgYmVpbmcgZW5jb2RlZCBvciBkZWNvZGVkLlxuICogQHByb3BlcnR5IHByZU9mZnNldCAtIFRoZSBvcmlnaW5hbCBvZmZzZXQgYmVmb3JlIGVuY29kaW5nIG9yIGRlY29kaW5nIHN0YXJ0cy5cbiAqIEBwcm9wZXJ0eSB3cmFwQnl0ZXMgLSBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IHdyYXBzIG9mZnNldHMgYXJvdW5kIHRoZSBieXRlIGFycmF5IGxlbmd0aC5cbiAqXG4gKiBAZXhhbXBsZVxuICogVXNpbmcgYHdyYXBCeXRlc2AgdG8gd3JhcCBhIG5lZ2F0aXZlIG9mZnNldCB0byB0aGUgZW5kIG9mIHRoZSBieXRlIGFycmF5LlxuICogYGBgdHNcbiAqIGNvbnN0IGNvbmZpZzogT2Zmc2V0Q29uZmlnID0ge1xuICogICAgIHByZU9mZnNldDogKHsgd3JhcEJ5dGVzIH0pID0+IHdyYXBCeXRlcygtNCksIC8vIE1vdmVzIHRvIGxhc3QgNCBieXRlc1xuICogfTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBBZGp1c3RpbmcgdGhlIG9mZnNldCBkeW5hbWljYWxseSBiYXNlZCBvbiB0aGUgYnl0ZSBhcnJheSBzaXplLlxuICogYGBgdHNcbiAqIGNvbnN0IGNvbmZpZzogT2Zmc2V0Q29uZmlnID0ge1xuICogICAgIHByZU9mZnNldDogKHsgYnl0ZXMgfSkgPT4gYnl0ZXMubGVuZ3RoID4gMTAgPyA0IDogMixcbiAqIH07XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBQcmVPZmZzZXRGdW5jdGlvbn1cbiAqIEBzZWUge0BsaW5rIFBvc3RPZmZzZXRGdW5jdGlvbn1cbiAqL1xudHlwZSBQcmVPZmZzZXRGdW5jdGlvblNjb3BlID0ge1xuICAgIC8qKiBUaGUgZW50aXJlIGJ5dGUgYXJyYXkuICovXG4gICAgYnl0ZXM6IFJlYWRvbmx5VWludDhBcnJheSB8IFVpbnQ4QXJyYXk7XG4gICAgLyoqIFRoZSBvcmlnaW5hbCBvZmZzZXQgcHJpb3IgdG8gZW5jb2RlIG9yIGRlY29kZS4gKi9cbiAgICBwcmVPZmZzZXQ6IE9mZnNldDtcbiAgICAvKiogV3JhcHMgdGhlIG9mZnNldCB0byB0aGUgYnl0ZSBhcnJheSBsZW5ndGguICovXG4gICAgd3JhcEJ5dGVzOiAob2Zmc2V0OiBPZmZzZXQpID0+IE9mZnNldDtcbn07XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IG1vZGlmaWVzIHRoZSBwcmUtb2Zmc2V0IGJlZm9yZSBlbmNvZGluZyBvciBkZWNvZGluZy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYWRqdXN0IHRoZSBzdGFydGluZyBwb3NpdGlvbiBiZWZvcmUgd3JpdGluZ1xuICogb3IgcmVhZGluZyBkYXRhIGluIGEgYnl0ZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0gc2NvcGUgLSBUaGUgY3VycmVudCBlbmNvZGluZyBvciBkZWNvZGluZyBjb250ZXh0LlxuICogQHJldHVybnMgVGhlIG5ldyBvZmZzZXQgYXQgd2hpY2ggZW5jb2Rpbmcgb3IgZGVjb2Rpbmcgc2hvdWxkIHN0YXJ0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBTa2lwcGluZyB0aGUgZmlyc3QgMiBieXRlcyBiZWZvcmUgd3JpdGluZyBvciByZWFkaW5nLlxuICogYGBgdHNcbiAqIGNvbnN0IHByZU9mZnNldDogUHJlT2Zmc2V0RnVuY3Rpb24gPSAoeyBwcmVPZmZzZXQgfSkgPT4gcHJlT2Zmc2V0ICsgMjtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBXcmFwcGluZyB0aGUgb2Zmc2V0IHRvIGVuc3VyZSBpdCBzdGF5cyB3aXRoaW4gYm91bmRzLlxuICogYGBgdHNcbiAqIGNvbnN0IHByZU9mZnNldDogUHJlT2Zmc2V0RnVuY3Rpb24gPSAoeyB3cmFwQnl0ZXMsIHByZU9mZnNldCB9KSA9PiB3cmFwQnl0ZXMocHJlT2Zmc2V0ICsgMTApO1xuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgT2Zmc2V0Q29uZmlnfVxuICogQHNlZSB7QGxpbmsgUHJlT2Zmc2V0RnVuY3Rpb25TY29wZX1cbiAqL1xudHlwZSBQcmVPZmZzZXRGdW5jdGlvbiA9IChzY29wZTogUHJlT2Zmc2V0RnVuY3Rpb25TY29wZSkgPT4gT2Zmc2V0O1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBtb2RpZmllcyB0aGUgcG9zdC1vZmZzZXQgYWZ0ZXIgZW5jb2Rpbmcgb3IgZGVjb2RpbmcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhZGp1c3RzIHdoZXJlIHRoZSBuZXh0IGVuY29kZXIgb3IgZGVjb2RlciBzaG91bGQgc3RhcnRcbiAqIGFmdGVyIHRoZSBjdXJyZW50IG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLlxuICpcbiAqIEBwYXJhbSBzY29wZSAtIFRoZSBjdXJyZW50IGVuY29kaW5nIG9yIGRlY29kaW5nIGNvbnRleHQsIGluY2x1ZGluZyB0aGUgbW9kaWZpZWQgcHJlLW9mZnNldFxuICogYW5kIHRoZSBvcmlnaW5hbCBwb3N0LW9mZnNldC5cbiAqIEByZXR1cm5zIFRoZSBuZXcgb2Zmc2V0IGF0IHdoaWNoIHRoZSBuZXh0IG9wZXJhdGlvbiBzaG91bGQgYmVnaW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIE1vdmluZyB0aGUgcG9zdC1vZmZzZXQgZm9yd2FyZCBieSA0IGJ5dGVzLlxuICogYGBgdHNcbiAqIGNvbnN0IHBvc3RPZmZzZXQ6IFBvc3RPZmZzZXRGdW5jdGlvbiA9ICh7IHBvc3RPZmZzZXQgfSkgPT4gcG9zdE9mZnNldCArIDQ7XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogV3JhcHBpbmcgdGhlIHBvc3Qtb2Zmc2V0IHdpdGhpbiB0aGUgYnl0ZSBhcnJheSBsZW5ndGguXG4gKiBgYGB0c1xuICogY29uc3QgcG9zdE9mZnNldDogUG9zdE9mZnNldEZ1bmN0aW9uID0gKHsgd3JhcEJ5dGVzLCBwb3N0T2Zmc2V0IH0pID0+IHdyYXBCeXRlcyhwb3N0T2Zmc2V0KTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBFbnN1cmluZyBhIG1pbmltdW0gc3BhY2luZyBvZiA4IGJ5dGVzIGJldHdlZW4gdmFsdWVzLlxuICogYGBgdHNcbiAqIGNvbnN0IHBvc3RPZmZzZXQ6IFBvc3RPZmZzZXRGdW5jdGlvbiA9ICh7IHBvc3RPZmZzZXQsIG5ld1ByZU9mZnNldCB9KSA9PlxuICogICAgIE1hdGgubWF4KHBvc3RPZmZzZXQsIG5ld1ByZU9mZnNldCArIDgpO1xuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgT2Zmc2V0Q29uZmlnfVxuICogQHNlZSB7QGxpbmsgUHJlT2Zmc2V0RnVuY3Rpb25TY29wZX1cbiAqL1xudHlwZSBQb3N0T2Zmc2V0RnVuY3Rpb24gPSAoXG4gICAgc2NvcGU6IFByZU9mZnNldEZ1bmN0aW9uU2NvcGUgJiB7XG4gICAgICAgIC8qKiBUaGUgbW9kaWZpZWQgb2Zmc2V0IHVzZWQgdG8gZW5jb2RlIG9yIGRlY29kZS4gKi9cbiAgICAgICAgbmV3UHJlT2Zmc2V0OiBPZmZzZXQ7XG4gICAgICAgIC8qKiBUaGUgb3JpZ2luYWwgb2Zmc2V0IHJldHVybmVkIGJ5IHRoZSBlbmNvZGVyIG9yIGRlY29kZXIuICovXG4gICAgICAgIHBvc3RPZmZzZXQ6IE9mZnNldDtcbiAgICB9LFxuKSA9PiBPZmZzZXQ7XG5cbi8qKlxuICogTW92ZXMgdGhlIG9mZnNldCBvZiBhIGdpdmVuIGVuY29kZXIgYmVmb3JlIGFuZC9vciBhZnRlciBlbmNvZGluZy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFsbG93cyBhbiBlbmNvZGVyIHRvIHdyaXRlIGl0cyBlbmNvZGVkIHZhbHVlIGF0IGEgZGlmZmVyZW50IG9mZnNldFxuICogdGhhbiB0aGUgb25lIG9yaWdpbmFsbHkgcHJvdmlkZWQuIEl0IHN1cHBvcnRzIGJvdGggcHJlLW9mZnNldCBhZGp1c3RtZW50c1xuICogKGJlZm9yZSBlbmNvZGluZykgYW5kIHBvc3Qtb2Zmc2V0IGFkanVzdG1lbnRzIChhZnRlciBlbmNvZGluZykuXG4gKlxuICogVGhlIHByZS1vZmZzZXQgZnVuY3Rpb24gZGV0ZXJtaW5lcyB3aGVyZSBlbmNvZGluZyBzaG91bGQgc3RhcnQsIHdoaWxlIHRoZVxuICogcG9zdC1vZmZzZXQgZnVuY3Rpb24gYWRqdXN0cyB3aGVyZSB0aGUgbmV4dCBlbmNvZGVyIHNob3VsZCBjb250aW51ZSB3cml0aW5nLlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB7QGxpbmsgb2Zmc2V0Q29kZWN9LlxuICpcbiAqIEB0eXBlUGFyYW0gVEZyb20gLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gZW5jb2RlLlxuICpcbiAqIEBwYXJhbSBlbmNvZGVyIC0gVGhlIGVuY29kZXIgdG8gYWRqdXN0LlxuICogQHBhcmFtIGNvbmZpZyAtIEFuIG9iamVjdCBzcGVjaWZ5aW5nIGhvdyB0aGUgb2Zmc2V0IHNob3VsZCBiZSBtb2RpZmllZC5cbiAqIEByZXR1cm5zIEEgbmV3IGVuY29kZXIgd2l0aCBhZGp1c3RlZCBvZmZzZXRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBNb3ZpbmcgdGhlIHByZS1vZmZzZXQgZm9yd2FyZCBieSAyIGJ5dGVzLlxuICogYGBgdHNcbiAqIGNvbnN0IGVuY29kZXIgPSBvZmZzZXRFbmNvZGVyKGdldFUzMkVuY29kZXIoKSwge1xuICogICAgIHByZU9mZnNldDogKHsgcHJlT2Zmc2V0IH0pID0+IHByZU9mZnNldCArIDIsXG4gKiB9KTtcbiAqIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTApO1xuICogZW5jb2Rlci53cml0ZSg0MiwgYnl0ZXMsIDApOyAvLyBBY3R1YWxseSB3cml0dGVuIGF0IG9mZnNldCAyXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogTW92aW5nIHRoZSBwb3N0LW9mZnNldCBmb3J3YXJkIGJ5IDIgYnl0ZXMuXG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlciA9IG9mZnNldEVuY29kZXIoZ2V0VTMyRW5jb2RlcigpLCB7XG4gKiAgICAgcG9zdE9mZnNldDogKHsgcG9zdE9mZnNldCB9KSA9PiBwb3N0T2Zmc2V0ICsgMixcbiAqIH0pO1xuICogY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxMCk7XG4gKiBjb25zdCBuZXh0T2Zmc2V0ID0gZW5jb2Rlci53cml0ZSg0MiwgYnl0ZXMsIDApOyAvLyBOZXh0IGVuY29kZXIgc3RhcnRzIGF0IG9mZnNldCA2IGluc3RlYWQgb2YgNFxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIFVzaW5nIGB3cmFwQnl0ZXNgIHRvIGVuc3VyZSBhbiBvZmZzZXQgd3JhcHMgYXJvdW5kIHRoZSBieXRlIGFycmF5IGxlbmd0aC5cbiAqIGBgYHRzXG4gKiBjb25zdCBlbmNvZGVyID0gb2Zmc2V0RW5jb2RlcihnZXRVMzJFbmNvZGVyKCksIHtcbiAqICAgICBwcmVPZmZzZXQ6ICh7IHdyYXBCeXRlcyB9KSA9PiB3cmFwQnl0ZXMoLTQpLCAvLyBNb3ZlcyBvZmZzZXQgdG8gbGFzdCA0IGJ5dGVzIG9mIHRoZSBhcnJheVxuICogfSk7XG4gKiBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KDEwKTtcbiAqIGVuY29kZXIud3JpdGUoNDIsIGJ5dGVzLCAwKTsgLy8gV3JpdGVzIGF0IGJ5dGVzLmxlbmd0aCAtIDRcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKiBJZiB5b3UgbmVlZCBib3RoIGVuY29kaW5nIGFuZCBkZWNvZGluZyBvZmZzZXRzIHRvIGJlIGFkanVzdGVkLCB1c2Uge0BsaW5rIG9mZnNldENvZGVjfS5cbiAqXG4gKiBAc2VlIHtAbGluayBvZmZzZXRDb2RlY31cbiAqIEBzZWUge0BsaW5rIG9mZnNldERlY29kZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZmZzZXRFbmNvZGVyPFRFbmNvZGVyIGV4dGVuZHMgQW55RW5jb2Rlcj4oZW5jb2RlcjogVEVuY29kZXIsIGNvbmZpZzogT2Zmc2V0Q29uZmlnKTogVEVuY29kZXIge1xuICAgIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAgICAgLi4uZW5jb2RlcixcbiAgICAgICAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIHByZU9mZnNldCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd3JhcEJ5dGVzID0gKG9mZnNldDogT2Zmc2V0KSA9PiBtb2R1bG8ob2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgbmV3UHJlT2Zmc2V0ID0gY29uZmlnLnByZU9mZnNldCA/IGNvbmZpZy5wcmVPZmZzZXQoeyBieXRlcywgcHJlT2Zmc2V0LCB3cmFwQnl0ZXMgfSkgOiBwcmVPZmZzZXQ7XG4gICAgICAgICAgICBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoJ29mZnNldEVuY29kZXInLCBuZXdQcmVPZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBwb3N0T2Zmc2V0ID0gZW5jb2Rlci53cml0ZSh2YWx1ZSwgYnl0ZXMsIG5ld1ByZU9mZnNldCk7XG4gICAgICAgICAgICBjb25zdCBuZXdQb3N0T2Zmc2V0ID0gY29uZmlnLnBvc3RPZmZzZXRcbiAgICAgICAgICAgICAgICA/IGNvbmZpZy5wb3N0T2Zmc2V0KHsgYnl0ZXMsIG5ld1ByZU9mZnNldCwgcG9zdE9mZnNldCwgcHJlT2Zmc2V0LCB3cmFwQnl0ZXMgfSlcbiAgICAgICAgICAgICAgICA6IHBvc3RPZmZzZXQ7XG4gICAgICAgICAgICBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoJ29mZnNldEVuY29kZXInLCBuZXdQb3N0T2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1Bvc3RPZmZzZXQ7XG4gICAgICAgIH0sXG4gICAgfSkgYXMgVEVuY29kZXI7XG59XG5cbi8qKlxuICogTW92ZXMgdGhlIG9mZnNldCBvZiBhIGdpdmVuIGRlY29kZXIgYmVmb3JlIGFuZC9vciBhZnRlciBkZWNvZGluZy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFsbG93cyBhIGRlY29kZXIgdG8gcmVhZCBpdHMgaW5wdXQgZnJvbSBhIGRpZmZlcmVudCBvZmZzZXRcbiAqIHRoYW4gdGhlIG9uZSBvcmlnaW5hbGx5IHByb3ZpZGVkLiBJdCBzdXBwb3J0cyBib3RoIHByZS1vZmZzZXQgYWRqdXN0bWVudHNcbiAqIChiZWZvcmUgZGVjb2RpbmcpIGFuZCBwb3N0LW9mZnNldCBhZGp1c3RtZW50cyAoYWZ0ZXIgZGVjb2RpbmcpLlxuICpcbiAqIFRoZSBwcmUtb2Zmc2V0IGZ1bmN0aW9uIGRldGVybWluZXMgd2hlcmUgZGVjb2Rpbmcgc2hvdWxkIHN0YXJ0LCB3aGlsZSB0aGVcbiAqIHBvc3Qtb2Zmc2V0IGZ1bmN0aW9uIGFkanVzdHMgd2hlcmUgdGhlIG5leHQgZGVjb2RlciBzaG91bGQgY29udGludWUgcmVhZGluZy5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUge0BsaW5rIG9mZnNldENvZGVjfS5cbiAqXG4gKiBAdHlwZVBhcmFtIFRUbyAtIFRoZSB0eXBlIG9mIHRoZSBkZWNvZGVkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBkZWNvZGVyIC0gVGhlIGRlY29kZXIgdG8gYWRqdXN0LlxuICogQHBhcmFtIGNvbmZpZyAtIEFuIG9iamVjdCBzcGVjaWZ5aW5nIGhvdyB0aGUgb2Zmc2V0IHNob3VsZCBiZSBtb2RpZmllZC5cbiAqIEByZXR1cm5zIEEgbmV3IGRlY29kZXIgd2l0aCBhZGp1c3RlZCBvZmZzZXRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBNb3ZpbmcgdGhlIHByZS1vZmZzZXQgZm9yd2FyZCBieSAyIGJ5dGVzLlxuICogYGBgdHNcbiAqIGNvbnN0IGRlY29kZXIgPSBvZmZzZXREZWNvZGVyKGdldFUzMkRlY29kZXIoKSwge1xuICogICAgIHByZU9mZnNldDogKHsgcHJlT2Zmc2V0IH0pID0+IHByZU9mZnNldCArIDIsXG4gKiB9KTtcbiAqIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDQyLCAwXSk7IC8vIFZhbHVlIHN0YXJ0cyBhdCBvZmZzZXQgMlxuICogZGVjb2Rlci5yZWFkKGJ5dGVzLCAwKTsgLy8gQWN0dWFsbHkgcmVhZHMgZnJvbSBvZmZzZXQgMlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIE1vdmluZyB0aGUgcG9zdC1vZmZzZXQgZm9yd2FyZCBieSAyIGJ5dGVzLlxuICogYGBgdHNcbiAqIGNvbnN0IGRlY29kZXIgPSBvZmZzZXREZWNvZGVyKGdldFUzMkRlY29kZXIoKSwge1xuICogICAgIHBvc3RPZmZzZXQ6ICh7IHBvc3RPZmZzZXQgfSkgPT4gcG9zdE9mZnNldCArIDIsXG4gKiB9KTtcbiAqIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzQyLCAwLCAwLCAwXSk7XG4gKiBjb25zdCBbdmFsdWUsIG5leHRPZmZzZXRdID0gZGVjb2Rlci5yZWFkKGJ5dGVzLCAwKTsgLy8gTmV4dCBkZWNvZGVyIHN0YXJ0cyBhdCBvZmZzZXQgNiBpbnN0ZWFkIG9mIDRcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBVc2luZyBgd3JhcEJ5dGVzYCB0byByZWFkIGZyb20gdGhlIGxhc3QgNCBieXRlcyBvZiBhbiBhcnJheS5cbiAqIGBgYHRzXG4gKiBjb25zdCBkZWNvZGVyID0gb2Zmc2V0RGVjb2RlcihnZXRVMzJEZWNvZGVyKCksIHtcbiAqICAgICBwcmVPZmZzZXQ6ICh7IHdyYXBCeXRlcyB9KSA9PiB3cmFwQnl0ZXMoLTQpLCAvLyBNb3ZlcyBvZmZzZXQgdG8gbGFzdCA0IGJ5dGVzIG9mIHRoZSBhcnJheVxuICogfSk7XG4gKiBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAwLCAwLCAwLCAwLCA0Ml0pOyAvLyBWYWx1ZSBzdG9yZWQgYXQgdGhlIGxhc3QgNCBieXRlc1xuICogZGVjb2Rlci5yZWFkKGJ5dGVzLCAwKTsgLy8gUmVhZHMgZnJvbSBieXRlcy5sZW5ndGggLSA0XG4gKiBgYGBcbiAqXG4gKiBAcmVtYXJrc1xuICogSWYgeW91IG5lZWQgYm90aCBlbmNvZGluZyBhbmQgZGVjb2Rpbmcgb2Zmc2V0cyB0byBiZSBhZGp1c3RlZCwgdXNlIHtAbGluayBvZmZzZXRDb2RlY30uXG4gKlxuICogQHNlZSB7QGxpbmsgb2Zmc2V0Q29kZWN9XG4gKiBAc2VlIHtAbGluayBvZmZzZXRFbmNvZGVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gb2Zmc2V0RGVjb2RlcjxURGVjb2RlciBleHRlbmRzIEFueURlY29kZXI+KGRlY29kZXI6IFREZWNvZGVyLCBjb25maWc6IE9mZnNldENvbmZpZyk6IFREZWNvZGVyIHtcbiAgICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgICAgIC4uLmRlY29kZXIsXG4gICAgICAgIHJlYWQ6IChieXRlcywgcHJlT2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3cmFwQnl0ZXMgPSAob2Zmc2V0OiBPZmZzZXQpID0+IG1vZHVsbyhvZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBuZXdQcmVPZmZzZXQgPSBjb25maWcucHJlT2Zmc2V0ID8gY29uZmlnLnByZU9mZnNldCh7IGJ5dGVzLCBwcmVPZmZzZXQsIHdyYXBCeXRlcyB9KSA6IHByZU9mZnNldDtcbiAgICAgICAgICAgIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZSgnb2Zmc2V0RGVjb2RlcicsIG5ld1ByZU9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IFt2YWx1ZSwgcG9zdE9mZnNldF0gPSBkZWNvZGVyLnJlYWQoYnl0ZXMsIG5ld1ByZU9mZnNldCk7XG4gICAgICAgICAgICBjb25zdCBuZXdQb3N0T2Zmc2V0ID0gY29uZmlnLnBvc3RPZmZzZXRcbiAgICAgICAgICAgICAgICA/IGNvbmZpZy5wb3N0T2Zmc2V0KHsgYnl0ZXMsIG5ld1ByZU9mZnNldCwgcG9zdE9mZnNldCwgcHJlT2Zmc2V0LCB3cmFwQnl0ZXMgfSlcbiAgICAgICAgICAgICAgICA6IHBvc3RPZmZzZXQ7XG4gICAgICAgICAgICBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoJ29mZnNldERlY29kZXInLCBuZXdQb3N0T2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIFt2YWx1ZSwgbmV3UG9zdE9mZnNldF07XG4gICAgICAgIH0sXG4gICAgfSkgYXMgVERlY29kZXI7XG59XG5cbi8qKlxuICogTW92ZXMgdGhlIG9mZnNldCBvZiBhIGdpdmVuIGNvZGVjIGJlZm9yZSBhbmQvb3IgYWZ0ZXIgZW5jb2RpbmcgYW5kIGRlY29kaW5nLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYWxsb3dzIGEgY29kZWMgdG8gZW5jb2RlIGFuZCBkZWNvZGUgdmFsdWVzIGF0IGN1c3RvbSBvZmZzZXRzXG4gKiB3aXRoaW4gYSBieXRlIGFycmF5LiBJdCBtb2RpZmllcyBib3RoIHRoZSAqKnByZS1vZmZzZXQqKiAod2hlcmUgZW5jb2RpbmcvZGVjb2Rpbmcgc3RhcnRzKVxuICogYW5kIHRoZSAqKnBvc3Qtb2Zmc2V0KiogKHdoZXJlIHRoZSBuZXh0IG9wZXJhdGlvbiBzaG91bGQgY29udGludWUpLlxuICpcbiAqIFRoaXMgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCB3aGVuIHdvcmtpbmcgd2l0aCBzdHJ1Y3R1cmVkIGJpbmFyeSBmb3JtYXRzXG4gKiB0aGF0IHJlcXVpcmUgc2tpcHBpbmcgcmVzZXJ2ZWQgYnl0ZXMsIGluc2VydGluZyBwYWRkaW5nLCBvciBhbGlnbmluZyBmaWVsZHMgYXRcbiAqIHNwZWNpZmljIGxvY2F0aW9ucy5cbiAqXG4gKiBAdHlwZVBhcmFtIFRGcm9tIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIGVuY29kZS5cbiAqIEB0eXBlUGFyYW0gVFRvIC0gVGhlIHR5cGUgb2YgdGhlIGRlY29kZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIGNvZGVjIC0gVGhlIGNvZGVjIHRvIGFkanVzdC5cbiAqIEBwYXJhbSBjb25maWcgLSBBbiBvYmplY3Qgc3BlY2lmeWluZyBob3cgdGhlIG9mZnNldCBzaG91bGQgYmUgbW9kaWZpZWQuXG4gKiBAcmV0dXJucyBBIG5ldyBjb2RlYyB3aXRoIGFkanVzdGVkIG9mZnNldHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIE1vdmluZyB0aGUgcHJlLW9mZnNldCBmb3J3YXJkIGJ5IDIgYnl0ZXMgd2hlbiBlbmNvZGluZyBhbmQgZGVjb2RpbmcuXG4gKiBgYGB0c1xuICogY29uc3QgY29kZWMgPSBvZmZzZXRDb2RlYyhnZXRVMzJDb2RlYygpLCB7XG4gKiAgICAgcHJlT2Zmc2V0OiAoeyBwcmVPZmZzZXQgfSkgPT4gcHJlT2Zmc2V0ICsgMixcbiAqIH0pO1xuICogY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxMCk7XG4gKiBjb2RlYy53cml0ZSg0MiwgYnl0ZXMsIDApOyAvLyBBY3R1YWxseSB3cml0dGVuIGF0IG9mZnNldCAyXG4gKiBjb2RlYy5yZWFkKGJ5dGVzLCAwKTsgICAgICAvLyBBY3R1YWxseSByZWFkIGZyb20gb2Zmc2V0IDJcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBNb3ZpbmcgdGhlIHBvc3Qtb2Zmc2V0IGZvcndhcmQgYnkgMiBieXRlcyB3aGVuIGVuY29kaW5nIGFuZCBkZWNvZGluZy5cbiAqIGBgYHRzXG4gKiBjb25zdCBjb2RlYyA9IG9mZnNldENvZGVjKGdldFUzMkNvZGVjKCksIHtcbiAqICAgICBwb3N0T2Zmc2V0OiAoeyBwb3N0T2Zmc2V0IH0pID0+IHBvc3RPZmZzZXQgKyAyLFxuICogfSk7XG4gKiBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KDEwKTtcbiAqIGNvZGVjLndyaXRlKDQyLCBieXRlcywgMCk7XG4gKiAvLyBOZXh0IGVuY29kaW5nIHN0YXJ0cyBhdCBvZmZzZXQgNiBpbnN0ZWFkIG9mIDRcbiAqIGNvZGVjLnJlYWQoYnl0ZXMsIDApO1xuICogLy8gTmV4dCBkZWNvZGluZyBzdGFydHMgYXQgb2Zmc2V0IDYgaW5zdGVhZCBvZiA0XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogVXNpbmcgYHdyYXBCeXRlc2AgdG8gbG9vcCBhcm91bmQgbmVnYXRpdmUgb2Zmc2V0cy5cbiAqIGBgYHRzXG4gKiBjb25zdCBjb2RlYyA9IG9mZnNldENvZGVjKGdldFUzMkNvZGVjKCksIHtcbiAqICAgICBwcmVPZmZzZXQ6ICh7IHdyYXBCeXRlcyB9KSA9PiB3cmFwQnl0ZXMoLTQpLCAvLyBNb3ZlcyBvZmZzZXQgdG8gbGFzdCA0IGJ5dGVzXG4gKiB9KTtcbiAqIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTApO1xuICogY29kZWMud3JpdGUoNDIsIGJ5dGVzLCAwKTsgLy8gV3JpdGVzIGF0IGJ5dGVzLmxlbmd0aCAtIDRcbiAqIGNvZGVjLnJlYWQoYnl0ZXMsIDApOyAvLyBSZWFkcyBmcm9tIGJ5dGVzLmxlbmd0aCAtIDRcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKiBJZiB5b3Ugb25seSBuZWVkIHRvIGFkanVzdCBvZmZzZXRzIGZvciBlbmNvZGluZywgdXNlIHtAbGluayBvZmZzZXRFbmNvZGVyfS5cbiAqIElmIHlvdSBvbmx5IG5lZWQgdG8gYWRqdXN0IG9mZnNldHMgZm9yIGRlY29kaW5nLCB1c2Uge0BsaW5rIG9mZnNldERlY29kZXJ9LlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KDEwKTtcbiAqIG9mZnNldEVuY29kZXIoZ2V0VTMyRW5jb2RlcigpLCB7IHByZU9mZnNldDogKHsgcHJlT2Zmc2V0IH0pID0+IHByZU9mZnNldCArIDIgfSkud3JpdGUoNDIsIGJ5dGVzLCAwKTtcbiAqIGNvbnN0IFt2YWx1ZV0gPSBvZmZzZXREZWNvZGVyKGdldFUzMkRlY29kZXIoKSwgeyBwcmVPZmZzZXQ6ICh7IHByZU9mZnNldCB9KSA9PiBwcmVPZmZzZXQgKyAyIH0pLnJlYWQoYnl0ZXMsIDApO1xuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgb2Zmc2V0RW5jb2Rlcn1cbiAqIEBzZWUge0BsaW5rIG9mZnNldERlY29kZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZmZzZXRDb2RlYzxUQ29kZWMgZXh0ZW5kcyBBbnlDb2RlYz4oY29kZWM6IFRDb2RlYywgY29uZmlnOiBPZmZzZXRDb25maWcpOiBUQ29kZWMge1xuICAgIHJldHVybiBjb21iaW5lQ29kZWMob2Zmc2V0RW5jb2Rlcihjb2RlYywgY29uZmlnKSwgb2Zmc2V0RGVjb2Rlcihjb2RlYywgY29uZmlnKSkgYXMgVENvZGVjO1xufVxuXG4vKiogQSBtb2R1bG8gZnVuY3Rpb24gdGhhdCBoYW5kbGVzIG5lZ2F0aXZlIGRpdmlkZW5kcyBhbmQgemVybyBkaXZpc29ycy4gKi9cbmZ1bmN0aW9uIG1vZHVsbyhkaXZpZGVuZDogbnVtYmVyLCBkaXZpc29yOiBudW1iZXIpIHtcbiAgICBpZiAoZGl2aXNvciA9PT0gMCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuICgoZGl2aWRlbmQgJSBkaXZpc29yKSArIGRpdmlzb3IpICUgZGl2aXNvcjtcbn1cbiIsICJpbXBvcnQgeyBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIFNvbGFuYUVycm9yIH0gZnJvbSAnQHNvbGFuYS9lcnJvcnMnO1xuXG5pbXBvcnQge1xuICAgIENvZGVjLFxuICAgIGNyZWF0ZURlY29kZXIsXG4gICAgY3JlYXRlRW5jb2RlcixcbiAgICBEZWNvZGVyLFxuICAgIEVuY29kZXIsXG4gICAgRml4ZWRTaXplQ29kZWMsXG4gICAgRml4ZWRTaXplRGVjb2RlcixcbiAgICBGaXhlZFNpemVFbmNvZGVyLFxuICAgIGlzRml4ZWRTaXplLFxufSBmcm9tICcuL2NvZGVjJztcbmltcG9ydCB7IGNvbWJpbmVDb2RlYyB9IGZyb20gJy4vY29tYmluZS1jb2RlYyc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG50eXBlIEFueUVuY29kZXIgPSBFbmNvZGVyPGFueT47XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxudHlwZSBBbnlEZWNvZGVyID0gRGVjb2Rlcjxhbnk+O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnR5cGUgQW55Q29kZWMgPSBDb2RlYzxhbnk+O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgYSBnaXZlbiBlbmNvZGVyLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbW9kaWZpZXMgdGhlIHNpemUgb2YgYW4gZW5jb2RlciB1c2luZyBhIHByb3ZpZGVkIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uLlxuICogRm9yIGZpeGVkLXNpemUgZW5jb2RlcnMsIGl0IHVwZGF0ZXMgdGhlIGBmaXhlZFNpemVgIHByb3BlcnR5LCBhbmQgZm9yIHZhcmlhYmxlLXNpemVcbiAqIGVuY29kZXJzLCBpdCBhZGp1c3RzIHRoZSBzaXplIGNhbGN1bGF0aW9uIGJhc2VkIG9uIHRoZSBlbmNvZGVkIHZhbHVlLlxuICpcbiAqIElmIHRoZSBuZXcgc2l6ZSBpcyBuZWdhdGl2ZSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKlxuICogRm9yIG1vcmUgZGV0YWlscywgc2VlIHtAbGluayByZXNpemVDb2RlY30uXG4gKlxuICogQHR5cGVQYXJhbSBURnJvbSAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAdHlwZVBhcmFtIFRTaXplIC0gVGhlIG9yaWdpbmFsIGZpeGVkIHNpemUgb2YgdGhlIGVuY29kZWQgdmFsdWUuXG4gKiBAdHlwZVBhcmFtIFROZXdTaXplIC0gVGhlIG5ldyBmaXhlZCBzaXplIGFmdGVyIHJlc2l6aW5nLlxuICpcbiAqIEBwYXJhbSBlbmNvZGVyIC0gVGhlIGVuY29kZXIgd2hvc2Ugc2l6ZSB3aWxsIGJlIHVwZGF0ZWQuXG4gKiBAcGFyYW0gcmVzaXplIC0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBjdXJyZW50IHNpemUgYW5kIHJldHVybnMgdGhlIG5ldyBzaXplLlxuICogQHJldHVybnMgQSBuZXcgZW5jb2RlciB3aXRoIHRoZSB1cGRhdGVkIHNpemUuXG4gKlxuICogQGV4YW1wbGVcbiAqIEluY3JlYXNpbmcgdGhlIHNpemUgb2YgYSBgdTE2YCBlbmNvZGVyIGJ5IDIgYnl0ZXMuXG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlciA9IHJlc2l6ZUVuY29kZXIoZ2V0VTE2RW5jb2RlcigpLCBzaXplID0+IHNpemUgKyAyKTtcbiAqIGVuY29kZXIuZW5jb2RlKDB4ZmZmZik7IC8vIDB4ZmZmZjAwMDAgKHR3byBleHRyYSBieXRlcyBhZGRlZClcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBTaHJpbmtpbmcgYSBgdTMyYCBlbmNvZGVyIHRvIG9ubHkgdXNlIDIgYnl0ZXMuXG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlciA9IHJlc2l6ZUVuY29kZXIoZ2V0VTMyRW5jb2RlcigpLCAoKSA9PiAyKTtcbiAqIGVuY29kZXIuZml4ZWRTaXplOyAvLyAyXG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayByZXNpemVDb2RlY31cbiAqIEBzZWUge0BsaW5rIHJlc2l6ZURlY29kZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNpemVFbmNvZGVyPFRGcm9tLCBUU2l6ZSBleHRlbmRzIG51bWJlciwgVE5ld1NpemUgZXh0ZW5kcyBudW1iZXI+KFxuICAgIGVuY29kZXI6IEZpeGVkU2l6ZUVuY29kZXI8VEZyb20sIFRTaXplPixcbiAgICByZXNpemU6IChzaXplOiBUU2l6ZSkgPT4gVE5ld1NpemUsXG4pOiBGaXhlZFNpemVFbmNvZGVyPFRGcm9tLCBUTmV3U2l6ZT47XG5leHBvcnQgZnVuY3Rpb24gcmVzaXplRW5jb2RlcjxURW5jb2RlciBleHRlbmRzIEFueUVuY29kZXI+KFxuICAgIGVuY29kZXI6IFRFbmNvZGVyLFxuICAgIHJlc2l6ZTogKHNpemU6IG51bWJlcikgPT4gbnVtYmVyLFxuKTogVEVuY29kZXI7XG5leHBvcnQgZnVuY3Rpb24gcmVzaXplRW5jb2RlcjxURW5jb2RlciBleHRlbmRzIEFueUVuY29kZXI+KFxuICAgIGVuY29kZXI6IFRFbmNvZGVyLFxuICAgIHJlc2l6ZTogKHNpemU6IG51bWJlcikgPT4gbnVtYmVyLFxuKTogVEVuY29kZXIge1xuICAgIGlmIChpc0ZpeGVkU2l6ZShlbmNvZGVyKSkge1xuICAgICAgICBjb25zdCBmaXhlZFNpemUgPSByZXNpemUoZW5jb2Rlci5maXhlZFNpemUpO1xuICAgICAgICBpZiAoZml4ZWRTaXplIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCwge1xuICAgICAgICAgICAgICAgIGJ5dGVzTGVuZ3RoOiBmaXhlZFNpemUsXG4gICAgICAgICAgICAgICAgY29kZWNEZXNjcmlwdGlvbjogJ3Jlc2l6ZUVuY29kZXInLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoeyAuLi5lbmNvZGVyLCBmaXhlZFNpemUgfSkgYXMgVEVuY29kZXI7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAgICAgLi4uZW5jb2RlcixcbiAgICAgICAgZ2V0U2l6ZUZyb21WYWx1ZTogdmFsdWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3U2l6ZSA9IHJlc2l6ZShlbmNvZGVyLmdldFNpemVGcm9tVmFsdWUodmFsdWUpKTtcbiAgICAgICAgICAgIGlmIChuZXdTaXplIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXNMZW5ndGg6IG5ld1NpemUsXG4gICAgICAgICAgICAgICAgICAgIGNvZGVjRGVzY3JpcHRpb246ICdyZXNpemVFbmNvZGVyJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdTaXplO1xuICAgICAgICB9LFxuICAgIH0pIGFzIFRFbmNvZGVyO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHNpemUgb2YgYSBnaXZlbiBkZWNvZGVyLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbW9kaWZpZXMgdGhlIHNpemUgb2YgYSBkZWNvZGVyIHVzaW5nIGEgcHJvdmlkZWQgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24uXG4gKiBGb3IgZml4ZWQtc2l6ZSBkZWNvZGVycywgaXQgdXBkYXRlcyB0aGUgYGZpeGVkU2l6ZWAgcHJvcGVydHkgdG8gcmVmbGVjdCB0aGUgbmV3IHNpemUuXG4gKiBWYXJpYWJsZS1zaXplIGRlY29kZXJzIHJlbWFpbiB1bmNoYW5nZWQsIGFzIHRoZWlyIHNpemUgaXMgZGV0ZXJtaW5lZCBkeW5hbWljYWxseS5cbiAqXG4gKiBJZiB0aGUgbmV3IHNpemUgaXMgbmVnYXRpdmUsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB7QGxpbmsgcmVzaXplQ29kZWN9LlxuICpcbiAqIEB0eXBlUGFyYW0gVFRvIC0gVGhlIHR5cGUgb2YgdGhlIGRlY29kZWQgdmFsdWUuXG4gKiBAdHlwZVBhcmFtIFRTaXplIC0gVGhlIG9yaWdpbmFsIGZpeGVkIHNpemUgb2YgdGhlIGRlY29kZWQgdmFsdWUuXG4gKiBAdHlwZVBhcmFtIFROZXdTaXplIC0gVGhlIG5ldyBmaXhlZCBzaXplIGFmdGVyIHJlc2l6aW5nLlxuICpcbiAqIEBwYXJhbSBkZWNvZGVyIC0gVGhlIGRlY29kZXIgd2hvc2Ugc2l6ZSB3aWxsIGJlIHVwZGF0ZWQuXG4gKiBAcGFyYW0gcmVzaXplIC0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBjdXJyZW50IHNpemUgYW5kIHJldHVybnMgdGhlIG5ldyBzaXplLlxuICogQHJldHVybnMgQSBuZXcgZGVjb2RlciB3aXRoIHRoZSB1cGRhdGVkIHNpemUuXG4gKlxuICogQGV4YW1wbGVcbiAqIEV4cGFuZGluZyBhIGB1MTZgIGRlY29kZXIgdG8gcmVhZCA0IGJ5dGVzIGluc3RlYWQgb2YgMi5cbiAqIGBgYHRzXG4gKiBjb25zdCBkZWNvZGVyID0gcmVzaXplRGVjb2RlcihnZXRVMTZEZWNvZGVyKCksIHNpemUgPT4gc2l6ZSArIDIpO1xuICogZGVjb2Rlci5maXhlZFNpemU7IC8vIDRcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBTaHJpbmtpbmcgYSBgdTMyYCBkZWNvZGVyIHRvIG9ubHkgcmVhZCAyIGJ5dGVzLlxuICogYGBgdHNcbiAqIGNvbnN0IGRlY29kZXIgPSByZXNpemVEZWNvZGVyKGdldFUzMkRlY29kZXIoKSwgKCkgPT4gMik7XG4gKiBkZWNvZGVyLmZpeGVkU2l6ZTsgLy8gMlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgcmVzaXplQ29kZWN9XG4gKiBAc2VlIHtAbGluayByZXNpemVFbmNvZGVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzaXplRGVjb2RlcjxURnJvbSwgVFNpemUgZXh0ZW5kcyBudW1iZXIsIFROZXdTaXplIGV4dGVuZHMgbnVtYmVyPihcbiAgICBkZWNvZGVyOiBGaXhlZFNpemVEZWNvZGVyPFRGcm9tLCBUU2l6ZT4sXG4gICAgcmVzaXplOiAoc2l6ZTogVFNpemUpID0+IFROZXdTaXplLFxuKTogRml4ZWRTaXplRGVjb2RlcjxURnJvbSwgVE5ld1NpemU+O1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2l6ZURlY29kZXI8VERlY29kZXIgZXh0ZW5kcyBBbnlEZWNvZGVyPihcbiAgICBkZWNvZGVyOiBURGVjb2RlcixcbiAgICByZXNpemU6IChzaXplOiBudW1iZXIpID0+IG51bWJlcixcbik6IFREZWNvZGVyO1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2l6ZURlY29kZXI8VERlY29kZXIgZXh0ZW5kcyBBbnlEZWNvZGVyPihcbiAgICBkZWNvZGVyOiBURGVjb2RlcixcbiAgICByZXNpemU6IChzaXplOiBudW1iZXIpID0+IG51bWJlcixcbik6IFREZWNvZGVyIHtcbiAgICBpZiAoaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICAgICAgY29uc3QgZml4ZWRTaXplID0gcmVzaXplKGRlY29kZXIuZml4ZWRTaXplKTtcbiAgICAgICAgaWYgKGZpeGVkU2l6ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIHtcbiAgICAgICAgICAgICAgICBieXRlc0xlbmd0aDogZml4ZWRTaXplLFxuICAgICAgICAgICAgICAgIGNvZGVjRGVzY3JpcHRpb246ICdyZXNpemVEZWNvZGVyJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVEZWNvZGVyKHsgLi4uZGVjb2RlciwgZml4ZWRTaXplIH0pIGFzIFREZWNvZGVyO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2Rlcjtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBzaXplIG9mIGEgZ2l2ZW4gY29kZWMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBtb2RpZmllcyB0aGUgc2l6ZSBvZiBib3RoIHRoZSBjb2RlYyB1c2luZyBhIHByb3ZpZGVkXG4gKiB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbi4gSXQgaXMgdXNlZnVsIGZvciBhZGp1c3RpbmcgdGhlIGFsbG9jYXRlZCBieXRlIHNpemUgZm9yXG4gKiBlbmNvZGluZyBhbmQgZGVjb2Rpbmcgd2l0aG91dCBhbHRlcmluZyB0aGUgdW5kZXJseWluZyBkYXRhIHN0cnVjdHVyZS5cbiAqXG4gKiBJZiB0aGUgbmV3IHNpemUgaXMgbmVnYXRpdmUsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICpcbiAqIEB0eXBlUGFyYW0gVEZyb20gLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gZW5jb2RlLlxuICogQHR5cGVQYXJhbSBUVG8gLSBUaGUgdHlwZSBvZiB0aGUgZGVjb2RlZCB2YWx1ZS5cbiAqIEB0eXBlUGFyYW0gVFNpemUgLSBUaGUgb3JpZ2luYWwgZml4ZWQgc2l6ZSBvZiB0aGUgZW5jb2RlZC9kZWNvZGVkIHZhbHVlIChmb3IgZml4ZWQtc2l6ZSBjb2RlY3MpLlxuICogQHR5cGVQYXJhbSBUTmV3U2l6ZSAtIFRoZSBuZXcgZml4ZWQgc2l6ZSBhZnRlciByZXNpemluZyAoZm9yIGZpeGVkLXNpemUgY29kZWNzKS5cbiAqXG4gKiBAcGFyYW0gY29kZWMgLSBUaGUgY29kZWMgd2hvc2Ugc2l6ZSB3aWxsIGJlIHVwZGF0ZWQuXG4gKiBAcGFyYW0gcmVzaXplIC0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBjdXJyZW50IHNpemUgYW5kIHJldHVybnMgdGhlIG5ldyBzaXplLlxuICogQHJldHVybnMgQSBuZXcgY29kZWMgd2l0aCB0aGUgdXBkYXRlZCBzaXplLlxuICpcbiAqIEBleGFtcGxlXG4gKiBFeHBhbmRpbmcgYSBgdTE2YCBjb2RlYyBmcm9tIDIgdG8gNCBieXRlcy5cbiAqIGBgYHRzXG4gKiBjb25zdCBjb2RlYyA9IHJlc2l6ZUNvZGVjKGdldFUxNkNvZGVjKCksIHNpemUgPT4gc2l6ZSArIDIpO1xuICogY29uc3QgYnl0ZXMgPSBjb2RlYy5lbmNvZGUoMHhmZmZmKTsgLy8gMHhmZmZmMDAwMCAodHdvIGV4dHJhIGJ5dGVzIGFkZGVkKVxuICogY29uc3QgdmFsdWUgPSBjb2RlYy5kZWNvZGUoYnl0ZXMpOyAgLy8gMHhmZmZmIChyZWFkcyBvcmlnaW5hbCB0d28gYnl0ZXMpXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogU2hyaW5raW5nIGEgYHUzMmAgY29kZWMgdG8gb25seSB1c2UgMiBieXRlcy5cbiAqIGBgYHRzXG4gKiBjb25zdCBjb2RlYyA9IHJlc2l6ZUNvZGVjKGdldFUzMkNvZGVjKCksICgpID0+IDIpO1xuICogY29kZWMuZml4ZWRTaXplOyAvLyAyXG4gKiBgYGBcbiAqXG4gKiBAcmVtYXJrc1xuICogSWYgeW91IG9ubHkgbmVlZCB0byByZXNpemUgYW4gZW5jb2RlciwgdXNlIHtAbGluayByZXNpemVFbmNvZGVyfS5cbiAqIElmIHlvdSBvbmx5IG5lZWQgdG8gcmVzaXplIGEgZGVjb2RlciwgdXNlIHtAbGluayByZXNpemVEZWNvZGVyfS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgYnl0ZXMgPSByZXNpemVFbmNvZGVyKGdldFUzMkVuY29kZXIoKSwgKHNpemUpID0+IHNpemUgKyAyKS5lbmNvZGUoMHhmZmZmKTtcbiAqIGNvbnN0IHZhbHVlID0gcmVzaXplRGVjb2RlcihnZXRVMzJEZWNvZGVyKCksIChzaXplKSA9PiBzaXplICsgMikuZGVjb2RlKGJ5dGVzKTtcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIHJlc2l6ZUVuY29kZXJ9XG4gKiBAc2VlIHtAbGluayByZXNpemVEZWNvZGVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzaXplQ29kZWM8VEZyb20sIFRUbyBleHRlbmRzIFRGcm9tLCBUU2l6ZSBleHRlbmRzIG51bWJlciwgVE5ld1NpemUgZXh0ZW5kcyBudW1iZXI+KFxuICAgIGNvZGVjOiBGaXhlZFNpemVDb2RlYzxURnJvbSwgVFRvLCBUU2l6ZT4sXG4gICAgcmVzaXplOiAoc2l6ZTogVFNpemUpID0+IFROZXdTaXplLFxuKTogRml4ZWRTaXplQ29kZWM8VEZyb20sIFRUbywgVE5ld1NpemU+O1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2l6ZUNvZGVjPFRDb2RlYyBleHRlbmRzIEFueUNvZGVjPihjb2RlYzogVENvZGVjLCByZXNpemU6IChzaXplOiBudW1iZXIpID0+IG51bWJlcik6IFRDb2RlYztcbmV4cG9ydCBmdW5jdGlvbiByZXNpemVDb2RlYzxUQ29kZWMgZXh0ZW5kcyBBbnlDb2RlYz4oY29kZWM6IFRDb2RlYywgcmVzaXplOiAoc2l6ZTogbnVtYmVyKSA9PiBudW1iZXIpOiBUQ29kZWMge1xuICAgIHJldHVybiBjb21iaW5lQ29kZWMocmVzaXplRW5jb2Rlcihjb2RlYywgcmVzaXplKSwgcmVzaXplRGVjb2Rlcihjb2RlYywgcmVzaXplKSkgYXMgVENvZGVjO1xufVxuIiwgImltcG9ydCB7IENvZGVjLCBEZWNvZGVyLCBFbmNvZGVyLCBPZmZzZXQgfSBmcm9tICcuL2NvZGVjJztcbmltcG9ydCB7IGNvbWJpbmVDb2RlYyB9IGZyb20gJy4vY29tYmluZS1jb2RlYyc7XG5pbXBvcnQgeyBvZmZzZXREZWNvZGVyLCBvZmZzZXRFbmNvZGVyIH0gZnJvbSAnLi9vZmZzZXQtY29kZWMnO1xuaW1wb3J0IHsgcmVzaXplRGVjb2RlciwgcmVzaXplRW5jb2RlciB9IGZyb20gJy4vcmVzaXplLWNvZGVjJztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnR5cGUgQW55RW5jb2RlciA9IEVuY29kZXI8YW55Pjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG50eXBlIEFueURlY29kZXIgPSBEZWNvZGVyPGFueT47XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxudHlwZSBBbnlDb2RlYyA9IENvZGVjPGFueT47XG5cbi8qKlxuICogQWRkcyBsZWZ0IHBhZGRpbmcgdG8gdGhlIGdpdmVuIGVuY29kZXIsIHNoaWZ0aW5nIHRoZSBlbmNvZGVkIHZhbHVlIGZvcndhcmRcbiAqIGJ5IGBvZmZzZXRgIGJ5dGVzIHdoaWxzdCBpbmNyZWFzaW5nIHRoZSBzaXplIG9mIHRoZSBlbmNvZGVyIGFjY29yZGluZ2x5LlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB7QGxpbmsgcGFkTGVmdENvZGVjfS5cbiAqXG4gKiBAdHlwZVBhcmFtIFRGcm9tIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIGVuY29kZS5cbiAqXG4gKiBAcGFyYW0gZW5jb2RlciAtIFRoZSBlbmNvZGVyIHRvIHBhZC5cbiAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgdG8gYWRkIGJlZm9yZSBlbmNvZGluZy5cbiAqIEByZXR1cm5zIEEgbmV3IGVuY29kZXIgd2l0aCBsZWZ0IHBhZGRpbmcgYXBwbGllZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGVuY29kZXIgPSBwYWRMZWZ0RW5jb2RlcihnZXRVMTZFbmNvZGVyKCksIDIpO1xuICogY29uc3QgYnl0ZXMgPSBlbmNvZGVyLmVuY29kZSgweGZmZmYpOyAvLyAweDAwMDBmZmZmICgweGZmZmYgd3JpdHRlbiBhdCBvZmZzZXQgMilcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIHBhZExlZnRDb2RlY31cbiAqIEBzZWUge0BsaW5rIHBhZExlZnREZWNvZGVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkTGVmdEVuY29kZXI8VEVuY29kZXIgZXh0ZW5kcyBBbnlFbmNvZGVyPihlbmNvZGVyOiBURW5jb2Rlciwgb2Zmc2V0OiBPZmZzZXQpOiBURW5jb2RlciB7XG4gICAgcmV0dXJuIG9mZnNldEVuY29kZXIoXG4gICAgICAgIHJlc2l6ZUVuY29kZXIoZW5jb2Rlciwgc2l6ZSA9PiBzaXplICsgb2Zmc2V0KSxcbiAgICAgICAgeyBwcmVPZmZzZXQ6ICh7IHByZU9mZnNldCB9KSA9PiBwcmVPZmZzZXQgKyBvZmZzZXQgfSxcbiAgICApO1xufVxuXG4vKipcbiAqIEFkZHMgcmlnaHQgcGFkZGluZyB0byB0aGUgZ2l2ZW4gZW5jb2RlciwgZXh0ZW5kaW5nIHRoZSBlbmNvZGVkIHZhbHVlIGJ5IGBvZmZzZXRgXG4gKiBieXRlcyB3aGlsc3QgaW5jcmVhc2luZyB0aGUgc2l6ZSBvZiB0aGUgZW5jb2RlciBhY2NvcmRpbmdseS5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUge0BsaW5rIHBhZFJpZ2h0Q29kZWN9LlxuICpcbiAqIEB0eXBlUGFyYW0gVEZyb20gLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gZW5jb2RlLlxuICpcbiAqIEBwYXJhbSBlbmNvZGVyIC0gVGhlIGVuY29kZXIgdG8gcGFkLlxuICogQHBhcmFtIG9mZnNldCAtIFRoZSBudW1iZXIgb2YgcGFkZGluZyBieXRlcyB0byBhZGQgYWZ0ZXIgZW5jb2RpbmcuXG4gKiBAcmV0dXJucyBBIG5ldyBlbmNvZGVyIHdpdGggcmlnaHQgcGFkZGluZyBhcHBsaWVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlciA9IHBhZFJpZ2h0RW5jb2RlcihnZXRVMTZFbmNvZGVyKCksIDIpO1xuICogY29uc3QgYnl0ZXMgPSBlbmNvZGVyLmVuY29kZSgweGZmZmYpOyAvLyAweGZmZmYwMDAwICh0d28gZXh0cmEgYnl0ZXMgYWRkZWQgYXQgdGhlIGVuZClcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIHBhZFJpZ2h0Q29kZWN9XG4gKiBAc2VlIHtAbGluayBwYWRSaWdodERlY29kZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWRSaWdodEVuY29kZXI8VEVuY29kZXIgZXh0ZW5kcyBBbnlFbmNvZGVyPihlbmNvZGVyOiBURW5jb2Rlciwgb2Zmc2V0OiBPZmZzZXQpOiBURW5jb2RlciB7XG4gICAgcmV0dXJuIG9mZnNldEVuY29kZXIoXG4gICAgICAgIHJlc2l6ZUVuY29kZXIoZW5jb2Rlciwgc2l6ZSA9PiBzaXplICsgb2Zmc2V0KSxcbiAgICAgICAgeyBwb3N0T2Zmc2V0OiAoeyBwb3N0T2Zmc2V0IH0pID0+IHBvc3RPZmZzZXQgKyBvZmZzZXQgfSxcbiAgICApO1xufVxuXG4vKipcbiAqIEFkZHMgbGVmdCBwYWRkaW5nIHRvIHRoZSBnaXZlbiBkZWNvZGVyLCBzaGlmdGluZyB0aGUgZGVjb2RpbmcgcG9zaXRpb24gZm9yd2FyZFxuICogYnkgYG9mZnNldGAgYnl0ZXMgd2hpbHN0IGluY3JlYXNpbmcgdGhlIHNpemUgb2YgdGhlIGRlY29kZXIgYWNjb3JkaW5nbHkuXG4gKlxuICogRm9yIG1vcmUgZGV0YWlscywgc2VlIHtAbGluayBwYWRMZWZ0Q29kZWN9LlxuICpcbiAqIEB0eXBlUGFyYW0gVFRvIC0gVGhlIHR5cGUgb2YgdGhlIGRlY29kZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIGRlY29kZXIgLSBUaGUgZGVjb2RlciB0byBwYWQuXG4gKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIG51bWJlciBvZiBwYWRkaW5nIGJ5dGVzIHRvIHNraXAgYmVmb3JlIGRlY29kaW5nLlxuICogQHJldHVybnMgQSBuZXcgZGVjb2RlciB3aXRoIGxlZnQgcGFkZGluZyBhcHBsaWVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3QgZGVjb2RlciA9IHBhZExlZnREZWNvZGVyKGdldFUxNkRlY29kZXIoKSwgMik7XG4gKiBjb25zdCB2YWx1ZSA9IGRlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KFswLCAwLCAweDEyLCAweDM0XSkpOyAvLyAweGZmZmYgKHJlYWRzIGZyb20gb2Zmc2V0IDIpXG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBwYWRMZWZ0Q29kZWN9XG4gKiBAc2VlIHtAbGluayBwYWRMZWZ0RW5jb2Rlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZExlZnREZWNvZGVyPFREZWNvZGVyIGV4dGVuZHMgQW55RGVjb2Rlcj4oZGVjb2RlcjogVERlY29kZXIsIG9mZnNldDogT2Zmc2V0KTogVERlY29kZXIge1xuICAgIHJldHVybiBvZmZzZXREZWNvZGVyKFxuICAgICAgICByZXNpemVEZWNvZGVyKGRlY29kZXIsIHNpemUgPT4gc2l6ZSArIG9mZnNldCksXG4gICAgICAgIHsgcHJlT2Zmc2V0OiAoeyBwcmVPZmZzZXQgfSkgPT4gcHJlT2Zmc2V0ICsgb2Zmc2V0IH0sXG4gICAgKTtcbn1cblxuLyoqXG4gKiBBZGRzIHJpZ2h0IHBhZGRpbmcgdG8gdGhlIGdpdmVuIGRlY29kZXIsIGV4dGVuZGluZyB0aGUgcG9zdC1vZmZzZXQgYnkgYG9mZnNldGBcbiAqIGJ5dGVzIHdoaWxzdCBpbmNyZWFzaW5nIHRoZSBzaXplIG9mIHRoZSBkZWNvZGVyIGFjY29yZGluZ2x5LlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB7QGxpbmsgcGFkUmlnaHRDb2RlY30uXG4gKlxuICogQHR5cGVQYXJhbSBUVG8gLSBUaGUgdHlwZSBvZiB0aGUgZGVjb2RlZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gZGVjb2RlciAtIFRoZSBkZWNvZGVyIHRvIHBhZC5cbiAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgdG8gc2tpcCBhZnRlciBkZWNvZGluZy5cbiAqIEByZXR1cm5zIEEgbmV3IGRlY29kZXIgd2l0aCByaWdodCBwYWRkaW5nIGFwcGxpZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBkZWNvZGVyID0gcGFkUmlnaHREZWNvZGVyKGdldFUxNkRlY29kZXIoKSwgMik7XG4gKiBjb25zdCB2YWx1ZSA9IGRlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KFsweDEyLCAweDM0LCAwLCAwXSkpOyAvLyAweGZmZmYgKGlnbm9yZXMgdHJhaWxpbmcgYnl0ZXMpXG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBwYWRSaWdodENvZGVjfVxuICogQHNlZSB7QGxpbmsgcGFkUmlnaHRFbmNvZGVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkUmlnaHREZWNvZGVyPFREZWNvZGVyIGV4dGVuZHMgQW55RGVjb2Rlcj4oZGVjb2RlcjogVERlY29kZXIsIG9mZnNldDogT2Zmc2V0KTogVERlY29kZXIge1xuICAgIHJldHVybiBvZmZzZXREZWNvZGVyKFxuICAgICAgICByZXNpemVEZWNvZGVyKGRlY29kZXIsIHNpemUgPT4gc2l6ZSArIG9mZnNldCksXG4gICAgICAgIHsgcG9zdE9mZnNldDogKHsgcG9zdE9mZnNldCB9KSA9PiBwb3N0T2Zmc2V0ICsgb2Zmc2V0IH0sXG4gICAgKTtcbn1cblxuLyoqXG4gKiBBZGRzIGxlZnQgcGFkZGluZyB0byB0aGUgZ2l2ZW4gY29kZWMsIHNoaWZ0aW5nIHRoZSBlbmNvZGluZyBhbmQgZGVjb2RpbmcgcG9zaXRpb25zXG4gKiBmb3J3YXJkIGJ5IGBvZmZzZXRgIGJ5dGVzIHdoaWxzdCBpbmNyZWFzaW5nIHRoZSBzaXplIG9mIHRoZSBjb2RlYyBhY2NvcmRpbmdseS5cbiAqXG4gKiBUaGlzIGVuc3VyZXMgdGhhdCB2YWx1ZXMgYXJlIHJlYWQgYW5kIHdyaXR0ZW4gYXQgYSBsYXRlciBwb3NpdGlvbiBpbiB0aGUgYnl0ZSBhcnJheSxcbiAqIHdoaWxlIHRoZSBwYWRkaW5nIGJ5dGVzIHJlbWFpbiB1bnVzZWQuXG4gKlxuICogQHR5cGVQYXJhbSBURnJvbSAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAdHlwZVBhcmFtIFRUbyAtIFRoZSB0eXBlIG9mIHRoZSBkZWNvZGVkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBjb2RlYyAtIFRoZSBjb2RlYyB0byBwYWQuXG4gKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIG51bWJlciBvZiBwYWRkaW5nIGJ5dGVzIHRvIGFkZCBiZWZvcmUgZW5jb2RpbmcgYW5kIGRlY29kaW5nLlxuICogQHJldHVybnMgQSBuZXcgY29kZWMgd2l0aCBsZWZ0IHBhZGRpbmcgYXBwbGllZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGNvZGVjID0gcGFkTGVmdENvZGVjKGdldFUxNkNvZGVjKCksIDIpO1xuICogY29uc3QgYnl0ZXMgPSBjb2RlYy5lbmNvZGUoMHhmZmZmKTsgLy8gMHgwMDAwZmZmZiAoMHhmZmZmIHdyaXR0ZW4gYXQgb2Zmc2V0IDIpXG4gKiBjb25zdCB2YWx1ZSA9IGNvZGVjLmRlY29kZShieXRlcyk7ICAvLyAweGZmZmYgKHJlYWRzIGZyb20gb2Zmc2V0IDIpXG4gKiBgYGBcbiAqXG4gKiBAcmVtYXJrc1xuICogSWYgeW91IG9ubHkgbmVlZCB0byBhcHBseSBwYWRkaW5nIGZvciBlbmNvZGluZywgdXNlIHtAbGluayBwYWRMZWZ0RW5jb2Rlcn0uXG4gKiBJZiB5b3Ugb25seSBuZWVkIHRvIGFwcGx5IHBhZGRpbmcgZm9yIGRlY29kaW5nLCB1c2Uge0BsaW5rIHBhZExlZnREZWNvZGVyfS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgYnl0ZXMgPSBwYWRMZWZ0RW5jb2RlcihnZXRVMTZFbmNvZGVyKCksIDIpLmVuY29kZSgweGZmZmYpO1xuICogY29uc3QgdmFsdWUgPSBwYWRMZWZ0RGVjb2RlcihnZXRVMTZEZWNvZGVyKCksIDIpLmRlY29kZShieXRlcyk7XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBwYWRMZWZ0RW5jb2Rlcn1cbiAqIEBzZWUge0BsaW5rIHBhZExlZnREZWNvZGVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkTGVmdENvZGVjPFRDb2RlYyBleHRlbmRzIEFueUNvZGVjPihjb2RlYzogVENvZGVjLCBvZmZzZXQ6IE9mZnNldCk6IFRDb2RlYyB7XG4gICAgcmV0dXJuIGNvbWJpbmVDb2RlYyhwYWRMZWZ0RW5jb2Rlcihjb2RlYywgb2Zmc2V0KSwgcGFkTGVmdERlY29kZXIoY29kZWMsIG9mZnNldCkpIGFzIFRDb2RlYztcbn1cblxuLyoqXG4gKiBBZGRzIHJpZ2h0IHBhZGRpbmcgdG8gdGhlIGdpdmVuIGNvZGVjLCBleHRlbmRpbmcgdGhlIGVuY29kZWQgYW5kIGRlY29kZWQgdmFsdWVcbiAqIGJ5IGBvZmZzZXRgIGJ5dGVzIHdoaWxzdCBpbmNyZWFzaW5nIHRoZSBzaXplIG9mIHRoZSBjb2RlYyBhY2NvcmRpbmdseS5cbiAqXG4gKiBUaGUgZXh0cmEgYnl0ZXMgcmVtYWluIHVudXNlZCwgZW5zdXJpbmcgdGhhdCB0aGUgbmV4dCBvcGVyYXRpb24gc3RhcnRzIGZ1cnRoZXJcbiAqIGFsb25nIHRoZSBieXRlIGFycmF5LlxuICpcbiAqIEB0eXBlUGFyYW0gVEZyb20gLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gZW5jb2RlLlxuICogQHR5cGVQYXJhbSBUVG8gLSBUaGUgdHlwZSBvZiB0aGUgZGVjb2RlZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gY29kZWMgLSBUaGUgY29kZWMgdG8gcGFkLlxuICogQHBhcmFtIG9mZnNldCAtIFRoZSBudW1iZXIgb2YgcGFkZGluZyBieXRlcyB0byBhZGQgYWZ0ZXIgZW5jb2RpbmcgYW5kIGRlY29kaW5nLlxuICogQHJldHVybnMgQSBuZXcgY29kZWMgd2l0aCByaWdodCBwYWRkaW5nIGFwcGxpZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBjb2RlYyA9IHBhZFJpZ2h0Q29kZWMoZ2V0VTE2Q29kZWMoKSwgMik7XG4gKiBjb25zdCBieXRlcyA9IGNvZGVjLmVuY29kZSgweGZmZmYpOyAvLyAweGZmZmYwMDAwICh0d28gZXh0cmEgYnl0ZXMgYWRkZWQpXG4gKiBjb25zdCB2YWx1ZSA9IGNvZGVjLmRlY29kZShieXRlcyk7ICAvLyAweGZmZmYgKGlnbm9yZXMgcGFkZGluZyBieXRlcylcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKiBJZiB5b3Ugb25seSBuZWVkIHRvIGFwcGx5IHBhZGRpbmcgZm9yIGVuY29kaW5nLCB1c2Uge0BsaW5rIHBhZFJpZ2h0RW5jb2Rlcn0uXG4gKiBJZiB5b3Ugb25seSBuZWVkIHRvIGFwcGx5IHBhZGRpbmcgZm9yIGRlY29kaW5nLCB1c2Uge0BsaW5rIHBhZFJpZ2h0RGVjb2Rlcn0uXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IGJ5dGVzID0gcGFkUmlnaHRFbmNvZGVyKGdldFUxNkVuY29kZXIoKSwgMikuZW5jb2RlKDB4ZmZmZik7XG4gKiBjb25zdCB2YWx1ZSA9IHBhZFJpZ2h0RGVjb2RlcihnZXRVMTZEZWNvZGVyKCksIDIpLmRlY29kZShieXRlcyk7XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBwYWRSaWdodEVuY29kZXJ9XG4gKiBAc2VlIHtAbGluayBwYWRSaWdodERlY29kZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWRSaWdodENvZGVjPFRDb2RlYyBleHRlbmRzIEFueUNvZGVjPihjb2RlYzogVENvZGVjLCBvZmZzZXQ6IE9mZnNldCk6IFRDb2RlYyB7XG4gICAgcmV0dXJuIGNvbWJpbmVDb2RlYyhwYWRSaWdodEVuY29kZXIoY29kZWMsIG9mZnNldCksIHBhZFJpZ2h0RGVjb2Rlcihjb2RlYywgb2Zmc2V0KSkgYXMgVENvZGVjO1xufVxuIiwgImltcG9ydCB7XG4gICAgYXNzZXJ0SXNGaXhlZFNpemUsXG4gICAgY3JlYXRlRGVjb2RlcixcbiAgICBjcmVhdGVFbmNvZGVyLFxuICAgIEZpeGVkU2l6ZUNvZGVjLFxuICAgIEZpeGVkU2l6ZURlY29kZXIsXG4gICAgRml4ZWRTaXplRW5jb2Rlcixcbn0gZnJvbSAnLi9jb2RlYyc7XG5pbXBvcnQgeyBjb21iaW5lQ29kZWMgfSBmcm9tICcuL2NvbWJpbmUtY29kZWMnO1xuaW1wb3J0IHsgUmVhZG9ubHlVaW50OEFycmF5IH0gZnJvbSAnLi9yZWFkb25seS11aW50OGFycmF5JztcblxuZnVuY3Rpb24gY29weVNvdXJjZVRvVGFyZ2V0SW5SZXZlcnNlKFxuICAgIHNvdXJjZTogUmVhZG9ubHlVaW50OEFycmF5LFxuICAgIHRhcmdldF9XSUxMX01VVEFURTogVWludDhBcnJheSxcbiAgICBzb3VyY2VPZmZzZXQ6IG51bWJlcixcbiAgICBzb3VyY2VMZW5ndGg6IG51bWJlcixcbiAgICB0YXJnZXRPZmZzZXQ6IG51bWJlciA9IDAsXG4pIHtcbiAgICB3aGlsZSAoc291cmNlT2Zmc2V0IDwgLS1zb3VyY2VMZW5ndGgpIHtcbiAgICAgICAgY29uc3QgbGVmdFZhbHVlID0gc291cmNlW3NvdXJjZU9mZnNldF07XG4gICAgICAgIHRhcmdldF9XSUxMX01VVEFURVtzb3VyY2VPZmZzZXQgKyB0YXJnZXRPZmZzZXRdID0gc291cmNlW3NvdXJjZUxlbmd0aF07XG4gICAgICAgIHRhcmdldF9XSUxMX01VVEFURVtzb3VyY2VMZW5ndGggKyB0YXJnZXRPZmZzZXRdID0gbGVmdFZhbHVlO1xuICAgICAgICBzb3VyY2VPZmZzZXQrKztcbiAgICB9XG4gICAgaWYgKHNvdXJjZU9mZnNldCA9PT0gc291cmNlTGVuZ3RoKSB7XG4gICAgICAgIHRhcmdldF9XSUxMX01VVEFURVtzb3VyY2VPZmZzZXQgKyB0YXJnZXRPZmZzZXRdID0gc291cmNlW3NvdXJjZU9mZnNldF07XG4gICAgfVxufVxuXG4vKipcbiAqIFJldmVyc2VzIHRoZSBieXRlcyBvZiBhIGZpeGVkLXNpemUgZW5jb2Rlci5cbiAqXG4gKiBHaXZlbiBhIGBGaXhlZFNpemVFbmNvZGVyYCwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgbmV3IGBGaXhlZFNpemVFbmNvZGVyYCB0aGF0XG4gKiByZXZlcnNlcyB0aGUgYnl0ZXMgd2l0aGluIHRoZSBmaXhlZC1zaXplIGJ5dGUgYXJyYXkgd2hlbiBlbmNvZGluZy5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gbW9kaWZ5IGVuZGlhbm5lc3Mgb3IgZm9yIG90aGVyIGJ5dGUtb3JkZXIgdHJhbnNmb3JtYXRpb25zLlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB7QGxpbmsgcmV2ZXJzZUNvZGVjfS5cbiAqXG4gKiBAdHlwZVBhcmFtIFRGcm9tIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIGVuY29kZS5cbiAqIEB0eXBlUGFyYW0gVFNpemUgLSBUaGUgZml4ZWQgc2l6ZSBvZiB0aGUgZW5jb2RlZCB2YWx1ZSBpbiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gZW5jb2RlciAtIFRoZSBmaXhlZC1zaXplIGVuY29kZXIgdG8gcmV2ZXJzZS5cbiAqIEByZXR1cm5zIEEgbmV3IGVuY29kZXIgdGhhdCB3cml0ZXMgYnl0ZXMgaW4gcmV2ZXJzZSBvcmRlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogRW5jb2RpbmcgYSBgdTE2YCB2YWx1ZSBpbiByZXZlcnNlIG9yZGVyLlxuICogYGBgdHNcbiAqIGNvbnN0IGVuY29kZXIgPSByZXZlcnNlRW5jb2RlcihnZXRVMTZFbmNvZGVyKHsgZW5kaWFuOiBFbmRpYW4uQmlnIH0pKTtcbiAqIGNvbnN0IGJ5dGVzID0gZW5jb2Rlci5lbmNvZGUoMHgxMjM0KTsgLy8gMHgzNDEyIChieXRlcyBhcmUgZmxpcHBlZClcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIHJldmVyc2VDb2RlY31cbiAqIEBzZWUge0BsaW5rIHJldmVyc2VEZWNvZGVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV2ZXJzZUVuY29kZXI8VEZyb20sIFRTaXplIGV4dGVuZHMgbnVtYmVyPihcbiAgICBlbmNvZGVyOiBGaXhlZFNpemVFbmNvZGVyPFRGcm9tLCBUU2l6ZT4sXG4pOiBGaXhlZFNpemVFbmNvZGVyPFRGcm9tLCBUU2l6ZT4ge1xuICAgIGFzc2VydElzRml4ZWRTaXplKGVuY29kZXIpO1xuICAgIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAgICAgLi4uZW5jb2RlcixcbiAgICAgICAgd3JpdGU6ICh2YWx1ZTogVEZyb20sIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld09mZnNldCA9IGVuY29kZXIud3JpdGUodmFsdWUsIGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgICAgICAgY29weVNvdXJjZVRvVGFyZ2V0SW5SZXZlcnNlKFxuICAgICAgICAgICAgICAgIGJ5dGVzIC8qIHNvdXJjZSAqLyxcbiAgICAgICAgICAgICAgICBieXRlcyAvKiB0YXJnZXRfV0lMTF9NVVRBVEUgKi8sXG4gICAgICAgICAgICAgICAgb2Zmc2V0IC8qIHNvdXJjZU9mZnNldCAqLyxcbiAgICAgICAgICAgICAgICBvZmZzZXQgKyBlbmNvZGVyLmZpeGVkU2l6ZSAvKiBzb3VyY2VMZW5ndGggKi8sXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIG5ld09mZnNldDtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBSZXZlcnNlcyB0aGUgYnl0ZXMgb2YgYSBmaXhlZC1zaXplIGRlY29kZXIuXG4gKlxuICogR2l2ZW4gYSBgRml4ZWRTaXplRGVjb2RlcmAsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIG5ldyBgRml4ZWRTaXplRGVjb2RlcmAgdGhhdFxuICogcmV2ZXJzZXMgdGhlIGJ5dGVzIHdpdGhpbiB0aGUgZml4ZWQtc2l6ZSBieXRlIGFycmF5IGJlZm9yZSBkZWNvZGluZy5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gbW9kaWZ5IGVuZGlhbm5lc3Mgb3IgZm9yIG90aGVyIGJ5dGUtb3JkZXIgdHJhbnNmb3JtYXRpb25zLlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB7QGxpbmsgcmV2ZXJzZUNvZGVjfS5cbiAqXG4gKiBAdHlwZVBhcmFtIFRUbyAtIFRoZSB0eXBlIG9mIHRoZSBkZWNvZGVkIHZhbHVlLlxuICogQHR5cGVQYXJhbSBUU2l6ZSAtIFRoZSBmaXhlZCBzaXplIG9mIHRoZSBkZWNvZGVkIHZhbHVlIGluIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBkZWNvZGVyIC0gVGhlIGZpeGVkLXNpemUgZGVjb2RlciB0byByZXZlcnNlLlxuICogQHJldHVybnMgQSBuZXcgZGVjb2RlciB0aGF0IHJlYWRzIGJ5dGVzIGluIHJldmVyc2Ugb3JkZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIERlY29kaW5nIGEgcmV2ZXJzZWQgYHUxNmAgdmFsdWUuXG4gKiBgYGB0c1xuICogY29uc3QgZGVjb2RlciA9IHJldmVyc2VEZWNvZGVyKGdldFUxNkRlY29kZXIoeyBlbmRpYW46IEVuZGlhbi5CaWcgfSkpO1xuICogY29uc3QgdmFsdWUgPSBkZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheShbMHgzNCwgMHgxMl0pKTsgLy8gMHgxMjM0IChieXRlcyBhcmUgZmxpcHBlZCBiYWNrKVxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgcmV2ZXJzZUNvZGVjfVxuICogQHNlZSB7QGxpbmsgcmV2ZXJzZUVuY29kZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXZlcnNlRGVjb2RlcjxUVG8sIFRTaXplIGV4dGVuZHMgbnVtYmVyPihcbiAgICBkZWNvZGVyOiBGaXhlZFNpemVEZWNvZGVyPFRUbywgVFNpemU+LFxuKTogRml4ZWRTaXplRGVjb2RlcjxUVG8sIFRTaXplPiB7XG4gICAgYXNzZXJ0SXNGaXhlZFNpemUoZGVjb2Rlcik7XG4gICAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgICAgICAuLi5kZWNvZGVyLFxuICAgICAgICByZWFkOiAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmV2ZXJzZWRCeXRlcyA9IGJ5dGVzLnNsaWNlKCk7XG4gICAgICAgICAgICBjb3B5U291cmNlVG9UYXJnZXRJblJldmVyc2UoXG4gICAgICAgICAgICAgICAgYnl0ZXMgLyogc291cmNlICovLFxuICAgICAgICAgICAgICAgIHJldmVyc2VkQnl0ZXMgLyogdGFyZ2V0X1dJTExfTVVUQVRFICovLFxuICAgICAgICAgICAgICAgIG9mZnNldCAvKiBzb3VyY2VPZmZzZXQgKi8sXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICsgZGVjb2Rlci5maXhlZFNpemUgLyogc291cmNlTGVuZ3RoICovLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVyLnJlYWQocmV2ZXJzZWRCeXRlcywgb2Zmc2V0KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBSZXZlcnNlcyB0aGUgYnl0ZXMgb2YgYSBmaXhlZC1zaXplIGNvZGVjLlxuICpcbiAqIEdpdmVuIGEgYEZpeGVkU2l6ZUNvZGVjYCwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgbmV3IGBGaXhlZFNpemVDb2RlY2AgdGhhdFxuICogcmV2ZXJzZXMgdGhlIGJ5dGVzIHdpdGhpbiB0aGUgZml4ZWQtc2l6ZSBieXRlIGFycmF5IGR1cmluZyBlbmNvZGluZyBhbmQgZGVjb2RpbmcuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZnVsIHRvIG1vZGlmeSBlbmRpYW5uZXNzIG9yIGZvciBvdGhlciBieXRlLW9yZGVyIHRyYW5zZm9ybWF0aW9ucy5cbiAqXG4gKiBAdHlwZVBhcmFtIFRGcm9tIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIGVuY29kZS5cbiAqIEB0eXBlUGFyYW0gVFRvIC0gVGhlIHR5cGUgb2YgdGhlIGRlY29kZWQgdmFsdWUuXG4gKiBAdHlwZVBhcmFtIFRTaXplIC0gVGhlIGZpeGVkIHNpemUgb2YgdGhlIGVuY29kZWQvZGVjb2RlZCB2YWx1ZSBpbiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gY29kZWMgLSBUaGUgZml4ZWQtc2l6ZSBjb2RlYyB0byByZXZlcnNlLlxuICogQHJldHVybnMgQSBuZXcgY29kZWMgdGhhdCBlbmNvZGVzIGFuZCBkZWNvZGVzIGJ5dGVzIGluIHJldmVyc2Ugb3JkZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIFJldmVyc2luZyBhIGB1MTZgIGNvZGVjLlxuICogYGBgdHNcbiAqIGNvbnN0IGNvZGVjID0gcmV2ZXJzZUNvZGVjKGdldFUxNkNvZGVjKHsgZW5kaWFuOiBFbmRpYW4uQmlnIH0pKTtcbiAqIGNvbnN0IGJ5dGVzID0gY29kZWMuZW5jb2RlKDB4MTIzNCk7IC8vIDB4MzQxMiAoYnl0ZXMgYXJlIGZsaXBwZWQpXG4gKiBjb25zdCB2YWx1ZSA9IGNvZGVjLmRlY29kZShieXRlcyk7ICAvLyAweDEyMzQgKGJ5dGVzIGFyZSBmbGlwcGVkIGJhY2spXG4gKiBgYGBcbiAqXG4gKiBAcmVtYXJrc1xuICogSWYgeW91IG9ubHkgbmVlZCB0byByZXZlcnNlIGFuIGVuY29kZXIsIHVzZSB7QGxpbmsgcmV2ZXJzZUVuY29kZXJ9LlxuICogSWYgeW91IG9ubHkgbmVlZCB0byByZXZlcnNlIGEgZGVjb2RlciwgdXNlIHtAbGluayByZXZlcnNlRGVjb2Rlcn0uXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IGJ5dGVzID0gcmV2ZXJzZUVuY29kZXIoZ2V0VTE2RW5jb2RlcigpKS5lbmNvZGUoMHgxMjM0KTtcbiAqIGNvbnN0IHZhbHVlID0gcmV2ZXJzZURlY29kZXIoZ2V0VTE2RGVjb2RlcigpKS5kZWNvZGUoYnl0ZXMpO1xuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgcmV2ZXJzZUVuY29kZXJ9XG4gKiBAc2VlIHtAbGluayByZXZlcnNlRGVjb2Rlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldmVyc2VDb2RlYzxURnJvbSwgVFRvIGV4dGVuZHMgVEZyb20sIFRTaXplIGV4dGVuZHMgbnVtYmVyPihcbiAgICBjb2RlYzogRml4ZWRTaXplQ29kZWM8VEZyb20sIFRUbywgVFNpemU+LFxuKTogRml4ZWRTaXplQ29kZWM8VEZyb20sIFRUbywgVFNpemU+IHtcbiAgICByZXR1cm4gY29tYmluZUNvZGVjKHJldmVyc2VFbmNvZGVyKGNvZGVjKSwgcmV2ZXJzZURlY29kZXIoY29kZWMpKTtcbn1cbiIsICJpbXBvcnQge1xuICAgIENvZGVjLFxuICAgIGNyZWF0ZUNvZGVjLFxuICAgIGNyZWF0ZURlY29kZXIsXG4gICAgY3JlYXRlRW5jb2RlcixcbiAgICBEZWNvZGVyLFxuICAgIEVuY29kZXIsXG4gICAgRml4ZWRTaXplQ29kZWMsXG4gICAgRml4ZWRTaXplRGVjb2RlcixcbiAgICBGaXhlZFNpemVFbmNvZGVyLFxuICAgIGlzVmFyaWFibGVTaXplLFxuICAgIFZhcmlhYmxlU2l6ZUNvZGVjLFxuICAgIFZhcmlhYmxlU2l6ZURlY29kZXIsXG4gICAgVmFyaWFibGVTaXplRW5jb2Rlcixcbn0gZnJvbSAnLi9jb2RlYyc7XG5pbXBvcnQgeyBSZWFkb25seVVpbnQ4QXJyYXkgfSBmcm9tICcuL3JlYWRvbmx5LXVpbnQ4YXJyYXknO1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgYW4gZW5jb2RlciBieSBtYXBwaW5nIGl0cyBpbnB1dCB2YWx1ZXMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiBleGlzdGluZyBgRW5jb2RlcjxBPmAgYW5kIHJldHVybnMgYW4gYEVuY29kZXI8Qj5gLCBhbGxvd2luZyB2YWx1ZXMgb2YgdHlwZSBgQmBcbiAqIHRvIGJlIGNvbnZlcnRlZCBpbnRvIHZhbHVlcyBvZiB0eXBlIGBBYCBiZWZvcmUgZW5jb2RpbmcuIFRoZSB0cmFuc2Zvcm1hdGlvbiBpcyBhcHBsaWVkIHZpYSB0aGUgYHVubWFwYCBmdW5jdGlvbi5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgaGFuZGxpbmcgdHlwZSBjb252ZXJzaW9ucywgYXBwbHlpbmcgZGVmYXVsdCB2YWx1ZXMsIG9yIHN0cnVjdHVyaW5nIGRhdGEgYmVmb3JlIGVuY29kaW5nLlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB7QGxpbmsgdHJhbnNmb3JtQ29kZWN9LlxuICpcbiAqIEB0eXBlUGFyYW0gVE9sZEZyb20gLSBUaGUgb3JpZ2luYWwgdHlwZSBleHBlY3RlZCBieSB0aGUgZW5jb2Rlci5cbiAqIEB0eXBlUGFyYW0gVE5ld0Zyb20gLSBUaGUgbmV3IHR5cGUgdGhhdCB3aWxsIGJlIHRyYW5zZm9ybWVkIGJlZm9yZSBlbmNvZGluZy5cbiAqXG4gKiBAcGFyYW0gZW5jb2RlciAtIFRoZSBlbmNvZGVyIHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB1bm1hcCAtIEEgZnVuY3Rpb24gdGhhdCBjb252ZXJ0cyB2YWx1ZXMgb2YgYFROZXdGcm9tYCBpbnRvIGBUT2xkRnJvbWAgYmVmb3JlIGVuY29kaW5nLlxuICogQHJldHVybnMgQSBuZXcgZW5jb2RlciB0aGF0IGFjY2VwdHMgYFROZXdGcm9tYCB2YWx1ZXMgYW5kIHRyYW5zZm9ybXMgdGhlbSBiZWZvcmUgZW5jb2RpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIEVuY29kaW5nIGEgc3RyaW5nIGJ5IGNvdW50aW5nIGl0cyBjaGFyYWN0ZXJzIGFuZCBzdG9yaW5nIHRoZSBsZW5ndGggYXMgYSBgdTMyYC5cbiAqIGBgYHRzXG4gKiBjb25zdCBlbmNvZGVyID0gdHJhbnNmb3JtRW5jb2RlcihnZXRVMzJFbmNvZGVyKCksICh2YWx1ZTogc3RyaW5nKSA9PiB2YWx1ZS5sZW5ndGgpO1xuICogZW5jb2Rlci5lbmNvZGUoXCJoZWxsb1wiKTsgLy8gMHgwNTAwMDAwMCAoc3RvcmVzIGxlbmd0aCA1KVxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgdHJhbnNmb3JtQ29kZWN9XG4gKiBAc2VlIHtAbGluayB0cmFuc2Zvcm1EZWNvZGVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtRW5jb2RlcjxUT2xkRnJvbSwgVE5ld0Zyb20sIFRTaXplIGV4dGVuZHMgbnVtYmVyPihcbiAgICBlbmNvZGVyOiBGaXhlZFNpemVFbmNvZGVyPFRPbGRGcm9tLCBUU2l6ZT4sXG4gICAgdW5tYXA6ICh2YWx1ZTogVE5ld0Zyb20pID0+IFRPbGRGcm9tLFxuKTogRml4ZWRTaXplRW5jb2RlcjxUTmV3RnJvbSwgVFNpemU+O1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybUVuY29kZXI8VE9sZEZyb20sIFROZXdGcm9tPihcbiAgICBlbmNvZGVyOiBWYXJpYWJsZVNpemVFbmNvZGVyPFRPbGRGcm9tPixcbiAgICB1bm1hcDogKHZhbHVlOiBUTmV3RnJvbSkgPT4gVE9sZEZyb20sXG4pOiBWYXJpYWJsZVNpemVFbmNvZGVyPFROZXdGcm9tPjtcbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1FbmNvZGVyPFRPbGRGcm9tLCBUTmV3RnJvbT4oXG4gICAgZW5jb2RlcjogRW5jb2RlcjxUT2xkRnJvbT4sXG4gICAgdW5tYXA6ICh2YWx1ZTogVE5ld0Zyb20pID0+IFRPbGRGcm9tLFxuKTogRW5jb2RlcjxUTmV3RnJvbT47XG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtRW5jb2RlcjxUT2xkRnJvbSwgVE5ld0Zyb20+KFxuICAgIGVuY29kZXI6IEVuY29kZXI8VE9sZEZyb20+LFxuICAgIHVubWFwOiAodmFsdWU6IFROZXdGcm9tKSA9PiBUT2xkRnJvbSxcbik6IEVuY29kZXI8VE5ld0Zyb20+IHtcbiAgICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgICAgIC4uLihpc1ZhcmlhYmxlU2l6ZShlbmNvZGVyKVxuICAgICAgICAgICAgPyB7IC4uLmVuY29kZXIsIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZTogVE5ld0Zyb20pID0+IGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSh1bm1hcCh2YWx1ZSkpIH1cbiAgICAgICAgICAgIDogZW5jb2RlciksXG4gICAgICAgIHdyaXRlOiAodmFsdWU6IFROZXdGcm9tLCBieXRlcywgb2Zmc2V0KSA9PiBlbmNvZGVyLndyaXRlKHVubWFwKHZhbHVlKSwgYnl0ZXMsIG9mZnNldCksXG4gICAgfSk7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIGRlY29kZXIgYnkgbWFwcGluZyBpdHMgb3V0cHV0IHZhbHVlcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIGV4aXN0aW5nIGBEZWNvZGVyPEE+YCBhbmQgcmV0dXJucyBhIGBEZWNvZGVyPEI+YCwgYWxsb3dpbmcgdmFsdWVzIG9mIHR5cGUgYEFgXG4gKiB0byBiZSBjb252ZXJ0ZWQgaW50byB2YWx1ZXMgb2YgdHlwZSBgQmAgYWZ0ZXIgZGVjb2RpbmcuIFRoZSB0cmFuc2Zvcm1hdGlvbiBpcyBhcHBsaWVkIHZpYSB0aGUgYG1hcGAgZnVuY3Rpb24uXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIHBvc3QtcHJvY2Vzc2luZywgdHlwZSBjb252ZXJzaW9ucywgb3IgZW5yaWNoaW5nIGRlY29kZWQgZGF0YS5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUge0BsaW5rIHRyYW5zZm9ybUNvZGVjfS5cbiAqXG4gKiBAdHlwZVBhcmFtIFRPbGRUbyAtIFRoZSBvcmlnaW5hbCB0eXBlIHJldHVybmVkIGJ5IHRoZSBkZWNvZGVyLlxuICogQHR5cGVQYXJhbSBUTmV3VG8gLSBUaGUgbmV3IHR5cGUgdGhhdCB3aWxsIGJlIHRyYW5zZm9ybWVkIGFmdGVyIGRlY29kaW5nLlxuICpcbiAqIEBwYXJhbSBkZWNvZGVyIC0gVGhlIGRlY29kZXIgdG8gdHJhbnNmb3JtLlxuICogQHBhcmFtIG1hcCAtIEEgZnVuY3Rpb24gdGhhdCBjb252ZXJ0cyB2YWx1ZXMgb2YgYFRPbGRUb2AgaW50byBgVE5ld1RvYCBhZnRlciBkZWNvZGluZy5cbiAqIEByZXR1cm5zIEEgbmV3IGRlY29kZXIgdGhhdCBkZWNvZGVzIGludG8gYFROZXdUb2AuXG4gKlxuICogQGV4YW1wbGVcbiAqIERlY29kaW5nIGEgc3RvcmVkIGB1MzJgIGxlbmd0aCBpbnRvIGEgc3RyaW5nIG9mIGAneCdgIGNoYXJhY3RlcnMuXG4gKiBgYGB0c1xuICogY29uc3QgZGVjb2RlciA9IHRyYW5zZm9ybURlY29kZXIoZ2V0VTMyRGVjb2RlcigpLCAobGVuZ3RoKSA9PiAneCcucmVwZWF0KGxlbmd0aCkpO1xuICogZGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoWzB4MDUsIDB4MDAsIDB4MDAsIDB4MDBdKSk7IC8vIFwieHh4eHhcIlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgdHJhbnNmb3JtQ29kZWN9XG4gKiBAc2VlIHtAbGluayB0cmFuc2Zvcm1FbmNvZGVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtRGVjb2RlcjxUT2xkVG8sIFROZXdUbywgVFNpemUgZXh0ZW5kcyBudW1iZXI+KFxuICAgIGRlY29kZXI6IEZpeGVkU2l6ZURlY29kZXI8VE9sZFRvLCBUU2l6ZT4sXG4gICAgbWFwOiAodmFsdWU6IFRPbGRUbywgYnl0ZXM6IFJlYWRvbmx5VWludDhBcnJheSB8IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKSA9PiBUTmV3VG8sXG4pOiBGaXhlZFNpemVEZWNvZGVyPFROZXdUbywgVFNpemU+O1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybURlY29kZXI8VE9sZFRvLCBUTmV3VG8+KFxuICAgIGRlY29kZXI6IFZhcmlhYmxlU2l6ZURlY29kZXI8VE9sZFRvPixcbiAgICBtYXA6ICh2YWx1ZTogVE9sZFRvLCBieXRlczogUmVhZG9ubHlVaW50OEFycmF5IHwgVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpID0+IFROZXdUbyxcbik6IFZhcmlhYmxlU2l6ZURlY29kZXI8VE5ld1RvPjtcbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1EZWNvZGVyPFRPbGRUbywgVE5ld1RvPihcbiAgICBkZWNvZGVyOiBEZWNvZGVyPFRPbGRUbz4sXG4gICAgbWFwOiAodmFsdWU6IFRPbGRUbywgYnl0ZXM6IFJlYWRvbmx5VWludDhBcnJheSB8IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKSA9PiBUTmV3VG8sXG4pOiBEZWNvZGVyPFROZXdUbz47XG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtRGVjb2RlcjxUT2xkVG8sIFROZXdUbz4oXG4gICAgZGVjb2RlcjogRGVjb2RlcjxUT2xkVG8+LFxuICAgIG1hcDogKHZhbHVlOiBUT2xkVG8sIGJ5dGVzOiBSZWFkb25seVVpbnQ4QXJyYXkgfCBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlcikgPT4gVE5ld1RvLFxuKTogRGVjb2RlcjxUTmV3VG8+IHtcbiAgICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgICAgIC4uLmRlY29kZXIsXG4gICAgICAgIHJlYWQ6IChieXRlczogUmVhZG9ubHlVaW50OEFycmF5IHwgVWludDhBcnJheSwgb2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbdmFsdWUsIG5ld09mZnNldF0gPSBkZWNvZGVyLnJlYWQoYnl0ZXMsIG9mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gW21hcCh2YWx1ZSwgYnl0ZXMsIG9mZnNldCksIG5ld09mZnNldF07XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIGNvZGVjIGJ5IG1hcHBpbmcgaXRzIGlucHV0IGFuZCBvdXRwdXQgdmFsdWVzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW4gZXhpc3RpbmcgYENvZGVjPEEsIEI+YCBhbmQgcmV0dXJucyBhIGBDb2RlYzxDLCBEPmAsIGFsbG93aW5nOlxuICogLSBWYWx1ZXMgb2YgdHlwZSBgQ2AgdG8gYmUgdHJhbnNmb3JtZWQgaW50byBgQWAgYmVmb3JlIGVuY29kaW5nLlxuICogLSBWYWx1ZXMgb2YgdHlwZSBgQmAgdG8gYmUgdHJhbnNmb3JtZWQgaW50byBgRGAgYWZ0ZXIgZGVjb2RpbmcuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGFkYXB0aW5nIGNvZGVjcyB0byB3b3JrIHdpdGggZGlmZmVyZW50IHJlcHJlc2VudGF0aW9ucywgaGFuZGxpbmcgZGVmYXVsdCB2YWx1ZXMsIG9yXG4gKiBjb252ZXJ0aW5nIGJldHdlZW4gcHJpbWl0aXZlIGFuZCBzdHJ1Y3R1cmVkIHR5cGVzLlxuICpcbiAqIEB0eXBlUGFyYW0gVE9sZEZyb20gLSBUaGUgb3JpZ2luYWwgdHlwZSBleHBlY3RlZCBieSB0aGUgY29kZWMuXG4gKiBAdHlwZVBhcmFtIFROZXdGcm9tIC0gVGhlIG5ldyB0eXBlIHRoYXQgd2lsbCBiZSB0cmFuc2Zvcm1lZCBiZWZvcmUgZW5jb2RpbmcuXG4gKiBAdHlwZVBhcmFtIFRPbGRUbyAtIFRoZSBvcmlnaW5hbCB0eXBlIHJldHVybmVkIGJ5IHRoZSBjb2RlYy5cbiAqIEB0eXBlUGFyYW0gVE5ld1RvIC0gVGhlIG5ldyB0eXBlIHRoYXQgd2lsbCBiZSB0cmFuc2Zvcm1lZCBhZnRlciBkZWNvZGluZy5cbiAqXG4gKiBAcGFyYW0gY29kZWMgLSBUaGUgY29kZWMgdG8gdHJhbnNmb3JtLlxuICogQHBhcmFtIHVubWFwIC0gQSBmdW5jdGlvbiB0aGF0IGNvbnZlcnRzIHZhbHVlcyBvZiBgVE5ld0Zyb21gIGludG8gYFRPbGRGcm9tYCBiZWZvcmUgZW5jb2RpbmcuXG4gKiBAcGFyYW0gbWFwIC0gQSBmdW5jdGlvbiB0aGF0IGNvbnZlcnRzIHZhbHVlcyBvZiBgVE9sZFRvYCBpbnRvIGBUTmV3VG9gIGFmdGVyIGRlY29kaW5nIChvcHRpb25hbCkuXG4gKiBAcmV0dXJucyBBIG5ldyBjb2RlYyB0aGF0IGVuY29kZXMgYFROZXdGcm9tYCBhbmQgZGVjb2RlcyBpbnRvIGBUTmV3VG9gLlxuICpcbiAqIEBleGFtcGxlXG4gKiBNYXBwaW5nIGEgYHUzMmAgY29kZWMgdG8gZW5jb2RlIHN0cmluZyBsZW5ndGhzIGFuZCBkZWNvZGUgdGhlbSBpbnRvIGAneCdgIGNoYXJhY3RlcnMuXG4gKiBgYGB0c1xuICogY29uc3QgY29kZWMgPSB0cmFuc2Zvcm1Db2RlYyhcbiAqICAgICBnZXRVMzJDb2RlYygpLFxuICogICAgICh2YWx1ZTogc3RyaW5nKSA9PiB2YWx1ZS5sZW5ndGgsIC8vIEVuY29kZSBzdHJpbmcgbGVuZ3RoXG4gKiAgICAgKGxlbmd0aCkgPT4gJ3gnLnJlcGVhdChsZW5ndGgpICAvLyBEZWNvZGUgbGVuZ3RoIGludG8gYSBzdHJpbmcgb2YgJ3gnc1xuICogKTtcbiAqXG4gKiBjb25zdCBieXRlcyA9IGNvZGVjLmVuY29kZShcImhlbGxvXCIpOyAvLyAweDA1MDAwMDAwIChzdG9yZXMgbGVuZ3RoIDUpXG4gKiBjb25zdCB2YWx1ZSA9IGNvZGVjLmRlY29kZShieXRlcyk7ICAgLy8gXCJ4eHh4eFwiXG4gKiBgYGBcbiAqXG4gKiBAcmVtYXJrc1xuICogSWYgb25seSBpbnB1dCB0cmFuc2Zvcm1hdGlvbiBpcyBuZWVkZWQsIHVzZSB7QGxpbmsgdHJhbnNmb3JtRW5jb2Rlcn0uXG4gKiBJZiBvbmx5IG91dHB1dCB0cmFuc2Zvcm1hdGlvbiBpcyBuZWVkZWQsIHVzZSB7QGxpbmsgdHJhbnNmb3JtRGVjb2Rlcn0uXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IGJ5dGVzID0gdHJhbnNmb3JtRW5jb2RlcihnZXRVMzJFbmNvZGVyKCksICh2YWx1ZTogc3RyaW5nKSA9PiB2YWx1ZS5sZW5ndGgpLmVuY29kZShcImhlbGxvXCIpO1xuICogY29uc3QgdmFsdWUgPSB0cmFuc2Zvcm1EZWNvZGVyKGdldFUzMkRlY29kZXIoKSwgKGxlbmd0aCkgPT4gJ3gnLnJlcGVhdChsZW5ndGgpKS5kZWNvZGUoYnl0ZXMpO1xuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgdHJhbnNmb3JtRW5jb2Rlcn1cbiAqIEBzZWUge0BsaW5rIHRyYW5zZm9ybURlY29kZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1Db2RlYzxUT2xkRnJvbSwgVE5ld0Zyb20sIFRUbyBleHRlbmRzIFROZXdGcm9tICYgVE9sZEZyb20sIFRTaXplIGV4dGVuZHMgbnVtYmVyPihcbiAgICBjb2RlYzogRml4ZWRTaXplQ29kZWM8VE9sZEZyb20sIFRUbywgVFNpemU+LFxuICAgIHVubWFwOiAodmFsdWU6IFROZXdGcm9tKSA9PiBUT2xkRnJvbSxcbik6IEZpeGVkU2l6ZUNvZGVjPFROZXdGcm9tLCBUVG8sIFRTaXplPjtcbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1Db2RlYzxUT2xkRnJvbSwgVE5ld0Zyb20sIFRUbyBleHRlbmRzIFROZXdGcm9tICYgVE9sZEZyb20+KFxuICAgIGNvZGVjOiBWYXJpYWJsZVNpemVDb2RlYzxUT2xkRnJvbSwgVFRvPixcbiAgICB1bm1hcDogKHZhbHVlOiBUTmV3RnJvbSkgPT4gVE9sZEZyb20sXG4pOiBWYXJpYWJsZVNpemVDb2RlYzxUTmV3RnJvbSwgVFRvPjtcbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1Db2RlYzxUT2xkRnJvbSwgVE5ld0Zyb20sIFRUbyBleHRlbmRzIFROZXdGcm9tICYgVE9sZEZyb20+KFxuICAgIGNvZGVjOiBDb2RlYzxUT2xkRnJvbSwgVFRvPixcbiAgICB1bm1hcDogKHZhbHVlOiBUTmV3RnJvbSkgPT4gVE9sZEZyb20sXG4pOiBDb2RlYzxUTmV3RnJvbSwgVFRvPjtcbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1Db2RlYzxcbiAgICBUT2xkRnJvbSxcbiAgICBUTmV3RnJvbSxcbiAgICBUT2xkVG8gZXh0ZW5kcyBUT2xkRnJvbSxcbiAgICBUTmV3VG8gZXh0ZW5kcyBUTmV3RnJvbSxcbiAgICBUU2l6ZSBleHRlbmRzIG51bWJlcixcbj4oXG4gICAgY29kZWM6IEZpeGVkU2l6ZUNvZGVjPFRPbGRGcm9tLCBUT2xkVG8sIFRTaXplPixcbiAgICB1bm1hcDogKHZhbHVlOiBUTmV3RnJvbSkgPT4gVE9sZEZyb20sXG4gICAgbWFwOiAodmFsdWU6IFRPbGRUbywgYnl0ZXM6IFJlYWRvbmx5VWludDhBcnJheSB8IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKSA9PiBUTmV3VG8sXG4pOiBGaXhlZFNpemVDb2RlYzxUTmV3RnJvbSwgVE5ld1RvLCBUU2l6ZT47XG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtQ29kZWM8VE9sZEZyb20sIFROZXdGcm9tLCBUT2xkVG8gZXh0ZW5kcyBUT2xkRnJvbSwgVE5ld1RvIGV4dGVuZHMgVE5ld0Zyb20+KFxuICAgIGNvZGVjOiBWYXJpYWJsZVNpemVDb2RlYzxUT2xkRnJvbSwgVE9sZFRvPixcbiAgICB1bm1hcDogKHZhbHVlOiBUTmV3RnJvbSkgPT4gVE9sZEZyb20sXG4gICAgbWFwOiAodmFsdWU6IFRPbGRUbywgYnl0ZXM6IFJlYWRvbmx5VWludDhBcnJheSB8IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKSA9PiBUTmV3VG8sXG4pOiBWYXJpYWJsZVNpemVDb2RlYzxUTmV3RnJvbSwgVE5ld1RvPjtcbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1Db2RlYzxUT2xkRnJvbSwgVE5ld0Zyb20sIFRPbGRUbyBleHRlbmRzIFRPbGRGcm9tLCBUTmV3VG8gZXh0ZW5kcyBUTmV3RnJvbT4oXG4gICAgY29kZWM6IENvZGVjPFRPbGRGcm9tLCBUT2xkVG8+LFxuICAgIHVubWFwOiAodmFsdWU6IFROZXdGcm9tKSA9PiBUT2xkRnJvbSxcbiAgICBtYXA6ICh2YWx1ZTogVE9sZFRvLCBieXRlczogUmVhZG9ubHlVaW50OEFycmF5IHwgVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpID0+IFROZXdUbyxcbik6IENvZGVjPFROZXdGcm9tLCBUTmV3VG8+O1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybUNvZGVjPFRPbGRGcm9tLCBUTmV3RnJvbSwgVE9sZFRvIGV4dGVuZHMgVE9sZEZyb20sIFROZXdUbyBleHRlbmRzIFROZXdGcm9tPihcbiAgICBjb2RlYzogQ29kZWM8VE9sZEZyb20sIFRPbGRUbz4sXG4gICAgdW5tYXA6ICh2YWx1ZTogVE5ld0Zyb20pID0+IFRPbGRGcm9tLFxuICAgIG1hcD86ICh2YWx1ZTogVE9sZFRvLCBieXRlczogUmVhZG9ubHlVaW50OEFycmF5IHwgVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpID0+IFROZXdUbyxcbik6IENvZGVjPFROZXdGcm9tLCBUTmV3VG8+IHtcbiAgICByZXR1cm4gY3JlYXRlQ29kZWMoe1xuICAgICAgICAuLi50cmFuc2Zvcm1FbmNvZGVyKGNvZGVjLCB1bm1hcCksXG4gICAgICAgIHJlYWQ6IG1hcCA/IHRyYW5zZm9ybURlY29kZXIoY29kZWMsIG1hcCkucmVhZCA6IChjb2RlYy5yZWFkIGFzIHVua25vd24gYXMgRGVjb2RlcjxUTmV3VG8+WydyZWFkJ10pLFxuICAgIH0pO1xufVxuIiwgImltcG9ydCB7IFNPTEFOQV9FUlJPUl9fQ09ERUNTX19OVU1CRVJfT1VUX09GX1JBTkdFLCBTb2xhbmFFcnJvciB9IGZyb20gJ0Bzb2xhbmEvZXJyb3JzJztcblxuLyoqXG4gKiBFbnN1cmVzIHRoYXQgYSBnaXZlbiBudW1iZXIgZmFsbHMgd2l0aGluIGEgc3BlY2lmaWVkIHJhbmdlLlxuICpcbiAqIElmIHRoZSBudW1iZXIgaXMgb3V0c2lkZSB0aGUgYWxsb3dlZCByYW5nZSwgYW4gZXJyb3IgaXMgdGhyb3duLlxuICogVGhpcyBmdW5jdGlvbiBpcyBwcmltYXJpbHkgdXNlZCB0byB2YWxpZGF0ZSB2YWx1ZXMgYmVmb3JlIGVuY29kaW5nIHRoZW0gaW4gYSBjb2RlYy5cbiAqXG4gKiBAcGFyYW0gY29kZWNEZXNjcmlwdGlvbiAtIEEgc3RyaW5nIGRlc2NyaWJpbmcgdGhlIGNvZGVjIHRoYXQgaXMgcGVyZm9ybWluZyB0aGUgdmFsaWRhdGlvbi5cbiAqIEBwYXJhbSBtaW4gLSBUaGUgbWluaW11bSBhbGxvd2VkIHZhbHVlIChpbmNsdXNpdmUpLlxuICogQHBhcmFtIG1heCAtIFRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUgKGluY2x1c2l2ZSkuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIHZhbGlkYXRlLlxuICpcbiAqIEB0aHJvd3Mge0BsaW5rIFNvbGFuYUVycm9yfSBpZiB0aGUgdmFsdWUgaXMgb3V0IG9mIHJhbmdlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBWYWxpZGF0aW5nIGEgbnVtYmVyIHdpdGhpbiByYW5nZS5cbiAqIGBgYHRzXG4gKiBhc3NlcnROdW1iZXJJc0JldHdlZW5Gb3JDb2RlYygndTgnLCAwLCAyNTUsIDQyKTsgLy8gUGFzc2VzXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogVGhyb3dpbmcgYW4gZXJyb3IgZm9yIGFuIG91dC1vZi1yYW5nZSB2YWx1ZS5cbiAqIGBgYHRzXG4gKiBhc3NlcnROdW1iZXJJc0JldHdlZW5Gb3JDb2RlYygndTgnLCAwLCAyNTUsIDMwMCk7IC8vIFRocm93c1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROdW1iZXJJc0JldHdlZW5Gb3JDb2RlYyhcbiAgICBjb2RlY0Rlc2NyaXB0aW9uOiBzdHJpbmcsXG4gICAgbWluOiBiaWdpbnQgfCBudW1iZXIsXG4gICAgbWF4OiBiaWdpbnQgfCBudW1iZXIsXG4gICAgdmFsdWU6IGJpZ2ludCB8IG51bWJlcixcbikge1xuICAgIGlmICh2YWx1ZSA8IG1pbiB8fCB2YWx1ZSA+IG1heCkge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX05VTUJFUl9PVVRfT0ZfUkFOR0UsIHtcbiAgICAgICAgICAgIGNvZGVjRGVzY3JpcHRpb24sXG4gICAgICAgICAgICBtYXgsXG4gICAgICAgICAgICBtaW4sXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IENvZGVjLCBEZWNvZGVyLCBFbmNvZGVyLCBGaXhlZFNpemVDb2RlYywgRml4ZWRTaXplRGVjb2RlciwgRml4ZWRTaXplRW5jb2RlciB9IGZyb20gJ0Bzb2xhbmEvY29kZWNzLWNvcmUnO1xuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGVuY29kZXIgZm9yIG51bWJlcnMgYW5kIGJpZ2ludHMuXG4gKlxuICogVGhpcyB0eXBlIGFsbG93cyBlbmNvZGluZyB2YWx1ZXMgdGhhdCBhcmUgZWl0aGVyIGBudW1iZXJgIG9yIGBiaWdpbnRgLlxuICogRGVwZW5kaW5nIG9uIHRoZSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiwgdGhlIGVuY29kZWQgb3V0cHV0IG1heSBoYXZlIGEgZml4ZWQgb3IgdmFyaWFibGUgc2l6ZS5cbiAqXG4gKiBAc2VlIHtAbGluayBGaXhlZFNpemVOdW1iZXJFbmNvZGVyfVxuICovXG5leHBvcnQgdHlwZSBOdW1iZXJFbmNvZGVyID0gRW5jb2RlcjxiaWdpbnQgfCBudW1iZXI+O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBmaXhlZC1zaXplIGVuY29kZXIgZm9yIG51bWJlcnMgYW5kIGJpZ2ludHMuXG4gKlxuICogVGhpcyBlbmNvZGVyIHNlcmlhbGl6ZXMgdmFsdWVzIHVzaW5nIGFuIGV4YWN0IG51bWJlciBvZiBieXRlcywgZGVmaW5lZCBieSBgVFNpemVgLlxuICpcbiAqIEB0eXBlUGFyYW0gVFNpemUgLSBUaGUgbnVtYmVyIG9mIGJ5dGVzIHVzZWQgZm9yIGVuY29kaW5nLlxuICpcbiAqIEBzZWUge0BsaW5rIE51bWJlckVuY29kZXJ9XG4gKi9cbmV4cG9ydCB0eXBlIEZpeGVkU2l6ZU51bWJlckVuY29kZXI8VFNpemUgZXh0ZW5kcyBudW1iZXIgPSBudW1iZXI+ID0gRml4ZWRTaXplRW5jb2RlcjxiaWdpbnQgfCBudW1iZXIsIFRTaXplPjtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgZGVjb2RlciBmb3IgbnVtYmVycyBhbmQgYmlnaW50cy5cbiAqXG4gKiBUaGlzIHR5cGUgc3VwcG9ydHMgZGVjb2RpbmcgdmFsdWVzIGFzIGVpdGhlciBgbnVtYmVyYCBvciBgYmlnaW50YCwgZGVwZW5kaW5nIG9uIHRoZSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAc2VlIHtAbGluayBGaXhlZFNpemVOdW1iZXJEZWNvZGVyfVxuICovXG5leHBvcnQgdHlwZSBOdW1iZXJEZWNvZGVyID0gRGVjb2RlcjxiaWdpbnQ+IHwgRGVjb2RlcjxudW1iZXI+O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBmaXhlZC1zaXplIGRlY29kZXIgZm9yIG51bWJlcnMgYW5kIGJpZ2ludHMuXG4gKlxuICogVGhpcyBkZWNvZGVyIHJlYWRzIGEgZml4ZWQgbnVtYmVyIG9mIGJ5dGVzIChgVFNpemVgKSBhbmQgY29udmVydHMgdGhlbSBpbnRvIGEgYG51bWJlcmAgb3IgYGJpZ2ludGAuXG4gKlxuICogQHR5cGVQYXJhbSBUU2l6ZSAtIFRoZSBudW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIGRlY29kaW5nLlxuICpcbiAqIEBzZWUge0BsaW5rIE51bWJlckRlY29kZXJ9XG4gKi9cbmV4cG9ydCB0eXBlIEZpeGVkU2l6ZU51bWJlckRlY29kZXI8VFNpemUgZXh0ZW5kcyBudW1iZXIgPSBudW1iZXI+ID1cbiAgICB8IEZpeGVkU2l6ZURlY29kZXI8YmlnaW50LCBUU2l6ZT5cbiAgICB8IEZpeGVkU2l6ZURlY29kZXI8bnVtYmVyLCBUU2l6ZT47XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNvZGVjIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgbnVtYmVycyBhbmQgYmlnaW50cy5cbiAqXG4gKiAtIFRoZSBlbmNvZGVkIHZhbHVlIGNhbiBiZSBlaXRoZXIgYSBgbnVtYmVyYCBvciBhIGBiaWdpbnRgLlxuICogLSBUaGUgZGVjb2RlZCB2YWx1ZSB3aWxsIGFsd2F5cyBiZSBlaXRoZXIgYSBgbnVtYmVyYCBvciBgYmlnaW50YCwgZGVwZW5kaW5nIG9uIHRoZSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAc2VlIHtAbGluayBGaXhlZFNpemVOdW1iZXJDb2RlY31cbiAqL1xuZXhwb3J0IHR5cGUgTnVtYmVyQ29kZWMgPSBDb2RlYzxiaWdpbnQgfCBudW1iZXIsIGJpZ2ludD4gfCBDb2RlYzxiaWdpbnQgfCBudW1iZXIsIG51bWJlcj47XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGZpeGVkLXNpemUgY29kZWMgZm9yIGVuY29kaW5nIGFuZCBkZWNvZGluZyBudW1iZXJzIGFuZCBiaWdpbnRzLlxuICpcbiAqIFRoaXMgY29kZWMgdXNlcyBhIHNwZWNpZmljIG51bWJlciBvZiBieXRlcyAoYFRTaXplYCkgZm9yIHNlcmlhbGl6YXRpb24uXG4gKiBUaGUgZW5jb2RlZCB2YWx1ZSBjYW4gYmUgZWl0aGVyIGEgYG51bWJlcmAgb3IgYGJpZ2ludGAsIGJ1dCB0aGUgZGVjb2RlZCB2YWx1ZSB3aWxsIGFsd2F5cyBiZSBhIGBudW1iZXJgIG9yIGBiaWdpbnRgLFxuICogZGVwZW5kaW5nIG9uIHRoZSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAdHlwZVBhcmFtIFRTaXplIC0gVGhlIG51bWJlciBvZiBieXRlcyB1c2VkIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcuXG4gKlxuICogQHNlZSB7QGxpbmsgTnVtYmVyQ29kZWN9XG4gKi9cbmV4cG9ydCB0eXBlIEZpeGVkU2l6ZU51bWJlckNvZGVjPFRTaXplIGV4dGVuZHMgbnVtYmVyID0gbnVtYmVyPiA9XG4gICAgfCBGaXhlZFNpemVDb2RlYzxiaWdpbnQgfCBudW1iZXIsIGJpZ2ludCwgVFNpemU+XG4gICAgfCBGaXhlZFNpemVDb2RlYzxiaWdpbnQgfCBudW1iZXIsIG51bWJlciwgVFNpemU+O1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgbnVtYmVyIGNvZGVjcyB0aGF0IHVzZSBtb3JlIHRoYW4gb25lIGJ5dGUuXG4gKlxuICogVGhpcyBjb25maWd1cmF0aW9uIGFwcGxpZXMgdG8gYWxsIG51bWJlciBjb2RlY3MgZXhjZXB0IGB1OGAgYW5kIGBpOGAsXG4gKiBhbGxvd2luZyB0aGUgdXNlciB0byBzcGVjaWZ5IHRoZSBlbmRpYW5uZXNzIG9mIHNlcmlhbGl6YXRpb24uXG4gKi9cbmV4cG9ydCB0eXBlIE51bWJlckNvZGVjQ29uZmlnID0ge1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIG51bWJlcnMgc2hvdWxkIGJlIGVuY29kZWQgaW4gbGl0dGxlLWVuZGlhbiBvciBiaWctZW5kaWFuIGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYEVuZGlhbi5MaXR0bGVgXG4gICAgICovXG4gICAgZW5kaWFuPzogRW5kaWFuO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBieXRlIG9yZGVyIHVzZWQgZm9yIG51bWJlciBzZXJpYWxpemF0aW9uLlxuICpcbiAqIC0gYExpdHRsZWA6IFRoZSBsZWFzdCBzaWduaWZpY2FudCBieXRlIGlzIHN0b3JlZCBmaXJzdC5cbiAqIC0gYEJpZ2A6IFRoZSBtb3N0IHNpZ25pZmljYW50IGJ5dGUgaXMgc3RvcmVkIGZpcnN0LlxuICovXG5leHBvcnQgZW51bSBFbmRpYW4ge1xuICAgIExpdHRsZSxcbiAgICBCaWcsXG59XG4iLCAiaW1wb3J0IHtcbiAgICBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjLFxuICAgIGFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYyxcbiAgICBjcmVhdGVEZWNvZGVyLFxuICAgIGNyZWF0ZUVuY29kZXIsXG4gICAgRml4ZWRTaXplRGVjb2RlcixcbiAgICBGaXhlZFNpemVFbmNvZGVyLFxuICAgIE9mZnNldCxcbiAgICBSZWFkb25seVVpbnQ4QXJyYXksXG59IGZyb20gJ0Bzb2xhbmEvY29kZWNzLWNvcmUnO1xuXG5pbXBvcnQgeyBhc3NlcnROdW1iZXJJc0JldHdlZW5Gb3JDb2RlYyB9IGZyb20gJy4vYXNzZXJ0aW9ucyc7XG5pbXBvcnQgeyBFbmRpYW4sIE51bWJlckNvZGVjQ29uZmlnIH0gZnJvbSAnLi9jb21tb24nO1xuXG50eXBlIE51bWJlckZhY3RvcnlTaGFyZWRJbnB1dDxUU2l6ZSBleHRlbmRzIG51bWJlcj4gPSB7XG4gICAgY29uZmlnPzogTnVtYmVyQ29kZWNDb25maWc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHNpemU6IFRTaXplO1xufTtcblxudHlwZSBOdW1iZXJGYWN0b3J5RW5jb2RlcklucHV0PFRGcm9tLCBUU2l6ZSBleHRlbmRzIG51bWJlcj4gPSBOdW1iZXJGYWN0b3J5U2hhcmVkSW5wdXQ8VFNpemU+ICYge1xuICAgIHJhbmdlPzogW2JpZ2ludCB8IG51bWJlciwgYmlnaW50IHwgbnVtYmVyXTtcbiAgICBzZXQ6ICh2aWV3OiBEYXRhVmlldywgdmFsdWU6IFRGcm9tLCBsaXR0bGVFbmRpYW4/OiBib29sZWFuKSA9PiB2b2lkO1xufTtcblxudHlwZSBOdW1iZXJGYWN0b3J5RGVjb2RlcklucHV0PFRUbywgVFNpemUgZXh0ZW5kcyBudW1iZXI+ID0gTnVtYmVyRmFjdG9yeVNoYXJlZElucHV0PFRTaXplPiAmIHtcbiAgICBnZXQ6ICh2aWV3OiBEYXRhVmlldywgbGl0dGxlRW5kaWFuPzogYm9vbGVhbikgPT4gVFRvO1xufTtcblxuZnVuY3Rpb24gaXNMaXR0bGVFbmRpYW4oY29uZmlnPzogTnVtYmVyQ29kZWNDb25maWcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gY29uZmlnPy5lbmRpYW4gPT09IEVuZGlhbi5CaWcgPyBmYWxzZSA6IHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJFbmNvZGVyRmFjdG9yeTxURnJvbSBleHRlbmRzIGJpZ2ludCB8IG51bWJlciwgVFNpemUgZXh0ZW5kcyBudW1iZXI+KFxuICAgIGlucHV0OiBOdW1iZXJGYWN0b3J5RW5jb2RlcklucHV0PFRGcm9tLCBUU2l6ZT4sXG4pOiBGaXhlZFNpemVFbmNvZGVyPFRGcm9tLCBUU2l6ZT4ge1xuICAgIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAgICAgZml4ZWRTaXplOiBpbnB1dC5zaXplLFxuICAgICAgICB3cml0ZSh2YWx1ZTogVEZyb20sIGJ5dGVzOiBVaW50OEFycmF5LCBvZmZzZXQ6IE9mZnNldCk6IE9mZnNldCB7XG4gICAgICAgICAgICBpZiAoaW5wdXQucmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnROdW1iZXJJc0JldHdlZW5Gb3JDb2RlYyhpbnB1dC5uYW1lLCBpbnB1dC5yYW5nZVswXSwgaW5wdXQucmFuZ2VbMV0sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGlucHV0LnNpemUpO1xuICAgICAgICAgICAgaW5wdXQuc2V0KG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlciksIHZhbHVlLCBpc0xpdHRsZUVuZGlhbihpbnB1dC5jb25maWcpKTtcbiAgICAgICAgICAgIGJ5dGVzLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciksIG9mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0ICsgaW5wdXQuc2l6ZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlckRlY29kZXJGYWN0b3J5PFRUbyBleHRlbmRzIGJpZ2ludCB8IG51bWJlciwgVFNpemUgZXh0ZW5kcyBudW1iZXI+KFxuICAgIGlucHV0OiBOdW1iZXJGYWN0b3J5RGVjb2RlcklucHV0PFRUbywgVFNpemU+LFxuKTogRml4ZWRTaXplRGVjb2RlcjxUVG8sIFRTaXplPiB7XG4gICAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgICAgICBmaXhlZFNpemU6IGlucHV0LnNpemUsXG4gICAgICAgIHJlYWQoYnl0ZXMsIG9mZnNldCA9IDApOiBbVFRvLCBudW1iZXJdIHtcbiAgICAgICAgICAgIGFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYyhpbnB1dC5uYW1lLCBieXRlcywgb2Zmc2V0KTtcbiAgICAgICAgICAgIGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMoaW5wdXQubmFtZSwgaW5wdXQuc2l6ZSwgYnl0ZXMsIG9mZnNldCk7XG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KHRvQXJyYXlCdWZmZXIoYnl0ZXMsIG9mZnNldCwgaW5wdXQuc2l6ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIFtpbnB1dC5nZXQodmlldywgaXNMaXR0bGVFbmRpYW4oaW5wdXQuY29uZmlnKSksIG9mZnNldCArIGlucHV0LnNpemVdO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBlbnN1cmUgdGhhdCB0aGUgQXJyYXlCdWZmZXIgaXMgY29udmVydGVkIHByb3Blcmx5IGZyb20gYSBVaW50OEFycmF5XG4gKiBTb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM3MjI4Mjg1L3VpbnQ4YXJyYXktdG8tYXJyYXlidWZmZXJcbiAqL1xuZnVuY3Rpb24gdG9BcnJheUJ1ZmZlcihieXRlczogUmVhZG9ubHlVaW50OEFycmF5IHwgVWludDhBcnJheSwgb2Zmc2V0PzogbnVtYmVyLCBsZW5ndGg/OiBudW1iZXIpOiBBcnJheUJ1ZmZlciB7XG4gICAgY29uc3QgYnl0ZXNPZmZzZXQgPSBieXRlcy5ieXRlT2Zmc2V0ICsgKG9mZnNldCA/PyAwKTtcbiAgICBjb25zdCBieXRlc0xlbmd0aCA9IGxlbmd0aCA/PyBieXRlcy5ieXRlTGVuZ3RoO1xuICAgIHJldHVybiBieXRlcy5idWZmZXIuc2xpY2UoYnl0ZXNPZmZzZXQsIGJ5dGVzT2Zmc2V0ICsgYnl0ZXNMZW5ndGgpO1xufVxuIiwgImltcG9ydCB7IGNvbWJpbmVDb2RlYywgRml4ZWRTaXplQ29kZWMsIEZpeGVkU2l6ZURlY29kZXIsIEZpeGVkU2l6ZUVuY29kZXIgfSBmcm9tICdAc29sYW5hL2NvZGVjcy1jb3JlJztcblxuaW1wb3J0IHsgTnVtYmVyQ29kZWNDb25maWcgfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyBudW1iZXJEZWNvZGVyRmFjdG9yeSwgbnVtYmVyRW5jb2RlckZhY3RvcnkgfSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGVuY29kZXIgZm9yIDMyLWJpdCBmbG9hdGluZy1wb2ludCBudW1iZXJzIChgZjMyYCkuXG4gKlxuICogVGhpcyBlbmNvZGVyIHNlcmlhbGl6ZXMgYGYzMmAgdmFsdWVzIHVzaW5nIDQgYnl0ZXMuXG4gKiBGbG9hdGluZy1wb2ludCB2YWx1ZXMgbWF5IGxvc2UgcHJlY2lzaW9uIHdoZW4gZW5jb2RlZC5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUge0BsaW5rIGdldEYzMkNvZGVjfS5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiB0byBzcGVjaWZ5IGVuZGlhbm5lc3MgKGxpdHRsZSBieSBkZWZhdWx0KS5cbiAqIEByZXR1cm5zIEEgYEZpeGVkU2l6ZUVuY29kZXI8bnVtYmVyLCA0PmAgZm9yIGVuY29kaW5nIGBmMzJgIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogRW5jb2RpbmcgYW4gYGYzMmAgdmFsdWUuXG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlciA9IGdldEYzMkVuY29kZXIoKTtcbiAqIGNvbnN0IGJ5dGVzID0gZW5jb2Rlci5lbmNvZGUoLTEuNSk7IC8vIDB4MDAwMGMwYmZcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGdldEYzMkNvZGVjfVxuICovXG5leHBvcnQgY29uc3QgZ2V0RjMyRW5jb2RlciA9IChjb25maWc6IE51bWJlckNvZGVjQ29uZmlnID0ge30pOiBGaXhlZFNpemVFbmNvZGVyPGJpZ2ludCB8IG51bWJlciwgND4gPT5cbiAgICBudW1iZXJFbmNvZGVyRmFjdG9yeSh7XG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgbmFtZTogJ2YzMicsXG4gICAgICAgIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRGbG9hdDMyKDAsIE51bWJlcih2YWx1ZSksIGxlKSxcbiAgICAgICAgc2l6ZTogNCxcbiAgICB9KTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZGVjb2RlciBmb3IgMzItYml0IGZsb2F0aW5nLXBvaW50IG51bWJlcnMgKGBmMzJgKS5cbiAqXG4gKiBUaGlzIGRlY29kZXIgZGVzZXJpYWxpemVzIGBmMzJgIHZhbHVlcyBmcm9tIDQgYnl0ZXMuXG4gKiBTb21lIHByZWNpc2lvbiBtYXkgYmUgbG9zdCBkdXJpbmcgZGVjb2RpbmcgZHVlIHRvIGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB7QGxpbmsgZ2V0RjMyQ29kZWN9LlxuICpcbiAqIEBwYXJhbSBjb25maWcgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIHRvIHNwZWNpZnkgZW5kaWFubmVzcyAobGl0dGxlIGJ5IGRlZmF1bHQpLlxuICogQHJldHVybnMgQSBgRml4ZWRTaXplRGVjb2RlcjxudW1iZXIsIDQ+YCBmb3IgZGVjb2RpbmcgYGYzMmAgdmFsdWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBEZWNvZGluZyBhbiBgZjMyYCB2YWx1ZS5cbiAqIGBgYHRzXG4gKiBjb25zdCBkZWNvZGVyID0gZ2V0RjMyRGVjb2RlcigpO1xuICogY29uc3QgdmFsdWUgPSBkZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheShbMHgwMCwgMHgwMCwgMHhjMCwgMHhiZl0pKTsgLy8gLTEuNVxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZ2V0RjMyQ29kZWN9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRGMzJEZWNvZGVyID0gKGNvbmZpZzogTnVtYmVyQ29kZWNDb25maWcgPSB7fSk6IEZpeGVkU2l6ZURlY29kZXI8bnVtYmVyLCA0PiA9PlxuICAgIG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBnZXQ6ICh2aWV3LCBsZSkgPT4gdmlldy5nZXRGbG9hdDMyKDAsIGxlKSxcbiAgICAgICAgbmFtZTogJ2YzMicsXG4gICAgICAgIHNpemU6IDQsXG4gICAgfSk7XG5cbi8qKlxuICogUmV0dXJucyBhIGNvZGVjIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgMzItYml0IGZsb2F0aW5nLXBvaW50IG51bWJlcnMgKGBmMzJgKS5cbiAqXG4gKiBUaGlzIGNvZGVjIHNlcmlhbGl6ZXMgYGYzMmAgdmFsdWVzIHVzaW5nIDQgYnl0ZXMuXG4gKiBEdWUgdG8gdGhlIElFRUUgNzU0IGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uLCBzb21lIHByZWNpc2lvbiBsb3NzIG1heSBvY2N1ci5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiB0byBzcGVjaWZ5IGVuZGlhbm5lc3MgKGxpdHRsZSBieSBkZWZhdWx0KS5cbiAqIEByZXR1cm5zIEEgYEZpeGVkU2l6ZUNvZGVjPG51bWJlciwgbnVtYmVyLCA0PmAgZm9yIGVuY29kaW5nIGFuZCBkZWNvZGluZyBgZjMyYCB2YWx1ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIEVuY29kaW5nIGFuZCBkZWNvZGluZyBhbiBgZjMyYCB2YWx1ZS5cbiAqIGBgYHRzXG4gKiBjb25zdCBjb2RlYyA9IGdldEYzMkNvZGVjKCk7XG4gKiBjb25zdCBieXRlcyA9IGNvZGVjLmVuY29kZSgtMS41KTsgLy8gMHgwMDAwYzBiZlxuICogY29uc3QgdmFsdWUgPSBjb2RlYy5kZWNvZGUoYnl0ZXMpOyAvLyAtMS41XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogVXNpbmcgYmlnLWVuZGlhbiBlbmNvZGluZy5cbiAqIGBgYHRzXG4gKiBjb25zdCBjb2RlYyA9IGdldEYzMkNvZGVjKHsgZW5kaWFuOiBFbmRpYW4uQmlnIH0pO1xuICogY29uc3QgYnl0ZXMgPSBjb2RlYy5lbmNvZGUoLTEuNSk7IC8vIDB4YmZjMDAwMDBcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKiBgZjMyYCB2YWx1ZXMgZm9sbG93IHRoZSBJRUVFIDc1NCBzaW5nbGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IHN0YW5kYXJkLlxuICogUHJlY2lzaW9uIGxvc3MgbWF5IG9jY3VyIGZvciBjZXJ0YWluIHZhbHVlcy5cbiAqXG4gKiAtIElmIHlvdSBuZWVkIGhpZ2hlciBwcmVjaXNpb24sIGNvbnNpZGVyIHVzaW5nIHtAbGluayBnZXRGNjRDb2RlY30uXG4gKiAtIElmIHlvdSBuZWVkIGludGVnZXIgdmFsdWVzLCBjb25zaWRlciB1c2luZyB7QGxpbmsgZ2V0STMyQ29kZWN9IG9yIHtAbGluayBnZXRVMzJDb2RlY30uXG4gKlxuICogU2VwYXJhdGUge0BsaW5rIGdldEYzMkVuY29kZXJ9IGFuZCB7QGxpbmsgZ2V0RjMyRGVjb2Rlcn0gZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUuXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IGJ5dGVzID0gZ2V0RjMyRW5jb2RlcigpLmVuY29kZSgtMS41KTtcbiAqIGNvbnN0IHZhbHVlID0gZ2V0RjMyRGVjb2RlcigpLmRlY29kZShieXRlcyk7XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBnZXRGMzJFbmNvZGVyfVxuICogQHNlZSB7QGxpbmsgZ2V0RjMyRGVjb2Rlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEYzMkNvZGVjID0gKGNvbmZpZzogTnVtYmVyQ29kZWNDb25maWcgPSB7fSk6IEZpeGVkU2l6ZUNvZGVjPGJpZ2ludCB8IG51bWJlciwgbnVtYmVyLCA0PiA9PlxuICAgIGNvbWJpbmVDb2RlYyhnZXRGMzJFbmNvZGVyKGNvbmZpZyksIGdldEYzMkRlY29kZXIoY29uZmlnKSk7XG4iLCAiaW1wb3J0IHsgY29tYmluZUNvZGVjLCBGaXhlZFNpemVDb2RlYywgRml4ZWRTaXplRGVjb2RlciwgRml4ZWRTaXplRW5jb2RlciB9IGZyb20gJ0Bzb2xhbmEvY29kZWNzLWNvcmUnO1xuXG5pbXBvcnQgeyBOdW1iZXJDb2RlY0NvbmZpZyB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7IG51bWJlckRlY29kZXJGYWN0b3J5LCBudW1iZXJFbmNvZGVyRmFjdG9yeSB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIFJldHVybnMgYW4gZW5jb2RlciBmb3IgNjQtYml0IGZsb2F0aW5nLXBvaW50IG51bWJlcnMgKGBmNjRgKS5cbiAqXG4gKiBUaGlzIGVuY29kZXIgc2VyaWFsaXplcyBgZjY0YCB2YWx1ZXMgdXNpbmcgOCBieXRlcy5cbiAqIEZsb2F0aW5nLXBvaW50IHZhbHVlcyBtYXkgbG9zZSBwcmVjaXNpb24gd2hlbiBlbmNvZGVkLlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB7QGxpbmsgZ2V0RjY0Q29kZWN9LlxuICpcbiAqIEBwYXJhbSBjb25maWcgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIHRvIHNwZWNpZnkgZW5kaWFubmVzcyAobGl0dGxlIGJ5IGRlZmF1bHQpLlxuICogQHJldHVybnMgQSBgRml4ZWRTaXplRW5jb2RlcjxudW1iZXIsIDg+YCBmb3IgZW5jb2RpbmcgYGY2NGAgdmFsdWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBFbmNvZGluZyBhbiBgZjY0YCB2YWx1ZS5cbiAqIGBgYHRzXG4gKiBjb25zdCBlbmNvZGVyID0gZ2V0RjY0RW5jb2RlcigpO1xuICogY29uc3QgYnl0ZXMgPSBlbmNvZGVyLmVuY29kZSgtMS41KTsgLy8gMHgwMDAwMDAwMDAwMDBmOGJmXG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBnZXRGNjRDb2RlY31cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEY2NEVuY29kZXIgPSAoY29uZmlnOiBOdW1iZXJDb2RlY0NvbmZpZyA9IHt9KTogRml4ZWRTaXplRW5jb2RlcjxiaWdpbnQgfCBudW1iZXIsIDg+ID0+XG4gICAgbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICAgICAgICBjb25maWcsXG4gICAgICAgIG5hbWU6ICdmNjQnLFxuICAgICAgICBzZXQ6ICh2aWV3LCB2YWx1ZSwgbGUpID0+IHZpZXcuc2V0RmxvYXQ2NCgwLCBOdW1iZXIodmFsdWUpLCBsZSksXG4gICAgICAgIHNpemU6IDgsXG4gICAgfSk7XG5cbi8qKlxuICogUmV0dXJucyBhIGRlY29kZXIgZm9yIDY0LWJpdCBmbG9hdGluZy1wb2ludCBudW1iZXJzIChgZjY0YCkuXG4gKlxuICogVGhpcyBkZWNvZGVyIGRlc2VyaWFsaXplcyBgZjY0YCB2YWx1ZXMgZnJvbSA4IGJ5dGVzLlxuICogU29tZSBwcmVjaXNpb24gbWF5IGJlIGxvc3QgZHVyaW5nIGRlY29kaW5nIGR1ZSB0byBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUge0BsaW5rIGdldEY2NENvZGVjfS5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiB0byBzcGVjaWZ5IGVuZGlhbm5lc3MgKGxpdHRsZSBieSBkZWZhdWx0KS5cbiAqIEByZXR1cm5zIEEgYEZpeGVkU2l6ZURlY29kZXI8bnVtYmVyLCA4PmAgZm9yIGRlY29kaW5nIGBmNjRgIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogRGVjb2RpbmcgYW4gYGY2NGAgdmFsdWUuXG4gKiBgYGB0c1xuICogY29uc3QgZGVjb2RlciA9IGdldEY2NERlY29kZXIoKTtcbiAqIGNvbnN0IHZhbHVlID0gZGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4ZjgsIDB4YmZdKSk7IC8vIC0xLjVcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGdldEY2NENvZGVjfVxuICovXG5leHBvcnQgY29uc3QgZ2V0RjY0RGVjb2RlciA9IChjb25maWc6IE51bWJlckNvZGVjQ29uZmlnID0ge30pOiBGaXhlZFNpemVEZWNvZGVyPG51bWJlciwgOD4gPT5cbiAgICBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgZ2V0OiAodmlldywgbGUpID0+IHZpZXcuZ2V0RmxvYXQ2NCgwLCBsZSksXG4gICAgICAgIG5hbWU6ICdmNjQnLFxuICAgICAgICBzaXplOiA4LFxuICAgIH0pO1xuXG4vKipcbiAqIFJldHVybnMgYSBjb2RlYyBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIDY0LWJpdCBmbG9hdGluZy1wb2ludCBudW1iZXJzIChgZjY0YCkuXG4gKlxuICogVGhpcyBjb2RlYyBzZXJpYWxpemVzIGBmNjRgIHZhbHVlcyB1c2luZyA4IGJ5dGVzLlxuICogRHVlIHRvIHRoZSBJRUVFIDc1NCBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiwgc29tZSBwcmVjaXNpb24gbG9zcyBtYXkgb2NjdXIuXG4gKlxuICogQHBhcmFtIGNvbmZpZyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gdG8gc3BlY2lmeSBlbmRpYW5uZXNzIChsaXR0bGUgYnkgZGVmYXVsdCkuXG4gKiBAcmV0dXJucyBBIGBGaXhlZFNpemVDb2RlYzxudW1iZXIsIG51bWJlciwgOD5gIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgYGY2NGAgdmFsdWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBFbmNvZGluZyBhbmQgZGVjb2RpbmcgYW4gYGY2NGAgdmFsdWUuXG4gKiBgYGB0c1xuICogY29uc3QgY29kZWMgPSBnZXRGNjRDb2RlYygpO1xuICogY29uc3QgYnl0ZXMgPSBjb2RlYy5lbmNvZGUoLTEuNSk7IC8vIDB4MDAwMDAwMDAwMDAwZjhiZlxuICogY29uc3QgdmFsdWUgPSBjb2RlYy5kZWNvZGUoYnl0ZXMpOyAvLyAtMS41XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogVXNpbmcgYmlnLWVuZGlhbiBlbmNvZGluZy5cbiAqIGBgYHRzXG4gKiBjb25zdCBjb2RlYyA9IGdldEY2NENvZGVjKHsgZW5kaWFuOiBFbmRpYW4uQmlnIH0pO1xuICogY29uc3QgYnl0ZXMgPSBjb2RlYy5lbmNvZGUoLTEuNSk7IC8vIDB4YmZmODAwMDAwMDAwMDAwMFxuICogYGBgXG4gKlxuICogQHJlbWFya3NcbiAqIGBmNjRgIHZhbHVlcyBmb2xsb3cgdGhlIElFRUUgNzU0IGRvdWJsZS1wcmVjaXNpb24gZmxvYXRpbmctcG9pbnQgc3RhbmRhcmQuXG4gKiBQcmVjaXNpb24gbG9zcyBtYXkgc3RpbGwgb2NjdXIgYnV0IGlzIHNpZ25pZmljYW50bHkgbG93ZXIgdGhhbiBgZjMyYC5cbiAqXG4gKiAtIElmIHlvdSBuZWVkIHNtYWxsZXIgZmxvYXRpbmctcG9pbnQgdmFsdWVzLCBjb25zaWRlciB1c2luZyB7QGxpbmsgZ2V0RjMyQ29kZWN9LlxuICogLSBJZiB5b3UgbmVlZCBpbnRlZ2VyIHZhbHVlcywgY29uc2lkZXIgdXNpbmcge0BsaW5rIGdldEk2NENvZGVjfSBvciB7QGxpbmsgZ2V0VTY0Q29kZWN9LlxuICpcbiAqIFNlcGFyYXRlIHtAbGluayBnZXRGNjRFbmNvZGVyfSBhbmQge0BsaW5rIGdldEY2NERlY29kZXJ9IGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlLlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBieXRlcyA9IGdldEY2NEVuY29kZXIoKS5lbmNvZGUoLTEuNSk7XG4gKiBjb25zdCB2YWx1ZSA9IGdldEY2NERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZ2V0RjY0RW5jb2Rlcn1cbiAqIEBzZWUge0BsaW5rIGdldEY2NERlY29kZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRGNjRDb2RlYyA9IChjb25maWc6IE51bWJlckNvZGVjQ29uZmlnID0ge30pOiBGaXhlZFNpemVDb2RlYzxiaWdpbnQgfCBudW1iZXIsIG51bWJlciwgOD4gPT5cbiAgICBjb21iaW5lQ29kZWMoZ2V0RjY0RW5jb2Rlcihjb25maWcpLCBnZXRGNjREZWNvZGVyKGNvbmZpZykpO1xuIiwgImltcG9ydCB7IGNvbWJpbmVDb2RlYywgRml4ZWRTaXplQ29kZWMsIEZpeGVkU2l6ZURlY29kZXIsIEZpeGVkU2l6ZUVuY29kZXIgfSBmcm9tICdAc29sYW5hL2NvZGVjcy1jb3JlJztcblxuaW1wb3J0IHsgTnVtYmVyQ29kZWNDb25maWcgfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyBudW1iZXJEZWNvZGVyRmFjdG9yeSwgbnVtYmVyRW5jb2RlckZhY3RvcnkgfSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGVuY29kZXIgZm9yIDEyOC1iaXQgc2lnbmVkIGludGVnZXJzIChgaTEyOGApLlxuICpcbiAqIFRoaXMgZW5jb2RlciBzZXJpYWxpemVzIGBpMTI4YCB2YWx1ZXMgdXNpbmcgMTYgYnl0ZXMuXG4gKiBWYWx1ZXMgY2FuIGJlIHByb3ZpZGVkIGFzIGVpdGhlciBgbnVtYmVyYCBvciBgYmlnaW50YC5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUge0BsaW5rIGdldEkxMjhDb2RlY30uXG4gKlxuICogQHBhcmFtIGNvbmZpZyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gdG8gc3BlY2lmeSBlbmRpYW5uZXNzIChsaXR0bGUgYnkgZGVmYXVsdCkuXG4gKiBAcmV0dXJucyBBIGBGaXhlZFNpemVFbmNvZGVyPG51bWJlciB8IGJpZ2ludCwgMTY+YCBmb3IgZW5jb2RpbmcgYGkxMjhgIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogRW5jb2RpbmcgYW4gYGkxMjhgIHZhbHVlLlxuICogYGBgdHNcbiAqIGNvbnN0IGVuY29kZXIgPSBnZXRJMTI4RW5jb2RlcigpO1xuICogY29uc3QgYnl0ZXMgPSBlbmNvZGVyLmVuY29kZSgtNDJuKTsgLy8gMHhkNmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZ2V0STEyOENvZGVjfVxuICovXG5leHBvcnQgY29uc3QgZ2V0STEyOEVuY29kZXIgPSAoY29uZmlnOiBOdW1iZXJDb2RlY0NvbmZpZyA9IHt9KTogRml4ZWRTaXplRW5jb2RlcjxiaWdpbnQgfCBudW1iZXIsIDE2PiA9PlxuICAgIG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBuYW1lOiAnaTEyOCcsXG4gICAgICAgIHJhbmdlOiBbLUJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicpIC0gMW4sIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicpXSxcbiAgICAgICAgc2V0OiAodmlldywgdmFsdWUsIGxlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0T2Zmc2V0ID0gbGUgPyA4IDogMDtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0T2Zmc2V0ID0gbGUgPyAwIDogODtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0TWFzayA9IDB4ZmZmZmZmZmZmZmZmZmZmZm47XG4gICAgICAgICAgICB2aWV3LnNldEJpZ0ludDY0KGxlZnRPZmZzZXQsIEJpZ0ludCh2YWx1ZSkgPj4gNjRuLCBsZSk7XG4gICAgICAgICAgICB2aWV3LnNldEJpZ1VpbnQ2NChyaWdodE9mZnNldCwgQmlnSW50KHZhbHVlKSAmIHJpZ2h0TWFzaywgbGUpO1xuICAgICAgICB9LFxuICAgICAgICBzaXplOiAxNixcbiAgICB9KTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZGVjb2RlciBmb3IgMTI4LWJpdCBzaWduZWQgaW50ZWdlcnMgKGBpMTI4YCkuXG4gKlxuICogVGhpcyBkZWNvZGVyIGRlc2VyaWFsaXplcyBgaTEyOGAgdmFsdWVzIGZyb20gMTYgYnl0ZXMuXG4gKiBUaGUgZGVjb2RlZCB2YWx1ZSBpcyBhbHdheXMgYSBgYmlnaW50YC5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUge0BsaW5rIGdldEkxMjhDb2RlY30uXG4gKlxuICogQHBhcmFtIGNvbmZpZyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gdG8gc3BlY2lmeSBlbmRpYW5uZXNzIChsaXR0bGUgYnkgZGVmYXVsdCkuXG4gKiBAcmV0dXJucyBBIGBGaXhlZFNpemVEZWNvZGVyPGJpZ2ludCwgMTY+YCBmb3IgZGVjb2RpbmcgYGkxMjhgIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogRGVjb2RpbmcgYW4gYGkxMjhgIHZhbHVlLlxuICogYGBgdHNcbiAqIGNvbnN0IGRlY29kZXIgPSBnZXRJMTI4RGVjb2RlcigpO1xuICogY29uc3QgdmFsdWUgPSBkZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheShbXG4gKiAgIDB4ZDYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gKiAgIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmZcbiAqIF0pKTsgLy8gLTQyblxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZ2V0STEyOENvZGVjfVxuICovXG5leHBvcnQgY29uc3QgZ2V0STEyOERlY29kZXIgPSAoY29uZmlnOiBOdW1iZXJDb2RlY0NvbmZpZyA9IHt9KTogRml4ZWRTaXplRGVjb2RlcjxiaWdpbnQsIDE2PiA9PlxuICAgIG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBnZXQ6ICh2aWV3LCBsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVmdE9mZnNldCA9IGxlID8gOCA6IDA7XG4gICAgICAgICAgICBjb25zdCByaWdodE9mZnNldCA9IGxlID8gMCA6IDg7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gdmlldy5nZXRCaWdJbnQ2NChsZWZ0T2Zmc2V0LCBsZSk7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHZpZXcuZ2V0QmlnVWludDY0KHJpZ2h0T2Zmc2V0LCBsZSk7XG4gICAgICAgICAgICByZXR1cm4gKGxlZnQgPDwgNjRuKSArIHJpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBuYW1lOiAnaTEyOCcsXG4gICAgICAgIHNpemU6IDE2LFxuICAgIH0pO1xuXG4vKipcbiAqIFJldHVybnMgYSBjb2RlYyBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIDEyOC1iaXQgc2lnbmVkIGludGVnZXJzIChgaTEyOGApLlxuICpcbiAqIFRoaXMgY29kZWMgc2VyaWFsaXplcyBgaTEyOGAgdmFsdWVzIHVzaW5nIDE2IGJ5dGVzLlxuICogVmFsdWVzIGNhbiBiZSBwcm92aWRlZCBhcyBlaXRoZXIgYG51bWJlcmAgb3IgYGJpZ2ludGAsIGJ1dCB0aGUgZGVjb2RlZCB2YWx1ZSBpcyBhbHdheXMgYSBgYmlnaW50YC5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiB0byBzcGVjaWZ5IGVuZGlhbm5lc3MgKGxpdHRsZSBieSBkZWZhdWx0KS5cbiAqIEByZXR1cm5zIEEgYEZpeGVkU2l6ZUNvZGVjPG51bWJlciB8IGJpZ2ludCwgYmlnaW50LCAxNj5gIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgYGkxMjhgIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogRW5jb2RpbmcgYW5kIGRlY29kaW5nIGFuIGBpMTI4YCB2YWx1ZS5cbiAqIGBgYHRzXG4gKiBjb25zdCBjb2RlYyA9IGdldEkxMjhDb2RlYygpO1xuICogY29uc3QgYnl0ZXMgPSBjb2RlYy5lbmNvZGUoLTQybik7IC8vIDB4ZDZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcbiAqIGNvbnN0IHZhbHVlID0gY29kZWMuZGVjb2RlKGJ5dGVzKTsgLy8gLTQyblxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIFVzaW5nIGJpZy1lbmRpYW4gZW5jb2RpbmcuXG4gKiBgYGB0c1xuICogY29uc3QgY29kZWMgPSBnZXRJMTI4Q29kZWMoeyBlbmRpYW46IEVuZGlhbi5CaWcgfSk7XG4gKiBjb25zdCBieXRlcyA9IGNvZGVjLmVuY29kZSgtNDJuKTsgLy8gMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZDZcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGNvZGVjIHN1cHBvcnRzIHZhbHVlcyBiZXR3ZWVuIGAtMl4xMjdgIGFuZCBgMl4xMjcgLSAxYC5cbiAqIFNpbmNlIEphdmFTY3JpcHQgYG51bWJlcmAgY2Fubm90IHNhZmVseSByZXByZXNlbnQgdmFsdWVzIGJleW9uZCBgMl41MyAtIDFgLCB0aGUgZGVjb2RlZCB2YWx1ZSBpcyBhbHdheXMgYSBgYmlnaW50YC5cbiAqXG4gKiAtIElmIHlvdSBuZWVkIGEgc21hbGxlciBzaWduZWQgaW50ZWdlciwgY29uc2lkZXIgdXNpbmcge0BsaW5rIGdldEk2NENvZGVjfSBvciB7QGxpbmsgZ2V0STMyQ29kZWN9LlxuICogLSBJZiB5b3UgbmVlZCBhIGxhcmdlciBzaWduZWQgaW50ZWdlciwgY29uc2lkZXIgdXNpbmcgYSBjdXN0b20gY29kZWMuXG4gKiAtIElmIHlvdSBuZWVkIHVuc2lnbmVkIGludGVnZXJzLCBjb25zaWRlciB1c2luZyB7QGxpbmsgZ2V0VTEyOENvZGVjfS5cbiAqXG4gKiBTZXBhcmF0ZSB7QGxpbmsgZ2V0STEyOEVuY29kZXJ9IGFuZCB7QGxpbmsgZ2V0STEyOERlY29kZXJ9IGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlLlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBieXRlcyA9IGdldEkxMjhFbmNvZGVyKCkuZW5jb2RlKC00Mik7XG4gKiBjb25zdCB2YWx1ZSA9IGdldEkxMjhEZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGdldEkxMjhFbmNvZGVyfVxuICogQHNlZSB7QGxpbmsgZ2V0STEyOERlY29kZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRJMTI4Q29kZWMgPSAoY29uZmlnOiBOdW1iZXJDb2RlY0NvbmZpZyA9IHt9KTogRml4ZWRTaXplQ29kZWM8YmlnaW50IHwgbnVtYmVyLCBiaWdpbnQsIDE2PiA9PlxuICAgIGNvbWJpbmVDb2RlYyhnZXRJMTI4RW5jb2Rlcihjb25maWcpLCBnZXRJMTI4RGVjb2Rlcihjb25maWcpKTtcbiIsICJpbXBvcnQgeyBjb21iaW5lQ29kZWMsIEZpeGVkU2l6ZUNvZGVjLCBGaXhlZFNpemVEZWNvZGVyLCBGaXhlZFNpemVFbmNvZGVyIH0gZnJvbSAnQHNvbGFuYS9jb2RlY3MtY29yZSc7XG5cbmltcG9ydCB7IE51bWJlckNvZGVjQ29uZmlnIH0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHsgbnVtYmVyRGVjb2RlckZhY3RvcnksIG51bWJlckVuY29kZXJGYWN0b3J5IH0gZnJvbSAnLi91dGlscyc7XG5cbi8qKlxuICogUmV0dXJucyBhbiBlbmNvZGVyIGZvciAxNi1iaXQgc2lnbmVkIGludGVnZXJzIChgaTE2YCkuXG4gKlxuICogVGhpcyBlbmNvZGVyIHNlcmlhbGl6ZXMgYGkxNmAgdmFsdWVzIHVzaW5nIDIgYnl0ZXMuXG4gKiBWYWx1ZXMgY2FuIGJlIHByb3ZpZGVkIGFzIGVpdGhlciBgbnVtYmVyYCBvciBgYmlnaW50YC5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUge0BsaW5rIGdldEkxNkNvZGVjfS5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiB0byBzcGVjaWZ5IGVuZGlhbm5lc3MgKGxpdHRsZSBieSBkZWZhdWx0KS5cbiAqIEByZXR1cm5zIEEgYEZpeGVkU2l6ZUVuY29kZXI8bnVtYmVyIHwgYmlnaW50LCAyPmAgZm9yIGVuY29kaW5nIGBpMTZgIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogRW5jb2RpbmcgYW4gYGkxNmAgdmFsdWUuXG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlciA9IGdldEkxNkVuY29kZXIoKTtcbiAqIGNvbnN0IGJ5dGVzID0gZW5jb2Rlci5lbmNvZGUoLTQyKTsgLy8gMHhkNmZmXG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBnZXRJMTZDb2RlY31cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEkxNkVuY29kZXIgPSAoY29uZmlnOiBOdW1iZXJDb2RlY0NvbmZpZyA9IHt9KTogRml4ZWRTaXplRW5jb2RlcjxiaWdpbnQgfCBudW1iZXIsIDI+ID0+XG4gICAgbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICAgICAgICBjb25maWcsXG4gICAgICAgIG5hbWU6ICdpMTYnLFxuICAgICAgICByYW5nZTogWy1OdW1iZXIoJzB4N2ZmZicpIC0gMSwgTnVtYmVyKCcweDdmZmYnKV0sXG4gICAgICAgIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRJbnQxNigwLCBOdW1iZXIodmFsdWUpLCBsZSksXG4gICAgICAgIHNpemU6IDIsXG4gICAgfSk7XG5cbi8qKlxuICogUmV0dXJucyBhIGRlY29kZXIgZm9yIDE2LWJpdCBzaWduZWQgaW50ZWdlcnMgKGBpMTZgKS5cbiAqXG4gKiBUaGlzIGRlY29kZXIgZGVzZXJpYWxpemVzIGBpMTZgIHZhbHVlcyBmcm9tIDIgYnl0ZXMuXG4gKiBUaGUgZGVjb2RlZCB2YWx1ZSBpcyBhbHdheXMgYSBgbnVtYmVyYC5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUge0BsaW5rIGdldEkxNkNvZGVjfS5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiB0byBzcGVjaWZ5IGVuZGlhbm5lc3MgKGxpdHRsZSBieSBkZWZhdWx0KS5cbiAqIEByZXR1cm5zIEEgYEZpeGVkU2l6ZURlY29kZXI8bnVtYmVyLCAyPmAgZm9yIGRlY29kaW5nIGBpMTZgIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogRGVjb2RpbmcgYW4gYGkxNmAgdmFsdWUuXG4gKiBgYGB0c1xuICogY29uc3QgZGVjb2RlciA9IGdldEkxNkRlY29kZXIoKTtcbiAqIGNvbnN0IHZhbHVlID0gZGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoWzB4ZDYsIDB4ZmZdKSk7IC8vIC00MlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZ2V0STE2Q29kZWN9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRJMTZEZWNvZGVyID0gKGNvbmZpZzogTnVtYmVyQ29kZWNDb25maWcgPSB7fSk6IEZpeGVkU2l6ZURlY29kZXI8bnVtYmVyLCAyPiA9PlxuICAgIG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBnZXQ6ICh2aWV3LCBsZSkgPT4gdmlldy5nZXRJbnQxNigwLCBsZSksXG4gICAgICAgIG5hbWU6ICdpMTYnLFxuICAgICAgICBzaXplOiAyLFxuICAgIH0pO1xuXG4vKipcbiAqIFJldHVybnMgYSBjb2RlYyBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIDE2LWJpdCBzaWduZWQgaW50ZWdlcnMgKGBpMTZgKS5cbiAqXG4gKiBUaGlzIGNvZGVjIHNlcmlhbGl6ZXMgYGkxNmAgdmFsdWVzIHVzaW5nIDIgYnl0ZXMuXG4gKiBWYWx1ZXMgY2FuIGJlIHByb3ZpZGVkIGFzIGVpdGhlciBgbnVtYmVyYCBvciBgYmlnaW50YCwgYnV0IHRoZSBkZWNvZGVkIHZhbHVlIGlzIGFsd2F5cyBhIGBudW1iZXJgLlxuICpcbiAqIEBwYXJhbSBjb25maWcgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIHRvIHNwZWNpZnkgZW5kaWFubmVzcyAobGl0dGxlIGJ5IGRlZmF1bHQpLlxuICogQHJldHVybnMgQSBgRml4ZWRTaXplQ29kZWM8bnVtYmVyIHwgYmlnaW50LCBudW1iZXIsIDI+YCBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIGBpMTZgIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogRW5jb2RpbmcgYW5kIGRlY29kaW5nIGFuIGBpMTZgIHZhbHVlLlxuICogYGBgdHNcbiAqIGNvbnN0IGNvZGVjID0gZ2V0STE2Q29kZWMoKTtcbiAqIGNvbnN0IGJ5dGVzID0gY29kZWMuZW5jb2RlKC00Mik7IC8vIDB4ZDZmZlxuICogY29uc3QgdmFsdWUgPSBjb2RlYy5kZWNvZGUoYnl0ZXMpOyAvLyAtNDJcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBVc2luZyBiaWctZW5kaWFuIGVuY29kaW5nLlxuICogYGBgdHNcbiAqIGNvbnN0IGNvZGVjID0gZ2V0STE2Q29kZWMoeyBlbmRpYW46IEVuZGlhbi5CaWcgfSk7XG4gKiBjb25zdCBieXRlcyA9IGNvZGVjLmVuY29kZSgtNDIpOyAvLyAweGZmZDZcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGNvZGVjIHN1cHBvcnRzIHZhbHVlcyBiZXR3ZWVuIGAtMl4xNWAgKGAtMzIsNzY4YCkgYW5kIGAyXjE1IC0gMWAgKGAzMiw3NjdgKS5cbiAqXG4gKiAtIElmIHlvdSBuZWVkIGEgc21hbGxlciBzaWduZWQgaW50ZWdlciwgY29uc2lkZXIgdXNpbmcge0BsaW5rIGdldEk4Q29kZWN9LlxuICogLSBJZiB5b3UgbmVlZCBhIGxhcmdlciBzaWduZWQgaW50ZWdlciwgY29uc2lkZXIgdXNpbmcge0BsaW5rIGdldEkzMkNvZGVjfS5cbiAqIC0gSWYgeW91IG5lZWQgdW5zaWduZWQgaW50ZWdlcnMsIGNvbnNpZGVyIHVzaW5nIHtAbGluayBnZXRVMTZDb2RlY30uXG4gKlxuICogU2VwYXJhdGUge0BsaW5rIGdldEkxNkVuY29kZXJ9IGFuZCB7QGxpbmsgZ2V0STE2RGVjb2Rlcn0gZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUuXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IGJ5dGVzID0gZ2V0STE2RW5jb2RlcigpLmVuY29kZSgtNDIpO1xuICogY29uc3QgdmFsdWUgPSBnZXRJMTZEZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGdldEkxNkVuY29kZXJ9XG4gKiBAc2VlIHtAbGluayBnZXRJMTZEZWNvZGVyfVxuICovXG5leHBvcnQgY29uc3QgZ2V0STE2Q29kZWMgPSAoY29uZmlnOiBOdW1iZXJDb2RlY0NvbmZpZyA9IHt9KTogRml4ZWRTaXplQ29kZWM8YmlnaW50IHwgbnVtYmVyLCBudW1iZXIsIDI+ID0+XG4gICAgY29tYmluZUNvZGVjKGdldEkxNkVuY29kZXIoY29uZmlnKSwgZ2V0STE2RGVjb2Rlcihjb25maWcpKTtcbiIsICJpbXBvcnQgeyBjb21iaW5lQ29kZWMsIEZpeGVkU2l6ZUNvZGVjLCBGaXhlZFNpemVEZWNvZGVyLCBGaXhlZFNpemVFbmNvZGVyIH0gZnJvbSAnQHNvbGFuYS9jb2RlY3MtY29yZSc7XG5cbmltcG9ydCB7IE51bWJlckNvZGVjQ29uZmlnIH0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHsgbnVtYmVyRGVjb2RlckZhY3RvcnksIG51bWJlckVuY29kZXJGYWN0b3J5IH0gZnJvbSAnLi91dGlscyc7XG5cbi8qKlxuICogUmV0dXJucyBhbiBlbmNvZGVyIGZvciAzMi1iaXQgc2lnbmVkIGludGVnZXJzIChgaTMyYCkuXG4gKlxuICogVGhpcyBlbmNvZGVyIHNlcmlhbGl6ZXMgYGkzMmAgdmFsdWVzIHVzaW5nIDQgYnl0ZXMuXG4gKiBWYWx1ZXMgY2FuIGJlIHByb3ZpZGVkIGFzIGVpdGhlciBgbnVtYmVyYCBvciBgYmlnaW50YC5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUge0BsaW5rIGdldEkzMkNvZGVjfS5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiB0byBzcGVjaWZ5IGVuZGlhbm5lc3MgKGxpdHRsZSBieSBkZWZhdWx0KS5cbiAqIEByZXR1cm5zIEEgYEZpeGVkU2l6ZUVuY29kZXI8bnVtYmVyIHwgYmlnaW50LCA0PmAgZm9yIGVuY29kaW5nIGBpMzJgIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogRW5jb2RpbmcgYW4gYGkzMmAgdmFsdWUuXG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlciA9IGdldEkzMkVuY29kZXIoKTtcbiAqIGNvbnN0IGJ5dGVzID0gZW5jb2Rlci5lbmNvZGUoLTQyKTsgLy8gMHhkNmZmZmZmZlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZ2V0STMyQ29kZWN9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRJMzJFbmNvZGVyID0gKGNvbmZpZzogTnVtYmVyQ29kZWNDb25maWcgPSB7fSk6IEZpeGVkU2l6ZUVuY29kZXI8YmlnaW50IHwgbnVtYmVyLCA0PiA9PlxuICAgIG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBuYW1lOiAnaTMyJyxcbiAgICAgICAgcmFuZ2U6IFstTnVtYmVyKCcweDdmZmZmZmZmJykgLSAxLCBOdW1iZXIoJzB4N2ZmZmZmZmYnKV0sXG4gICAgICAgIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRJbnQzMigwLCBOdW1iZXIodmFsdWUpLCBsZSksXG4gICAgICAgIHNpemU6IDQsXG4gICAgfSk7XG5cbi8qKlxuICogUmV0dXJucyBhIGRlY29kZXIgZm9yIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgKGBpMzJgKS5cbiAqXG4gKiBUaGlzIGRlY29kZXIgZGVzZXJpYWxpemVzIGBpMzJgIHZhbHVlcyBmcm9tIDQgYnl0ZXMuXG4gKiBUaGUgZGVjb2RlZCB2YWx1ZSBpcyBhbHdheXMgYSBgbnVtYmVyYC5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUge0BsaW5rIGdldEkzMkNvZGVjfS5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiB0byBzcGVjaWZ5IGVuZGlhbm5lc3MgKGxpdHRsZSBieSBkZWZhdWx0KS5cbiAqIEByZXR1cm5zIEEgYEZpeGVkU2l6ZURlY29kZXI8bnVtYmVyLCA0PmAgZm9yIGRlY29kaW5nIGBpMzJgIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogRGVjb2RpbmcgYW4gYGkzMmAgdmFsdWUuXG4gKiBgYGB0c1xuICogY29uc3QgZGVjb2RlciA9IGdldEkzMkRlY29kZXIoKTtcbiAqIGNvbnN0IHZhbHVlID0gZGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoWzB4ZDYsIDB4ZmYsIDB4ZmYsIDB4ZmZdKSk7IC8vIC00MlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZ2V0STMyQ29kZWN9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRJMzJEZWNvZGVyID0gKGNvbmZpZzogTnVtYmVyQ29kZWNDb25maWcgPSB7fSk6IEZpeGVkU2l6ZURlY29kZXI8bnVtYmVyLCA0PiA9PlxuICAgIG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBnZXQ6ICh2aWV3LCBsZSkgPT4gdmlldy5nZXRJbnQzMigwLCBsZSksXG4gICAgICAgIG5hbWU6ICdpMzInLFxuICAgICAgICBzaXplOiA0LFxuICAgIH0pO1xuXG4vKipcbiAqIFJldHVybnMgYSBjb2RlYyBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgKGBpMzJgKS5cbiAqXG4gKiBUaGlzIGNvZGVjIHNlcmlhbGl6ZXMgYGkzMmAgdmFsdWVzIHVzaW5nIDQgYnl0ZXMuXG4gKiBWYWx1ZXMgY2FuIGJlIHByb3ZpZGVkIGFzIGVpdGhlciBgbnVtYmVyYCBvciBgYmlnaW50YCwgYnV0IHRoZSBkZWNvZGVkIHZhbHVlIGlzIGFsd2F5cyBhIGBudW1iZXJgLlxuICpcbiAqIEBwYXJhbSBjb25maWcgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIHRvIHNwZWNpZnkgZW5kaWFubmVzcyAobGl0dGxlIGJ5IGRlZmF1bHQpLlxuICogQHJldHVybnMgQSBgRml4ZWRTaXplQ29kZWM8bnVtYmVyIHwgYmlnaW50LCBudW1iZXIsIDQ+YCBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIGBpMzJgIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogRW5jb2RpbmcgYW5kIGRlY29kaW5nIGFuIGBpMzJgIHZhbHVlLlxuICogYGBgdHNcbiAqIGNvbnN0IGNvZGVjID0gZ2V0STMyQ29kZWMoKTtcbiAqIGNvbnN0IGJ5dGVzID0gY29kZWMuZW5jb2RlKC00Mik7IC8vIDB4ZDZmZmZmZmZcbiAqIGNvbnN0IHZhbHVlID0gY29kZWMuZGVjb2RlKGJ5dGVzKTsgLy8gLTQyXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogVXNpbmcgYmlnLWVuZGlhbiBlbmNvZGluZy5cbiAqIGBgYHRzXG4gKiBjb25zdCBjb2RlYyA9IGdldEkzMkNvZGVjKHsgZW5kaWFuOiBFbmRpYW4uQmlnIH0pO1xuICogY29uc3QgYnl0ZXMgPSBjb2RlYy5lbmNvZGUoLTQyKTsgLy8gMHhmZmZmZmZkNlxuICogYGBgXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgY29kZWMgc3VwcG9ydHMgdmFsdWVzIGJldHdlZW4gYC0yXjMxYCAoYC0yLDE0Nyw0ODMsNjQ4YCkgYW5kIGAyXjMxIC0gMWAgKGAyLDE0Nyw0ODMsNjQ3YCkuXG4gKlxuICogLSBJZiB5b3UgbmVlZCBhIHNtYWxsZXIgc2lnbmVkIGludGVnZXIsIGNvbnNpZGVyIHVzaW5nIHtAbGluayBnZXRJMTZDb2RlY30gb3Ige0BsaW5rIGdldEk4Q29kZWN9LlxuICogLSBJZiB5b3UgbmVlZCBhIGxhcmdlciBzaWduZWQgaW50ZWdlciwgY29uc2lkZXIgdXNpbmcge0BsaW5rIGdldEk2NENvZGVjfS5cbiAqIC0gSWYgeW91IG5lZWQgdW5zaWduZWQgaW50ZWdlcnMsIGNvbnNpZGVyIHVzaW5nIHtAbGluayBnZXRVMzJDb2RlY30uXG4gKlxuICogU2VwYXJhdGUge0BsaW5rIGdldEkzMkVuY29kZXJ9IGFuZCB7QGxpbmsgZ2V0STMyRGVjb2Rlcn0gZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUuXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IGJ5dGVzID0gZ2V0STMyRW5jb2RlcigpLmVuY29kZSgtNDIpO1xuICogY29uc3QgdmFsdWUgPSBnZXRJMzJEZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGdldEkzMkVuY29kZXJ9XG4gKiBAc2VlIHtAbGluayBnZXRJMzJEZWNvZGVyfVxuICovXG5leHBvcnQgY29uc3QgZ2V0STMyQ29kZWMgPSAoY29uZmlnOiBOdW1iZXJDb2RlY0NvbmZpZyA9IHt9KTogRml4ZWRTaXplQ29kZWM8YmlnaW50IHwgbnVtYmVyLCBudW1iZXIsIDQ+ID0+XG4gICAgY29tYmluZUNvZGVjKGdldEkzMkVuY29kZXIoY29uZmlnKSwgZ2V0STMyRGVjb2Rlcihjb25maWcpKTtcbiIsICJpbXBvcnQgeyBjb21iaW5lQ29kZWMsIEZpeGVkU2l6ZUNvZGVjLCBGaXhlZFNpemVEZWNvZGVyLCBGaXhlZFNpemVFbmNvZGVyIH0gZnJvbSAnQHNvbGFuYS9jb2RlY3MtY29yZSc7XG5cbmltcG9ydCB7IE51bWJlckNvZGVjQ29uZmlnIH0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHsgbnVtYmVyRGVjb2RlckZhY3RvcnksIG51bWJlckVuY29kZXJGYWN0b3J5IH0gZnJvbSAnLi91dGlscyc7XG5cbi8qKlxuICogUmV0dXJucyBhbiBlbmNvZGVyIGZvciA2NC1iaXQgc2lnbmVkIGludGVnZXJzIChgaTY0YCkuXG4gKlxuICogVGhpcyBlbmNvZGVyIHNlcmlhbGl6ZXMgYGk2NGAgdmFsdWVzIHVzaW5nIDggYnl0ZXMuXG4gKiBWYWx1ZXMgY2FuIGJlIHByb3ZpZGVkIGFzIGVpdGhlciBgbnVtYmVyYCBvciBgYmlnaW50YC5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUge0BsaW5rIGdldEk2NENvZGVjfS5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiB0byBzcGVjaWZ5IGVuZGlhbm5lc3MgKGxpdHRsZSBieSBkZWZhdWx0KS5cbiAqIEByZXR1cm5zIEEgYEZpeGVkU2l6ZUVuY29kZXI8bnVtYmVyIHwgYmlnaW50LCA4PmAgZm9yIGVuY29kaW5nIGBpNjRgIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogRW5jb2RpbmcgYW4gYGk2NGAgdmFsdWUuXG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlciA9IGdldEk2NEVuY29kZXIoKTtcbiAqIGNvbnN0IGJ5dGVzID0gZW5jb2Rlci5lbmNvZGUoLTQybik7IC8vIDB4ZDZmZmZmZmZmZmZmZmZmZlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZ2V0STY0Q29kZWN9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRJNjRFbmNvZGVyID0gKGNvbmZpZzogTnVtYmVyQ29kZWNDb25maWcgPSB7fSk6IEZpeGVkU2l6ZUVuY29kZXI8YmlnaW50IHwgbnVtYmVyLCA4PiA9PlxuICAgIG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBuYW1lOiAnaTY0JyxcbiAgICAgICAgcmFuZ2U6IFstQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSAtIDFuLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpXSxcbiAgICAgICAgc2V0OiAodmlldywgdmFsdWUsIGxlKSA9PiB2aWV3LnNldEJpZ0ludDY0KDAsIEJpZ0ludCh2YWx1ZSksIGxlKSxcbiAgICAgICAgc2l6ZTogOCxcbiAgICB9KTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZGVjb2RlciBmb3IgNjQtYml0IHNpZ25lZCBpbnRlZ2VycyAoYGk2NGApLlxuICpcbiAqIFRoaXMgZGVjb2RlciBkZXNlcmlhbGl6ZXMgYGk2NGAgdmFsdWVzIGZyb20gOCBieXRlcy5cbiAqIFRoZSBkZWNvZGVkIHZhbHVlIGlzIGFsd2F5cyBhIGBiaWdpbnRgLlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB7QGxpbmsgZ2V0STY0Q29kZWN9LlxuICpcbiAqIEBwYXJhbSBjb25maWcgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIHRvIHNwZWNpZnkgZW5kaWFubmVzcyAobGl0dGxlIGJ5IGRlZmF1bHQpLlxuICogQHJldHVybnMgQSBgRml4ZWRTaXplRGVjb2RlcjxiaWdpbnQsIDg+YCBmb3IgZGVjb2RpbmcgYGk2NGAgdmFsdWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBEZWNvZGluZyBhbiBgaTY0YCB2YWx1ZS5cbiAqIGBgYHRzXG4gKiBjb25zdCBkZWNvZGVyID0gZ2V0STY0RGVjb2RlcigpO1xuICogY29uc3QgdmFsdWUgPSBkZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheShbXG4gKiAgIDB4ZDYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmZcbiAqIF0pKTsgLy8gLTQyblxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZ2V0STY0Q29kZWN9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRJNjREZWNvZGVyID0gKGNvbmZpZzogTnVtYmVyQ29kZWNDb25maWcgPSB7fSk6IEZpeGVkU2l6ZURlY29kZXI8YmlnaW50LCA4PiA9PlxuICAgIG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBnZXQ6ICh2aWV3LCBsZSkgPT4gdmlldy5nZXRCaWdJbnQ2NCgwLCBsZSksXG4gICAgICAgIG5hbWU6ICdpNjQnLFxuICAgICAgICBzaXplOiA4LFxuICAgIH0pO1xuXG4vKipcbiAqIFJldHVybnMgYSBjb2RlYyBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIDY0LWJpdCBzaWduZWQgaW50ZWdlcnMgKGBpNjRgKS5cbiAqXG4gKiBUaGlzIGNvZGVjIHNlcmlhbGl6ZXMgYGk2NGAgdmFsdWVzIHVzaW5nIDggYnl0ZXMuXG4gKiBWYWx1ZXMgY2FuIGJlIHByb3ZpZGVkIGFzIGVpdGhlciBgbnVtYmVyYCBvciBgYmlnaW50YCwgYnV0IHRoZSBkZWNvZGVkIHZhbHVlIGlzIGFsd2F5cyBhIGBiaWdpbnRgLlxuICpcbiAqIEBwYXJhbSBjb25maWcgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIHRvIHNwZWNpZnkgZW5kaWFubmVzcyAobGl0dGxlIGJ5IGRlZmF1bHQpLlxuICogQHJldHVybnMgQSBgRml4ZWRTaXplQ29kZWM8bnVtYmVyIHwgYmlnaW50LCBiaWdpbnQsIDg+YCBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIGBpNjRgIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogRW5jb2RpbmcgYW5kIGRlY29kaW5nIGFuIGBpNjRgIHZhbHVlLlxuICogYGBgdHNcbiAqIGNvbnN0IGNvZGVjID0gZ2V0STY0Q29kZWMoKTtcbiAqIGNvbnN0IGJ5dGVzID0gY29kZWMuZW5jb2RlKC00Mm4pOyAvLyAweGQ2ZmZmZmZmZmZmZmZmZmZcbiAqIGNvbnN0IHZhbHVlID0gY29kZWMuZGVjb2RlKGJ5dGVzKTsgLy8gLTQyblxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIFVzaW5nIGJpZy1lbmRpYW4gZW5jb2RpbmcuXG4gKiBgYGB0c1xuICogY29uc3QgY29kZWMgPSBnZXRJNjRDb2RlYyh7IGVuZGlhbjogRW5kaWFuLkJpZyB9KTtcbiAqIGNvbnN0IGJ5dGVzID0gY29kZWMuZW5jb2RlKC00Mm4pOyAvLyAweGZmZmZmZmZmZmZmZmZmZDZcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGNvZGVjIHN1cHBvcnRzIHZhbHVlcyBiZXR3ZWVuIGAtMl42M2AgYW5kIGAyXjYzIC0gMWAuXG4gKiBTaW5jZSBKYXZhU2NyaXB0IGBudW1iZXJgIGNhbm5vdCBzYWZlbHkgcmVwcmVzZW50IHZhbHVlcyBiZXlvbmQgYDJeNTMgLSAxYCwgdGhlIGRlY29kZWQgdmFsdWUgaXMgYWx3YXlzIGEgYGJpZ2ludGAuXG4gKlxuICogLSBJZiB5b3UgbmVlZCBhIHNtYWxsZXIgc2lnbmVkIGludGVnZXIsIGNvbnNpZGVyIHVzaW5nIHtAbGluayBnZXRJMzJDb2RlY30gb3Ige0BsaW5rIGdldEkxNkNvZGVjfS5cbiAqIC0gSWYgeW91IG5lZWQgYSBsYXJnZXIgc2lnbmVkIGludGVnZXIsIGNvbnNpZGVyIHVzaW5nIHtAbGluayBnZXRJMTI4Q29kZWN9LlxuICogLSBJZiB5b3UgbmVlZCB1bnNpZ25lZCBpbnRlZ2VycywgY29uc2lkZXIgdXNpbmcge0BsaW5rIGdldFU2NENvZGVjfS5cbiAqXG4gKiBTZXBhcmF0ZSB7QGxpbmsgZ2V0STY0RW5jb2Rlcn0gYW5kIHtAbGluayBnZXRJNjREZWNvZGVyfSBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgYnl0ZXMgPSBnZXRJNjRFbmNvZGVyKCkuZW5jb2RlKC00Mik7XG4gKiBjb25zdCB2YWx1ZSA9IGdldEk2NERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZ2V0STY0RW5jb2Rlcn1cbiAqIEBzZWUge0BsaW5rIGdldEk2NERlY29kZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRJNjRDb2RlYyA9IChjb25maWc6IE51bWJlckNvZGVjQ29uZmlnID0ge30pOiBGaXhlZFNpemVDb2RlYzxiaWdpbnQgfCBudW1iZXIsIGJpZ2ludCwgOD4gPT5cbiAgICBjb21iaW5lQ29kZWMoZ2V0STY0RW5jb2Rlcihjb25maWcpLCBnZXRJNjREZWNvZGVyKGNvbmZpZykpO1xuIiwgImltcG9ydCB7IGNvbWJpbmVDb2RlYywgRml4ZWRTaXplQ29kZWMsIEZpeGVkU2l6ZURlY29kZXIsIEZpeGVkU2l6ZUVuY29kZXIgfSBmcm9tICdAc29sYW5hL2NvZGVjcy1jb3JlJztcblxuaW1wb3J0IHsgbnVtYmVyRGVjb2RlckZhY3RvcnksIG51bWJlckVuY29kZXJGYWN0b3J5IH0gZnJvbSAnLi91dGlscyc7XG5cbi8qKlxuICogUmV0dXJucyBhbiBlbmNvZGVyIGZvciA4LWJpdCBzaWduZWQgaW50ZWdlcnMgKGBpOGApLlxuICpcbiAqIFRoaXMgZW5jb2RlciBzZXJpYWxpemVzIGBpOGAgdmFsdWVzIHVzaW5nIDEgYnl0ZS5cbiAqIFZhbHVlcyBjYW4gYmUgcHJvdmlkZWQgYXMgZWl0aGVyIGBudW1iZXJgIG9yIGBiaWdpbnRgLlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB7QGxpbmsgZ2V0SThDb2RlY30uXG4gKlxuICogQHJldHVybnMgQSBgRml4ZWRTaXplRW5jb2RlcjxudW1iZXIgfCBiaWdpbnQsIDE+YCBmb3IgZW5jb2RpbmcgYGk4YCB2YWx1ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIEVuY29kaW5nIGFuIGBpOGAgdmFsdWUuXG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlciA9IGdldEk4RW5jb2RlcigpO1xuICogY29uc3QgYnl0ZXMgPSBlbmNvZGVyLmVuY29kZSgtNDIpOyAvLyAweGQ2XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBnZXRJOENvZGVjfVxuICovXG5leHBvcnQgY29uc3QgZ2V0SThFbmNvZGVyID0gKCk6IEZpeGVkU2l6ZUVuY29kZXI8YmlnaW50IHwgbnVtYmVyLCAxPiA9PlxuICAgIG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgICAgICAgbmFtZTogJ2k4JyxcbiAgICAgICAgcmFuZ2U6IFstTnVtYmVyKCcweDdmJykgLSAxLCBOdW1iZXIoJzB4N2YnKV0sXG4gICAgICAgIHNldDogKHZpZXcsIHZhbHVlKSA9PiB2aWV3LnNldEludDgoMCwgTnVtYmVyKHZhbHVlKSksXG4gICAgICAgIHNpemU6IDEsXG4gICAgfSk7XG5cbi8qKlxuICogUmV0dXJucyBhIGRlY29kZXIgZm9yIDgtYml0IHNpZ25lZCBpbnRlZ2VycyAoYGk4YCkuXG4gKlxuICogVGhpcyBkZWNvZGVyIGRlc2VyaWFsaXplcyBgaThgIHZhbHVlcyBmcm9tIDEgYnl0ZS5cbiAqIFRoZSBkZWNvZGVkIHZhbHVlIGlzIGFsd2F5cyBhIGBudW1iZXJgLlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB7QGxpbmsgZ2V0SThDb2RlY30uXG4gKlxuICogQHJldHVybnMgQSBgRml4ZWRTaXplRGVjb2RlcjxudW1iZXIsIDE+YCBmb3IgZGVjb2RpbmcgYGk4YCB2YWx1ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIERlY29kaW5nIGFuIGBpOGAgdmFsdWUuXG4gKiBgYGB0c1xuICogY29uc3QgZGVjb2RlciA9IGdldEk4RGVjb2RlcigpO1xuICogY29uc3QgdmFsdWUgPSBkZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheShbMHhkNl0pKTsgLy8gLTQyXG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBnZXRJOENvZGVjfVxuICovXG5leHBvcnQgY29uc3QgZ2V0SThEZWNvZGVyID0gKCk6IEZpeGVkU2l6ZURlY29kZXI8bnVtYmVyLCAxPiA9PlxuICAgIG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgICAgICAgZ2V0OiB2aWV3ID0+IHZpZXcuZ2V0SW50OCgwKSxcbiAgICAgICAgbmFtZTogJ2k4JyxcbiAgICAgICAgc2l6ZTogMSxcbiAgICB9KTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgY29kZWMgZm9yIGVuY29kaW5nIGFuZCBkZWNvZGluZyA4LWJpdCBzaWduZWQgaW50ZWdlcnMgKGBpOGApLlxuICpcbiAqIFRoaXMgY29kZWMgc2VyaWFsaXplcyBgaThgIHZhbHVlcyB1c2luZyAxIGJ5dGUuXG4gKiBWYWx1ZXMgY2FuIGJlIHByb3ZpZGVkIGFzIGVpdGhlciBgbnVtYmVyYCBvciBgYmlnaW50YCwgYnV0IHRoZSBkZWNvZGVkIHZhbHVlIGlzIGFsd2F5cyBhIGBudW1iZXJgLlxuICpcbiAqIEByZXR1cm5zIEEgYEZpeGVkU2l6ZUNvZGVjPG51bWJlciB8IGJpZ2ludCwgbnVtYmVyLCAxPmAgZm9yIGVuY29kaW5nIGFuZCBkZWNvZGluZyBgaThgIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogRW5jb2RpbmcgYW5kIGRlY29kaW5nIGFuIGBpOGAgdmFsdWUuXG4gKiBgYGB0c1xuICogY29uc3QgY29kZWMgPSBnZXRJOENvZGVjKCk7XG4gKiBjb25zdCBieXRlcyA9IGNvZGVjLmVuY29kZSgtNDIpOyAvLyAweGQ2XG4gKiBjb25zdCB2YWx1ZSA9IGNvZGVjLmRlY29kZShieXRlcyk7IC8vIC00MlxuICogYGBgXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgY29kZWMgc3VwcG9ydHMgdmFsdWVzIGJldHdlZW4gYC0yXjdgIChgLTEyOGApIGFuZCBgMl43IC0gMWAgKGAxMjdgKS5cbiAqXG4gKiAtIElmIHlvdSBuZWVkIGEgbGFyZ2VyIHNpZ25lZCBpbnRlZ2VyLCBjb25zaWRlciB1c2luZyB7QGxpbmsgZ2V0STE2Q29kZWN9LlxuICogLSBJZiB5b3UgbmVlZCBhbiB1bnNpZ25lZCBpbnRlZ2VyLCBjb25zaWRlciB1c2luZyB7QGxpbmsgZ2V0VThDb2RlY30uXG4gKlxuICogU2VwYXJhdGUge0BsaW5rIGdldEk4RW5jb2Rlcn0gYW5kIHtAbGluayBnZXRJOERlY29kZXJ9IGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlLlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBieXRlcyA9IGdldEk4RW5jb2RlcigpLmVuY29kZSgtNDIpO1xuICogY29uc3QgdmFsdWUgPSBnZXRJOERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZ2V0SThFbmNvZGVyfVxuICogQHNlZSB7QGxpbmsgZ2V0SThEZWNvZGVyfVxuICovXG5leHBvcnQgY29uc3QgZ2V0SThDb2RlYyA9ICgpOiBGaXhlZFNpemVDb2RlYzxiaWdpbnQgfCBudW1iZXIsIG51bWJlciwgMT4gPT5cbiAgICBjb21iaW5lQ29kZWMoZ2V0SThFbmNvZGVyKCksIGdldEk4RGVjb2RlcigpKTtcbiIsICJpbXBvcnQge1xuICAgIGNvbWJpbmVDb2RlYyxcbiAgICBjcmVhdGVEZWNvZGVyLFxuICAgIGNyZWF0ZUVuY29kZXIsXG4gICAgT2Zmc2V0LFxuICAgIFJlYWRvbmx5VWludDhBcnJheSxcbiAgICBWYXJpYWJsZVNpemVDb2RlYyxcbiAgICBWYXJpYWJsZVNpemVEZWNvZGVyLFxuICAgIFZhcmlhYmxlU2l6ZUVuY29kZXIsXG59IGZyb20gJ0Bzb2xhbmEvY29kZWNzLWNvcmUnO1xuXG5pbXBvcnQgeyBhc3NlcnROdW1iZXJJc0JldHdlZW5Gb3JDb2RlYyB9IGZyb20gJy4vYXNzZXJ0aW9ucyc7XG5cbi8qKlxuICogUmV0dXJucyBhbiBlbmNvZGVyIGZvciBgc2hvcnRVMTZgIHZhbHVlcy5cbiAqXG4gKiBUaGlzIGVuY29kZXIgc2VyaWFsaXplcyBgc2hvcnRVMTZgIHZhbHVlcyB1c2luZyAqKjEgdG8gMyBieXRlcyoqLlxuICogU21hbGxlciB2YWx1ZXMgdXNlIGZld2VyIGJ5dGVzLCB3aGlsZSBsYXJnZXIgdmFsdWVzIHRha2UgdXAgbW9yZSBzcGFjZS5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUge0BsaW5rIGdldFNob3J0VTE2Q29kZWN9LlxuICpcbiAqIEByZXR1cm5zIEEgYFZhcmlhYmxlU2l6ZUVuY29kZXI8bnVtYmVyIHwgYmlnaW50PmAgZm9yIGVuY29kaW5nIGBzaG9ydFUxNmAgdmFsdWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBFbmNvZGluZyBhIGBzaG9ydFUxNmAgdmFsdWUuXG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlciA9IGdldFNob3J0VTE2RW5jb2RlcigpO1xuICogZW5jb2Rlci5lbmNvZGUoNDIpOyAgICAvLyAweDJhXG4gKiBlbmNvZGVyLmVuY29kZSgxMjgpOyAgIC8vIDB4ODAwMVxuICogZW5jb2Rlci5lbmNvZGUoMTYzODQpOyAvLyAweDgwODAwMVxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZ2V0U2hvcnRVMTZDb2RlY31cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFNob3J0VTE2RW5jb2RlciA9ICgpOiBWYXJpYWJsZVNpemVFbmNvZGVyPGJpZ2ludCB8IG51bWJlcj4gPT5cbiAgICBjcmVhdGVFbmNvZGVyKHtcbiAgICAgICAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlOiBiaWdpbnQgfCBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlIDw9IDBiMDExMTExMTEpIHJldHVybiAxO1xuICAgICAgICAgICAgaWYgKHZhbHVlIDw9IDBiMDAxMTExMTExMTExMTExMSkgcmV0dXJuIDI7XG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgfSxcbiAgICAgICAgbWF4U2l6ZTogMyxcbiAgICAgICAgd3JpdGU6ICh2YWx1ZTogYmlnaW50IHwgbnVtYmVyLCBieXRlczogVWludDhBcnJheSwgb2Zmc2V0OiBPZmZzZXQpOiBPZmZzZXQgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0TnVtYmVySXNCZXR3ZWVuRm9yQ29kZWMoJ3Nob3J0VTE2JywgMCwgNjU1MzUsIHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3J0VTE2Qnl0ZXMgPSBbMF07XG4gICAgICAgICAgICBmb3IgKGxldCBpaSA9IDA7IDsgaWkgKz0gMSkge1xuICAgICAgICAgICAgICAgIC8vIFNoaWZ0IHRoZSBiaXRzIG9mIHRoZSB2YWx1ZSBvdmVyIHN1Y2ggdGhhdCB0aGUgbmV4dCA3IGJpdHMgYXJlIGF0IHRoZSByaWdodCBlZGdlLlxuICAgICAgICAgICAgICAgIGNvbnN0IGFsaWduZWRWYWx1ZSA9IE51bWJlcih2YWx1ZSkgPj4gKGlpICogNyk7XG4gICAgICAgICAgICAgICAgaWYgKGFsaWduZWRWYWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBtb3JlIGJpdHMgdG8gY29uc3VtZS5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhvc2UgNyBiaXRzIHVzaW5nIGEgbWFzay5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0U2V2ZW5CaXRzID0gMGIxMTExMTExICYgYWxpZ25lZFZhbHVlO1xuICAgICAgICAgICAgICAgIHNob3J0VTE2Qnl0ZXNbaWldID0gbmV4dFNldmVuQml0cztcbiAgICAgICAgICAgICAgICBpZiAoaWkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgY29udGludWF0aW9uIGJpdCBvZiB0aGUgcHJldmlvdXMgc2xpY2UuXG4gICAgICAgICAgICAgICAgICAgIHNob3J0VTE2Qnl0ZXNbaWkgLSAxXSB8PSAwYjEwMDAwMDAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ5dGVzLnNldChzaG9ydFUxNkJ5dGVzLCBvZmZzZXQpO1xuICAgICAgICAgICAgcmV0dXJuIG9mZnNldCArIHNob3J0VTE2Qnl0ZXMubGVuZ3RoO1xuICAgICAgICB9LFxuICAgIH0pO1xuXG4vKipcbiAqIFJldHVybnMgYSBkZWNvZGVyIGZvciBgc2hvcnRVMTZgIHZhbHVlcy5cbiAqXG4gKiBUaGlzIGRlY29kZXIgZGVzZXJpYWxpemVzIGBzaG9ydFUxNmAgdmFsdWVzIGZyb20gKioxIHRvIDMgYnl0ZXMqKi5cbiAqIFRoZSBudW1iZXIgb2YgYnl0ZXMgdXNlZCBkZXBlbmRzIG9uIHRoZSBlbmNvZGVkIHZhbHVlLlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB7QGxpbmsgZ2V0U2hvcnRVMTZDb2RlY30uXG4gKlxuICogQHJldHVybnMgQSBgVmFyaWFibGVTaXplRGVjb2RlcjxudW1iZXI+YCBmb3IgZGVjb2RpbmcgYHNob3J0VTE2YCB2YWx1ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIERlY29kaW5nIGEgYHNob3J0VTE2YCB2YWx1ZS5cbiAqIGBgYHRzXG4gKiBjb25zdCBkZWNvZGVyID0gZ2V0U2hvcnRVMTZEZWNvZGVyKCk7XG4gKiBkZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheShbMHgyYV0pKTsgICAgICAgICAgICAgLy8gNDJcbiAqIGRlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KFsweDgwLCAweDAxXSkpOyAgICAgICAvLyAxMjhcbiAqIGRlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KFsweDgwLCAweDgwLCAweDAxXSkpOyAvLyAxNjM4NFxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZ2V0U2hvcnRVMTZDb2RlY31cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFNob3J0VTE2RGVjb2RlciA9ICgpOiBWYXJpYWJsZVNpemVEZWNvZGVyPG51bWJlcj4gPT5cbiAgICBjcmVhdGVEZWNvZGVyKHtcbiAgICAgICAgbWF4U2l6ZTogMyxcbiAgICAgICAgcmVhZDogKGJ5dGVzOiBSZWFkb25seVVpbnQ4QXJyYXkgfCBVaW50OEFycmF5LCBvZmZzZXQpOiBbbnVtYmVyLCBPZmZzZXRdID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgICAgICAgICBsZXQgYnl0ZUNvdW50ID0gMDtcbiAgICAgICAgICAgIHdoaWxlICgrK2J5dGVDb3VudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVJbmRleCA9IGJ5dGVDb3VudCAtIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEJ5dGUgPSBieXRlc1tvZmZzZXQgKyBieXRlSW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRTZXZlbkJpdHMgPSAwYjExMTExMTEgJiBjdXJyZW50Qnl0ZTtcbiAgICAgICAgICAgICAgICAvLyBJbnNlcnQgdGhlIG5leHQgZ3JvdXAgb2Ygc2V2ZW4gYml0cyBpbnRvIHRoZSBjb3JyZWN0IHNsb3Qgb2YgdGhlIG91dHB1dCB2YWx1ZS5cbiAgICAgICAgICAgICAgICB2YWx1ZSB8PSBuZXh0U2V2ZW5CaXRzIDw8IChieXRlSW5kZXggKiA3KTtcbiAgICAgICAgICAgICAgICBpZiAoKGN1cnJlbnRCeXRlICYgMGIxMDAwMDAwMCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBieXRlIGRvZXMgbm90IGhhdmUgaXRzIGNvbnRpbnVhdGlvbiBiaXQgc2V0LiBXZSdyZSBkb25lLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3ZhbHVlLCBvZmZzZXQgKyBieXRlQ291bnRdO1xuICAgICAgICB9LFxuICAgIH0pO1xuXG4vKipcbiAqIFJldHVybnMgYSBjb2RlYyBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIGBzaG9ydFUxNmAgdmFsdWVzLlxuICpcbiAqIEl0IHNlcmlhbGl6ZXMgdW5zaWduZWQgaW50ZWdlcnMgdXNpbmcgKioxIHRvIDMgYnl0ZXMqKiBiYXNlZCBvbiB0aGUgZW5jb2RlZCB2YWx1ZS5cbiAqIFRoZSBsYXJnZXIgdGhlIHZhbHVlLCB0aGUgbW9yZSBieXRlcyBpdCB1c2VzLlxuICpcbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGA8PSAweDdmYCAoMTI3KSwgaXQgaXMgc3RvcmVkIGluIGEgKipzaW5nbGUgYnl0ZSoqXG4gKiAgIGFuZCB0aGUgZmlyc3QgYml0IGlzIHNldCB0byBgMGAgdG8gaW5kaWNhdGUgdGhlIGVuZCBvZiB0aGUgdmFsdWUuXG4gKiAtIE90aGVyd2lzZSwgdGhlIGZpcnN0IGJpdCBpcyBzZXQgdG8gYDFgIHRvIGluZGljYXRlIHRoYXQgdGhlIHZhbHVlIGNvbnRpbnVlcyBpbiB0aGUgbmV4dCBieXRlLCB3aGljaCBmb2xsb3dzIHRoZSBzYW1lIHBhdHRlcm4uXG4gKiAtIFRoaXMgcHJvY2VzcyByZXBlYXRzIHVudGlsIHRoZSB2YWx1ZSBpcyBmdWxseSBlbmNvZGVkIGluIHVwIHRvIDMgYnl0ZXMuIFRoZSB0aGlyZCBhbmQgbGFzdCBieXRlLCBpZiBuZWVkZWQsIHVzZXMgYWxsIDggYml0cyB0byBzdG9yZSB0aGUgcmVtYWluaW5nIHZhbHVlLlxuICpcbiAqIEluIG90aGVyIHdvcmRzLCB0aGUgZW5jb2Rpbmcgc2NoZW1lIGZvbGxvd3MgdGhpcyBzdHJ1Y3R1cmU6XG4gKlxuICogYGBgdHh0XG4gKiAwWFhYWFhYWCAgICAgICAgICAgICAgICAgICA8LSBWYWx1ZXMgMCB0byAxMjcgKDEgYnl0ZSlcbiAqIDFYWFhYWFhYIDBYWFhYWFhYICAgICAgICAgIDwtIFZhbHVlcyAxMjggdG8gMTYsMzgzICgyIGJ5dGVzKVxuICogMVhYWFhYWFggMVhYWFhYWFggWFhYWFhYWFggPC0gVmFsdWVzIDE2LDM4NCB0byA0LDE5NCwzMDMgKDMgYnl0ZXMpXG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBBIGBWYXJpYWJsZVNpemVDb2RlYzxudW1iZXIgfCBiaWdpbnQsIG51bWJlcj5gIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgYHNob3J0VTE2YCB2YWx1ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIEVuY29kaW5nIGFuZCBkZWNvZGluZyBgc2hvcnRVMTZgIHZhbHVlcy5cbiAqIGBgYHRzXG4gKiBjb25zdCBjb2RlYyA9IGdldFNob3J0VTE2Q29kZWMoKTtcbiAqIGNvbnN0IGJ5dGVzMSA9IGNvZGVjLmVuY29kZSg0Mik7ICAgIC8vIDB4MmFcbiAqIGNvbnN0IGJ5dGVzMiA9IGNvZGVjLmVuY29kZSgxMjgpOyAgIC8vIDB4ODAwMVxuICogY29uc3QgYnl0ZXMzID0gY29kZWMuZW5jb2RlKDE2Mzg0KTsgLy8gMHg4MDgwMDFcbiAqXG4gKiBjb2RlYy5kZWNvZGUoYnl0ZXMxKTsgLy8gNDJcbiAqIGNvZGVjLmRlY29kZShieXRlczIpOyAvLyAxMjhcbiAqIGNvZGVjLmRlY29kZShieXRlczMpOyAvLyAxNjM4NFxuICogYGBgXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgY29kZWMgZWZmaWNpZW50bHkgc3RvcmVzIHNtYWxsIG51bWJlcnMsIG1ha2luZyBpdCB1c2VmdWwgZm9yIHRyYW5zYWN0aW9ucyBhbmQgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gKlxuICogSWYgeW91IG5lZWQgYSBmaXhlZC1zaXplIGB1MTZgIGNvZGVjLCBjb25zaWRlciB1c2luZyB7QGxpbmsgZ2V0VTE2Q29kZWN9LlxuICpcbiAqIFNlcGFyYXRlIHtAbGluayBnZXRTaG9ydFUxNkVuY29kZXJ9IGFuZCB7QGxpbmsgZ2V0U2hvcnRVMTZEZWNvZGVyfSBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgYnl0ZXMgPSBnZXRTaG9ydFUxNkVuY29kZXIoKS5lbmNvZGUoNDIpO1xuICogY29uc3QgdmFsdWUgPSBnZXRTaG9ydFUxNkRlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZ2V0U2hvcnRVMTZFbmNvZGVyfVxuICogQHNlZSB7QGxpbmsgZ2V0U2hvcnRVMTZEZWNvZGVyfVxuICovXG5leHBvcnQgY29uc3QgZ2V0U2hvcnRVMTZDb2RlYyA9ICgpOiBWYXJpYWJsZVNpemVDb2RlYzxiaWdpbnQgfCBudW1iZXIsIG51bWJlcj4gPT5cbiAgICBjb21iaW5lQ29kZWMoZ2V0U2hvcnRVMTZFbmNvZGVyKCksIGdldFNob3J0VTE2RGVjb2RlcigpKTtcbiIsICJpbXBvcnQgeyBjb21iaW5lQ29kZWMsIEZpeGVkU2l6ZUNvZGVjLCBGaXhlZFNpemVEZWNvZGVyLCBGaXhlZFNpemVFbmNvZGVyIH0gZnJvbSAnQHNvbGFuYS9jb2RlY3MtY29yZSc7XG5cbmltcG9ydCB7IE51bWJlckNvZGVjQ29uZmlnIH0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHsgbnVtYmVyRGVjb2RlckZhY3RvcnksIG51bWJlckVuY29kZXJGYWN0b3J5IH0gZnJvbSAnLi91dGlscyc7XG5cbi8qKlxuICogUmV0dXJucyBhbiBlbmNvZGVyIGZvciAxMjgtYml0IHVuc2lnbmVkIGludGVnZXJzIChgdTEyOGApLlxuICpcbiAqIFRoaXMgZW5jb2RlciBzZXJpYWxpemVzIGB1MTI4YCB2YWx1ZXMgdXNpbmcgc2l4dGVlbiBieXRlcyBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdCBieSBkZWZhdWx0LlxuICogWW91IG1heSBzcGVjaWZ5IGJpZy1lbmRpYW4gc3RvcmFnZSB1c2luZyB0aGUgYGVuZGlhbmAgb3B0aW9uLlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB7QGxpbmsgZ2V0VTEyOENvZGVjfS5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gT3B0aW9uYWwgc2V0dGluZ3MgZm9yIGVuZGlhbm5lc3MuXG4gKiBAcmV0dXJucyBBIGBGaXhlZFNpemVFbmNvZGVyPG51bWJlciB8IGJpZ2ludCwgMTY+YCBmb3IgZW5jb2RpbmcgYHUxMjhgIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogRW5jb2RpbmcgYSBgdTEyOGAgdmFsdWUuXG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlciA9IGdldFUxMjhFbmNvZGVyKCk7XG4gKiBjb25zdCBieXRlcyA9IGVuY29kZXIuZW5jb2RlKDQybik7IC8vIDB4MmEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGdldFUxMjhDb2RlY31cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFUxMjhFbmNvZGVyID0gKGNvbmZpZzogTnVtYmVyQ29kZWNDb25maWcgPSB7fSk6IEZpeGVkU2l6ZUVuY29kZXI8YmlnaW50IHwgbnVtYmVyLCAxNj4gPT5cbiAgICBudW1iZXJFbmNvZGVyRmFjdG9yeSh7XG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgbmFtZTogJ3UxMjgnLFxuICAgICAgICByYW5nZTogWzBuLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYnKV0sXG4gICAgICAgIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVmdE9mZnNldCA9IGxlID8gOCA6IDA7XG4gICAgICAgICAgICBjb25zdCByaWdodE9mZnNldCA9IGxlID8gMCA6IDg7XG4gICAgICAgICAgICBjb25zdCByaWdodE1hc2sgPSAweGZmZmZmZmZmZmZmZmZmZmZuO1xuICAgICAgICAgICAgdmlldy5zZXRCaWdVaW50NjQobGVmdE9mZnNldCwgQmlnSW50KHZhbHVlKSA+PiA2NG4sIGxlKTtcbiAgICAgICAgICAgIHZpZXcuc2V0QmlnVWludDY0KHJpZ2h0T2Zmc2V0LCBCaWdJbnQodmFsdWUpICYgcmlnaHRNYXNrLCBsZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IDE2LFxuICAgIH0pO1xuXG4vKipcbiAqIFJldHVybnMgYSBkZWNvZGVyIGZvciAxMjgtYml0IHVuc2lnbmVkIGludGVnZXJzIChgdTEyOGApLlxuICpcbiAqIFRoaXMgZGVjb2RlciBkZXNlcmlhbGl6ZXMgYHUxMjhgIHZhbHVlcyBmcm9tIHNpeHRlZW4gYnl0ZXMgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQgYnkgZGVmYXVsdC5cbiAqIFlvdSBtYXkgc3BlY2lmeSBiaWctZW5kaWFuIHN0b3JhZ2UgdXNpbmcgdGhlIGBlbmRpYW5gIG9wdGlvbi5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUge0BsaW5rIGdldFUxMjhDb2RlY30uXG4gKlxuICogQHBhcmFtIGNvbmZpZyAtIE9wdGlvbmFsIHNldHRpbmdzIGZvciBlbmRpYW5uZXNzLlxuICogQHJldHVybnMgQSBgRml4ZWRTaXplRGVjb2RlcjxiaWdpbnQsIDE2PmAgZm9yIGRlY29kaW5nIGB1MTI4YCB2YWx1ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIERlY29kaW5nIGEgYHUxMjhgIHZhbHVlLlxuICogYGBgdHNcbiAqIGNvbnN0IGRlY29kZXIgPSBnZXRVMTI4RGVjb2RlcigpO1xuICogY29uc3QgdmFsdWUgPSBkZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheShbMHgyYSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMF0pKTsgLy8gNDJuXG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBnZXRVMTI4Q29kZWN9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRVMTI4RGVjb2RlciA9IChjb25maWc6IE51bWJlckNvZGVjQ29uZmlnID0ge30pOiBGaXhlZFNpemVEZWNvZGVyPGJpZ2ludCwgMTY+ID0+XG4gICAgbnVtYmVyRGVjb2RlckZhY3Rvcnkoe1xuICAgICAgICBjb25maWcsXG4gICAgICAgIGdldDogKHZpZXcsIGxlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0T2Zmc2V0ID0gbGUgPyA4IDogMDtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0T2Zmc2V0ID0gbGUgPyAwIDogODtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSB2aWV3LmdldEJpZ1VpbnQ2NChsZWZ0T2Zmc2V0LCBsZSk7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHZpZXcuZ2V0QmlnVWludDY0KHJpZ2h0T2Zmc2V0LCBsZSk7XG4gICAgICAgICAgICByZXR1cm4gKGxlZnQgPDwgNjRuKSArIHJpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBuYW1lOiAndTEyOCcsXG4gICAgICAgIHNpemU6IDE2LFxuICAgIH0pO1xuXG4vKipcbiAqIFJldHVybnMgYSBjb2RlYyBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIDEyOC1iaXQgdW5zaWduZWQgaW50ZWdlcnMgKGB1MTI4YCkuXG4gKlxuICogVGhpcyBjb2RlYyBzZXJpYWxpemVzIGB1MTI4YCB2YWx1ZXMgdXNpbmcgMTYgYnl0ZXMuXG4gKiBWYWx1ZXMgY2FuIGJlIHByb3ZpZGVkIGFzIGVpdGhlciBgbnVtYmVyYCBvciBgYmlnaW50YCwgYnV0IHRoZSBkZWNvZGVkIHZhbHVlIGlzIGFsd2F5cyBhIGBiaWdpbnRgLlxuICpcbiAqIEBwYXJhbSBjb25maWcgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIHRvIHNwZWNpZnkgZW5kaWFubmVzcyAobGl0dGxlIGJ5IGRlZmF1bHQpLlxuICogQHJldHVybnMgQSBgRml4ZWRTaXplQ29kZWM8bnVtYmVyIHwgYmlnaW50LCBiaWdpbnQsIDE2PmAgZm9yIGVuY29kaW5nIGFuZCBkZWNvZGluZyBgdTEyOGAgdmFsdWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBFbmNvZGluZyBhbmQgZGVjb2RpbmcgYSBgdTEyOGAgdmFsdWUuXG4gKiBgYGB0c1xuICogY29uc3QgY29kZWMgPSBnZXRVMTI4Q29kZWMoKTtcbiAqIGNvbnN0IGJ5dGVzID0gY29kZWMuZW5jb2RlKDQyKTsgLy8gMHgyYTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFxuICogY29uc3QgdmFsdWUgPSBjb2RlYy5kZWNvZGUoYnl0ZXMpOyAvLyA0Mm5cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBVc2luZyBiaWctZW5kaWFuIGVuY29kaW5nLlxuICogYGBgdHNcbiAqIGNvbnN0IGNvZGVjID0gZ2V0VTEyOENvZGVjKHsgZW5kaWFuOiBFbmRpYW4uQmlnIH0pO1xuICogY29uc3QgYnl0ZXMgPSBjb2RlYy5lbmNvZGUoNDIpOyAvLyAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDJhXG4gKiBgYGBcbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBjb2RlYyBzdXBwb3J0cyB2YWx1ZXMgYmV0d2VlbiBgMGAgYW5kIGAyXjEyOCAtIDFgLlxuICogU2luY2UgSmF2YVNjcmlwdCBgbnVtYmVyYCBjYW5ub3Qgc2FmZWx5IHJlcHJlc2VudCB2YWx1ZXMgYmV5b25kIGAyXjUzIC0gMWAsIHRoZSBkZWNvZGVkIHZhbHVlIGlzIGFsd2F5cyBhIGBiaWdpbnRgLlxuICpcbiAqIC0gSWYgeW91IG5lZWQgYSBzbWFsbGVyIHVuc2lnbmVkIGludGVnZXIsIGNvbnNpZGVyIHVzaW5nIHtAbGluayBnZXRVNjRDb2RlY30gb3Ige0BsaW5rIGdldFUzMkNvZGVjfS5cbiAqIC0gSWYgeW91IG5lZWQgc2lnbmVkIGludGVnZXJzLCBjb25zaWRlciB1c2luZyB7QGxpbmsgZ2V0STEyOENvZGVjfS5cbiAqXG4gKiBTZXBhcmF0ZSB7QGxpbmsgZ2V0VTEyOEVuY29kZXJ9IGFuZCB7QGxpbmsgZ2V0VTEyOERlY29kZXJ9IGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlLlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBieXRlcyA9IGdldFUxMjhFbmNvZGVyKCkuZW5jb2RlKDQyKTtcbiAqIGNvbnN0IHZhbHVlID0gZ2V0VTEyOERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZ2V0VTEyOEVuY29kZXJ9XG4gKiBAc2VlIHtAbGluayBnZXRVMTI4RGVjb2Rlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFUxMjhDb2RlYyA9IChjb25maWc6IE51bWJlckNvZGVjQ29uZmlnID0ge30pOiBGaXhlZFNpemVDb2RlYzxiaWdpbnQgfCBudW1iZXIsIGJpZ2ludCwgMTY+ID0+XG4gICAgY29tYmluZUNvZGVjKGdldFUxMjhFbmNvZGVyKGNvbmZpZyksIGdldFUxMjhEZWNvZGVyKGNvbmZpZykpO1xuIiwgImltcG9ydCB7IGNvbWJpbmVDb2RlYywgRml4ZWRTaXplQ29kZWMsIEZpeGVkU2l6ZURlY29kZXIsIEZpeGVkU2l6ZUVuY29kZXIgfSBmcm9tICdAc29sYW5hL2NvZGVjcy1jb3JlJztcblxuaW1wb3J0IHsgTnVtYmVyQ29kZWNDb25maWcgfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyBudW1iZXJEZWNvZGVyRmFjdG9yeSwgbnVtYmVyRW5jb2RlckZhY3RvcnkgfSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGVuY29kZXIgZm9yIDE2LWJpdCB1bnNpZ25lZCBpbnRlZ2VycyAoYHUxNmApLlxuICpcbiAqIFRoaXMgZW5jb2RlciBzZXJpYWxpemVzIGB1MTZgIHZhbHVlcyB1c2luZyB0d28gYnl0ZXMgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQgYnkgZGVmYXVsdC5cbiAqIFlvdSBtYXkgc3BlY2lmeSBiaWctZW5kaWFuIHN0b3JhZ2UgdXNpbmcgdGhlIGBlbmRpYW5gIG9wdGlvbi5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUge0BsaW5rIGdldFUxNkNvZGVjfS5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gT3B0aW9uYWwgc2V0dGluZ3MgZm9yIGVuZGlhbm5lc3MuXG4gKiBAcmV0dXJucyBBIGBGaXhlZFNpemVFbmNvZGVyPG51bWJlciB8IGJpZ2ludCwgMj5gIGZvciBlbmNvZGluZyBgdTE2YCB2YWx1ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIEVuY29kaW5nIGEgYHUxNmAgdmFsdWUuXG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlciA9IGdldFUxNkVuY29kZXIoKTtcbiAqIGNvbnN0IGJ5dGVzID0gZW5jb2Rlci5lbmNvZGUoNDIpOyAvLyAweDJhMDBcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGdldFUxNkNvZGVjfVxuICovXG5leHBvcnQgY29uc3QgZ2V0VTE2RW5jb2RlciA9IChjb25maWc6IE51bWJlckNvZGVjQ29uZmlnID0ge30pOiBGaXhlZFNpemVFbmNvZGVyPGJpZ2ludCB8IG51bWJlciwgMj4gPT5cbiAgICBudW1iZXJFbmNvZGVyRmFjdG9yeSh7XG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgbmFtZTogJ3UxNicsXG4gICAgICAgIHJhbmdlOiBbMCwgTnVtYmVyKCcweGZmZmYnKV0sXG4gICAgICAgIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRVaW50MTYoMCwgTnVtYmVyKHZhbHVlKSwgbGUpLFxuICAgICAgICBzaXplOiAyLFxuICAgIH0pO1xuXG4vKipcbiAqIFJldHVybnMgYSBkZWNvZGVyIGZvciAxNi1iaXQgdW5zaWduZWQgaW50ZWdlcnMgKGB1MTZgKS5cbiAqXG4gKiBUaGlzIGRlY29kZXIgZGVzZXJpYWxpemVzIGB1MTZgIHZhbHVlcyBmcm9tIHR3byBieXRlcyBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdCBieSBkZWZhdWx0LlxuICogWW91IG1heSBzcGVjaWZ5IGJpZy1lbmRpYW4gc3RvcmFnZSB1c2luZyB0aGUgYGVuZGlhbmAgb3B0aW9uLlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB7QGxpbmsgZ2V0VTE2Q29kZWN9LlxuICpcbiAqIEBwYXJhbSBjb25maWcgLSBPcHRpb25hbCBzZXR0aW5ncyBmb3IgZW5kaWFubmVzcy5cbiAqIEByZXR1cm5zIEEgYEZpeGVkU2l6ZURlY29kZXI8bnVtYmVyLCAyPmAgZm9yIGRlY29kaW5nIGB1MTZgIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogRGVjb2RpbmcgYSBgdTE2YCB2YWx1ZS5cbiAqIGBgYHRzXG4gKiBjb25zdCBkZWNvZGVyID0gZ2V0VTE2RGVjb2RlcigpO1xuICogY29uc3QgdmFsdWUgPSBkZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheShbMHgyYSwgMHgwMF0pKTsgLy8gNDJcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGdldFUxNkNvZGVjfVxuICovXG5leHBvcnQgY29uc3QgZ2V0VTE2RGVjb2RlciA9IChjb25maWc6IE51bWJlckNvZGVjQ29uZmlnID0ge30pOiBGaXhlZFNpemVEZWNvZGVyPG51bWJlciwgMj4gPT5cbiAgICBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgZ2V0OiAodmlldywgbGUpID0+IHZpZXcuZ2V0VWludDE2KDAsIGxlKSxcbiAgICAgICAgbmFtZTogJ3UxNicsXG4gICAgICAgIHNpemU6IDIsXG4gICAgfSk7XG5cbi8qKlxuICogUmV0dXJucyBhIGNvZGVjIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgMTYtYml0IHVuc2lnbmVkIGludGVnZXJzIChgdTE2YCkuXG4gKlxuICogVGhpcyBjb2RlYyBzZXJpYWxpemVzIGB1MTZgIHZhbHVlcyB1c2luZyB0d28gYnl0ZXMgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQgYnkgZGVmYXVsdC5cbiAqIFlvdSBtYXkgc3BlY2lmeSBiaWctZW5kaWFuIHN0b3JhZ2UgdXNpbmcgdGhlIGBlbmRpYW5gIG9wdGlvbi5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gT3B0aW9uYWwgc2V0dGluZ3MgZm9yIGVuZGlhbm5lc3MuXG4gKiBAcmV0dXJucyBBIGBGaXhlZFNpemVDb2RlYzxudW1iZXIgfCBiaWdpbnQsIG51bWJlciwgMj5gIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgYHUxNmAgdmFsdWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBFbmNvZGluZyBhbmQgZGVjb2RpbmcgYSBgdTE2YCB2YWx1ZS5cbiAqIGBgYHRzXG4gKiBjb25zdCBjb2RlYyA9IGdldFUxNkNvZGVjKCk7XG4gKiBjb25zdCBieXRlcyA9IGNvZGVjLmVuY29kZSg0Mik7IC8vIDB4MmEwMCAobGl0dGxlLWVuZGlhbilcbiAqIGNvbnN0IHZhbHVlID0gY29kZWMuZGVjb2RlKGJ5dGVzKTsgLy8gNDJcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBTdG9yaW5nIHZhbHVlcyBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAqIGBgYHRzXG4gKiBjb25zdCBjb2RlYyA9IGdldFUxNkNvZGVjKHsgZW5kaWFuOiBFbmRpYW4uQmlnIH0pO1xuICogY29uc3QgYnl0ZXMgPSBjb2RlYy5lbmNvZGUoNDIpOyAvLyAweDAwMmFcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGNvZGVjIHN1cHBvcnRzIHZhbHVlcyBiZXR3ZWVuIGAwYCBhbmQgYDJeMTYgLSAxYC5cbiAqIElmIHlvdSBuZWVkIGEgbGFyZ2VyIHJhbmdlLCBjb25zaWRlciB1c2luZyB7QGxpbmsgZ2V0VTMyQ29kZWN9IG9yIHtAbGluayBnZXRVNjRDb2RlY30uXG4gKiBGb3Igc2lnbmVkIGludGVnZXJzLCB1c2Uge0BsaW5rIGdldEkxNkNvZGVjfS5cbiAqXG4gKiBTZXBhcmF0ZSB7QGxpbmsgZ2V0VTE2RW5jb2Rlcn0gYW5kIHtAbGluayBnZXRVMTZEZWNvZGVyfSBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgYnl0ZXMgPSBnZXRVMTZFbmNvZGVyKCkuZW5jb2RlKDQyKTtcbiAqIGNvbnN0IHZhbHVlID0gZ2V0VTE2RGVjb2RlcigpLmRlY29kZShieXRlcyk7XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBnZXRVMTZFbmNvZGVyfVxuICogQHNlZSB7QGxpbmsgZ2V0VTE2RGVjb2Rlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFUxNkNvZGVjID0gKGNvbmZpZzogTnVtYmVyQ29kZWNDb25maWcgPSB7fSk6IEZpeGVkU2l6ZUNvZGVjPGJpZ2ludCB8IG51bWJlciwgbnVtYmVyLCAyPiA9PlxuICAgIGNvbWJpbmVDb2RlYyhnZXRVMTZFbmNvZGVyKGNvbmZpZyksIGdldFUxNkRlY29kZXIoY29uZmlnKSk7XG4iLCAiaW1wb3J0IHsgY29tYmluZUNvZGVjLCBGaXhlZFNpemVDb2RlYywgRml4ZWRTaXplRGVjb2RlciwgRml4ZWRTaXplRW5jb2RlciB9IGZyb20gJ0Bzb2xhbmEvY29kZWNzLWNvcmUnO1xuXG5pbXBvcnQgeyBOdW1iZXJDb2RlY0NvbmZpZyB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7IG51bWJlckRlY29kZXJGYWN0b3J5LCBudW1iZXJFbmNvZGVyRmFjdG9yeSB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIFJldHVybnMgYW4gZW5jb2RlciBmb3IgMzItYml0IHVuc2lnbmVkIGludGVnZXJzIChgdTMyYCkuXG4gKlxuICogVGhpcyBlbmNvZGVyIHNlcmlhbGl6ZXMgYHUzMmAgdmFsdWVzIHVzaW5nIGZvdXIgYnl0ZXMgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQgYnkgZGVmYXVsdC5cbiAqIFlvdSBtYXkgc3BlY2lmeSBiaWctZW5kaWFuIHN0b3JhZ2UgdXNpbmcgdGhlIGBlbmRpYW5gIG9wdGlvbi5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUge0BsaW5rIGdldFUzMkNvZGVjfS5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gT3B0aW9uYWwgc2V0dGluZ3MgZm9yIGVuZGlhbm5lc3MuXG4gKiBAcmV0dXJucyBBIGBGaXhlZFNpemVFbmNvZGVyPGJpZ2ludCB8IG51bWJlciwgND5gIGZvciBlbmNvZGluZyBgdTMyYCB2YWx1ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIEVuY29kaW5nIGEgYHUzMmAgdmFsdWUuXG4gKiBgYGB0c1xuICogY29uc3QgZW5jb2RlciA9IGdldFUzMkVuY29kZXIoKTtcbiAqIGNvbnN0IGJ5dGVzID0gZW5jb2Rlci5lbmNvZGUoNDIpOyAvLyAweDJhMDAwMDAwXG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBnZXRVMzJDb2RlY31cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFUzMkVuY29kZXIgPSAoY29uZmlnOiBOdW1iZXJDb2RlY0NvbmZpZyA9IHt9KTogRml4ZWRTaXplRW5jb2RlcjxiaWdpbnQgfCBudW1iZXIsIDQ+ID0+XG4gICAgbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICAgICAgICBjb25maWcsXG4gICAgICAgIG5hbWU6ICd1MzInLFxuICAgICAgICByYW5nZTogWzAsIE51bWJlcignMHhmZmZmZmZmZicpXSxcbiAgICAgICAgc2V0OiAodmlldywgdmFsdWUsIGxlKSA9PiB2aWV3LnNldFVpbnQzMigwLCBOdW1iZXIodmFsdWUpLCBsZSksXG4gICAgICAgIHNpemU6IDQsXG4gICAgfSk7XG5cbi8qKlxuICogUmV0dXJucyBhIGRlY29kZXIgZm9yIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VycyAoYHUzMmApLlxuICpcbiAqIFRoaXMgZGVjb2RlciBkZXNlcmlhbGl6ZXMgYHUzMmAgdmFsdWVzIGZyb20gZm91ciBieXRlcyBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdCBieSBkZWZhdWx0LlxuICogWW91IG1heSBzcGVjaWZ5IGJpZy1lbmRpYW4gc3RvcmFnZSB1c2luZyB0aGUgYGVuZGlhbmAgb3B0aW9uLlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB7QGxpbmsgZ2V0VTMyQ29kZWN9LlxuICpcbiAqIEBwYXJhbSBjb25maWcgLSBPcHRpb25hbCBzZXR0aW5ncyBmb3IgZW5kaWFubmVzcy5cbiAqIEByZXR1cm5zIEEgYEZpeGVkU2l6ZURlY29kZXI8bnVtYmVyLCA0PmAgZm9yIGRlY29kaW5nIGB1MzJgIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogRGVjb2RpbmcgYSBgdTMyYCB2YWx1ZS5cbiAqIGBgYHRzXG4gKiBjb25zdCBkZWNvZGVyID0gZ2V0VTMyRGVjb2RlcigpO1xuICogY29uc3QgdmFsdWUgPSBkZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheShbMHgyYSwgMHgwMCwgMHgwMCwgMHgwMF0pKTsgLy8gNDJcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGdldFUzMkNvZGVjfVxuICovXG5leHBvcnQgY29uc3QgZ2V0VTMyRGVjb2RlciA9IChjb25maWc6IE51bWJlckNvZGVjQ29uZmlnID0ge30pOiBGaXhlZFNpemVEZWNvZGVyPG51bWJlciwgND4gPT5cbiAgICBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgZ2V0OiAodmlldywgbGUpID0+IHZpZXcuZ2V0VWludDMyKDAsIGxlKSxcbiAgICAgICAgbmFtZTogJ3UzMicsXG4gICAgICAgIHNpemU6IDQsXG4gICAgfSk7XG5cbi8qKlxuICogUmV0dXJucyBhIGNvZGVjIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgMzItYml0IHVuc2lnbmVkIGludGVnZXJzIChgdTMyYCkuXG4gKlxuICogVGhpcyBjb2RlYyBzZXJpYWxpemVzIGB1MzJgIHZhbHVlcyB1c2luZyBmb3VyIGJ5dGVzIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0IGJ5IGRlZmF1bHQuXG4gKiBZb3UgbWF5IHNwZWNpZnkgYmlnLWVuZGlhbiBzdG9yYWdlIHVzaW5nIHRoZSBgZW5kaWFuYCBvcHRpb24uXG4gKlxuICogQHBhcmFtIGNvbmZpZyAtIE9wdGlvbmFsIHNldHRpbmdzIGZvciBlbmRpYW5uZXNzLlxuICogQHJldHVybnMgQSBgRml4ZWRTaXplQ29kZWM8YmlnaW50IHwgbnVtYmVyLCBudW1iZXIsIDQ+YCBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIGB1MzJgIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogRW5jb2RpbmcgYW5kIGRlY29kaW5nIGEgYHUzMmAgdmFsdWUuXG4gKiBgYGB0c1xuICogY29uc3QgY29kZWMgPSBnZXRVMzJDb2RlYygpO1xuICogY29uc3QgYnl0ZXMgPSBjb2RlYy5lbmNvZGUoNDIpOyAvLyAweDJhMDAwMDAwIChsaXR0bGUtZW5kaWFuKVxuICogY29uc3QgdmFsdWUgPSBjb2RlYy5kZWNvZGUoYnl0ZXMpOyAvLyA0MlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIFN0b3JpbmcgdmFsdWVzIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICogYGBgdHNcbiAqIGNvbnN0IGNvZGVjID0gZ2V0VTMyQ29kZWMoeyBlbmRpYW46IEVuZGlhbi5CaWcgfSk7XG4gKiBjb25zdCBieXRlcyA9IGNvZGVjLmVuY29kZSg0Mik7IC8vIDB4MDAwMDAwMmFcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGNvZGVjIG9ubHkgc3VwcG9ydHMgdmFsdWVzIGJldHdlZW4gYDBgIGFuZCBgMl4zMiAtIDFgLlxuICogSWYgeW91IG5lZWQgYSBsYXJnZXIgcmFuZ2UsIGNvbnNpZGVyIHVzaW5nIHtAbGluayBnZXRVNjRDb2RlY30gb3Ige0BsaW5rIGdldFUxMjhDb2RlY30uXG4gKiBGb3Igc2lnbmVkIGludGVnZXJzLCB1c2Uge0BsaW5rIGdldEkzMkNvZGVjfS5cbiAqXG4gKiBTZXBhcmF0ZSB7QGxpbmsgZ2V0VTMyRW5jb2Rlcn0gYW5kIHtAbGluayBnZXRVMzJEZWNvZGVyfSBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgYnl0ZXMgPSBnZXRVMzJFbmNvZGVyKCkuZW5jb2RlKDQyKTtcbiAqIGNvbnN0IHZhbHVlID0gZ2V0VTMyRGVjb2RlcigpLmRlY29kZShieXRlcyk7XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBnZXRVMzJFbmNvZGVyfVxuICogQHNlZSB7QGxpbmsgZ2V0VTMyRGVjb2Rlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFUzMkNvZGVjID0gKGNvbmZpZzogTnVtYmVyQ29kZWNDb25maWcgPSB7fSk6IEZpeGVkU2l6ZUNvZGVjPGJpZ2ludCB8IG51bWJlciwgbnVtYmVyLCA0PiA9PlxuICAgIGNvbWJpbmVDb2RlYyhnZXRVMzJFbmNvZGVyKGNvbmZpZyksIGdldFUzMkRlY29kZXIoY29uZmlnKSk7XG4iLCAiaW1wb3J0IHsgY29tYmluZUNvZGVjLCBGaXhlZFNpemVDb2RlYywgRml4ZWRTaXplRGVjb2RlciwgRml4ZWRTaXplRW5jb2RlciB9IGZyb20gJ0Bzb2xhbmEvY29kZWNzLWNvcmUnO1xuXG5pbXBvcnQgeyBOdW1iZXJDb2RlY0NvbmZpZyB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7IG51bWJlckRlY29kZXJGYWN0b3J5LCBudW1iZXJFbmNvZGVyRmFjdG9yeSB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIFJldHVybnMgYW4gZW5jb2RlciBmb3IgNjQtYml0IHVuc2lnbmVkIGludGVnZXJzIChgdTY0YCkuXG4gKlxuICogVGhpcyBlbmNvZGVyIHNlcmlhbGl6ZXMgYHU2NGAgdmFsdWVzIHVzaW5nIDggYnl0ZXMuXG4gKiBWYWx1ZXMgY2FuIGJlIHByb3ZpZGVkIGFzIGVpdGhlciBgbnVtYmVyYCBvciBgYmlnaW50YC5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUge0BsaW5rIGdldFU2NENvZGVjfS5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiB0byBzcGVjaWZ5IGVuZGlhbm5lc3MgKGxpdHRsZSBieSBkZWZhdWx0KS5cbiAqIEByZXR1cm5zIEEgYEZpeGVkU2l6ZUVuY29kZXI8bnVtYmVyIHwgYmlnaW50LCA4PmAgZm9yIGVuY29kaW5nIGB1NjRgIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogRW5jb2RpbmcgYSBgdTY0YCB2YWx1ZS5cbiAqIGBgYHRzXG4gKiBjb25zdCBlbmNvZGVyID0gZ2V0VTY0RW5jb2RlcigpO1xuICogY29uc3QgYnl0ZXMgPSBlbmNvZGVyLmVuY29kZSg0Mik7IC8vIDB4MmEwMDAwMDAwMDAwMDAwMFxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZ2V0VTY0Q29kZWN9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRVNjRFbmNvZGVyID0gKGNvbmZpZzogTnVtYmVyQ29kZWNDb25maWcgPSB7fSk6IEZpeGVkU2l6ZUVuY29kZXI8YmlnaW50IHwgbnVtYmVyLCA4PiA9PlxuICAgIG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBuYW1lOiAndTY0JyxcbiAgICAgICAgcmFuZ2U6IFswbiwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKV0sXG4gICAgICAgIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRCaWdVaW50NjQoMCwgQmlnSW50KHZhbHVlKSwgbGUpLFxuICAgICAgICBzaXplOiA4LFxuICAgIH0pO1xuXG4vKipcbiAqIFJldHVybnMgYSBkZWNvZGVyIGZvciA2NC1iaXQgdW5zaWduZWQgaW50ZWdlcnMgKGB1NjRgKS5cbiAqXG4gKiBUaGlzIGRlY29kZXIgZGVzZXJpYWxpemVzIGB1NjRgIHZhbHVlcyBmcm9tIDggYnl0ZXMuXG4gKiBUaGUgZGVjb2RlZCB2YWx1ZSBpcyBhbHdheXMgYSBgYmlnaW50YC5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUge0BsaW5rIGdldFU2NENvZGVjfS5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiB0byBzcGVjaWZ5IGVuZGlhbm5lc3MgKGxpdHRsZSBieSBkZWZhdWx0KS5cbiAqIEByZXR1cm5zIEEgYEZpeGVkU2l6ZURlY29kZXI8YmlnaW50LCA4PmAgZm9yIGRlY29kaW5nIGB1NjRgIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogRGVjb2RpbmcgYSBgdTY0YCB2YWx1ZS5cbiAqIGBgYHRzXG4gKiBjb25zdCBkZWNvZGVyID0gZ2V0VTY0RGVjb2RlcigpO1xuICogY29uc3QgdmFsdWUgPSBkZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheShbMHgyYSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMF0pKTsgLy8gNDJuXG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBnZXRVNjRDb2RlY31cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFU2NERlY29kZXIgPSAoY29uZmlnOiBOdW1iZXJDb2RlY0NvbmZpZyA9IHt9KTogRml4ZWRTaXplRGVjb2RlcjxiaWdpbnQsIDg+ID0+XG4gICAgbnVtYmVyRGVjb2RlckZhY3Rvcnkoe1xuICAgICAgICBjb25maWcsXG4gICAgICAgIGdldDogKHZpZXcsIGxlKSA9PiB2aWV3LmdldEJpZ1VpbnQ2NCgwLCBsZSksXG4gICAgICAgIG5hbWU6ICd1NjQnLFxuICAgICAgICBzaXplOiA4LFxuICAgIH0pO1xuXG4vKipcbiAqIFJldHVybnMgYSBjb2RlYyBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIDY0LWJpdCB1bnNpZ25lZCBpbnRlZ2VycyAoYHU2NGApLlxuICpcbiAqIFRoaXMgY29kZWMgc2VyaWFsaXplcyBgdTY0YCB2YWx1ZXMgdXNpbmcgOCBieXRlcy5cbiAqIFZhbHVlcyBjYW4gYmUgcHJvdmlkZWQgYXMgZWl0aGVyIGBudW1iZXJgIG9yIGBiaWdpbnRgLCBidXQgdGhlIGRlY29kZWQgdmFsdWUgaXMgYWx3YXlzIGEgYGJpZ2ludGAuXG4gKlxuICogQHBhcmFtIGNvbmZpZyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gdG8gc3BlY2lmeSBlbmRpYW5uZXNzIChsaXR0bGUgYnkgZGVmYXVsdCkuXG4gKiBAcmV0dXJucyBBIGBGaXhlZFNpemVDb2RlYzxudW1iZXIgfCBiaWdpbnQsIGJpZ2ludCwgOD5gIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgYHU2NGAgdmFsdWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBFbmNvZGluZyBhbmQgZGVjb2RpbmcgYSBgdTY0YCB2YWx1ZS5cbiAqIGBgYHRzXG4gKiBjb25zdCBjb2RlYyA9IGdldFU2NENvZGVjKCk7XG4gKiBjb25zdCBieXRlcyA9IGNvZGVjLmVuY29kZSg0Mik7IC8vIDB4MmEwMDAwMDAwMDAwMDAwMFxuICogY29uc3QgdmFsdWUgPSBjb2RlYy5kZWNvZGUoYnl0ZXMpOyAvLyA0Mm5cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBVc2luZyBiaWctZW5kaWFuIGVuY29kaW5nLlxuICogYGBgdHNcbiAqIGNvbnN0IGNvZGVjID0gZ2V0VTY0Q29kZWMoeyBlbmRpYW46IEVuZGlhbi5CaWcgfSk7XG4gKiBjb25zdCBieXRlcyA9IGNvZGVjLmVuY29kZSg0Mik7IC8vIDB4MDAwMDAwMDAwMDAwMDAyYVxuICogYGBgXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgY29kZWMgc3VwcG9ydHMgdmFsdWVzIGJldHdlZW4gYDBgIGFuZCBgMl42NCAtIDFgLlxuICogU2luY2UgSmF2YVNjcmlwdCBgbnVtYmVyYCBjYW5ub3Qgc2FmZWx5IHJlcHJlc2VudCB2YWx1ZXMgYmV5b25kIGAyXjUzIC0gMWAsIHRoZSBkZWNvZGVkIHZhbHVlIGlzIGFsd2F5cyBhIGBiaWdpbnRgLlxuICpcbiAqIC0gSWYgeW91IG5lZWQgYSBzbWFsbGVyIHVuc2lnbmVkIGludGVnZXIsIGNvbnNpZGVyIHVzaW5nIHtAbGluayBnZXRVMzJDb2RlY30gb3Ige0BsaW5rIGdldFUxNkNvZGVjfS5cbiAqIC0gSWYgeW91IG5lZWQgYSBsYXJnZXIgdW5zaWduZWQgaW50ZWdlciwgY29uc2lkZXIgdXNpbmcge0BsaW5rIGdldFUxMjhDb2RlY30uXG4gKiAtIElmIHlvdSBuZWVkIHNpZ25lZCBpbnRlZ2VycywgY29uc2lkZXIgdXNpbmcge0BsaW5rIGdldEk2NENvZGVjfS5cbiAqXG4gKiBTZXBhcmF0ZSB7QGxpbmsgZ2V0VTY0RW5jb2Rlcn0gYW5kIHtAbGluayBnZXRVNjREZWNvZGVyfSBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgYnl0ZXMgPSBnZXRVNjRFbmNvZGVyKCkuZW5jb2RlKDQyKTtcbiAqIGNvbnN0IHZhbHVlID0gZ2V0VTY0RGVjb2RlcigpLmRlY29kZShieXRlcyk7XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBnZXRVNjRFbmNvZGVyfVxuICogQHNlZSB7QGxpbmsgZ2V0VTY0RGVjb2Rlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFU2NENvZGVjID0gKGNvbmZpZzogTnVtYmVyQ29kZWNDb25maWcgPSB7fSk6IEZpeGVkU2l6ZUNvZGVjPGJpZ2ludCB8IG51bWJlciwgYmlnaW50LCA4PiA9PlxuICAgIGNvbWJpbmVDb2RlYyhnZXRVNjRFbmNvZGVyKGNvbmZpZyksIGdldFU2NERlY29kZXIoY29uZmlnKSk7XG4iLCAiaW1wb3J0IHsgY29tYmluZUNvZGVjLCBGaXhlZFNpemVDb2RlYywgRml4ZWRTaXplRGVjb2RlciwgRml4ZWRTaXplRW5jb2RlciB9IGZyb20gJ0Bzb2xhbmEvY29kZWNzLWNvcmUnO1xuXG5pbXBvcnQgeyBudW1iZXJEZWNvZGVyRmFjdG9yeSwgbnVtYmVyRW5jb2RlckZhY3RvcnkgfSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGVuY29kZXIgZm9yIDgtYml0IHVuc2lnbmVkIGludGVnZXJzIChgdThgKS5cbiAqXG4gKiBUaGlzIGVuY29kZXIgc2VyaWFsaXplcyBgdThgIHZhbHVlcyB1c2luZyBhIHNpbmdsZSBieXRlLlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB7QGxpbmsgZ2V0VThDb2RlY30uXG4gKlxuICogQHJldHVybnMgQSBgRml4ZWRTaXplRW5jb2RlcjxudW1iZXIgfCBiaWdpbnQsIDE+YCBmb3IgZW5jb2RpbmcgYHU4YCB2YWx1ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIEVuY29kaW5nIGEgYHU4YCB2YWx1ZS5cbiAqIGBgYHRzXG4gKiBjb25zdCBlbmNvZGVyID0gZ2V0VThFbmNvZGVyKCk7XG4gKiBjb25zdCBieXRlcyA9IGVuY29kZXIuZW5jb2RlKDQyKTsgLy8gMHgyYVxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZ2V0VThDb2RlY31cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFU4RW5jb2RlciA9ICgpOiBGaXhlZFNpemVFbmNvZGVyPGJpZ2ludCB8IG51bWJlciwgMT4gPT5cbiAgICBudW1iZXJFbmNvZGVyRmFjdG9yeSh7XG4gICAgICAgIG5hbWU6ICd1OCcsXG4gICAgICAgIHJhbmdlOiBbMCwgTnVtYmVyKCcweGZmJyldLFxuICAgICAgICBzZXQ6ICh2aWV3LCB2YWx1ZSkgPT4gdmlldy5zZXRVaW50OCgwLCBOdW1iZXIodmFsdWUpKSxcbiAgICAgICAgc2l6ZTogMSxcbiAgICB9KTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZGVjb2RlciBmb3IgOC1iaXQgdW5zaWduZWQgaW50ZWdlcnMgKGB1OGApLlxuICpcbiAqIFRoaXMgZGVjb2RlciBkZXNlcmlhbGl6ZXMgYHU4YCB2YWx1ZXMgZnJvbSBhIHNpbmdsZSBieXRlLlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB7QGxpbmsgZ2V0VThDb2RlY30uXG4gKlxuICogQHJldHVybnMgQSBgRml4ZWRTaXplRGVjb2RlcjxudW1iZXIsIDE+YCBmb3IgZGVjb2RpbmcgYHU4YCB2YWx1ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIERlY29kaW5nIGEgYHU4YCB2YWx1ZS5cbiAqIGBgYHRzXG4gKiBjb25zdCBkZWNvZGVyID0gZ2V0VThEZWNvZGVyKCk7XG4gKiBjb25zdCB2YWx1ZSA9IGRlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KFsweGZmXSkpOyAvLyAyNTVcbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGdldFU4Q29kZWN9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRVOERlY29kZXIgPSAoKTogRml4ZWRTaXplRGVjb2RlcjxudW1iZXIsIDE+ID0+XG4gICAgbnVtYmVyRGVjb2RlckZhY3Rvcnkoe1xuICAgICAgICBnZXQ6IHZpZXcgPT4gdmlldy5nZXRVaW50OCgwKSxcbiAgICAgICAgbmFtZTogJ3U4JyxcbiAgICAgICAgc2l6ZTogMSxcbiAgICB9KTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgY29kZWMgZm9yIGVuY29kaW5nIGFuZCBkZWNvZGluZyA4LWJpdCB1bnNpZ25lZCBpbnRlZ2VycyAoYHU4YCkuXG4gKlxuICogVGhpcyBjb2RlYyBzZXJpYWxpemVzIGB1OGAgdmFsdWVzIHVzaW5nIGEgc2luZ2xlIGJ5dGUuXG4gKlxuICogQHJldHVybnMgQSBgRml4ZWRTaXplQ29kZWM8bnVtYmVyIHwgYmlnaW50LCBudW1iZXIsIDE+YCBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIGB1OGAgdmFsdWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBFbmNvZGluZyBhbmQgZGVjb2RpbmcgYSBgdThgIHZhbHVlLlxuICogYGBgdHNcbiAqIGNvbnN0IGNvZGVjID0gZ2V0VThDb2RlYygpO1xuICogY29uc3QgYnl0ZXMgPSBjb2RlYy5lbmNvZGUoMjU1KTsgLy8gMHhmZlxuICogY29uc3QgdmFsdWUgPSBjb2RlYy5kZWNvZGUoYnl0ZXMpOyAvLyAyNTVcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGNvZGVjIHN1cHBvcnRzIHZhbHVlcyBiZXR3ZWVuIGAwYCBhbmQgYDJeOCAtIDFgICgwIHRvIDI1NSkuXG4gKiBJZiB5b3UgbmVlZCBsYXJnZXIgaW50ZWdlcnMsIGNvbnNpZGVyIHVzaW5nIHtAbGluayBnZXRVMTZDb2RlY30sIHtAbGluayBnZXRVMzJDb2RlY30sIG9yIHtAbGluayBnZXRVNjRDb2RlY30uXG4gKiBGb3Igc2lnbmVkIGludGVnZXJzLCB1c2Uge0BsaW5rIGdldEk4Q29kZWN9LlxuICpcbiAqIFNlcGFyYXRlIHtAbGluayBnZXRVOEVuY29kZXJ9IGFuZCB7QGxpbmsgZ2V0VThEZWNvZGVyfSBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgYnl0ZXMgPSBnZXRVOEVuY29kZXIoKS5lbmNvZGUoNDIpO1xuICogY29uc3QgdmFsdWUgPSBnZXRVOERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZ2V0VThFbmNvZGVyfVxuICogQHNlZSB7QGxpbmsgZ2V0VThEZWNvZGVyfVxuICovXG5leHBvcnQgY29uc3QgZ2V0VThDb2RlYyA9ICgpOiBGaXhlZFNpemVDb2RlYzxiaWdpbnQgfCBudW1iZXIsIG51bWJlciwgMT4gPT5cbiAgICBjb21iaW5lQ29kZWMoZ2V0VThFbmNvZGVyKCksIGdldFU4RGVjb2RlcigpKTtcbiIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4vaW5kZXguanMnXG5cbmV4cG9ydCB7IEV2ZW50RW1pdHRlciB9XG5leHBvcnQgZGVmYXVsdCBFdmVudEVtaXR0ZXJcbiIsICIvKipcbiAqIFdlYlNvY2tldCBpbXBsZW1lbnRzIGEgYnJvd3Nlci1zaWRlIFdlYlNvY2tldCBzcGVjaWZpY2F0aW9uLlxuICogQG1vZHVsZSBDbGllbnRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tIFwiZXZlbnRlbWl0dGVyM1wiXG5cbmltcG9ydCB7XG4gICAgQnJvd3NlcldlYlNvY2tldFR5cGUsXG4gICAgTm9kZVdlYlNvY2tldFR5cGUsXG4gICAgSVdTQ2xpZW50QWRkaXRpb25hbE9wdGlvbnMsXG59IGZyb20gXCIuL2NsaWVudC50eXBlcy5qc1wiXG5cbmNsYXNzIFdlYlNvY2tldEJyb3dzZXJJbXBsIGV4dGVuZHMgRXZlbnRFbWl0dGVyXG57XG4gICAgc29ja2V0OiBCcm93c2VyV2ViU29ja2V0VHlwZVxuXG4gICAgLyoqIEluc3RhbnRpYXRlIGEgV2ViU29ja2V0IGNsYXNzXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyAtIHVybCB0byBhIHdlYnNvY2tldCBzZXJ2ZXJcbiAgICogQHBhcmFtIHsoT2JqZWN0KX0gb3B0aW9ucyAtIHdlYnNvY2tldCBvcHRpb25zXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xBcnJheSl9IHByb3RvY29scyAtIGEgbGlzdCBvZiBwcm90b2NvbHNcbiAgICogQHJldHVybiB7V2ViU29ja2V0QnJvd3NlckltcGx9IC0gcmV0dXJucyBhIFdlYlNvY2tldCBpbnN0YW5jZVxuICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzOiBzdHJpbmcsIG9wdGlvbnM6IHt9LCBwcm90b2NvbHM/OiBzdHJpbmcgfCBzdHJpbmdbXSlcbiAgICB7XG4gICAgICAgIHN1cGVyKClcblxuICAgICAgICB0aGlzLnNvY2tldCA9IG5ldyB3aW5kb3cuV2ViU29ja2V0KGFkZHJlc3MsIHByb3RvY29scylcblxuICAgICAgICB0aGlzLnNvY2tldC5vbm9wZW4gPSAoKSA9PiB0aGlzLmVtaXQoXCJvcGVuXCIpXG4gICAgICAgIHRoaXMuc29ja2V0Lm9ubWVzc2FnZSA9IChldmVudCkgPT4gdGhpcy5lbWl0KFwibWVzc2FnZVwiLCBldmVudC5kYXRhKVxuICAgICAgICB0aGlzLnNvY2tldC5vbmVycm9yID0gKGVycm9yKSA9PiB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcilcbiAgICAgICAgdGhpcy5zb2NrZXQub25jbG9zZSA9IChldmVudCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiY2xvc2VcIiwgZXZlbnQuY29kZSwgZXZlbnQucmVhc29uKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAqIFNlbmRzIGRhdGEgdGhyb3VnaCBhIHdlYnNvY2tldCBjb25uZWN0aW9uXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHsoU3RyaW5nfE9iamVjdCl9IGRhdGEgLSBkYXRhIHRvIGJlIHNlbnQgdmlhIHdlYnNvY2tldFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc09yQ2FsbGJhY2sgLSB3cyBvcHRpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gYSBjYWxsYmFjayBjYWxsZWQgb25jZSB0aGUgZGF0YSBpcyBzZW50XG4gICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgICovXG4gICAgc2VuZChcbiAgICAgICAgZGF0YTogUGFyYW1ldGVyczxCcm93c2VyV2ViU29ja2V0VHlwZVtcInNlbmRcIl0+WzBdLFxuICAgICAgICBvcHRpb25zT3JDYWxsYmFjazogKFxuICAgICAgZXJyb3I/OiBFcnJvclxuICAgICkgPT4gdm9pZCB8IFBhcmFtZXRlcnM8Tm9kZVdlYlNvY2tldFR5cGVbXCJzZW5kXCJdPlsxXSxcbiAgICAgICAgY2FsbGJhY2s/OiAoKSA9PiB2b2lkXG4gICAgKVxuICAgIHtcbiAgICAgICAgY29uc3QgY2IgPSBjYWxsYmFjayB8fCBvcHRpb25zT3JDYWxsYmFja1xuXG4gICAgICAgIHRyeVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKGRhdGEpXG4gICAgICAgICAgICBjYigpXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKVxuICAgICAgICB7XG4gICAgICAgICAgICBjYihlcnJvcilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgKiBDbG9zZXMgYW4gdW5kZXJseWluZyBzb2NrZXRcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge051bWJlcn0gY29kZSAtIHN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGJlaW5nIGNsb3NlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uIC0gYSBkZXNjcmlwdGlvbiB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZ1xuICAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgKi9cbiAgICBjbG9zZShjb2RlPzogbnVtYmVyLCByZWFzb24/OiBzdHJpbmcpXG4gICAge1xuICAgICAgICB0aGlzLnNvY2tldC5jbG9zZShjb2RlLCByZWFzb24pXG4gICAgfVxuXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjxLIGV4dGVuZHMga2V5b2YgV2ViU29ja2V0RXZlbnRNYXA+KFxuICAgICAgICB0eXBlOiBLLFxuICAgICAgICBsaXN0ZW5lcjogKGV2OiBXZWJTb2NrZXRFdmVudE1hcFtLXSkgPT4gYW55LFxuICAgICAgICBvcHRpb25zPzogYm9vbGVhbiB8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zXG4gICAgKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucylcbiAgICB9XG59XG5cbi8qKlxuICogZmFjdG9yeSBtZXRob2QgZm9yIGNvbW1vbiBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIC0gdXJsIHRvIGEgd2Vic29ja2V0IHNlcnZlclxuICogQHBhcmFtIHsoT2JqZWN0KX0gb3B0aW9ucyAtIHdlYnNvY2tldCBvcHRpb25zXG4gKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBXZWJTb2NrZXQoXG4gICAgYWRkcmVzczogc3RyaW5nLFxuICAgIG9wdGlvbnM6IElXU0NsaWVudEFkZGl0aW9uYWxPcHRpb25zXG4pXG57XG4gICAgcmV0dXJuIG5ldyBXZWJTb2NrZXRCcm93c2VySW1wbChhZGRyZXNzLCBvcHRpb25zKVxufVxuIiwgIlwidXNlIHN0cmljdFwiXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVBhY2s8XG4gIFQsXG4gIFIgZXh0ZW5kcyBzdHJpbmcgfCBBcnJheUJ1ZmZlckxpa2UgfCBCbG9iIHwgQXJyYXlCdWZmZXJWaWV3XG4+IHtcbiAgZW5jb2RlKHZhbHVlOiBUKTogUjtcbiAgZGVjb2RlKHZhbHVlOiBSKTogVDtcbn1cblxuZXhwb3J0IGNsYXNzIERlZmF1bHREYXRhUGFjayBpbXBsZW1lbnRzIERhdGFQYWNrPE9iamVjdCwgc3RyaW5nPlxue1xuICAgIGVuY29kZSh2YWx1ZTogT2JqZWN0KTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpXG4gICAgfVxuXG4gICAgZGVjb2RlKHZhbHVlOiBzdHJpbmcpOiBPYmplY3RcbiAgICB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKVxuICAgIH1cbn1cbiIsICIvKipcbiAqIFwiQ2xpZW50XCIgd3JhcHMgXCJ3c1wiIG9yIGEgYnJvd3Nlci1pbXBsZW1lbnRlZCBcIldlYlNvY2tldFwiIGxpYnJhcnlcbiAqIGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQgcHJvdmlkaW5nIEpTT04gUlBDIDIuMCBzdXBwb3J0IG9uIHRvcC5cbiAqIEBtb2R1bGUgQ2xpZW50XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCJcblxuaW1wb3J0IE5vZGVXZWJTb2NrZXQgZnJvbSBcIndzXCJcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gXCJldmVudGVtaXR0ZXIzXCJcbmltcG9ydCB7XG4gICAgSUNvbW1vbldlYlNvY2tldCxcbiAgICBJV1NDbGllbnRBZGRpdGlvbmFsT3B0aW9ucyxcbiAgICBOb2RlV2ViU29ja2V0VHlwZSxcbiAgICBJQ29tbW9uV2ViU29ja2V0RmFjdG9yeSxcbn0gZnJvbSBcIi4vY2xpZW50L2NsaWVudC50eXBlcy5qc1wiXG5cbmltcG9ydCB7IERhdGFQYWNrLCBEZWZhdWx0RGF0YVBhY2sgfSBmcm9tIFwiLi91dGlscy5qc1wiXG5cbmludGVyZmFjZSBJUXVldWVFbGVtZW50IHtcbiAgcHJvbWlzZTogW1xuICAgIFBhcmFtZXRlcnM8Q29uc3RydWN0b3JQYXJhbWV0ZXJzPHR5cGVvZiBQcm9taXNlPlswXT5bMF0sXG4gICAgUGFyYW1ldGVyczxDb25zdHJ1Y3RvclBhcmFtZXRlcnM8dHlwZW9mIFByb21pc2U+WzBdPlsxXVxuICBdO1xuICB0aW1lb3V0PzogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVF1ZXVlIHtcbiAgW3g6IG51bWJlciB8IHN0cmluZ106IElRdWV1ZUVsZW1lbnQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVdTUmVxdWVzdFBhcmFtcyB7XG4gIFt4OiBzdHJpbmddOiBhbnk7XG4gIFt4OiBudW1iZXJdOiBhbnk7XG59XG5cbmV4cG9ydCBjbGFzcyBDb21tb25DbGllbnQgZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbntcbiAgICBwcml2YXRlIGFkZHJlc3M6IHN0cmluZ1xuICAgIHByaXZhdGUgcnBjX2lkOiBudW1iZXIgfCBzdHJpbmdcbiAgICBwcml2YXRlIHF1ZXVlOiBJUXVldWVcbiAgICBwcml2YXRlIG9wdGlvbnM6IElXU0NsaWVudEFkZGl0aW9uYWxPcHRpb25zICYgTm9kZVdlYlNvY2tldC5DbGllbnRPcHRpb25zXG4gICAgcHJpdmF0ZSBhdXRvY29ubmVjdDogYm9vbGVhblxuICAgIHByaXZhdGUgcmVhZHk6IGJvb2xlYW5cbiAgICBwcml2YXRlIHJlY29ubmVjdDogYm9vbGVhblxuICAgIHByaXZhdGUgcmVjb25uZWN0X3RpbWVyX2lkOiBOb2RlSlMuVGltZW91dFxuICAgIHByaXZhdGUgcmVjb25uZWN0X2ludGVydmFsOiBudW1iZXJcbiAgICBwcml2YXRlIG1heF9yZWNvbm5lY3RzOiBudW1iZXJcbiAgICBwcml2YXRlIHJlc3Rfb3B0aW9uczogSVdTQ2xpZW50QWRkaXRpb25hbE9wdGlvbnMgJlxuICAgIE5vZGVXZWJTb2NrZXQuQ2xpZW50T3B0aW9uc1xuICAgIHByaXZhdGUgY3VycmVudF9yZWNvbm5lY3RzOiBudW1iZXJcbiAgICBwcml2YXRlIGdlbmVyYXRlX3JlcXVlc3RfaWQ6IChcbiAgICBtZXRob2Q6IHN0cmluZyxcbiAgICBwYXJhbXM6IG9iamVjdCB8IEFycmF5PGFueT5cbiAgKSA9PiBudW1iZXIgfCBzdHJpbmdcbiAgICBwcml2YXRlIHNvY2tldDogSUNvbW1vbldlYlNvY2tldFxuICAgIHByaXZhdGUgd2ViU29ja2V0RmFjdG9yeTogSUNvbW1vbldlYlNvY2tldEZhY3RvcnlcbiAgICBwcml2YXRlIGRhdGFQYWNrOiBEYXRhUGFjazxvYmplY3QsIHN0cmluZz5cblxuICAgIC8qKlxuICAgKiBJbnN0YW50aWF0ZSBhIENsaWVudCBjbGFzcy5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7d2ViU29ja2V0RmFjdG9yeX0gd2ViU29ja2V0RmFjdG9yeSAtIGZhY3RvcnkgbWV0aG9kIGZvciBXZWJTb2NrZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgLSB1cmwgdG8gYSB3ZWJzb2NrZXQgc2VydmVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gd3Mgb3B0aW9ucyBvYmplY3Qgd2l0aCByZWNvbm5lY3QgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZW5lcmF0ZV9yZXF1ZXN0X2lkIC0gY3VzdG9tIGdlbmVyYXRpb24gcmVxdWVzdCBJZFxuICAgKiBAcGFyYW0ge0RhdGFQYWNrfSBkYXRhUGFjayAtIGRhdGEgcGFjayBjb250YWlucyBlbmNvZGVyIGFuZCBkZWNvZGVyXG4gICAqIEByZXR1cm4ge0NvbW1vbkNsaWVudH1cbiAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHdlYlNvY2tldEZhY3Rvcnk6IElDb21tb25XZWJTb2NrZXRGYWN0b3J5LFxuICAgICAgICBhZGRyZXNzID0gXCJ3czovL2xvY2FsaG9zdDo4MDgwXCIsXG4gICAgICAgIHtcbiAgICAgICAgICAgIGF1dG9jb25uZWN0ID0gdHJ1ZSxcbiAgICAgICAgICAgIHJlY29ubmVjdCA9IHRydWUsXG4gICAgICAgICAgICByZWNvbm5lY3RfaW50ZXJ2YWwgPSAxMDAwLFxuICAgICAgICAgICAgbWF4X3JlY29ubmVjdHMgPSA1LFxuICAgICAgICAgICAgLi4ucmVzdF9vcHRpb25zXG4gICAgICAgIH0gPSB7fSxcbiAgICAgICAgZ2VuZXJhdGVfcmVxdWVzdF9pZD86IChcbiAgICAgIG1ldGhvZDogc3RyaW5nLFxuICAgICAgcGFyYW1zOiBvYmplY3QgfCBBcnJheTxhbnk+XG4gICAgKSA9PiBudW1iZXIgfCBzdHJpbmcsXG4gICAgICAgIGRhdGFQYWNrPzogRGF0YVBhY2s8b2JqZWN0LCBzdHJpbmc+XG4gICAgKVxuICAgIHtcbiAgICAgICAgc3VwZXIoKVxuXG4gICAgICAgIHRoaXMud2ViU29ja2V0RmFjdG9yeSA9IHdlYlNvY2tldEZhY3RvcnlcblxuICAgICAgICB0aGlzLnF1ZXVlID0ge31cbiAgICAgICAgdGhpcy5ycGNfaWQgPSAwXG5cbiAgICAgICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzc1xuICAgICAgICB0aGlzLmF1dG9jb25uZWN0ID0gYXV0b2Nvbm5lY3RcbiAgICAgICAgdGhpcy5yZWFkeSA9IGZhbHNlXG4gICAgICAgIHRoaXMucmVjb25uZWN0ID0gcmVjb25uZWN0XG4gICAgICAgIHRoaXMucmVjb25uZWN0X3RpbWVyX2lkID0gdW5kZWZpbmVkXG4gICAgICAgIHRoaXMucmVjb25uZWN0X2ludGVydmFsID0gcmVjb25uZWN0X2ludGVydmFsXG4gICAgICAgIHRoaXMubWF4X3JlY29ubmVjdHMgPSBtYXhfcmVjb25uZWN0c1xuICAgICAgICB0aGlzLnJlc3Rfb3B0aW9ucyA9IHJlc3Rfb3B0aW9uc1xuICAgICAgICB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cyA9IDBcbiAgICAgICAgdGhpcy5nZW5lcmF0ZV9yZXF1ZXN0X2lkID0gZ2VuZXJhdGVfcmVxdWVzdF9pZCB8fCAoKCkgPT4gdHlwZW9mIHRoaXMucnBjX2lkID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICA/ICsrdGhpcy5ycGNfaWRcbiAgICAgICAgICAgIDogTnVtYmVyKHRoaXMucnBjX2lkKSArIDEpXG5cbiAgICAgICAgaWYgKCFkYXRhUGFjaykgdGhpcy5kYXRhUGFjayA9IG5ldyBEZWZhdWx0RGF0YVBhY2soKVxuICAgICAgICBlbHNlIHRoaXMuZGF0YVBhY2sgPSBkYXRhUGFja1xuXG4gICAgICAgIGlmICh0aGlzLmF1dG9jb25uZWN0KVxuICAgICAgICAgICAgdGhpcy5fY29ubmVjdCh0aGlzLmFkZHJlc3MsIHtcbiAgICAgICAgICAgICAgICBhdXRvY29ubmVjdDogdGhpcy5hdXRvY29ubmVjdCxcbiAgICAgICAgICAgICAgICByZWNvbm5lY3Q6IHRoaXMucmVjb25uZWN0LFxuICAgICAgICAgICAgICAgIHJlY29ubmVjdF9pbnRlcnZhbDogdGhpcy5yZWNvbm5lY3RfaW50ZXJ2YWwsXG4gICAgICAgICAgICAgICAgbWF4X3JlY29ubmVjdHM6IHRoaXMubWF4X3JlY29ubmVjdHMsXG4gICAgICAgICAgICAgICAgLi4udGhpcy5yZXN0X29wdGlvbnMsXG4gICAgICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgKiBDb25uZWN0cyB0byBhIGRlZmluZWQgc2VydmVyIGlmIG5vdCBjb25uZWN0ZWQgYWxyZWFkeS5cbiAgICogQG1ldGhvZFxuICAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICAqL1xuICAgIGNvbm5lY3QoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0KSByZXR1cm5cblxuICAgICAgICB0aGlzLl9jb25uZWN0KHRoaXMuYWRkcmVzcywge1xuICAgICAgICAgICAgYXV0b2Nvbm5lY3Q6IHRoaXMuYXV0b2Nvbm5lY3QsXG4gICAgICAgICAgICByZWNvbm5lY3Q6IHRoaXMucmVjb25uZWN0LFxuICAgICAgICAgICAgcmVjb25uZWN0X2ludGVydmFsOiB0aGlzLnJlY29ubmVjdF9pbnRlcnZhbCxcbiAgICAgICAgICAgIG1heF9yZWNvbm5lY3RzOiB0aGlzLm1heF9yZWNvbm5lY3RzLFxuICAgICAgICAgICAgLi4udGhpcy5yZXN0X29wdGlvbnMsXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAqIENhbGxzIGEgcmVnaXN0ZXJlZCBSUEMgbWV0aG9kIG9uIHNlcnZlci5cbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIC0gUlBDIG1ldGhvZCBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBwYXJhbXMgLSBvcHRpb25hbCBtZXRob2QgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dCAtIFJQQyByZXBseSB0aW1lb3V0IHZhbHVlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB3c19vcHRzIC0gb3B0aW9ucyBwYXNzZWQgdG8gd3NcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gICAgY2FsbChcbiAgICAgICAgbWV0aG9kOiBzdHJpbmcsXG4gICAgICAgIHBhcmFtcz86IElXU1JlcXVlc3RQYXJhbXMsXG4gICAgICAgIHRpbWVvdXQ/OiBudW1iZXIsXG4gICAgICAgIHdzX29wdHM/OiBQYXJhbWV0ZXJzPE5vZGVXZWJTb2NrZXRUeXBlW1wic2VuZFwiXT5bMV1cbiAgICApXG4gICAge1xuICAgICAgICBpZiAoIXdzX29wdHMgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHRpbWVvdXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdzX29wdHMgPSB0aW1lb3V0XG4gICAgICAgICAgICB0aW1lb3V0ID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWFkeSkgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJzb2NrZXQgbm90IHJlYWR5XCIpKVxuXG4gICAgICAgICAgICBjb25zdCBycGNfaWQgPSB0aGlzLmdlbmVyYXRlX3JlcXVlc3RfaWQobWV0aG9kLCBwYXJhbXMpXG5cbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgaWQ6IHJwY19pZCxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZCh0aGlzLmRhdGFQYWNrLmVuY29kZShtZXNzYWdlKSwgd3Nfb3B0cywgKGVycm9yKSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIHJlamVjdChlcnJvcilcblxuICAgICAgICAgICAgICAgIHRoaXMucXVldWVbcnBjX2lkXSA9IHsgcHJvbWlzZTogW3Jlc29sdmUsIHJlamVjdF0gfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlW3JwY19pZF0udGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucXVldWVbcnBjX2lkXVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInJlcGx5IHRpbWVvdXRcIikpXG4gICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICogTG9naW5zIHdpdGggdGhlIG90aGVyIHNpZGUgb2YgdGhlIGNvbm5lY3Rpb24uXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIExvZ2luIGNyZWRlbnRpYWxzIG9iamVjdFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgICBhc3luYyBsb2dpbihwYXJhbXM6IElXU1JlcXVlc3RQYXJhbXMpXG4gICAge1xuICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5jYWxsKFwicnBjLmxvZ2luXCIsIHBhcmFtcylcblxuICAgICAgICBpZiAoIXJlc3ApIHRocm93IG5ldyBFcnJvcihcImF1dGhlbnRpY2F0aW9uIGZhaWxlZFwiKVxuXG4gICAgICAgIHJldHVybiByZXNwXG4gICAgfVxuXG4gICAgLyoqXG4gICAqIEZldGNoZXMgYSBsaXN0IG9mIGNsaWVudCdzIG1ldGhvZHMgcmVnaXN0ZXJlZCBvbiBzZXJ2ZXIuXG4gICAqIEBtZXRob2RcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICAgIGFzeW5jIGxpc3RNZXRob2RzKClcbiAgICB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNhbGwoXCJfX2xpc3RNZXRob2RzXCIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAqIFNlbmRzIGEgSlNPTi1SUEMgMi4wIG5vdGlmaWNhdGlvbiB0byBzZXJ2ZXIuXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCAtIFJQQyBtZXRob2QgbmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gb3B0aW9uYWwgbWV0aG9kIHBhcmFtZXRlcnNcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gICAgbm90aWZ5KG1ldGhvZDogc3RyaW5nLCBwYXJhbXM/OiBJV1NSZXF1ZXN0UGFyYW1zKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWFkeSkgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJzb2NrZXQgbm90IHJlYWR5XCIpKVxuXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKHRoaXMuZGF0YVBhY2suZW5jb2RlKG1lc3NhZ2UpLCAoZXJyb3IpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gcmVqZWN0KGVycm9yKVxuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgKiBTdWJzY3JpYmVzIGZvciBhIGRlZmluZWQgZXZlbnQuXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGV2ZW50IC0gZXZlbnQgbmFtZVxuICAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgKi9cbiAgICBhc3luYyBzdWJzY3JpYmUoZXZlbnQ6IHN0cmluZyB8IEFycmF5PHN0cmluZz4pXG4gICAge1xuICAgICAgICBpZiAodHlwZW9mIGV2ZW50ID09PSBcInN0cmluZ1wiKSBldmVudCA9IFtldmVudF1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNhbGwoXCJycGMub25cIiwgZXZlbnQpXG5cbiAgICAgICAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIiAmJiByZXN1bHRbZXZlbnRdICE9PSBcIm9rXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJGYWlsZWQgc3Vic2NyaWJpbmcgdG8gYW4gZXZlbnQgJ1wiICsgZXZlbnQgKyBcIicgd2l0aDogXCIgKyByZXN1bHRbZXZlbnRdXG4gICAgICAgICAgICApXG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIC8qKlxuICAgKiBVbnN1YnNjcmliZXMgZnJvbSBhIGRlZmluZWQgZXZlbnQuXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGV2ZW50IC0gZXZlbnQgbmFtZVxuICAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgKi9cbiAgICBhc3luYyB1bnN1YnNjcmliZShldmVudDogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPilcbiAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIpIGV2ZW50ID0gW2V2ZW50XVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2FsbChcInJwYy5vZmZcIiwgZXZlbnQpXG5cbiAgICAgICAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIiAmJiByZXN1bHRbZXZlbnRdICE9PSBcIm9rXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdW5zdWJzY3JpYmluZyBmcm9tIGFuIGV2ZW50IHdpdGg6IFwiICsgcmVzdWx0KVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICAvKipcbiAgICogQ2xvc2VzIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24gZ3JhY2VmdWxseS5cbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge051bWJlcn0gY29kZSAtIHNvY2tldCBjbG9zZSBjb2RlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIC0gb3B0aW9uYWwgZGF0YSB0byBiZSBzZW50IGJlZm9yZSBjbG9zaW5nXG4gICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgICovXG4gICAgY2xvc2UoY29kZT86IG51bWJlciwgZGF0YT86IHN0cmluZylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldCkgdGhpcy5zb2NrZXQuY2xvc2UoY29kZSB8fCAxMDAwLCBkYXRhKVxuICAgIH1cblxuICAgIC8qKlxuICAgKiBFbmFibGUgLyBkaXNhYmxlIGF1dG9tYXRpYyByZWNvbm5lY3Rpb24uXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHtCb29sZWFufSByZWNvbm5lY3QgLSBlbmFibGUgLyBkaXNhYmxlIHJlY29ubmVjdGlvblxuICAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICAqL1xuICAgIHNldEF1dG9SZWNvbm5lY3QocmVjb25uZWN0OiBib29sZWFuKVxuICAgIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3QgPSByZWNvbm5lY3RcbiAgICB9XG5cbiAgICAvKipcbiAgICogU2V0IHRoZSBpbnRlcnZhbCBiZXR3ZWVuIHJlY29ubmVjdGlvbiBhdHRlbXB0cy5cbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW50ZXJ2YWwgLSByZWNvbm5lY3Rpb24gaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzXG4gICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgICovXG4gICAgc2V0UmVjb25uZWN0SW50ZXJ2YWwoaW50ZXJ2YWw6IG51bWJlcilcbiAgICB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0X2ludGVydmFsID0gaW50ZXJ2YWxcbiAgICB9XG5cbiAgICAvKipcbiAgICogU2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiByZWNvbm5lY3Rpb24gYXR0ZW1wdHMuXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1heF9yZWNvbm5lY3RzIC0gbWF4aW11bSByZWNvbm5lY3Rpb24gYXR0ZW1wdHNcbiAgICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAgKi9cbiAgICBzZXRNYXhSZWNvbm5lY3RzKG1heF9yZWNvbm5lY3RzOiBudW1iZXIpXG4gICAge1xuICAgICAgICB0aGlzLm1heF9yZWNvbm5lY3RzID0gbWF4X3JlY29ubmVjdHNcbiAgICB9XG5cbiAgICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IG51bWJlciBvZiByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgbWFkZS5cbiAgICogQG1ldGhvZFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGN1cnJlbnQgcmVjb25uZWN0aW9uIGF0dGVtcHRzXG4gICAqL1xuICAgIGdldEN1cnJlbnRSZWNvbm5lY3RzKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRfcmVjb25uZWN0c1xuICAgIH1cblxuICAgIC8qKlxuICAgKiBHZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJlY29ubmVjdGlvbiBhdHRlbXB0cy5cbiAgICogQG1ldGhvZFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IG1heGltdW0gcmVjb25uZWN0aW9uIGF0dGVtcHRzXG4gICAqL1xuICAgIGdldE1heFJlY29ubmVjdHMoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4X3JlY29ubmVjdHNcbiAgICB9XG5cbiAgICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGNsaWVudCBpcyBjdXJyZW50bHkgYXR0ZW1wdGluZyB0byByZWNvbm5lY3QuXG4gICAqIEBtZXRob2RcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiByZWNvbm5lY3Rpb24gaXMgaW4gcHJvZ3Jlc3NcbiAgICovXG4gICAgaXNSZWNvbm5lY3RpbmcoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjb25uZWN0X3RpbWVyX2lkICE9PSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGNsaWVudCB3aWxsIGF0dGVtcHQgdG8gcmVjb25uZWN0IG9uIHRoZSBuZXh0IGNsb3NlIGV2ZW50LlxuICAgKiBAbWV0aG9kXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgcmVjb25uZWN0aW9uIHdpbGwgYmUgYXR0ZW1wdGVkXG4gICAqL1xuICAgIHdpbGxSZWNvbm5lY3QoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjb25uZWN0ICYmXG4gICAgICAgICAgICAodGhpcy5tYXhfcmVjb25uZWN0cyA9PT0gMCB8fCB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cyA8IHRoaXMubWF4X3JlY29ubmVjdHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAqIENvbm5lY3Rpb24vTWVzc2FnZSBoYW5kbGVyLlxuICAgKiBAbWV0aG9kXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIC0gV2ViU29ja2V0IEFQSSBhZGRyZXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gd3Mgb3B0aW9ucyBvYmplY3RcbiAgICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAgKi9cbiAgICBwcml2YXRlIF9jb25uZWN0KFxuICAgICAgICBhZGRyZXNzOiBzdHJpbmcsXG4gICAgICAgIG9wdGlvbnM6IElXU0NsaWVudEFkZGl0aW9uYWxPcHRpb25zICYgTm9kZVdlYlNvY2tldC5DbGllbnRPcHRpb25zXG4gICAgKVxuICAgIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0X3RpbWVyX2lkKVxuICAgICAgICB0aGlzLnNvY2tldCA9IHRoaXMud2ViU29ja2V0RmFjdG9yeShhZGRyZXNzLCBvcHRpb25zKVxuXG4gICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsICgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucmVhZHkgPSB0cnVlXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJvcGVuXCIpXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cyA9IDBcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoeyBkYXRhOiBtZXNzYWdlIH0pID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UpLnRvU3RyaW5nKClcblxuICAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IHRoaXMuZGF0YVBhY2suZGVjb2RlKG1lc3NhZ2UpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGFueSBsaXN0ZW5lcnMgYXJlIGF0dGFjaGVkIGFuZCBmb3J3YXJkIGV2ZW50XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ub3RpZmljYXRpb24gJiYgdGhpcy5saXN0ZW5lcnMobWVzc2FnZS5ub3RpZmljYXRpb24pLmxlbmd0aClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKG1lc3NhZ2UucGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQobWVzc2FnZS5ub3RpZmljYXRpb24pXG5cbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gW21lc3NhZ2Uubm90aWZpY2F0aW9uXVxuXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGFyYW1zLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIGFyZ3MucHVzaChtZXNzYWdlLnBhcmFtcylcbiAgICAgICAgICAgICAgICAvLyB1c2luZyBmb3ItbG9vcCBpbnN0ZWFkIG9mIHVuc2hpZnQvc3ByZWFkIGJlY2F1c2UgcGVyZm9ybWFuY2UgaXMgYmV0dGVyXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UucGFyYW1zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKG1lc3NhZ2UucGFyYW1zW2ldKVxuXG4gICAgICAgICAgICAgICAgLy8gcnVuIGFzIG1pY3JvdGFzayBzbyB0aGF0IHBlbmRpbmcgcXVldWUgbWVzc2FnZXMgYXJlIHJlc29sdmVkIGZpcnN0XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIGdlbmVyYWwgSlNPTiBSUEMgMi4wIGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJ1biBhcyBtaWNyb3Rhc2sgc28gdGhhdCBwZW5kaW5nIHF1ZXVlIG1lc3NhZ2VzIGFyZSByZXNvbHZlZCBmaXJzdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQobWVzc2FnZS5tZXRob2QsIG1lc3NhZ2U/LnBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVqZWN0IGVhcmx5IHNpbmNlIHNlcnZlcidzIHJlc3BvbnNlIGlzIGludmFsaWRcbiAgICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gbWVzc2FnZSA9PT0gXCJyZXN1bHRcIiBpbiBtZXNzYWdlKVxuICAgICAgICAgICAgICAgIHRoaXMucXVldWVbbWVzc2FnZS5pZF0ucHJvbWlzZVsxXShcbiAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJTZXJ2ZXIgcmVzcG9uc2UgbWFsZm9ybWVkLiBSZXNwb25zZSBtdXN0IGluY2x1ZGUgZWl0aGVyIFxcXCJyZXN1bHRcXFwiXCIgK1xuICAgICAgICAgICAgICBcIiBvciBcXFwiZXJyb3JcXFwiLCBidXQgbm90IGJvdGguXCJcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgaWYgKHRoaXMucXVldWVbbWVzc2FnZS5pZF0udGltZW91dClcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5xdWV1ZVttZXNzYWdlLmlkXS50aW1lb3V0KVxuXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5lcnJvcikgdGhpcy5xdWV1ZVttZXNzYWdlLmlkXS5wcm9taXNlWzFdKG1lc3NhZ2UuZXJyb3IpXG4gICAgICAgICAgICBlbHNlIHRoaXMucXVldWVbbWVzc2FnZS5pZF0ucHJvbWlzZVswXShtZXNzYWdlLnJlc3VsdClcblxuICAgICAgICAgICAgZGVsZXRlIHRoaXMucXVldWVbbWVzc2FnZS5pZF1cbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcikpXG5cbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsICh7IGNvZGUsIHJlYXNvbiB9KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkeSlcbiAgICAgICAgICAgIC8vIERlbGF5IGNsb3NlIGV2ZW50IHVudGlsIGludGVybmFsIHN0YXRlIGlzIHVwZGF0ZWRcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZW1pdChcImNsb3NlXCIsIGNvZGUsIHJlYXNvbiksIDApXG5cbiAgICAgICAgICAgIHRoaXMucmVhZHkgPSBmYWxzZVxuICAgICAgICAgICAgdGhpcy5zb2NrZXQgPSB1bmRlZmluZWRcblxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IDEwMDApIHJldHVyblxuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cysrXG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdCAmJlxuICAgICAgICAodGhpcy5tYXhfcmVjb25uZWN0cyA+IHRoaXMuY3VycmVudF9yZWNvbm5lY3RzIHx8XG4gICAgICAgICAgdGhpcy5tYXhfcmVjb25uZWN0cyA9PT0gMClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdF90aW1lcl9pZCA9IHNldFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgICAgICgpID0+IHRoaXMuX2Nvbm5lY3QoYWRkcmVzcywgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0X2ludGVydmFsXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5yZWNvbm5lY3QgJiYgdGhpcy5tYXhfcmVjb25uZWN0cyA+IDAgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cyA+PSB0aGlzLm1heF9yZWNvbm5lY3RzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIEVtaXQgZXZlbnQgd2hlbiBtYXggcmVjb25uZWN0cyByZWFjaGVkLCBhZnRlciBjbG9zZSBldmVudFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5lbWl0KFwibWF4X3JlY29ubmVjdHNfcmVhY2hlZFwiLCBjb2RlLCByZWFzb24pLCAxKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgeyBXZWJTb2NrZXQgfSBmcm9tIFwiLi9saWIvY2xpZW50L3dlYnNvY2tldC5icm93c2VyLmpzXCJcbmltcG9ydCB7IENvbW1vbkNsaWVudCB9IGZyb20gXCIuL2xpYi9jbGllbnQuanNcIlxuaW1wb3J0IHsgSVdTQ2xpZW50QWRkaXRpb25hbE9wdGlvbnMgfSBmcm9tIFwiLi9saWIvY2xpZW50L2NsaWVudC50eXBlcy5qc1wiXG5cbmV4cG9ydCBjbGFzcyBDbGllbnQgZXh0ZW5kcyBDb21tb25DbGllbnRcbntcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgYWRkcmVzcyA9IFwid3M6Ly9sb2NhbGhvc3Q6ODA4MFwiLFxuICAgICAgICB7XG4gICAgICAgICAgICBhdXRvY29ubmVjdCA9IHRydWUsXG4gICAgICAgICAgICByZWNvbm5lY3QgPSB0cnVlLFxuICAgICAgICAgICAgcmVjb25uZWN0X2ludGVydmFsID0gMTAwMCxcbiAgICAgICAgICAgIG1heF9yZWNvbm5lY3RzID0gNSxcbiAgICAgICAgfTogSVdTQ2xpZW50QWRkaXRpb25hbE9wdGlvbnMgPSB7fSxcbiAgICAgICAgZ2VuZXJhdGVfcmVxdWVzdF9pZD86IChcbiAgICAgIG1ldGhvZDogc3RyaW5nLFxuICAgICAgcGFyYW1zOiBvYmplY3QgfCBBcnJheTxhbnk+XG4gICAgKSA9PiBudW1iZXIgfCBzdHJpbmdcbiAgICApXG4gICAge1xuICAgICAgICBzdXBlcihcbiAgICAgICAgICAgIFdlYlNvY2tldCxcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXV0b2Nvbm5lY3QsXG4gICAgICAgICAgICAgICAgcmVjb25uZWN0LFxuICAgICAgICAgICAgICAgIHJlY29ubmVjdF9pbnRlcnZhbCxcbiAgICAgICAgICAgICAgICBtYXhfcmVjb25uZWN0cyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZW5lcmF0ZV9yZXF1ZXN0X2lkXG4gICAgICAgIClcbiAgICB9XG59XG5cbmV4cG9ydCAqIGZyb20gXCIuL2xpYi9jbGllbnQuanNcIlxuZXhwb3J0ICogZnJvbSBcIi4vbGliL2NsaWVudC93ZWJzb2NrZXQuYnJvd3Nlci5qc1wiXG5leHBvcnQgKiBmcm9tIFwiLi9saWIvY2xpZW50L2NsaWVudC50eXBlcy5qc1wiXG5leHBvcnQgKiBmcm9tIFwiLi9saWIvdXRpbHMuanNcIlxuIiwgIi8qKlxuICogU0hBMyAoa2VjY2FrKSBoYXNoIGZ1bmN0aW9uLCBiYXNlZCBvbiBhIG5ldyBcIlNwb25nZSBmdW5jdGlvblwiIGRlc2lnbi5cbiAqIERpZmZlcmVudCBmcm9tIG9sZGVyIGhhc2hlcywgdGhlIGludGVybmFsIHN0YXRlIGlzIGJpZ2dlciB0aGFuIG91dHB1dCBzaXplLlxuICpcbiAqIENoZWNrIG91dCBbRklQUy0yMDJdKGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4yMDIucGRmKSxcbiAqIFtXZWJzaXRlXShodHRwczovL2tlY2Nhay50ZWFtL2tlY2Nhay5odG1sKSxcbiAqIFt0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBTSEEtMyBhbmQgS2VjY2FrXShodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTU3Mjcvd2hhdC1hcmUtdGhlLWtleS1kaWZmZXJlbmNlcy1iZXR3ZWVuLXRoZS1kcmFmdC1zaGEtMy1zdGFuZGFyZC1hbmQtdGhlLWtlY2Nhay1zdWIpLlxuICpcbiAqIENoZWNrIG91dCBgc2hhMy1hZGRvbnNgIG1vZHVsZSBmb3IgY1NIQUtFLCBrMTIsIGFuZCBvdGhlcnMuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IHJvdGxCSCwgcm90bEJMLCByb3RsU0gsIHJvdGxTTCwgc3BsaXQgfSBmcm9tICcuL191NjQudHMnO1xuLy8gcHJldHRpZXItaWdub3JlXG5pbXBvcnQge1xuICBhYnl0ZXMsIGFleGlzdHMsIGFudW1iZXIsIGFvdXRwdXQsXG4gIGNsZWFuLCBjcmVhdGVIYXNoZXIsIGNyZWF0ZVhPRmVyLCBIYXNoLFxuICBzd2FwMzJJZkJFLFxuICB0b0J5dGVzLCB1MzIsXG4gIHR5cGUgQ0hhc2gsIHR5cGUgQ0hhc2hYTywgdHlwZSBIYXNoWE9GLCB0eXBlIElucHV0XG59IGZyb20gJy4vdXRpbHMudHMnO1xuXG4vLyBObyBfX1BVUkVfXyBhbm5vdGF0aW9ucyBpbiBzaGEzIGhlYWRlcjpcbi8vIEVWRVJZVEhJTkcgaXMgaW4gZmFjdCB1c2VkIG9uIGV2ZXJ5IGV4cG9ydC5cbi8vIFZhcmlvdXMgcGVyIHJvdW5kIGNvbnN0YW50cyBjYWxjdWxhdGlvbnNcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IF83biA9IEJpZ0ludCg3KTtcbmNvbnN0IF8yNTZuID0gQmlnSW50KDI1Nik7XG5jb25zdCBfMHg3MW4gPSBCaWdJbnQoMHg3MSk7XG5jb25zdCBTSEEzX1BJOiBudW1iZXJbXSA9IFtdO1xuY29uc3QgU0hBM19ST1RMOiBudW1iZXJbXSA9IFtdO1xuY29uc3QgX1NIQTNfSU9UQTogYmlnaW50W10gPSBbXTtcbmZvciAobGV0IHJvdW5kID0gMCwgUiA9IF8xbiwgeCA9IDEsIHkgPSAwOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gIC8vIFBpXG4gIFt4LCB5XSA9IFt5LCAoMiAqIHggKyAzICogeSkgJSA1XTtcbiAgU0hBM19QSS5wdXNoKDIgKiAoNSAqIHkgKyB4KSk7XG4gIC8vIFJvdGF0aW9uYWxcbiAgU0hBM19ST1RMLnB1c2goKCgocm91bmQgKyAxKSAqIChyb3VuZCArIDIpKSAvIDIpICUgNjQpO1xuICAvLyBJb3RhXG4gIGxldCB0ID0gXzBuO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgIFIgPSAoKFIgPDwgXzFuKSBeICgoUiA+PiBfN24pICogXzB4NzFuKSkgJSBfMjU2bjtcbiAgICBpZiAoUiAmIF8ybikgdCBePSBfMW4gPDwgKChfMW4gPDwgLyogQF9fUFVSRV9fICovIEJpZ0ludChqKSkgLSBfMW4pO1xuICB9XG4gIF9TSEEzX0lPVEEucHVzaCh0KTtcbn1cbmNvbnN0IElPVEFTID0gc3BsaXQoX1NIQTNfSU9UQSwgdHJ1ZSk7XG5jb25zdCBTSEEzX0lPVEFfSCA9IElPVEFTWzBdO1xuY29uc3QgU0hBM19JT1RBX0wgPSBJT1RBU1sxXTtcblxuLy8gTGVmdCByb3RhdGlvbiAod2l0aG91dCAwLCAzMiwgNjQpXG5jb25zdCByb3RsSCA9IChoOiBudW1iZXIsIGw6IG51bWJlciwgczogbnVtYmVyKSA9PiAocyA+IDMyID8gcm90bEJIKGgsIGwsIHMpIDogcm90bFNIKGgsIGwsIHMpKTtcbmNvbnN0IHJvdGxMID0gKGg6IG51bWJlciwgbDogbnVtYmVyLCBzOiBudW1iZXIpID0+IChzID4gMzIgPyByb3RsQkwoaCwgbCwgcykgOiByb3RsU0woaCwgbCwgcykpO1xuXG4vKiogYGtlY2Nha2YxNjAwYCBpbnRlcm5hbCBmdW5jdGlvbiwgYWRkaXRpb25hbGx5IGFsbG93cyB0byBhZGp1c3Qgcm91bmQgY291bnQuICovXG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrUChzOiBVaW50MzJBcnJheSwgcm91bmRzOiBudW1iZXIgPSAyNCk6IHZvaWQge1xuICBjb25zdCBCID0gbmV3IFVpbnQzMkFycmF5KDUgKiAyKTtcbiAgLy8gTk9URTogYWxsIGluZGljZXMgYXJlIHgyIHNpbmNlIHdlIHN0b3JlIHN0YXRlIGFzIHUzMiBpbnN0ZWFkIG9mIHU2NCAoYmlnaW50cyB0byBzbG93IGluIGpzKVxuICBmb3IgKGxldCByb3VuZCA9IDI0IC0gcm91bmRzOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgLy8gVGhldGEgXHUwM0I4XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKSBCW3hdID0gc1t4XSBeIHNbeCArIDEwXSBeIHNbeCArIDIwXSBeIHNbeCArIDMwXSBeIHNbeCArIDQwXTtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4ICs9IDIpIHtcbiAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XG4gICAgICBjb25zdCBpZHgwID0gKHggKyAyKSAlIDEwO1xuICAgICAgY29uc3QgQjAgPSBCW2lkeDBdO1xuICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcbiAgICAgIGNvbnN0IFRoID0gcm90bEgoQjAsIEIxLCAxKSBeIEJbaWR4MV07XG4gICAgICBjb25zdCBUbCA9IHJvdGxMKEIwLCBCMSwgMSkgXiBCW2lkeDEgKyAxXTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgc1t4ICsgeV0gXj0gVGg7XG4gICAgICAgIHNbeCArIHkgKyAxXSBePSBUbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmhvIChcdTAzQzEpIGFuZCBQaSAoXHUwM0MwKVxuICAgIGxldCBjdXJIID0gc1syXTtcbiAgICBsZXQgY3VyTCA9IHNbM107XG4gICAgZm9yIChsZXQgdCA9IDA7IHQgPCAyNDsgdCsrKSB7XG4gICAgICBjb25zdCBzaGlmdCA9IFNIQTNfUk9UTFt0XTtcbiAgICAgIGNvbnN0IFRoID0gcm90bEgoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgY29uc3QgVGwgPSByb3RsTChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICBjb25zdCBQSSA9IFNIQTNfUElbdF07XG4gICAgICBjdXJIID0gc1tQSV07XG4gICAgICBjdXJMID0gc1tQSSArIDFdO1xuICAgICAgc1tQSV0gPSBUaDtcbiAgICAgIHNbUEkgKyAxXSA9IFRsO1xuICAgIH1cbiAgICAvLyBDaGkgKFx1MDNDNylcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspIEJbeF0gPSBzW3kgKyB4XTtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKykgc1t5ICsgeF0gXj0gfkJbKHggKyAyKSAlIDEwXSAmIEJbKHggKyA0KSAlIDEwXTtcbiAgICB9XG4gICAgLy8gSW90YSAoXHUwM0I5KVxuICAgIHNbMF0gXj0gU0hBM19JT1RBX0hbcm91bmRdO1xuICAgIHNbMV0gXj0gU0hBM19JT1RBX0xbcm91bmRdO1xuICB9XG4gIGNsZWFuKEIpO1xufVxuXG4vKiogS2VjY2FrIHNwb25nZSBmdW5jdGlvbi4gKi9cbmV4cG9ydCBjbGFzcyBLZWNjYWsgZXh0ZW5kcyBIYXNoPEtlY2Nhaz4gaW1wbGVtZW50cyBIYXNoWE9GPEtlY2Nhaz4ge1xuICBwcm90ZWN0ZWQgc3RhdGU6IFVpbnQ4QXJyYXk7XG4gIHByb3RlY3RlZCBwb3MgPSAwO1xuICBwcm90ZWN0ZWQgcG9zT3V0ID0gMDtcbiAgcHJvdGVjdGVkIGZpbmlzaGVkID0gZmFsc2U7XG4gIHByb3RlY3RlZCBzdGF0ZTMyOiBVaW50MzJBcnJheTtcbiAgcHJvdGVjdGVkIGRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIHB1YmxpYyBibG9ja0xlbjogbnVtYmVyO1xuICBwdWJsaWMgc3VmZml4OiBudW1iZXI7XG4gIHB1YmxpYyBvdXRwdXRMZW46IG51bWJlcjtcbiAgcHJvdGVjdGVkIGVuYWJsZVhPRiA9IGZhbHNlO1xuICBwcm90ZWN0ZWQgcm91bmRzOiBudW1iZXI7XG5cbiAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgY29uc3RydWN0b3IoXG4gICAgYmxvY2tMZW46IG51bWJlcixcbiAgICBzdWZmaXg6IG51bWJlcixcbiAgICBvdXRwdXRMZW46IG51bWJlcixcbiAgICBlbmFibGVYT0YgPSBmYWxzZSxcbiAgICByb3VuZHM6IG51bWJlciA9IDI0XG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgIHRoaXMuZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgIC8vIENhbiBiZSBwYXNzZWQgZnJvbSB1c2VyIGFzIGRrTGVuXG4gICAgYW51bWJlcihvdXRwdXRMZW4pO1xuICAgIC8vIDE2MDAgPSA1eDUgbWF0cml4IG9mIDY0Yml0LiAgMTYwMCBiaXRzID09PSAyMDAgYnl0ZXNcbiAgICAvLyAwIDwgYmxvY2tMZW4gPCAyMDBcbiAgICBpZiAoISgwIDwgYmxvY2tMZW4gJiYgYmxvY2tMZW4gPCAyMDApKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbmx5IGtlY2Nhay1mMTYwMCBmdW5jdGlvbiBpcyBzdXBwb3J0ZWQnKTtcbiAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMjAwKTtcbiAgICB0aGlzLnN0YXRlMzIgPSB1MzIodGhpcy5zdGF0ZSk7XG4gIH1cbiAgY2xvbmUoKTogS2VjY2FrIHtcbiAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gIH1cbiAgcHJvdGVjdGVkIGtlY2NhaygpOiB2b2lkIHtcbiAgICBzd2FwMzJJZkJFKHRoaXMuc3RhdGUzMik7XG4gICAga2VjY2FrUCh0aGlzLnN0YXRlMzIsIHRoaXMucm91bmRzKTtcbiAgICBzd2FwMzJJZkJFKHRoaXMuc3RhdGUzMik7XG4gICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgIHRoaXMucG9zID0gMDtcbiAgfVxuICB1cGRhdGUoZGF0YTogSW5wdXQpOiB0aGlzIHtcbiAgICBhZXhpc3RzKHRoaXMpO1xuICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgIGFieXRlcyhkYXRhKTtcbiAgICBjb25zdCB7IGJsb2NrTGVuLCBzdGF0ZSB9ID0gdGhpcztcbiAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47ICkge1xuICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2U7IGkrKykgc3RhdGVbdGhpcy5wb3MrK10gXj0gZGF0YVtwb3MrK107XG4gICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB0aGlzLmtlY2NhaygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwcm90ZWN0ZWQgZmluaXNoKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmZpbmlzaGVkKSByZXR1cm47XG4gICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgY29uc3QgeyBzdGF0ZSwgc3VmZml4LCBwb3MsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgIC8vIERvIHRoZSBwYWRkaW5nXG4gICAgc3RhdGVbcG9zXSBePSBzdWZmaXg7XG4gICAgaWYgKChzdWZmaXggJiAweDgwKSAhPT0gMCAmJiBwb3MgPT09IGJsb2NrTGVuIC0gMSkgdGhpcy5rZWNjYWsoKTtcbiAgICBzdGF0ZVtibG9ja0xlbiAtIDFdIF49IDB4ODA7XG4gICAgdGhpcy5rZWNjYWsoKTtcbiAgfVxuICBwcm90ZWN0ZWQgd3JpdGVJbnRvKG91dDogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkge1xuICAgIGFleGlzdHModGhpcywgZmFsc2UpO1xuICAgIGFieXRlcyhvdXQpO1xuICAgIHRoaXMuZmluaXNoKCk7XG4gICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7IGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgIGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IG91dC5sZW5ndGg7IHBvcyA8IGxlbjsgKSB7XG4gICAgICBpZiAodGhpcy5wb3NPdXQgPj0gYmxvY2tMZW4pIHRoaXMua2VjY2FrKCk7XG4gICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvc091dCwgbGVuIC0gcG9zKTtcbiAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xuICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcbiAgICAgIHBvcyArPSB0YWtlO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIHhvZkludG8ob3V0OiBVaW50OEFycmF5KTogVWludDhBcnJheSB7XG4gICAgLy8gU2hhMy9LZWNjYWsgdXNhZ2Ugd2l0aCBYT0YgaXMgcHJvYmFibHkgbWlzdGFrZSwgb25seSBTSEFLRSBpbnN0YW5jZXMgY2FuIGRvIFhPRlxuICAgIGlmICghdGhpcy5lbmFibGVYT0YpIHRocm93IG5ldyBFcnJvcignWE9GIGlzIG5vdCBwb3NzaWJsZSBmb3IgdGhpcyBpbnN0YW5jZScpO1xuICAgIHJldHVybiB0aGlzLndyaXRlSW50byhvdXQpO1xuICB9XG4gIHhvZihieXRlczogbnVtYmVyKTogVWludDhBcnJheSB7XG4gICAgYW51bWJlcihieXRlcyk7XG4gICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xuICB9XG4gIGRpZ2VzdEludG8ob3V0OiBVaW50OEFycmF5KTogVWludDhBcnJheSB7XG4gICAgYW91dHB1dChvdXQsIHRoaXMpO1xuICAgIGlmICh0aGlzLmZpbmlzaGVkKSB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBkaWdlc3QoKTogVWludDhBcnJheSB7XG4gICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICB9XG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIGNsZWFuKHRoaXMuc3RhdGUpO1xuICB9XG4gIF9jbG9uZUludG8odG8/OiBLZWNjYWspOiBLZWNjYWsge1xuICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcbiAgICB0byB8fD0gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiwgcm91bmRzKTtcbiAgICB0by5zdGF0ZTMyLnNldCh0aGlzLnN0YXRlMzIpO1xuICAgIHRvLnBvcyA9IHRoaXMucG9zO1xuICAgIHRvLnBvc091dCA9IHRoaXMucG9zT3V0O1xuICAgIHRvLmZpbmlzaGVkID0gdGhpcy5maW5pc2hlZDtcbiAgICB0by5yb3VuZHMgPSByb3VuZHM7XG4gICAgLy8gU3VmZml4IGNhbiBjaGFuZ2UgaW4gY1NIQUtFXG4gICAgdG8uc3VmZml4ID0gc3VmZml4O1xuICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICB0by5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgdG8uZGVzdHJveWVkID0gdGhpcy5kZXN0cm95ZWQ7XG4gICAgcmV0dXJuIHRvO1xuICB9XG59XG5cbmNvbnN0IGdlbiA9IChzdWZmaXg6IG51bWJlciwgYmxvY2tMZW46IG51bWJlciwgb3V0cHV0TGVuOiBudW1iZXIpID0+XG4gIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbikpO1xuXG4vKiogU0hBMy0yMjQgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzIyNDogQ0hhc2ggPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDA2LCAxNDQsIDIyNCAvIDgpKSgpO1xuLyoqIFNIQTMtMjU2IGhhc2ggZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIGtlY2Nhay0yNTYuICovXG5leHBvcnQgY29uc3Qgc2hhM18yNTY6IENIYXNoID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBnZW4oMHgwNiwgMTM2LCAyNTYgLyA4KSkoKTtcbi8qKiBTSEEzLTM4NCBoYXNoIGZ1bmN0aW9uLiAqL1xuZXhwb3J0IGNvbnN0IHNoYTNfMzg0OiBDSGFzaCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDYsIDEwNCwgMzg0IC8gOCkpKCk7XG4vKiogU0hBMy01MTIgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzUxMjogQ0hhc2ggPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDA2LCA3MiwgNTEyIC8gOCkpKCk7XG5cbi8qKiBrZWNjYWstMjI0IGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnQgY29uc3Qga2VjY2FrXzIyNDogQ0hhc2ggPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDAxLCAxNDQsIDIyNCAvIDgpKSgpO1xuLyoqIGtlY2Nhay0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20gU0hBMy0yNTYuICovXG5leHBvcnQgY29uc3Qga2VjY2FrXzI1NjogQ0hhc2ggPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDAxLCAxMzYsIDI1NiAvIDgpKSgpO1xuLyoqIGtlY2Nhay0zODQgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydCBjb25zdCBrZWNjYWtfMzg0OiBDSGFzaCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCkpKCk7XG4vKioga2VjY2FrLTUxMiBoYXNoIGZ1bmN0aW9uLiAqL1xuZXhwb3J0IGNvbnN0IGtlY2Nha181MTI6IENIYXNoID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBnZW4oMHgwMSwgNzIsIDUxMiAvIDgpKSgpO1xuXG5leHBvcnQgdHlwZSBTaGFrZU9wdHMgPSB7IGRrTGVuPzogbnVtYmVyIH07XG5cbmNvbnN0IGdlblNoYWtlID0gKHN1ZmZpeDogbnVtYmVyLCBibG9ja0xlbjogbnVtYmVyLCBvdXRwdXRMZW46IG51bWJlcikgPT5cbiAgY3JlYXRlWE9GZXI8SGFzaFhPRjxLZWNjYWs+LCBTaGFrZU9wdHM+KFxuICAgIChvcHRzOiBTaGFrZU9wdHMgPSB7fSkgPT5cbiAgICAgIG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gb3V0cHV0TGVuIDogb3B0cy5ka0xlbiwgdHJ1ZSlcbiAgKTtcblxuLyoqIFNIQUtFMTI4IFhPRiB3aXRoIDEyOC1iaXQgc2VjdXJpdHkuICovXG5leHBvcnQgY29uc3Qgc2hha2UxMjg6IENIYXNoWE8gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlblNoYWtlKDB4MWYsIDE2OCwgMTI4IC8gOCkpKCk7XG4vKiogU0hBS0UyNTYgWE9GIHdpdGggMjU2LWJpdCBzZWN1cml0eS4gKi9cbmV4cG9ydCBjb25zdCBzaGFrZTI1NjogQ0hhc2hYTyA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuU2hha2UoMHgxZiwgMTM2LCAyNTYgLyA4KSkoKTtcbiIsICIvKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBhYnl0ZXMsIGFleGlzdHMsIGFoYXNoLCBjbGVhbiwgSGFzaCwgdG9CeXRlcywgdHlwZSBDSGFzaCwgdHlwZSBJbnB1dCB9IGZyb20gJy4vdXRpbHMudHMnO1xuXG5leHBvcnQgY2xhc3MgSE1BQzxUIGV4dGVuZHMgSGFzaDxUPj4gZXh0ZW5kcyBIYXNoPEhNQUM8VD4+IHtcbiAgb0hhc2g6IFQ7XG4gIGlIYXNoOiBUO1xuICBibG9ja0xlbjogbnVtYmVyO1xuICBvdXRwdXRMZW46IG51bWJlcjtcbiAgcHJpdmF0ZSBmaW5pc2hlZCA9IGZhbHNlO1xuICBwcml2YXRlIGRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGhhc2g6IENIYXNoLCBfa2V5OiBJbnB1dCkge1xuICAgIHN1cGVyKCk7XG4gICAgYWhhc2goaGFzaCk7XG4gICAgY29uc3Qga2V5ID0gdG9CeXRlcyhfa2V5KTtcbiAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKSBhcyBUO1xuICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKykgcGFkW2ldIF49IDB4MzY7XG4gICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCkgYXMgVDtcbiAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKykgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgY2xlYW4ocGFkKTtcbiAgfVxuICB1cGRhdGUoYnVmOiBJbnB1dCk6IHRoaXMge1xuICAgIGFleGlzdHModGhpcyk7XG4gICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkaWdlc3RJbnRvKG91dDogVWludDhBcnJheSk6IHZvaWQge1xuICAgIGFleGlzdHModGhpcyk7XG4gICAgYWJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbiAgZGlnZXN0KCk6IFVpbnQ4QXJyYXkge1xuICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIF9jbG9uZUludG8odG8/OiBITUFDPFQ+KTogSE1BQzxUPiB7XG4gICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgdG8gfHw9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSk7XG4gICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgdG8gPSB0byBhcyB0aGlzO1xuICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICByZXR1cm4gdG87XG4gIH1cbiAgY2xvbmUoKTogSE1BQzxUPiB7XG4gICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICB9XG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICB9XG59XG5cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuICogaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyJztcbiAqIGNvbnN0IG1hYzEgPSBobWFjKHNoYTI1NiwgJ2tleScsICdtZXNzYWdlJyk7XG4gKi9cbmV4cG9ydCBjb25zdCBobWFjOiB7XG4gIChoYXNoOiBDSGFzaCwga2V5OiBJbnB1dCwgbWVzc2FnZTogSW5wdXQpOiBVaW50OEFycmF5O1xuICBjcmVhdGUoaGFzaDogQ0hhc2gsIGtleTogSW5wdXQpOiBITUFDPGFueT47XG59ID0gKGhhc2g6IENIYXNoLCBrZXk6IElucHV0LCBtZXNzYWdlOiBJbnB1dCk6IFVpbnQ4QXJyYXkgPT5cbiAgbmV3IEhNQUM8YW55PihoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2g6IENIYXNoLCBrZXk6IElucHV0KSA9PiBuZXcgSE1BQzxhbnk+KGhhc2gsIGtleSk7XG4iLCAiLyoqXG4gKiBTaG9ydCBXZWllcnN0cmFzcyBjdXJ2ZSBtZXRob2RzLiBUaGUgZm9ybXVsYSBpczogeVx1MDBCMiA9IHhcdTAwQjMgKyBheCArIGIuXG4gKlxuICogIyMjIERlc2lnbiByYXRpb25hbGUgZm9yIHR5cGVzXG4gKlxuICogKiBJbnRlcmFjdGlvbiBiZXR3ZWVuIGNsYXNzZXMgZnJvbSBkaWZmZXJlbnQgY3VydmVzIHNob3VsZCBmYWlsOlxuICogICBgazI1Ni5Qb2ludC5CQVNFLmFkZChwMjU2LlBvaW50LkJBU0UpYFxuICogKiBGb3IgdGhpcyBwdXJwb3NlIHdlIHdhbnQgdG8gdXNlIGBpbnN0YW5jZW9mYCBvcGVyYXRvciwgd2hpY2ggaXMgZmFzdCBhbmQgd29ya3MgZHVyaW5nIHJ1bnRpbWVcbiAqICogRGlmZmVyZW50IGNhbGxzIG9mIGBjdXJ2ZSgpYCB3b3VsZCByZXR1cm4gZGlmZmVyZW50IGNsYXNzZXMgLVxuICogICBgY3VydmUocGFyYW1zKSAhPT0gY3VydmUocGFyYW1zKWA6IGlmIHNvbWVib2R5IGRlY2lkZWQgdG8gbW9ua2V5LXBhdGNoIHRoZWlyIGN1cnZlLFxuICogICBpdCB3b24ndCBhZmZlY3Qgb3RoZXJzXG4gKlxuICogVHlwZVNjcmlwdCBjYW4ndCBpbmZlciB0eXBlcyBmb3IgY2xhc3NlcyBjcmVhdGVkIGluc2lkZSBhIGZ1bmN0aW9uLiBDbGFzc2VzIGlzIG9uZSBpbnN0YW5jZVxuICogb2Ygbm9taW5hdGl2ZSB0eXBlcyBpbiBUeXBlU2NyaXB0IGFuZCBpbnRlcmZhY2VzIG9ubHkgY2hlY2sgZm9yIHNoYXBlLCBzbyBpdCdzIGhhcmQgdG8gY3JlYXRlXG4gKiB1bmlxdWUgdHlwZSBmb3IgZXZlcnkgZnVuY3Rpb24gY2FsbC5cbiAqXG4gKiBXZSBjYW4gdXNlIGdlbmVyaWMgdHlwZXMgdmlhIHNvbWUgcGFyYW0sIGxpa2UgY3VydmUgb3B0cywgYnV0IHRoYXQgd291bGQ6XG4gKiAgICAgMS4gRW5hYmxlIGludGVyYWN0aW9uIGJldHdlZW4gYGN1cnZlKHBhcmFtcylgIGFuZCBgY3VydmUocGFyYW1zKWAgKGN1cnZlcyBvZiBzYW1lIHBhcmFtcylcbiAqICAgICB3aGljaCBpcyBoYXJkIHRvIGRlYnVnLlxuICogICAgIDIuIFBhcmFtcyBjYW4gYmUgZ2VuZXJpYyBhbmQgd2UgY2FuJ3QgZW5mb3JjZSB0aGVtIHRvIGJlIGNvbnN0YW50IHZhbHVlOlxuICogICAgIGlmIHNvbWVib2R5IGNyZWF0ZXMgY3VydmUgZnJvbSBub24tY29uc3RhbnQgcGFyYW1zLFxuICogICAgIGl0IHdvdWxkIGJlIGFsbG93ZWQgdG8gaW50ZXJhY3Qgd2l0aCBvdGhlciBjdXJ2ZXMgd2l0aCBub24tY29uc3RhbnQgcGFyYW1zXG4gKlxuICogQHRvZG8gaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svcmVsZWFzZS1ub3Rlcy90eXBlc2NyaXB0LTItNy5odG1sI3VuaXF1ZS1zeW1ib2xcbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgaG1hYyBhcyBub2JsZUhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMuanMnO1xuaW1wb3J0IHsgYWhhc2ggfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7XG4gIF92YWxpZGF0ZU9iamVjdCxcbiAgX2Fib29sMiBhcyBhYm9vbCxcbiAgX2FieXRlczIgYXMgYWJ5dGVzLFxuICBhSW5SYW5nZSxcbiAgYml0TGVuLFxuICBiaXRNYXNrLFxuICBieXRlc1RvSGV4LFxuICBieXRlc1RvTnVtYmVyQkUsXG4gIGNvbmNhdEJ5dGVzLFxuICBjcmVhdGVIbWFjRHJiZyxcbiAgZW5zdXJlQnl0ZXMsXG4gIGhleFRvQnl0ZXMsXG4gIGluUmFuZ2UsXG4gIGlzQnl0ZXMsXG4gIG1lbW9pemVkLFxuICBudW1iZXJUb0hleFVucGFkZGVkLFxuICByYW5kb21CeXRlcyBhcyByYW5kb21CeXRlc1dlYixcbiAgdHlwZSBDSGFzaCxcbiAgdHlwZSBIZXgsXG4gIHR5cGUgUHJpdktleSxcbn0gZnJvbSAnLi4vdXRpbHMudHMnO1xuaW1wb3J0IHtcbiAgX2NyZWF0ZUN1cnZlRmllbGRzLFxuICBtdWxFbmRvVW5zYWZlLFxuICBuZWdhdGVDdCxcbiAgbm9ybWFsaXplWixcbiAgcGlwcGVuZ2VyLFxuICB3TkFGLFxuICB0eXBlIEFmZmluZVBvaW50LFxuICB0eXBlIEJhc2ljQ3VydmUsXG4gIHR5cGUgQ3VydmVMZW5ndGhzLFxuICB0eXBlIEN1cnZlUG9pbnQsXG4gIHR5cGUgQ3VydmVQb2ludENvbnMsXG59IGZyb20gJy4vY3VydmUudHMnO1xuaW1wb3J0IHtcbiAgRmllbGQsXG4gIEZwSW52ZXJ0QmF0Y2gsXG4gIGdldE1pbkhhc2hMZW5ndGgsXG4gIG1hcEhhc2hUb0ZpZWxkLFxuICBuTGVuZ3RoLFxuICB2YWxpZGF0ZUZpZWxkLFxuICB0eXBlIElGaWVsZCxcbiAgdHlwZSBOTGVuZ3RoLFxufSBmcm9tICcuL21vZHVsYXIudHMnO1xuXG5leHBvcnQgdHlwZSB7IEFmZmluZVBvaW50IH07XG5leHBvcnQgdHlwZSBIbWFjRm5TeW5jID0gKGtleTogVWludDhBcnJheSwgLi4ubWVzc2FnZXM6IFVpbnQ4QXJyYXlbXSkgPT4gVWludDhBcnJheTtcblxudHlwZSBFbmRvQmFzaXMgPSBbW2JpZ2ludCwgYmlnaW50XSwgW2JpZ2ludCwgYmlnaW50XV07XG4vKipcbiAqIFdoZW4gV2VpZXJzdHJhc3MgY3VydmUgaGFzIGBhPTBgLCBpdCBiZWNvbWVzIEtvYmxpdHogY3VydmUuXG4gKiBLb2JsaXR6IGN1cnZlcyBhbGxvdyB1c2luZyAqKmVmZmljaWVudGx5LWNvbXB1dGFibGUgR0xWIGVuZG9tb3JwaGlzbSBcdTAzQzgqKi5cbiAqIEVuZG9tb3JwaGlzbSB1c2VzIDJ4IGxlc3MgUkFNLCBzcGVlZHMgdXAgcHJlY29tcHV0YXRpb24gYnkgMnggYW5kIEVDREggLyBrZXkgcmVjb3ZlcnkgYnkgMjAlLlxuICogRm9yIHByZWNvbXB1dGVkIHdOQUYgaXQgdHJhZGVzIG9mZiAxLzIgaW5pdCB0aW1lICYgMS8zIHJhbSBmb3IgMjAlIHBlcmYgaGl0LlxuICpcbiAqIEVuZG9tb3JwaGlzbSBjb25zaXN0cyBvZiBiZXRhLCBsYW1iZGEgYW5kIHNwbGl0U2NhbGFyOlxuICpcbiAqIDEuIEdMViBlbmRvbW9ycGhpc20gXHUwM0M4IHRyYW5zZm9ybXMgYSBwb2ludDogYFAgPSAoeCwgeSkgXHUyMUE2IFx1MDNDOChQKSA9IChcdTAzQjJcdTAwQjd4IG1vZCBwLCB5KWBcbiAqIDIuIEdMViBzY2FsYXIgZGVjb21wb3NpdGlvbiB0cmFuc2Zvcm1zIGEgc2NhbGFyOiBgayBcdTIyNjEga1x1MjA4MSArIGtcdTIwODJcdTAwQjdcdTAzQkIgKG1vZCBuKWBcbiAqIDMuIFRoZW4gdGhlc2UgYXJlIGNvbWJpbmVkOiBga1x1MDBCN1AgPSBrXHUyMDgxXHUwMEI3UCArIGtcdTIwODJcdTAwQjdcdTAzQzgoUClgXG4gKiA0LiBUd28gMTI4LWJpdCBwb2ludC1ieS1zY2FsYXIgbXVsdGlwbGljYXRpb25zICsgb25lIHBvaW50IGFkZGl0aW9uIGlzIGZhc3RlciB0aGFuXG4gKiAgICBvbmUgMjU2LWJpdCBtdWx0aXBsaWNhdGlvbi5cbiAqXG4gKiB3aGVyZVxuICogKiBiZXRhOiBcdTAzQjIgXHUyMjA4IEZcdTIwOUEgd2l0aCBcdTAzQjJcdTAwQjMgPSAxLCBcdTAzQjIgXHUyMjYwIDFcbiAqICogbGFtYmRhOiBcdTAzQkIgXHUyMjA4IEZcdTIwOTkgd2l0aCBcdTAzQkJcdTAwQjMgPSAxLCBcdTAzQkIgXHUyMjYwIDFcbiAqICogc3BsaXRTY2FsYXIgZGVjb21wb3NlcyBrIFx1MjFBNiBrXHUyMDgxLCBrXHUyMDgyLCBieSB1c2luZyByZWR1Y2VkIGJhc2lzIHZlY3RvcnMuXG4gKiAgIEdhdXNzIGxhdHRpY2UgcmVkdWN0aW9uIGNhbGN1bGF0ZXMgdGhlbSBmcm9tIGluaXRpYWwgYmFzaXMgdmVjdG9ycyBgKG4sIDApLCAoLVx1MDNCQiwgMClgXG4gKlxuICogQ2hlY2sgb3V0IGB0ZXN0L21pc2MvZW5kb21vcnBoaXNtLmpzYCBhbmRcbiAqIFtnaXN0XShodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsbWlsbHIvZWI2NzA4MDY3OTNlODRkZjYyOGE3YzQzNGE4NzMwNjYpLlxuICovXG5leHBvcnQgdHlwZSBFbmRvbW9ycGhpc21PcHRzID0ge1xuICBiZXRhOiBiaWdpbnQ7XG4gIGJhc2lzZXM/OiBFbmRvQmFzaXM7XG4gIHNwbGl0U2NhbGFyPzogKGs6IGJpZ2ludCkgPT4geyBrMW5lZzogYm9vbGVhbjsgazE6IGJpZ2ludDsgazJuZWc6IGJvb2xlYW47IGsyOiBiaWdpbnQgfTtcbn07XG5cbi8vIFdlIGNvbnN0cnVjdCBiYXNpcyBpbiBzdWNoIHdheSB0aGF0IGRlbiBpcyBhbHdheXMgcG9zaXRpdmUgYW5kIGVxdWFscyBuLCBidXQgbnVtIHNpZ24gZGVwZW5kcyBvbiBiYXNpcyAobm90IG9uIHNlY3JldCB2YWx1ZSlcbmNvbnN0IGRpdk5lYXJlc3QgPSAobnVtOiBiaWdpbnQsIGRlbjogYmlnaW50KSA9PiAobnVtICsgKG51bSA+PSAwID8gZGVuIDogLWRlbikgLyBfMm4pIC8gZGVuO1xuXG5leHBvcnQgdHlwZSBTY2FsYXJFbmRvUGFydHMgPSB7IGsxbmVnOiBib29sZWFuOyBrMTogYmlnaW50OyBrMm5lZzogYm9vbGVhbjsgazI6IGJpZ2ludCB9O1xuXG4vKipcbiAqIFNwbGl0cyBzY2FsYXIgZm9yIEdMViBlbmRvbW9ycGhpc20uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc3BsaXRFbmRvU2NhbGFyKGs6IGJpZ2ludCwgYmFzaXM6IEVuZG9CYXNpcywgbjogYmlnaW50KTogU2NhbGFyRW5kb1BhcnRzIHtcbiAgLy8gU3BsaXQgc2NhbGFyIGludG8gdHdvIHN1Y2ggdGhhdCBwYXJ0IGlzIH5oYWxmIGJpdHM6IGBhYnMocGFydCkgPCBzcXJ0KE4pYFxuICAvLyBTaW5jZSBwYXJ0IGNhbiBiZSBuZWdhdGl2ZSwgd2UgbmVlZCB0byBkbyB0aGlzIG9uIHBvaW50LlxuICAvLyBUT0RPOiB2ZXJpZnlTY2FsYXIgZnVuY3Rpb24gd2hpY2ggY29uc3VtZXMgbGFtYmRhXG4gIGNvbnN0IFtbYTEsIGIxXSwgW2EyLCBiMl1dID0gYmFzaXM7XG4gIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gIC8vIHxrMXwvfGsyfCBpcyA8IHNxcnQoTiksIGJ1dCBjYW4gYmUgbmVnYXRpdmUuXG4gIC8vIElmIHdlIGRvIGBrMSBtb2QgTmAsIHdlJ2xsIGdldCBiaWcgc2NhbGFyIChgPiBzcXJ0KE4pYCk6IHNvLCB3ZSBkbyBjaGVhcGVyIG5lZ2F0aW9uIGluc3RlYWQuXG4gIGxldCBrMSA9IGsgLSBjMSAqIGExIC0gYzIgKiBhMjtcbiAgbGV0IGsyID0gLWMxICogYjEgLSBjMiAqIGIyO1xuICBjb25zdCBrMW5lZyA9IGsxIDwgXzBuO1xuICBjb25zdCBrMm5lZyA9IGsyIDwgXzBuO1xuICBpZiAoazFuZWcpIGsxID0gLWsxO1xuICBpZiAoazJuZWcpIGsyID0gLWsyO1xuICAvLyBEb3VibGUgY2hlY2sgdGhhdCByZXN1bHRpbmcgc2NhbGFyIGxlc3MgdGhhbiBoYWxmIGJpdHMgb2YgTjogb3RoZXJ3aXNlIHdOQUYgd2lsbCBmYWlsLlxuICAvLyBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBvbiB3cm9uZyBiYXNpc2VzLiBBbHNvLCBtYXRoIGluc2lkZSBpcyB0b28gY29tcGxleCBhbmQgSSBkb24ndCB0cnVzdCBpdC5cbiAgY29uc3QgTUFYX05VTSA9IGJpdE1hc2soTWF0aC5jZWlsKGJpdExlbihuKSAvIDIpKSArIF8xbjsgLy8gSGFsZiBiaXRzIG9mIE5cbiAgaWYgKGsxIDwgXzBuIHx8IGsxID49IE1BWF9OVU0gfHwgazIgPCBfMG4gfHwgazIgPj0gTUFYX05VTSkge1xuICAgIHRocm93IG5ldyBFcnJvcignc3BsaXRTY2FsYXIgKGVuZG9tb3JwaGlzbSk6IGZhaWxlZCwgaz0nICsgayk7XG4gIH1cbiAgcmV0dXJuIHsgazFuZWcsIGsxLCBrMm5lZywgazIgfTtcbn1cblxuZXhwb3J0IHR5cGUgRUNEU0FTaWdGb3JtYXQgPSAnY29tcGFjdCcgfCAncmVjb3ZlcmVkJyB8ICdkZXInO1xuZXhwb3J0IHR5cGUgRUNEU0FSZWNvdmVyT3B0cyA9IHtcbiAgcHJlaGFzaD86IGJvb2xlYW47XG59O1xuZXhwb3J0IHR5cGUgRUNEU0FWZXJpZnlPcHRzID0ge1xuICBwcmVoYXNoPzogYm9vbGVhbjtcbiAgbG93Uz86IGJvb2xlYW47XG4gIGZvcm1hdD86IEVDRFNBU2lnRm9ybWF0O1xufTtcbmV4cG9ydCB0eXBlIEVDRFNBU2lnbk9wdHMgPSB7XG4gIHByZWhhc2g/OiBib29sZWFuO1xuICBsb3dTPzogYm9vbGVhbjtcbiAgZm9ybWF0PzogRUNEU0FTaWdGb3JtYXQ7XG4gIGV4dHJhRW50cm9weT86IFVpbnQ4QXJyYXkgfCBib29sZWFuO1xufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVTaWdGb3JtYXQoZm9ybWF0OiBzdHJpbmcpOiBFQ0RTQVNpZ0Zvcm1hdCB7XG4gIGlmICghWydjb21wYWN0JywgJ3JlY292ZXJlZCcsICdkZXInXS5pbmNsdWRlcyhmb3JtYXQpKVxuICAgIHRocm93IG5ldyBFcnJvcignU2lnbmF0dXJlIGZvcm1hdCBtdXN0IGJlIFwiY29tcGFjdFwiLCBcInJlY292ZXJlZFwiLCBvciBcImRlclwiJyk7XG4gIHJldHVybiBmb3JtYXQgYXMgRUNEU0FTaWdGb3JtYXQ7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlU2lnT3B0czxUIGV4dGVuZHMgRUNEU0FTaWduT3B0cywgRCBleHRlbmRzIFJlcXVpcmVkPEVDRFNBU2lnbk9wdHM+PihcbiAgb3B0czogVCxcbiAgZGVmOiBEXG4pOiBSZXF1aXJlZDxFQ0RTQVNpZ25PcHRzPiB7XG4gIGNvbnN0IG9wdHNuOiBFQ0RTQVNpZ25PcHRzID0ge307XG4gIGZvciAobGV0IG9wdE5hbWUgb2YgT2JqZWN0LmtleXMoZGVmKSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBvcHRzbltvcHROYW1lXSA9IG9wdHNbb3B0TmFtZV0gPT09IHVuZGVmaW5lZCA/IGRlZltvcHROYW1lXSA6IG9wdHNbb3B0TmFtZV07XG4gIH1cbiAgYWJvb2wob3B0c24ubG93UyEsICdsb3dTJyk7XG4gIGFib29sKG9wdHNuLnByZWhhc2ghLCAncHJlaGFzaCcpO1xuICBpZiAob3B0c24uZm9ybWF0ICE9PSB1bmRlZmluZWQpIHZhbGlkYXRlU2lnRm9ybWF0KG9wdHNuLmZvcm1hdCk7XG4gIHJldHVybiBvcHRzbiBhcyBSZXF1aXJlZDxFQ0RTQVNpZ25PcHRzPjtcbn1cblxuLyoqIEluc3RhbmNlIG1ldGhvZHMgZm9yIDNEIFhZWiBwcm9qZWN0aXZlIHBvaW50cy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgV2VpZXJzdHJhc3NQb2ludDxUPiBleHRlbmRzIEN1cnZlUG9pbnQ8VCwgV2VpZXJzdHJhc3NQb2ludDxUPj4ge1xuICAvKiogcHJvamVjdGl2ZSBYIGNvb3JkaW5hdGUuIERpZmZlcmVudCBmcm9tIGFmZmluZSB4LiAqL1xuICByZWFkb25seSBYOiBUO1xuICAvKiogcHJvamVjdGl2ZSBZIGNvb3JkaW5hdGUuIERpZmZlcmVudCBmcm9tIGFmZmluZSB5LiAqL1xuICByZWFkb25seSBZOiBUO1xuICAvKiogcHJvamVjdGl2ZSB6IGNvb3JkaW5hdGUgKi9cbiAgcmVhZG9ubHkgWjogVDtcbiAgLyoqIGFmZmluZSB4IGNvb3JkaW5hdGUuIERpZmZlcmVudCBmcm9tIHByb2plY3RpdmUgWC4gKi9cbiAgZ2V0IHgoKTogVDtcbiAgLyoqIGFmZmluZSB5IGNvb3JkaW5hdGUuIERpZmZlcmVudCBmcm9tIHByb2plY3RpdmUgWS4gKi9cbiAgZ2V0IHkoKTogVDtcbiAgLyoqIEVuY29kZXMgcG9pbnQgdXNpbmcgSUVFRSBQMTM2MyAoREVSKSBlbmNvZGluZy4gRmlyc3QgYnl0ZSBpcyAyLzMvNC4gRGVmYXVsdCA9IGlzQ29tcHJlc3NlZC4gKi9cbiAgdG9CeXRlcyhpc0NvbXByZXNzZWQ/OiBib29sZWFuKTogVWludDhBcnJheTtcbiAgdG9IZXgoaXNDb21wcmVzc2VkPzogYm9vbGVhbik6IHN0cmluZztcblxuICAvKiogQGRlcHJlY2F0ZWQgdXNlIGAuWGAgKi9cbiAgcmVhZG9ubHkgcHg6IFQ7XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgYC5ZYCAqL1xuICByZWFkb25seSBweTogVDtcbiAgLyoqIEBkZXByZWNhdGVkIHVzZSBgLlpgICovXG4gIHJlYWRvbmx5IHB6OiBUO1xuICAvKiogQGRlcHJlY2F0ZWQgdXNlIGB0b0J5dGVzYCAqL1xuICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZD86IGJvb2xlYW4pOiBVaW50OEFycmF5O1xuICAvKiogQGRlcHJlY2F0ZWQgdXNlIGBtdWx0aXBseVVuc2FmZWAgKi9cbiAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoXG4gICAgUTogV2VpZXJzdHJhc3NQb2ludDxUPixcbiAgICBhOiBiaWdpbnQsXG4gICAgYjogYmlnaW50XG4gICk6IFdlaWVyc3RyYXNzUG9pbnQ8VD4gfCB1bmRlZmluZWQ7XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgYHAueSAlIDJuID09PSAwbmAgKi9cbiAgaGFzRXZlblkoKTogYm9vbGVhbjtcbiAgLyoqIEBkZXByZWNhdGVkIHVzZSBgcC5wcmVjb21wdXRlKHdpbmRvd1NpemUpYCAqL1xuICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplOiBudW1iZXIpOiB2b2lkO1xufVxuXG4vKiogU3RhdGljIG1ldGhvZHMgZm9yIDNEIFhZWiBwcm9qZWN0aXZlIHBvaW50cy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgV2VpZXJzdHJhc3NQb2ludENvbnM8VD4gZXh0ZW5kcyBDdXJ2ZVBvaW50Q29uczxXZWllcnN0cmFzc1BvaW50PFQ+PiB7XG4gIC8qKiBEb2VzIE5PVCB2YWxpZGF0ZSBpZiB0aGUgcG9pbnQgaXMgdmFsaWQuIFVzZSBgLmFzc2VydFZhbGlkaXR5KClgLiAqL1xuICBuZXcgKFg6IFQsIFk6IFQsIFo6IFQpOiBXZWllcnN0cmFzc1BvaW50PFQ+O1xuICBDVVJWRSgpOiBXZWllcnN0cmFzc09wdHM8VD47XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgYFBvaW50LkJBU0UubXVsdGlwbHkoUG9pbnQuRm4uZnJvbUJ5dGVzKHByaXZhdGVLZXkpKWAgKi9cbiAgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleTogUHJpdktleSk6IFdlaWVyc3RyYXNzUG9pbnQ8VD47XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgYGltcG9ydCB7IG5vcm1hbGl6ZVogfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L2N1cnZlLmpzJztgICovXG4gIG5vcm1hbGl6ZVoocG9pbnRzOiBXZWllcnN0cmFzc1BvaW50PFQ+W10pOiBXZWllcnN0cmFzc1BvaW50PFQ+W107XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgYGltcG9ydCB7IHBpcHBlbmdlciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvY3VydmUuanMnO2AgKi9cbiAgbXNtKHBvaW50czogV2VpZXJzdHJhc3NQb2ludDxUPltdLCBzY2FsYXJzOiBiaWdpbnRbXSk6IFdlaWVyc3RyYXNzUG9pbnQ8VD47XG59XG5cbi8qKlxuICogV2VpZXJzdHJhc3MgY3VydmUgb3B0aW9ucy5cbiAqXG4gKiAqIHA6IHByaW1lIGNoYXJhY3RlcmlzdGljIChvcmRlcikgb2YgZmluaXRlIGZpZWxkLCBpbiB3aGljaCBhcml0aG1ldGljcyBpcyBkb25lXG4gKiAqIG46IG9yZGVyIG9mIHByaW1lIHN1Ymdyb3VwIGEuay5hIHRvdGFsIGFtb3VudCBvZiB2YWxpZCBjdXJ2ZSBwb2ludHNcbiAqICogaDogY29mYWN0b3IsIHVzdWFsbHkgMS4gaCpuIGlzIGdyb3VwIG9yZGVyOyBuIGlzIHN1Ymdyb3VwIG9yZGVyXG4gKiAqIGE6IGZvcm11bGEgcGFyYW0sIG11c3QgYmUgaW4gZmllbGQgb2YgcFxuICogKiBiOiBmb3JtdWxhIHBhcmFtLCBtdXN0IGJlIGluIGZpZWxkIG9mIHBcbiAqICogR3g6IHggY29vcmRpbmF0ZSBvZiBnZW5lcmF0b3IgcG9pbnQgYS5rLmEuIGJhc2UgcG9pbnRcbiAqICogR3k6IHkgY29vcmRpbmF0ZSBvZiBnZW5lcmF0b3IgcG9pbnRcbiAqL1xuZXhwb3J0IHR5cGUgV2VpZXJzdHJhc3NPcHRzPFQ+ID0gUmVhZG9ubHk8e1xuICBwOiBiaWdpbnQ7XG4gIG46IGJpZ2ludDtcbiAgaDogYmlnaW50O1xuICBhOiBUO1xuICBiOiBUO1xuICBHeDogVDtcbiAgR3k6IFQ7XG59PjtcblxuLy8gV2hlbiBhIGNvZmFjdG9yICE9IDEsIHRoZXJlIGNhbiBiZSBhbiBlZmZlY3RpdmUgbWV0aG9kcyB0bzpcbi8vIDEuIERldGVybWluZSB3aGV0aGVyIGEgcG9pbnQgaXMgdG9yc2lvbi1mcmVlXG4vLyAyLiBDbGVhciB0b3JzaW9uIGNvbXBvbmVudFxuLy8gd3JhcFByaXZhdGVLZXk6IGJsczEyLTM4MSByZXF1aXJlcyBtb2QobikgaW5zdGVhZCBvZiByZWplY3Rpbmcga2V5cyA+PSBuXG5leHBvcnQgdHlwZSBXZWllcnN0cmFzc0V4dHJhT3B0czxUPiA9IFBhcnRpYWw8e1xuICBGcDogSUZpZWxkPFQ+O1xuICBGbjogSUZpZWxkPGJpZ2ludD47XG4gIGFsbG93SW5maW5pdHlQb2ludDogYm9vbGVhbjtcbiAgZW5kbzogRW5kb21vcnBoaXNtT3B0cztcbiAgaXNUb3JzaW9uRnJlZTogKGM6IFdlaWVyc3RyYXNzUG9pbnRDb25zPFQ+LCBwb2ludDogV2VpZXJzdHJhc3NQb2ludDxUPikgPT4gYm9vbGVhbjtcbiAgY2xlYXJDb2ZhY3RvcjogKGM6IFdlaWVyc3RyYXNzUG9pbnRDb25zPFQ+LCBwb2ludDogV2VpZXJzdHJhc3NQb2ludDxUPikgPT4gV2VpZXJzdHJhc3NQb2ludDxUPjtcbiAgZnJvbUJ5dGVzOiAoYnl0ZXM6IFVpbnQ4QXJyYXkpID0+IEFmZmluZVBvaW50PFQ+O1xuICB0b0J5dGVzOiAoXG4gICAgYzogV2VpZXJzdHJhc3NQb2ludENvbnM8VD4sXG4gICAgcG9pbnQ6IFdlaWVyc3RyYXNzUG9pbnQ8VD4sXG4gICAgaXNDb21wcmVzc2VkOiBib29sZWFuXG4gICkgPT4gVWludDhBcnJheTtcbn0+O1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIEVDRFNBIHNpZ25hdHVyZXMgb3ZlciBhIFdlaWVyc3RyYXNzIGN1cnZlLlxuICpcbiAqICogbG93UzogKGRlZmF1bHQ6IHRydWUpIHdoZXRoZXIgcHJvZHVjZWQgLyB2ZXJpZmllZCBzaWduYXR1cmVzIG9jY3VweSBsb3cgaGFsZiBvZiBlY2RzYU9wdHMucC4gUHJldmVudHMgbWFsbGVhYmlsaXR5LlxuICogKiBobWFjOiAoZGVmYXVsdDogbm9ibGUtaGFzaGVzIGhtYWMpIGZ1bmN0aW9uLCB3b3VsZCBiZSB1c2VkIHRvIGluaXQgaG1hYy1kcmJnIGZvciBrIGdlbmVyYXRpb24uXG4gKiAqIHJhbmRvbUJ5dGVzOiAoZGVmYXVsdDogd2ViY3J5cHRvIG9zLWxldmVsIENTUFJORykgY3VzdG9tIG1ldGhvZCBmb3IgZmV0Y2hpbmcgc2VjdXJlIHJhbmRvbW5lc3MuXG4gKiAqIGJpdHMyaW50LCBiaXRzMmludF9tb2ROOiB1c2VkIGluIHNpZ3MsIHNvbWV0aW1lcyBvdmVycmlkZGVuIGJ5IGN1cnZlc1xuICovXG5leHBvcnQgdHlwZSBFQ0RTQU9wdHMgPSBQYXJ0aWFsPHtcbiAgbG93UzogYm9vbGVhbjtcbiAgaG1hYzogSG1hY0ZuU3luYztcbiAgcmFuZG9tQnl0ZXM6IChieXRlc0xlbmd0aD86IG51bWJlcikgPT4gVWludDhBcnJheTtcbiAgYml0czJpbnQ6IChieXRlczogVWludDhBcnJheSkgPT4gYmlnaW50O1xuICBiaXRzMmludF9tb2ROOiAoYnl0ZXM6IFVpbnQ4QXJyYXkpID0+IGJpZ2ludDtcbn0+O1xuXG4vKipcbiAqIEVsbGlwdGljIEN1cnZlIERpZmZpZS1IZWxsbWFuIGludGVyZmFjZS5cbiAqIFByb3ZpZGVzIGtleWdlbiwgc2VjcmV0LXRvLXB1YmxpYyBjb252ZXJzaW9uLCBjYWxjdWxhdGluZyBzaGFyZWQgc2VjcmV0cy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFQ0RIIHtcbiAga2V5Z2VuOiAoc2VlZD86IFVpbnQ4QXJyYXkpID0+IHsgc2VjcmV0S2V5OiBVaW50OEFycmF5OyBwdWJsaWNLZXk6IFVpbnQ4QXJyYXkgfTtcbiAgZ2V0UHVibGljS2V5OiAoc2VjcmV0S2V5OiBQcml2S2V5LCBpc0NvbXByZXNzZWQ/OiBib29sZWFuKSA9PiBVaW50OEFycmF5O1xuICBnZXRTaGFyZWRTZWNyZXQ6IChzZWNyZXRLZXlBOiBQcml2S2V5LCBwdWJsaWNLZXlCOiBIZXgsIGlzQ29tcHJlc3NlZD86IGJvb2xlYW4pID0+IFVpbnQ4QXJyYXk7XG4gIFBvaW50OiBXZWllcnN0cmFzc1BvaW50Q29uczxiaWdpbnQ+O1xuICB1dGlsczoge1xuICAgIGlzVmFsaWRTZWNyZXRLZXk6IChzZWNyZXRLZXk6IFByaXZLZXkpID0+IGJvb2xlYW47XG4gICAgaXNWYWxpZFB1YmxpY0tleTogKHB1YmxpY0tleTogVWludDhBcnJheSwgaXNDb21wcmVzc2VkPzogYm9vbGVhbikgPT4gYm9vbGVhbjtcbiAgICByYW5kb21TZWNyZXRLZXk6IChzZWVkPzogVWludDhBcnJheSkgPT4gVWludDhBcnJheTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIGByYW5kb21TZWNyZXRLZXlgICovXG4gICAgcmFuZG9tUHJpdmF0ZUtleTogKHNlZWQ/OiBVaW50OEFycmF5KSA9PiBVaW50OEFycmF5O1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgYGlzVmFsaWRTZWNyZXRLZXlgICovXG4gICAgaXNWYWxpZFByaXZhdGVLZXk6IChzZWNyZXRLZXk6IFByaXZLZXkpID0+IGJvb2xlYW47XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBgUG9pbnQuRm4uZnJvbUJ5dGVzKClgICovXG4gICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogKGtleTogUHJpdktleSkgPT4gYmlnaW50O1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgYHBvaW50LnByZWNvbXB1dGUoKWAgKi9cbiAgICBwcmVjb21wdXRlOiAod2luZG93U2l6ZT86IG51bWJlciwgcG9pbnQ/OiBXZWllcnN0cmFzc1BvaW50PGJpZ2ludD4pID0+IFdlaWVyc3RyYXNzUG9pbnQ8YmlnaW50PjtcbiAgfTtcbiAgbGVuZ3RoczogQ3VydmVMZW5ndGhzO1xufVxuXG4vKipcbiAqIEVDRFNBIGludGVyZmFjZS5cbiAqIE9ubHkgc3VwcG9ydGVkIGZvciBwcmltZSBmaWVsZHMsIG5vdCBGcDIgKGV4dGVuc2lvbiBmaWVsZHMpLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVDRFNBIGV4dGVuZHMgRUNESCB7XG4gIHNpZ246IChtZXNzYWdlOiBIZXgsIHNlY3JldEtleTogUHJpdktleSwgb3B0cz86IEVDRFNBU2lnbk9wdHMpID0+IEVDRFNBU2lnUmVjb3ZlcmVkO1xuICB2ZXJpZnk6IChcbiAgICBzaWduYXR1cmU6IFVpbnQ4QXJyYXksXG4gICAgbWVzc2FnZTogVWludDhBcnJheSxcbiAgICBwdWJsaWNLZXk6IFVpbnQ4QXJyYXksXG4gICAgb3B0cz86IEVDRFNBVmVyaWZ5T3B0c1xuICApID0+IGJvb2xlYW47XG4gIHJlY292ZXJQdWJsaWNLZXkoc2lnbmF0dXJlOiBVaW50OEFycmF5LCBtZXNzYWdlOiBVaW50OEFycmF5LCBvcHRzPzogRUNEU0FSZWNvdmVyT3B0cyk6IFVpbnQ4QXJyYXk7XG4gIFNpZ25hdHVyZTogRUNEU0FTaWduYXR1cmVDb25zO1xufVxuZXhwb3J0IGNsYXNzIERFUkVyciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobSA9ICcnKSB7XG4gICAgc3VwZXIobSk7XG4gIH1cbn1cbmV4cG9ydCB0eXBlIElERVIgPSB7XG4gIC8vIGFzbi4xIERFUiBlbmNvZGluZyB1dGlsc1xuICBFcnI6IHR5cGVvZiBERVJFcnI7XG4gIC8vIEJhc2ljIGJ1aWxkaW5nIGJsb2NrIGlzIFRMViAoVGFnLUxlbmd0aC1WYWx1ZSlcbiAgX3Rsdjoge1xuICAgIGVuY29kZTogKHRhZzogbnVtYmVyLCBkYXRhOiBzdHJpbmcpID0+IHN0cmluZztcbiAgICAvLyB2IC0gdmFsdWUsIGwgLSBsZWZ0IGJ5dGVzICh1bnBhcnNlZClcbiAgICBkZWNvZGUodGFnOiBudW1iZXIsIGRhdGE6IFVpbnQ4QXJyYXkpOiB7IHY6IFVpbnQ4QXJyYXk7IGw6IFVpbnQ4QXJyYXkgfTtcbiAgfTtcbiAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICBfaW50OiB7XG4gICAgZW5jb2RlKG51bTogYmlnaW50KTogc3RyaW5nO1xuICAgIGRlY29kZShkYXRhOiBVaW50OEFycmF5KTogYmlnaW50O1xuICB9O1xuICB0b1NpZyhoZXg6IHN0cmluZyB8IFVpbnQ4QXJyYXkpOiB7IHI6IGJpZ2ludDsgczogYmlnaW50IH07XG4gIGhleEZyb21TaWcoc2lnOiB7IHI6IGJpZ2ludDsgczogYmlnaW50IH0pOiBzdHJpbmc7XG59O1xuLyoqXG4gKiBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzLiBBU04gaXMgdmVyeSBjb21wbGV4ICYgZnJhZ2lsZS4gRm9ybWF0OlxuICpcbiAqICAgICBbMHgzMCAoU0VRVUVOQ0UpLCBieXRlbGVuZ3RoLCAweDAyIChJTlRFR0VSKSwgaW50TGVuZ3RoLCBSLCAweDAyIChJTlRFR0VSKSwgaW50TGVuZ3RoLCBTXVxuICpcbiAqIERvY3M6IGh0dHBzOi8vbGV0c2VuY3J5cHQub3JnL2RvY3MvYS13YXJtLXdlbGNvbWUtdG8tYXNuMS1hbmQtZGVyLywgaHR0cHM6Ly9sdWNhLm50b3Aub3JnL1RlYWNoaW5nL0FwcHVudGkvYXNuMS5odG1sXG4gKi9cbmV4cG9ydCBjb25zdCBERVI6IElERVIgPSB7XG4gIC8vIGFzbi4xIERFUiBlbmNvZGluZyB1dGlsc1xuICBFcnI6IERFUkVycixcbiAgLy8gQmFzaWMgYnVpbGRpbmcgYmxvY2sgaXMgVExWIChUYWctTGVuZ3RoLVZhbHVlKVxuICBfdGx2OiB7XG4gICAgZW5jb2RlOiAodGFnOiBudW1iZXIsIGRhdGE6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgaWYgKHRhZyA8IDAgfHwgdGFnID4gMjU2KSB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogd3JvbmcgdGFnJyk7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggJiAxKSB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogdW5wYWRkZWQgZGF0YScpO1xuICAgICAgY29uc3QgZGF0YUxlbiA9IGRhdGEubGVuZ3RoIC8gMjtcbiAgICAgIGNvbnN0IGxlbiA9IG51bWJlclRvSGV4VW5wYWRkZWQoZGF0YUxlbik7XG4gICAgICBpZiAoKGxlbi5sZW5ndGggLyAyKSAmIDBiMTAwMF8wMDAwKSB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogbG9uZyBmb3JtIGxlbmd0aCB0b28gYmlnJyk7XG4gICAgICAvLyBsZW5ndGggb2YgbGVuZ3RoIHdpdGggbG9uZyBmb3JtIGZsYWdcbiAgICAgIGNvbnN0IGxlbkxlbiA9IGRhdGFMZW4gPiAxMjcgPyBudW1iZXJUb0hleFVucGFkZGVkKChsZW4ubGVuZ3RoIC8gMikgfCAwYjEwMDBfMDAwMCkgOiAnJztcbiAgICAgIGNvbnN0IHQgPSBudW1iZXJUb0hleFVucGFkZGVkKHRhZyk7XG4gICAgICByZXR1cm4gdCArIGxlbkxlbiArIGxlbiArIGRhdGE7XG4gICAgfSxcbiAgICAvLyB2IC0gdmFsdWUsIGwgLSBsZWZ0IGJ5dGVzICh1bnBhcnNlZClcbiAgICBkZWNvZGUodGFnOiBudW1iZXIsIGRhdGE6IFVpbnQ4QXJyYXkpOiB7IHY6IFVpbnQ4QXJyYXk7IGw6IFVpbnQ4QXJyYXkgfSB7XG4gICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICBpZiAodGFnIDwgMCB8fCB0YWcgPiAyNTYpIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiB3cm9uZyB0YWcnKTtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVtwb3MrK10gIT09IHRhZykgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IHdyb25nIHRsdicpO1xuICAgICAgY29uc3QgZmlyc3QgPSBkYXRhW3BvcysrXTtcbiAgICAgIGNvbnN0IGlzTG9uZyA9ICEhKGZpcnN0ICYgMGIxMDAwXzAwMDApOyAvLyBGaXJzdCBiaXQgb2YgZmlyc3QgbGVuZ3RoIGJ5dGUgaXMgZmxhZyBmb3Igc2hvcnQvbG9uZyBmb3JtXG4gICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgIGlmICghaXNMb25nKSBsZW5ndGggPSBmaXJzdDtcbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBMb25nIGZvcm06IFtsb25nRmxhZygxYml0KSwgbGVuZ3RoTGVuZ3RoKDdiaXQpLCBsZW5ndGggKEJFKV1cbiAgICAgICAgY29uc3QgbGVuTGVuID0gZmlyc3QgJiAwYjAxMTFfMTExMTtcbiAgICAgICAgaWYgKCFsZW5MZW4pIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBpbmRlZmluaXRlIGxlbmd0aCBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIGlmIChsZW5MZW4gPiA0KSB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogYnl0ZSBsZW5ndGggaXMgdG9vIGJpZycpOyAvLyB0aGlzIHdpbGwgb3ZlcmZsb3cgdTMyIGluIGpzXG4gICAgICAgIGNvbnN0IGxlbmd0aEJ5dGVzID0gZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIGxlbkxlbik7XG4gICAgICAgIGlmIChsZW5ndGhCeXRlcy5sZW5ndGggIT09IGxlbkxlbikgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IGxlbmd0aCBieXRlcyBub3QgY29tcGxldGUnKTtcbiAgICAgICAgaWYgKGxlbmd0aEJ5dGVzWzBdID09PSAwKSB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogemVybyBsZWZ0bW9zdCBieXRlJyk7XG4gICAgICAgIGZvciAoY29uc3QgYiBvZiBsZW5ndGhCeXRlcykgbGVuZ3RoID0gKGxlbmd0aCA8PCA4KSB8IGI7XG4gICAgICAgIHBvcyArPSBsZW5MZW47XG4gICAgICAgIGlmIChsZW5ndGggPCAxMjgpIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBub3QgbWluaW1hbCBlbmNvZGluZycpO1xuICAgICAgfVxuICAgICAgY29uc3QgdiA9IGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyBsZW5ndGgpO1xuICAgICAgaWYgKHYubGVuZ3RoICE9PSBsZW5ndGgpIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlOiB3cm9uZyB2YWx1ZSBsZW5ndGgnKTtcbiAgICAgIHJldHVybiB7IHYsIGw6IGRhdGEuc3ViYXJyYXkocG9zICsgbGVuZ3RoKSB9O1xuICAgIH0sXG4gIH0sXG4gIC8vIGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL2EvNTc3MzQgTGVmdG1vc3QgYml0IG9mIGZpcnN0IGJ5dGUgaXMgJ25lZ2F0aXZlJyBmbGFnLFxuICAvLyBzaW5jZSB3ZSBhbHdheXMgdXNlIHBvc2l0aXZlIGludGVnZXJzIGhlcmUuIEl0IG11c3QgYWx3YXlzIGJlIGVtcHR5OlxuICAvLyAtIGFkZCB6ZXJvIGJ5dGUgaWYgZXhpc3RzXG4gIC8vIC0gaWYgbmV4dCBieXRlIGRvZXNuJ3QgaGF2ZSBhIGZsYWcsIGxlYWRpbmcgemVybyBpcyBub3QgYWxsb3dlZCAobWluaW1hbCBlbmNvZGluZylcbiAgX2ludDoge1xuICAgIGVuY29kZShudW06IGJpZ2ludCk6IHN0cmluZyB7XG4gICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgaWYgKG51bSA8IF8wbikgdGhyb3cgbmV3IEUoJ2ludGVnZXI6IG5lZ2F0aXZlIGludGVnZXJzIGFyZSBub3QgYWxsb3dlZCcpO1xuICAgICAgbGV0IGhleCA9IG51bWJlclRvSGV4VW5wYWRkZWQobnVtKTtcbiAgICAgIC8vIFBhZCB3aXRoIHplcm8gYnl0ZSBpZiBuZWdhdGl2ZSBmbGFnIGlzIHByZXNlbnRcbiAgICAgIGlmIChOdW1iZXIucGFyc2VJbnQoaGV4WzBdLCAxNikgJiAwYjEwMDApIGhleCA9ICcwMCcgKyBoZXg7XG4gICAgICBpZiAoaGV4Lmxlbmd0aCAmIDEpIHRocm93IG5ldyBFKCd1bmV4cGVjdGVkIERFUiBwYXJzaW5nIGFzc2VydGlvbjogdW5wYWRkZWQgaGV4Jyk7XG4gICAgICByZXR1cm4gaGV4O1xuICAgIH0sXG4gICAgZGVjb2RlKGRhdGE6IFVpbnQ4QXJyYXkpOiBiaWdpbnQge1xuICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgIGlmIChkYXRhWzBdICYgMGIxMDAwXzAwMDApIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgaWYgKGRhdGFbMF0gPT09IDB4MDAgJiYgIShkYXRhWzFdICYgMGIxMDAwXzAwMDApKVxuICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICByZXR1cm4gYnl0ZXNUb051bWJlckJFKGRhdGEpO1xuICAgIH0sXG4gIH0sXG4gIHRvU2lnKGhleDogc3RyaW5nIHwgVWludDhBcnJheSk6IHsgcjogYmlnaW50OyBzOiBiaWdpbnQgfSB7XG4gICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgIGNvbnN0IHsgRXJyOiBFLCBfaW50OiBpbnQsIF90bHY6IHRsdiB9ID0gREVSO1xuICAgIGNvbnN0IGRhdGEgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgaGV4KTtcbiAgICBjb25zdCB7IHY6IHNlcUJ5dGVzLCBsOiBzZXFMZWZ0Qnl0ZXMgfSA9IHRsdi5kZWNvZGUoMHgzMCwgZGF0YSk7XG4gICAgaWYgKHNlcUxlZnRCeXRlcy5sZW5ndGgpIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgY29uc3QgeyB2OiByQnl0ZXMsIGw6IHJMZWZ0Qnl0ZXMgfSA9IHRsdi5kZWNvZGUoMHgwMiwgc2VxQnl0ZXMpO1xuICAgIGNvbnN0IHsgdjogc0J5dGVzLCBsOiBzTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MDIsIHJMZWZ0Qnl0ZXMpO1xuICAgIGlmIChzTGVmdEJ5dGVzLmxlbmd0aCkgdGhyb3cgbmV3IEUoJ2ludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmcnKTtcbiAgICByZXR1cm4geyByOiBpbnQuZGVjb2RlKHJCeXRlcyksIHM6IGludC5kZWNvZGUoc0J5dGVzKSB9O1xuICB9LFxuICBoZXhGcm9tU2lnKHNpZzogeyByOiBiaWdpbnQ7IHM6IGJpZ2ludCB9KTogc3RyaW5nIHtcbiAgICBjb25zdCB7IF90bHY6IHRsdiwgX2ludDogaW50IH0gPSBERVI7XG4gICAgY29uc3QgcnMgPSB0bHYuZW5jb2RlKDB4MDIsIGludC5lbmNvZGUoc2lnLnIpKTtcbiAgICBjb25zdCBzcyA9IHRsdi5lbmNvZGUoMHgwMiwgaW50LmVuY29kZShzaWcucykpO1xuICAgIGNvbnN0IHNlcSA9IHJzICsgc3M7XG4gICAgcmV0dXJuIHRsdi5lbmNvZGUoMHgzMCwgc2VxKTtcbiAgfSxcbn07XG5cbi8vIEJlIGZyaWVuZGx5IHRvIGJhZCBFQ01BU2NyaXB0IHBhcnNlcnMgYnkgbm90IHVzaW5nIGJpZ2ludCBsaXRlcmFsc1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyksIF80biA9IEJpZ0ludCg0KTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9ub3JtRm5FbGVtZW50KEZuOiBJRmllbGQ8YmlnaW50Piwga2V5OiBQcml2S2V5KTogYmlnaW50IHtcbiAgY29uc3QgeyBCWVRFUzogZXhwZWN0ZWQgfSA9IEZuO1xuICBsZXQgbnVtOiBiaWdpbnQ7XG4gIGlmICh0eXBlb2Yga2V5ID09PSAnYmlnaW50Jykge1xuICAgIG51bSA9IGtleTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgYnl0ZXMgPSBlbnN1cmVCeXRlcygncHJpdmF0ZSBrZXknLCBrZXkpO1xuICAgIHRyeSB7XG4gICAgICBudW0gPSBGbi5mcm9tQnl0ZXMoYnl0ZXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgcHJpdmF0ZSBrZXk6IGV4cGVjdGVkIHVpOGEgb2Ygc2l6ZSAke2V4cGVjdGVkfSwgZ290ICR7dHlwZW9mIGtleX1gKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFGbi5pc1ZhbGlkTm90MChudW0pKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJpdmF0ZSBrZXk6IG91dCBvZiByYW5nZSBbMS4uTi0xXScpO1xuICByZXR1cm4gbnVtO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgd2VpZXJzdHJhc3MgUG9pbnQgY29uc3RydWN0b3IsIGJhc2VkIG9uIHNwZWNpZmllZCBjdXJ2ZSBvcHRpb25zLlxuICpcbiAqIEBleGFtcGxlXG5gYGBqc1xuY29uc3Qgb3B0cyA9IHtcbiAgcDogQmlnSW50KCcweGZmZmZmZmZmMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYnKSxcbiAgbjogQmlnSW50KCcweGZmZmZmZmZmMDAwMDAwMDBmZmZmZmZmZmZmZmZmZmZmYmNlNmZhYWRhNzE3OWU4NGYzYjljYWMyZmM2MzI1NTEnKSxcbiAgaDogQmlnSW50KDEpLFxuICBhOiBCaWdJbnQoJzB4ZmZmZmZmZmYwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYycpLFxuICBiOiBCaWdJbnQoJzB4NWFjNjM1ZDhhYTNhOTNlN2IzZWJiZDU1NzY5ODg2YmM2NTFkMDZiMGNjNTNiMGY2M2JjZTNjM2UyN2QyNjA0YicpLFxuICBHeDogQmlnSW50KCcweDZiMTdkMWYyZTEyYzQyNDdmOGJjZTZlNTYzYTQ0MGYyNzcwMzdkODEyZGViMzNhMGY0YTEzOTQ1ZDg5OGMyOTYnKSxcbiAgR3k6IEJpZ0ludCgnMHg0ZmUzNDJlMmZlMWE3ZjliOGVlN2ViNGE3YzBmOWUxNjJiY2UzMzU3NmIzMTVlY2VjYmI2NDA2ODM3YmY1MWY1JyksXG59O1xuY29uc3QgcDI1Nl9Qb2ludCA9IHdlaWVyc3RyYXNzKG9wdHMpO1xuYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3ZWllcnN0cmFzc048VD4oXG4gIHBhcmFtczogV2VpZXJzdHJhc3NPcHRzPFQ+LFxuICBleHRyYU9wdHM6IFdlaWVyc3RyYXNzRXh0cmFPcHRzPFQ+ID0ge31cbik6IFdlaWVyc3RyYXNzUG9pbnRDb25zPFQ+IHtcbiAgY29uc3QgdmFsaWRhdGVkID0gX2NyZWF0ZUN1cnZlRmllbGRzKCd3ZWllcnN0cmFzcycsIHBhcmFtcywgZXh0cmFPcHRzKTtcbiAgY29uc3QgeyBGcCwgRm4gfSA9IHZhbGlkYXRlZDtcbiAgbGV0IENVUlZFID0gdmFsaWRhdGVkLkNVUlZFIGFzIFdlaWVyc3RyYXNzT3B0czxUPjtcbiAgY29uc3QgeyBoOiBjb2ZhY3RvciwgbjogQ1VSVkVfT1JERVIgfSA9IENVUlZFO1xuICBfdmFsaWRhdGVPYmplY3QoXG4gICAgZXh0cmFPcHRzLFxuICAgIHt9LFxuICAgIHtcbiAgICAgIGFsbG93SW5maW5pdHlQb2ludDogJ2Jvb2xlYW4nLFxuICAgICAgY2xlYXJDb2ZhY3RvcjogJ2Z1bmN0aW9uJyxcbiAgICAgIGlzVG9yc2lvbkZyZWU6ICdmdW5jdGlvbicsXG4gICAgICBmcm9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgZW5kbzogJ29iamVjdCcsXG4gICAgICB3cmFwUHJpdmF0ZUtleTogJ2Jvb2xlYW4nLFxuICAgIH1cbiAgKTtcblxuICBjb25zdCB7IGVuZG8gfSA9IGV4dHJhT3B0cztcbiAgaWYgKGVuZG8pIHtcbiAgICAvLyB2YWxpZGF0ZU9iamVjdChlbmRvLCB7IGJldGE6ICdiaWdpbnQnLCBzcGxpdFNjYWxhcjogJ2Z1bmN0aW9uJyB9KTtcbiAgICBpZiAoIUZwLmlzMChDVVJWRS5hKSB8fCB0eXBlb2YgZW5kby5iZXRhICE9PSAnYmlnaW50JyB8fCAhQXJyYXkuaXNBcnJheShlbmRvLmJhc2lzZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZW5kbzogZXhwZWN0ZWQgXCJiZXRhXCI6IGJpZ2ludCBhbmQgXCJiYXNpc2VzXCI6IGFycmF5Jyk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbGVuZ3RocyA9IGdldFdMZW5ndGhzKEZwLCBGbik7XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Q29tcHJlc3Npb25Jc1N1cHBvcnRlZCgpIHtcbiAgICBpZiAoIUZwLmlzT2RkKSB0aHJvdyBuZXcgRXJyb3IoJ2NvbXByZXNzaW9uIGlzIG5vdCBzdXBwb3J0ZWQ6IEZpZWxkIGRvZXMgbm90IGhhdmUgLmlzT2RkKCknKTtcbiAgfVxuXG4gIC8vIEltcGxlbWVudHMgSUVFRSBQMTM2MyBwb2ludCBlbmNvZGluZ1xuICBmdW5jdGlvbiBwb2ludFRvQnl0ZXMoXG4gICAgX2M6IFdlaWVyc3RyYXNzUG9pbnRDb25zPFQ+LFxuICAgIHBvaW50OiBXZWllcnN0cmFzc1BvaW50PFQ+LFxuICAgIGlzQ29tcHJlc3NlZDogYm9vbGVhblxuICApOiBVaW50OEFycmF5IHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgY29uc3QgYnggPSBGcC50b0J5dGVzKHgpO1xuICAgIGFib29sKGlzQ29tcHJlc3NlZCwgJ2lzQ29tcHJlc3NlZCcpO1xuICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgIGFzc2VydENvbXByZXNzaW9uSXNTdXBwb3J0ZWQoKTtcbiAgICAgIGNvbnN0IGhhc0V2ZW5ZID0gIUZwLmlzT2RkISh5KTtcbiAgICAgIHJldHVybiBjb25jYXRCeXRlcyhwcHJlZml4KGhhc0V2ZW5ZKSwgYngpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoVWludDhBcnJheS5vZigweDA0KSwgYngsIEZwLnRvQnl0ZXMoeSkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwb2ludEZyb21CeXRlcyhieXRlczogVWludDhBcnJheSkge1xuICAgIGFieXRlcyhieXRlcywgdW5kZWZpbmVkLCAnUG9pbnQnKTtcbiAgICBjb25zdCB7IHB1YmxpY0tleTogY29tcCwgcHVibGljS2V5VW5jb21wcmVzc2VkOiB1bmNvbXAgfSA9IGxlbmd0aHM7IC8vIGUuZy4gZm9yIDMyLWJ5dGU6IDMzLCA2NVxuICAgIGNvbnN0IGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgICBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgIC8vIE5vIGFjdHVhbCB2YWxpZGF0aW9uIGlzIGRvbmUgaGVyZTogdXNlIC5hc3NlcnRWYWxpZGl0eSgpXG4gICAgaWYgKGxlbmd0aCA9PT0gY29tcCAmJiAoaGVhZCA9PT0gMHgwMiB8fCBoZWFkID09PSAweDAzKSkge1xuICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsKTtcbiAgICAgIGlmICghRnAuaXNWYWxpZCh4KSkgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGlzIG5vdCBvbiBjdXJ2ZSwgd3JvbmcgeCcpO1xuICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5XHUwMEIyID0geFx1MDBCMyArIGF4ICsgYlxuICAgICAgbGV0IHk6IFQ7XG4gICAgICB0cnkge1xuICAgICAgICB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5XHUwMEIyIF4gKHArMSkvNFxuICAgICAgfSBjYXRjaCAoc3FydEVycm9yKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IHNxcnRFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gJzogJyArIHNxcnRFcnJvci5tZXNzYWdlIDogJyc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBpcyBub3Qgb24gY3VydmUsIHNxcnQgZXJyb3InICsgZXJyKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydENvbXByZXNzaW9uSXNTdXBwb3J0ZWQoKTtcbiAgICAgIGNvbnN0IGlzWU9kZCA9IEZwLmlzT2RkISh5KTsgLy8gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxOyAvLyBFQ0RTQS1zcGVjaWZpY1xuICAgICAgaWYgKGlzSGVhZE9kZCAhPT0gaXNZT2RkKSB5ID0gRnAubmVnKHkpO1xuICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmNvbXAgJiYgaGVhZCA9PT0gMHgwNCkge1xuICAgICAgLy8gVE9ETzogbW9yZSBjaGVja3NcbiAgICAgIGNvbnN0IEwgPSBGcC5CWVRFUztcbiAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBMKSk7XG4gICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoTCwgTCAqIDIpKTtcbiAgICAgIGlmICghaXNWYWxpZFhZKHgsIHkpKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGJhZCBwb2ludDogZ290IGxlbmd0aCAke2xlbmd0aH0sIGV4cGVjdGVkIGNvbXByZXNzZWQ9JHtjb21wfSBvciB1bmNvbXByZXNzZWQ9JHt1bmNvbXB9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBlbmNvZGVQb2ludCA9IGV4dHJhT3B0cy50b0J5dGVzIHx8IHBvaW50VG9CeXRlcztcbiAgY29uc3QgZGVjb2RlUG9pbnQgPSBleHRyYU9wdHMuZnJvbUJ5dGVzIHx8IHBvaW50RnJvbUJ5dGVzO1xuICBmdW5jdGlvbiB3ZWllcnN0cmFzc0VxdWF0aW9uKHg6IFQpOiBUIHtcbiAgICBjb25zdCB4MiA9IEZwLnNxcih4KTsgLy8geCAqIHhcbiAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHhcdTAwQjIgKiB4XG4gICAgcmV0dXJuIEZwLmFkZChGcC5hZGQoeDMsIEZwLm11bCh4LCBDVVJWRS5hKSksIENVUlZFLmIpOyAvLyB4XHUwMEIzICsgYSAqIHggKyBiXG4gIH1cblxuICAvLyBUT0RPOiBtb3ZlIHRvcC1sZXZlbFxuICAvKiogQ2hlY2tzIHdoZXRoZXIgZXF1YXRpb24gaG9sZHMgZm9yIGdpdmVuIHgsIHk6IHlcdTAwQjIgPT0geFx1MDBCMyArIGF4ICsgYiAqL1xuICBmdW5jdGlvbiBpc1ZhbGlkWFkoeDogVCwgeTogVCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGxlZnQgPSBGcC5zcXIoeSk7IC8vIHlcdTAwQjJcbiAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHhcdTAwQjMgKyBheCArIGJcbiAgICByZXR1cm4gRnAuZXFsKGxlZnQsIHJpZ2h0KTtcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAvLyBUZXN0IDE6IGVxdWF0aW9uIHlcdTAwQjIgPSB4XHUwMEIzICsgYXggKyBiIHNob3VsZCB3b3JrIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gIGlmICghaXNWYWxpZFhZKENVUlZFLkd4LCBDVVJWRS5HeSkpIHRocm93IG5ldyBFcnJvcignYmFkIGN1cnZlIHBhcmFtczogZ2VuZXJhdG9yIHBvaW50Jyk7XG5cbiAgLy8gVGVzdCAyOiBkaXNjcmltaW5hbnQgXHUwMzk0IHBhcnQgc2hvdWxkIGJlIG5vbi16ZXJvOiA0YVx1MDBCMyArIDI3Ylx1MDBCMiAhPSAwLlxuICAvLyBHdWFyYW50ZWVzIGN1cnZlIGlzIGdlbnVzLTEsIHNtb290aCAobm9uLXNpbmd1bGFyKS5cbiAgY29uc3QgXzRhMyA9IEZwLm11bChGcC5wb3coQ1VSVkUuYSwgXzNuKSwgXzRuKTtcbiAgY29uc3QgXzI3YjIgPSBGcC5tdWwoRnAuc3FyKENVUlZFLmIpLCBCaWdJbnQoMjcpKTtcbiAgaWYgKEZwLmlzMChGcC5hZGQoXzRhMywgXzI3YjIpKSkgdGhyb3cgbmV3IEVycm9yKCdiYWQgY3VydmUgcGFyYW1zOiBhIG9yIGInKTtcblxuICAvKiogQXNzZXJ0cyBjb29yZGluYXRlIGlzIHZhbGlkOiAwIDw9IG4gPCBGcC5PUkRFUi4gKi9cbiAgZnVuY3Rpb24gYWNvb3JkKHRpdGxlOiBzdHJpbmcsIG46IFQsIGJhblplcm8gPSBmYWxzZSkge1xuICAgIGlmICghRnAuaXNWYWxpZChuKSB8fCAoYmFuWmVybyAmJiBGcC5pczAobikpKSB0aHJvdyBuZXcgRXJyb3IoYGJhZCBwb2ludCBjb29yZGluYXRlICR7dGl0bGV9YCk7XG4gICAgcmV0dXJuIG47XG4gIH1cblxuICBmdW5jdGlvbiBhcHJqcG9pbnQob3RoZXI6IHVua25vd24pIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSkgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwbGl0RW5kb1NjYWxhck4oazogYmlnaW50KSB7XG4gICAgaWYgKCFlbmRvIHx8ICFlbmRvLmJhc2lzZXMpIHRocm93IG5ldyBFcnJvcignbm8gZW5kbycpO1xuICAgIHJldHVybiBfc3BsaXRFbmRvU2NhbGFyKGssIGVuZG8uYmFzaXNlcywgRm4uT1JERVIpO1xuICB9XG5cbiAgLy8gTWVtb2l6ZWQgdG9BZmZpbmUgLyB2YWxpZGl0eSBjaGVjay4gVGhleSBhcmUgaGVhdnkuIFBvaW50cyBhcmUgaW1tdXRhYmxlLlxuXG4gIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gIC8vIChYLCBZLCBaKSBcdTIyMEIgKHg9WC9aLCB5PVkvWilcbiAgY29uc3QgdG9BZmZpbmVNZW1vID0gbWVtb2l6ZWQoKHA6IFBvaW50LCBpej86IFQpOiBBZmZpbmVQb2ludDxUPiA9PiB7XG4gICAgY29uc3QgeyBYLCBZLCBaIH0gPSBwO1xuICAgIC8vIEZhc3QtcGF0aCBmb3Igbm9ybWFsaXplZCBwb2ludHNcbiAgICBpZiAoRnAuZXFsKFosIEZwLk9ORSkpIHJldHVybiB7IHg6IFgsIHk6IFkgfTtcbiAgICBjb25zdCBpczAgPSBwLmlzMCgpO1xuICAgIC8vIElmIGludlogd2FzIDAsIHdlIHJldHVybiB6ZXJvIHBvaW50LiBIb3dldmVyIHdlIHN0aWxsIHdhbnQgdG8gZXhlY3V0ZVxuICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgaWYgKGl6ID09IG51bGwpIGl6ID0gaXMwID8gRnAuT05FIDogRnAuaW52KFopO1xuICAgIGNvbnN0IHggPSBGcC5tdWwoWCwgaXopO1xuICAgIGNvbnN0IHkgPSBGcC5tdWwoWSwgaXopO1xuICAgIGNvbnN0IHp6ID0gRnAubXVsKFosIGl6KTtcbiAgICBpZiAoaXMwKSByZXR1cm4geyB4OiBGcC5aRVJPLCB5OiBGcC5aRVJPIH07XG4gICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgIHJldHVybiB7IHgsIHkgfTtcbiAgfSk7XG4gIC8vIE5PVEU6IG9uIGV4Y2VwdGlvbiB0aGlzIHdpbGwgY3Jhc2ggJ2NhY2hlZCcgYW5kIG5vIHZhbHVlIHdpbGwgYmUgc2V0LlxuICAvLyBPdGhlcndpc2UgdHJ1ZSB3aWxsIGJlIHJldHVyblxuICBjb25zdCBhc3NlcnRWYWxpZE1lbW8gPSBtZW1vaXplZCgocDogUG9pbnQpID0+IHtcbiAgICBpZiAocC5pczAoKSkge1xuICAgICAgLy8gKDAsIDEsIDApIGFrYSBaRVJPIGlzIGludmFsaWQgaW4gbW9zdCBjb250ZXh0cy5cbiAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAvLyAoMCwgMCwgMCkgaXMgaW52YWxpZCByZXByZXNlbnRhdGlvbiBvZiBaRVJPLlxuICAgICAgaWYgKGV4dHJhT3B0cy5hbGxvd0luZmluaXR5UG9pbnQgJiYgIUZwLmlzMChwLlkpKSByZXR1cm47XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogWkVSTycpO1xuICAgIH1cbiAgICAvLyBTb21lIDNyZC1wYXJ0eSB0ZXN0IHZlY3RvcnMgcmVxdWlyZSBkaWZmZXJlbnQgd29yZGluZyBiZXR3ZWVuIGhlcmUgJiBgZnJvbUNvbXByZXNzZWRIZXhgXG4gICAgY29uc3QgeyB4LCB5IH0gPSBwLnRvQWZmaW5lKCk7XG4gICAgaWYgKCFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeCBvciB5IG5vdCBmaWVsZCBlbGVtZW50cycpO1xuICAgIGlmICghaXNWYWxpZFhZKHgsIHkpKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgIGlmICghcC5pc1RvcnNpb25GcmVlKCkpIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZmluaXNoRW5kbyhcbiAgICBlbmRvQmV0YTogRW5kb21vcnBoaXNtT3B0c1snYmV0YSddLFxuICAgIGsxcDogUG9pbnQsXG4gICAgazJwOiBQb2ludCxcbiAgICBrMW5lZzogYm9vbGVhbixcbiAgICBrMm5lZzogYm9vbGVhblxuICApIHtcbiAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5YLCBlbmRvQmV0YSksIGsycC5ZLCBrMnAuWik7XG4gICAgazFwID0gbmVnYXRlQ3QoazFuZWcsIGsxcCk7XG4gICAgazJwID0gbmVnYXRlQ3QoazJuZWcsIGsycCk7XG4gICAgcmV0dXJuIGsxcC5hZGQoazJwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOihYLCBZLCBaKSBcdTIyMEIgKHg9WC9aLCB5PVkvWikuXG4gICAqIERlZmF1bHQgUG9pbnQgd29ya3MgaW4gMmQgLyBhZmZpbmUgY29vcmRpbmF0ZXM6ICh4LCB5KS5cbiAgICogV2UncmUgZG9pbmcgY2FsY3VsYXRpb25zIGluIHByb2plY3RpdmUsIGJlY2F1c2UgaXRzIG9wZXJhdGlvbnMgZG9uJ3QgcmVxdWlyZSBjb3N0bHkgaW52ZXJzaW9uLlxuICAgKi9cbiAgY2xhc3MgUG9pbnQgaW1wbGVtZW50cyBXZWllcnN0cmFzc1BvaW50PFQ+IHtcbiAgICAvLyBiYXNlIC8gZ2VuZXJhdG9yIHBvaW50XG4gICAgc3RhdGljIHJlYWRvbmx5IEJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIC8vIHplcm8gLyBpbmZpbml0eSAvIGlkZW50aXR5IHBvaW50XG4gICAgc3RhdGljIHJlYWRvbmx5IFpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTsgLy8gMCwgMSwgMFxuICAgIC8vIG1hdGggZmllbGRcbiAgICBzdGF0aWMgcmVhZG9ubHkgRnAgPSBGcDtcbiAgICAvLyBzY2FsYXIgZmllbGRcbiAgICBzdGF0aWMgcmVhZG9ubHkgRm4gPSBGbjtcblxuICAgIHJlYWRvbmx5IFg6IFQ7XG4gICAgcmVhZG9ubHkgWTogVDtcbiAgICByZWFkb25seSBaOiBUO1xuXG4gICAgLyoqIERvZXMgTk9UIHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyB2YWxpZC4gVXNlIGAuYXNzZXJ0VmFsaWRpdHkoKWAuICovXG4gICAgY29uc3RydWN0b3IoWDogVCwgWTogVCwgWjogVCkge1xuICAgICAgdGhpcy5YID0gYWNvb3JkKCd4JywgWCk7XG4gICAgICB0aGlzLlkgPSBhY29vcmQoJ3knLCBZLCB0cnVlKTtcbiAgICAgIHRoaXMuWiA9IGFjb29yZCgneicsIFopO1xuICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgQ1VSVkUoKTogV2VpZXJzdHJhc3NPcHRzPFQ+IHtcbiAgICAgIHJldHVybiBDVVJWRTtcbiAgICB9XG5cbiAgICAvKiogRG9lcyBOT1QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIHZhbGlkLiBVc2UgYC5hc3NlcnRWYWxpZGl0eSgpYC4gKi9cbiAgICBzdGF0aWMgZnJvbUFmZmluZShwOiBBZmZpbmVQb2ludDxUPik6IFBvaW50IHtcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcbiAgICAgIGlmICghcCB8fCAhRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludCkgdGhyb3cgbmV3IEVycm9yKCdwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAvLyAoMCwgMCkgd291bGQndmUgcHJvZHVjZWQgKDAsIDAsIDEpIC0gaW5zdGVhZCwgd2UgbmVlZCAoMCwgMSwgMClcbiAgICAgIGlmIChGcC5pczAoeCkgJiYgRnAuaXMwKHkpKSByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzOiBVaW50OEFycmF5KTogUG9pbnQge1xuICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUoZGVjb2RlUG9pbnQoYWJ5dGVzKGJ5dGVzLCB1bmRlZmluZWQsICdwb2ludCcpKSk7XG4gICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICByZXR1cm4gUDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21IZXgoaGV4OiBIZXgpOiBQb2ludCB7XG4gICAgICByZXR1cm4gUG9pbnQuZnJvbUJ5dGVzKGVuc3VyZUJ5dGVzKCdwb2ludEhleCcsIGhleCkpO1xuICAgIH1cblxuICAgIGdldCB4KCk6IFQge1xuICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgIH1cbiAgICBnZXQgeSgpOiBUIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aW5kb3dTaXplXG4gICAgICogQHBhcmFtIGlzTGF6eSB0cnVlIHdpbGwgZGVmZXIgdGFibGUgY29tcHV0YXRpb24gdW50aWwgdGhlIGZpcnN0IG11bHRpcGxpY2F0aW9uXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBwcmVjb21wdXRlKHdpbmRvd1NpemU6IG51bWJlciA9IDgsIGlzTGF6eSA9IHRydWUpOiBQb2ludCB7XG4gICAgICB3bmFmLmNyZWF0ZUNhY2hlKHRoaXMsIHdpbmRvd1NpemUpO1xuICAgICAgaWYgKCFpc0xhenkpIHRoaXMubXVsdGlwbHkoXzNuKTsgLy8gcmFuZG9tIG51bWJlclxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmV0dXJuIGB0aGlzYFxuICAgIC8qKiBBIHBvaW50IG9uIGN1cnZlIGlzIHZhbGlkIGlmIGl0IGNvbmZvcm1zIHRvIGVxdWF0aW9uLiAqL1xuICAgIGFzc2VydFZhbGlkaXR5KCk6IHZvaWQge1xuICAgICAgYXNzZXJ0VmFsaWRNZW1vKHRoaXMpO1xuICAgIH1cblxuICAgIGhhc0V2ZW5ZKCk6IGJvb2xlYW4ge1xuICAgICAgY29uc3QgeyB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICBpZiAoIUZwLmlzT2RkKSB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICByZXR1cm4gIUZwLmlzT2RkKHkpO1xuICAgIH1cblxuICAgIC8qKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLiAqL1xuICAgIGVxdWFscyhvdGhlcjogUG9pbnQpOiBib29sZWFuIHtcbiAgICAgIGFwcmpwb2ludChvdGhlcik7XG4gICAgICBjb25zdCB7IFg6IFgxLCBZOiBZMSwgWjogWjEgfSA9IHRoaXM7XG4gICAgICBjb25zdCB7IFg6IFgyLCBZOiBZMiwgWjogWjIgfSA9IG90aGVyO1xuICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgfVxuXG4gICAgLyoqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLiAqL1xuICAgIG5lZ2F0ZSgpOiBQb2ludCB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuWCwgRnAubmVnKHRoaXMuWSksIHRoaXMuWik7XG4gICAgfVxuXG4gICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgIGRvdWJsZSgpIHtcbiAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICBjb25zdCBiMyA9IEZwLm11bChiLCBfM24pO1xuICAgICAgY29uc3QgeyBYOiBYMSwgWTogWTEsIFo6IFoxIH0gPSB0aGlzO1xuICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMSk7IC8vIHN0ZXAgMVxuICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMSk7XG4gICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoxKTtcbiAgICAgIGxldCB0MyA9IEZwLm11bChYMSwgWTEpO1xuICAgICAgdDMgPSBGcC5hZGQodDMsIHQzKTsgLy8gc3RlcCA1XG4gICAgICBaMyA9IEZwLm11bChYMSwgWjEpO1xuICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgIFgzID0gRnAubXVsKGEsIFozKTtcbiAgICAgIFkzID0gRnAubXVsKGIzLCB0Mik7XG4gICAgICBZMyA9IEZwLmFkZChYMywgWTMpOyAvLyBzdGVwIDEwXG4gICAgICBYMyA9IEZwLnN1Yih0MSwgWTMpO1xuICAgICAgWTMgPSBGcC5hZGQodDEsIFkzKTtcbiAgICAgIFkzID0gRnAubXVsKFgzLCBZMyk7XG4gICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgWjMgPSBGcC5tdWwoYjMsIFozKTsgLy8gc3RlcCAxNVxuICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgdDMgPSBGcC5zdWIodDAsIHQyKTtcbiAgICAgIHQzID0gRnAubXVsKGEsIHQzKTtcbiAgICAgIHQzID0gRnAuYWRkKHQzLCBaMyk7XG4gICAgICBaMyA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDIwXG4gICAgICB0MCA9IEZwLmFkZChaMywgdDApO1xuICAgICAgdDAgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgIHQwID0gRnAubXVsKHQwLCB0Myk7XG4gICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgdDIgPSBGcC5tdWwoWTEsIFoxKTsgLy8gc3RlcCAyNVxuICAgICAgdDIgPSBGcC5hZGQodDIsIHQyKTtcbiAgICAgIHQwID0gRnAubXVsKHQyLCB0Myk7XG4gICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgWjMgPSBGcC5tdWwodDIsIHQxKTtcbiAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7IC8vIHN0ZXAgMzBcbiAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgIH1cblxuICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBhZGRpdGlvbiBmb3JtdWxhLlxuICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgLy8gQ29zdDogMTJNICsgMFMgKyAzKmEgKyAzKmIzICsgMjNhZGQuXG4gICAgYWRkKG90aGVyOiBQb2ludCk6IFBvaW50IHtcbiAgICAgIGFwcmpwb2ludChvdGhlcik7XG4gICAgICBjb25zdCB7IFg6IFgxLCBZOiBZMSwgWjogWjEgfSA9IHRoaXM7XG4gICAgICBjb25zdCB7IFg6IFgyLCBZOiBZMiwgWjogWjIgfSA9IG90aGVyO1xuICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgY29uc3QgYSA9IENVUlZFLmE7XG4gICAgICBjb25zdCBiMyA9IEZwLm11bChDVVJWRS5iLCBfM24pO1xuICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxuICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XG4gICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoyKTtcbiAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xuICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7IC8vIHN0ZXAgNVxuICAgICAgdDMgPSBGcC5tdWwodDMsIHQ0KTtcbiAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XG4gICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuICAgICAgdDQgPSBGcC5hZGQoWDEsIFoxKTtcbiAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXG4gICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xuICAgICAgdDUgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XG4gICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xuICAgICAgWDMgPSBGcC5hZGQoWTIsIFoyKTsgLy8gc3RlcCAxNVxuICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcbiAgICAgIFgzID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICB0NSA9IEZwLnN1Yih0NSwgWDMpO1xuICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xuICAgICAgWDMgPSBGcC5tdWwoYjMsIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgWjMgPSBGcC5hZGQoWDMsIFozKTtcbiAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XG4gICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuICAgICAgWTMgPSBGcC5tdWwoWDMsIFozKTtcbiAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcbiAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XG4gICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xuICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgIHQyID0gRnAuc3ViKHQwLCB0Mik7IC8vIHN0ZXAgMzBcbiAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgIHQ0ID0gRnAuYWRkKHQ0LCB0Mik7XG4gICAgICB0MCA9IEZwLm11bCh0MSwgdDQpO1xuICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgIHQwID0gRnAubXVsKHQ1LCB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcbiAgICAgIFozID0gRnAubXVsKHQ1LCBaMyk7XG4gICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXG4gICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgIH1cblxuICAgIHN1YnRyYWN0KG90aGVyOiBQb2ludCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0ZSgpKTtcbiAgICB9XG5cbiAgICBpczAoKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gdGhpcy5lcXVhbHMoUG9pbnQuWkVSTyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RhbnQgdGltZSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgKiBVc2VzIHdOQUYgbWV0aG9kLiBXaW5kb3dlZCBtZXRob2QgbWF5IGJlIDEwJSBmYXN0ZXIsXG4gICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAqIFVzZXMgcHJlY29tcHV0ZXMgd2hlbiBhdmFpbGFibGUuXG4gICAgICogVXNlcyBlbmRvbW9ycGhpc20gZm9yIEtvYmxpdHogY3VydmVzLlxuICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgKiBAcmV0dXJucyBOZXcgcG9pbnRcbiAgICAgKi9cbiAgICBtdWx0aXBseShzY2FsYXI6IGJpZ2ludCk6IFBvaW50IHtcbiAgICAgIGNvbnN0IHsgZW5kbyB9ID0gZXh0cmFPcHRzO1xuICAgICAgaWYgKCFGbi5pc1ZhbGlkTm90MChzY2FsYXIpKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyOiBvdXQgb2YgcmFuZ2UnKTsgLy8gMCBpcyBpbnZhbGlkXG4gICAgICBsZXQgcG9pbnQ6IFBvaW50LCBmYWtlOiBQb2ludDsgLy8gRmFrZSBwb2ludCBpcyB1c2VkIHRvIGNvbnN0LXRpbWUgbXVsdFxuICAgICAgY29uc3QgbXVsID0gKG46IGJpZ2ludCkgPT4gd25hZi5jYWNoZWQodGhpcywgbiwgKHApID0+IG5vcm1hbGl6ZVooUG9pbnQsIHApKTtcbiAgICAgIC8qKiBTZWUgZG9jcyBmb3Ige0BsaW5rIEVuZG9tb3JwaGlzbU9wdHN9ICovXG4gICAgICBpZiAoZW5kbykge1xuICAgICAgICBjb25zdCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBzcGxpdEVuZG9TY2FsYXJOKHNjYWxhcik7XG4gICAgICAgIGNvbnN0IHsgcDogazFwLCBmOiBrMWYgfSA9IG11bChrMSk7XG4gICAgICAgIGNvbnN0IHsgcDogazJwLCBmOiBrMmYgfSA9IG11bChrMik7XG4gICAgICAgIGZha2UgPSBrMWYuYWRkKGsyZik7XG4gICAgICAgIHBvaW50ID0gZmluaXNoRW5kbyhlbmRvLmJldGEsIGsxcCwgazJwLCBrMW5lZywgazJuZWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBwLCBmIH0gPSBtdWwoc2NhbGFyKTtcbiAgICAgICAgcG9pbnQgPSBwO1xuICAgICAgICBmYWtlID0gZjtcbiAgICAgIH1cbiAgICAgIC8vIE5vcm1hbGl6ZSBgemAgZm9yIGJvdGggcG9pbnRzLCBidXQgcmV0dXJuIG9ubHkgcmVhbCBvbmVcbiAgICAgIHJldHVybiBub3JtYWxpemVaKFBvaW50LCBbcG9pbnQsIGZha2VdKVswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb24tY29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi4gVXNlcyBkb3VibGUtYW5kLWFkZCBhbGdvcml0aG0uXG4gICAgICogSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgKiBhbiBleHBvc2VkIHNlY3JldCBrZXkgZS5nLiBzaWcgdmVyaWZpY2F0aW9uLCB3aGljaCB3b3JrcyBvdmVyICpwdWJsaWMqIGtleXMuXG4gICAgICovXG4gICAgbXVsdGlwbHlVbnNhZmUoc2M6IGJpZ2ludCk6IFBvaW50IHtcbiAgICAgIGNvbnN0IHsgZW5kbyB9ID0gZXh0cmFPcHRzO1xuICAgICAgY29uc3QgcCA9IHRoaXMgYXMgUG9pbnQ7XG4gICAgICBpZiAoIUZuLmlzVmFsaWQoc2MpKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyOiBvdXQgb2YgcmFuZ2UnKTsgLy8gMCBpcyB2YWxpZFxuICAgICAgaWYgKHNjID09PSBfMG4gfHwgcC5pczAoKSkgcmV0dXJuIFBvaW50LlpFUk87XG4gICAgICBpZiAoc2MgPT09IF8xbikgcmV0dXJuIHA7IC8vIGZhc3QtcGF0aFxuICAgICAgaWYgKHduYWYuaGFzQ2FjaGUodGhpcykpIHJldHVybiB0aGlzLm11bHRpcGx5KHNjKTtcbiAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IHNwbGl0RW5kb1NjYWxhck4oc2MpO1xuICAgICAgICBjb25zdCB7IHAxLCBwMiB9ID0gbXVsRW5kb1Vuc2FmZShQb2ludCwgcCwgazEsIGsyKTsgLy8gMzAlIGZhc3RlciB2cyB3bmFmLnVuc2FmZVxuICAgICAgICByZXR1cm4gZmluaXNoRW5kbyhlbmRvLmJldGEsIHAxLCBwMiwgazFuZWcsIGsybmVnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB3bmFmLnVuc2FmZShwLCBzYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUTogUG9pbnQsIGE6IGJpZ2ludCwgYjogYmlnaW50KTogUG9pbnQgfCB1bmRlZmluZWQge1xuICAgICAgY29uc3Qgc3VtID0gdGhpcy5tdWx0aXBseVVuc2FmZShhKS5hZGQoUS5tdWx0aXBseVVuc2FmZShiKSk7XG4gICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0gaW52ZXJ0ZWRaIFpeLTEgKGludmVydGVkIHplcm8pIC0gb3B0aW9uYWwsIHByZWNvbXB1dGF0aW9uIGlzIHVzZWZ1bCBmb3IgaW52ZXJ0QmF0Y2hcbiAgICAgKi9cbiAgICB0b0FmZmluZShpbnZlcnRlZFo/OiBUKTogQWZmaW5lUG9pbnQ8VD4ge1xuICAgICAgcmV0dXJuIHRvQWZmaW5lTWVtbyh0aGlzLCBpbnZlcnRlZFopO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIFBvaW50IGlzIGZyZWUgb2YgdG9yc2lvbiBlbGVtZW50cyAoaXMgaW4gcHJpbWUgc3ViZ3JvdXApLlxuICAgICAqIEFsd2F5cyB0b3JzaW9uLWZyZWUgZm9yIGNvZmFjdG9yPTEgY3VydmVzLlxuICAgICAqL1xuICAgIGlzVG9yc2lvbkZyZWUoKTogYm9vbGVhbiB7XG4gICAgICBjb25zdCB7IGlzVG9yc2lvbkZyZWUgfSA9IGV4dHJhT3B0cztcbiAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChpc1RvcnNpb25GcmVlKSByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG4gICAgICByZXR1cm4gd25hZi51bnNhZmUodGhpcywgQ1VSVkVfT1JERVIpLmlzMCgpO1xuICAgIH1cblxuICAgIGNsZWFyQ29mYWN0b3IoKTogUG9pbnQge1xuICAgICAgY29uc3QgeyBjbGVhckNvZmFjdG9yIH0gPSBleHRyYU9wdHM7XG4gICAgICBpZiAoY29mYWN0b3IgPT09IF8xbikgcmV0dXJuIHRoaXM7IC8vIEZhc3QtcGF0aFxuICAgICAgaWYgKGNsZWFyQ29mYWN0b3IpIHJldHVybiBjbGVhckNvZmFjdG9yKFBvaW50LCB0aGlzKSBhcyBQb2ludDtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKGNvZmFjdG9yKTtcbiAgICB9XG5cbiAgICBpc1NtYWxsT3JkZXIoKTogYm9vbGVhbiB7XG4gICAgICAvLyBjYW4gd2UgdXNlIHRoaXMuY2xlYXJDb2ZhY3RvcigpP1xuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoY29mYWN0b3IpLmlzMCgpO1xuICAgIH1cblxuICAgIHRvQnl0ZXMoaXNDb21wcmVzc2VkID0gdHJ1ZSk6IFVpbnQ4QXJyYXkge1xuICAgICAgYWJvb2woaXNDb21wcmVzc2VkLCAnaXNDb21wcmVzc2VkJyk7XG4gICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICByZXR1cm4gZW5jb2RlUG9pbnQoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuXG4gICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSk6IHN0cmluZyB7XG4gICAgICByZXR1cm4gYnl0ZXNUb0hleCh0aGlzLnRvQnl0ZXMoaXNDb21wcmVzc2VkKSk7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYDxQb2ludCAke3RoaXMuaXMwKCkgPyAnWkVSTycgOiB0aGlzLnRvSGV4KCl9PmA7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlXG4gICAgZ2V0IHB4KCk6IFQge1xuICAgICAgcmV0dXJuIHRoaXMuWDtcbiAgICB9XG4gICAgZ2V0IHB5KCk6IFQge1xuICAgICAgcmV0dXJuIHRoaXMuWDtcbiAgICB9XG4gICAgZ2V0IHB6KCk6IFQge1xuICAgICAgcmV0dXJuIHRoaXMuWjtcbiAgICB9XG4gICAgdG9SYXdCeXRlcyhpc0NvbXByZXNzZWQgPSB0cnVlKTogVWludDhBcnJheSB7XG4gICAgICByZXR1cm4gdGhpcy50b0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemU6IG51bWJlcikge1xuICAgICAgdGhpcy5wcmVjb21wdXRlKHdpbmRvd1NpemUpO1xuICAgIH1cbiAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHM6IFBvaW50W10pOiBQb2ludFtdIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVaKFBvaW50LCBwb2ludHMpO1xuICAgIH1cbiAgICBzdGF0aWMgbXNtKHBvaW50czogUG9pbnRbXSwgc2NhbGFyczogYmlnaW50W10pOiBQb2ludCB7XG4gICAgICByZXR1cm4gcGlwcGVuZ2VyKFBvaW50LCBGbiwgcG9pbnRzLCBzY2FsYXJzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXk6IFByaXZLZXkpIHtcbiAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KF9ub3JtRm5FbGVtZW50KEZuLCBwcml2YXRlS2V5KSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGJpdHMgPSBGbi5CSVRTO1xuICBjb25zdCB3bmFmID0gbmV3IHdOQUYoUG9pbnQsIGV4dHJhT3B0cy5lbmRvID8gTWF0aC5jZWlsKGJpdHMgLyAyKSA6IGJpdHMpO1xuICBQb2ludC5CQVNFLnByZWNvbXB1dGUoOCk7IC8vIEVuYWJsZSBwcmVjb21wdXRlcy4gU2xvd3MgZG93biBmaXJzdCBwdWJsaWNLZXkgY29tcHV0YXRpb24gYnkgMjBtcy5cbiAgcmV0dXJuIFBvaW50O1xufVxuXG4vKiogTWV0aG9kcyBvZiBFQ0RTQSBzaWduYXR1cmUgaW5zdGFuY2UuICovXG5leHBvcnQgaW50ZXJmYWNlIEVDRFNBU2lnbmF0dXJlIHtcbiAgcmVhZG9ubHkgcjogYmlnaW50O1xuICByZWFkb25seSBzOiBiaWdpbnQ7XG4gIHJlYWRvbmx5IHJlY292ZXJ5PzogbnVtYmVyO1xuICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeTogbnVtYmVyKTogRUNEU0FTaWdSZWNvdmVyZWQ7XG4gIGhhc0hpZ2hTKCk6IGJvb2xlYW47XG4gIHRvQnl0ZXMoZm9ybWF0Pzogc3RyaW5nKTogVWludDhBcnJheTtcbiAgdG9IZXgoZm9ybWF0Pzogc3RyaW5nKTogc3RyaW5nO1xuXG4gIC8qKiBAZGVwcmVjYXRlZCAqL1xuICBhc3NlcnRWYWxpZGl0eSgpOiB2b2lkO1xuICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgbm9ybWFsaXplUygpOiBFQ0RTQVNpZ25hdHVyZTtcbiAgLyoqIEBkZXByZWNhdGVkIHVzZSBzdGFuZGFsb25lIG1ldGhvZCBgY3VydmUucmVjb3ZlclB1YmxpY0tleShzaWcudG9CeXRlcygncmVjb3ZlcmVkJyksIG1zZylgICovXG4gIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaDogSGV4KTogV2VpZXJzdHJhc3NQb2ludDxiaWdpbnQ+O1xuICAvKiogQGRlcHJlY2F0ZWQgdXNlIGAudG9CeXRlcygnY29tcGFjdCcpYCAqL1xuICB0b0NvbXBhY3RSYXdCeXRlcygpOiBVaW50OEFycmF5O1xuICAvKiogQGRlcHJlY2F0ZWQgdXNlIGAudG9CeXRlcygnY29tcGFjdCcpYCAqL1xuICB0b0NvbXBhY3RIZXgoKTogc3RyaW5nO1xuICAvKiogQGRlcHJlY2F0ZWQgdXNlIGAudG9CeXRlcygnZGVyJylgICovXG4gIHRvREVSUmF3Qnl0ZXMoKTogVWludDhBcnJheTtcbiAgLyoqIEBkZXByZWNhdGVkIHVzZSBgLnRvQnl0ZXMoJ2RlcicpYCAqL1xuICB0b0RFUkhleCgpOiBzdHJpbmc7XG59XG5leHBvcnQgdHlwZSBFQ0RTQVNpZ1JlY292ZXJlZCA9IEVDRFNBU2lnbmF0dXJlICYge1xuICByZWFkb25seSByZWNvdmVyeTogbnVtYmVyO1xufTtcbi8qKiBNZXRob2RzIG9mIEVDRFNBIHNpZ25hdHVyZSBjb25zdHJ1Y3Rvci4gKi9cbmV4cG9ydCB0eXBlIEVDRFNBU2lnbmF0dXJlQ29ucyA9IHtcbiAgbmV3IChyOiBiaWdpbnQsIHM6IGJpZ2ludCwgcmVjb3Zlcnk/OiBudW1iZXIpOiBFQ0RTQVNpZ25hdHVyZTtcbiAgZnJvbUJ5dGVzKGJ5dGVzOiBVaW50OEFycmF5LCBmb3JtYXQ/OiBFQ0RTQVNpZ0Zvcm1hdCk6IEVDRFNBU2lnbmF0dXJlO1xuICBmcm9tSGV4KGhleDogc3RyaW5nLCBmb3JtYXQ/OiBFQ0RTQVNpZ0Zvcm1hdCk6IEVDRFNBU2lnbmF0dXJlO1xuXG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgYC5mcm9tQnl0ZXMoYnl0ZXMsICdjb21wYWN0JylgICovXG4gIGZyb21Db21wYWN0KGhleDogSGV4KTogRUNEU0FTaWduYXR1cmU7XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgYC5mcm9tQnl0ZXMoYnl0ZXMsICdkZXInKWAgKi9cbiAgZnJvbURFUihoZXg6IEhleCk6IEVDRFNBU2lnbmF0dXJlO1xufTtcblxuLy8gUG9pbnRzIHN0YXJ0IHdpdGggYnl0ZSAweDAyIHdoZW4geSBpcyBldmVuOyBvdGhlcndpc2UgMHgwM1xuZnVuY3Rpb24gcHByZWZpeChoYXNFdmVuWTogYm9vbGVhbik6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gVWludDhBcnJheS5vZihoYXNFdmVuWSA/IDB4MDIgOiAweDAzKTtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2hhbGx1ZSBhbmQgdmFuIGRlIFdvZXN0aWpuZSBtZXRob2QgZm9yIGFueSB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIFRPRE86IGNoZWNrIGlmIHRoZXJlIGlzIGEgd2F5IHRvIG1lcmdlIHRoaXMgd2l0aCB1dlJhdGlvIGluIEVkd2FyZHM7IG1vdmUgdG8gbW9kdWxhci5cbiAqIGIgPSBUcnVlIGFuZCB5ID0gc3FydCh1IC8gdikgaWYgKHUgLyB2KSBpcyBzcXVhcmUgaW4gRiwgYW5kXG4gKiBiID0gRmFsc2UgYW5kIHkgPSBzcXJ0KFogKiAodSAvIHYpKSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gRnBcbiAqIEBwYXJhbSBaXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gU1dVRnBTcXJ0UmF0aW88VD4oXG4gIEZwOiBJRmllbGQ8VD4sXG4gIFo6IFRcbik6ICh1OiBULCB2OiBUKSA9PiB7IGlzVmFsaWQ6IGJvb2xlYW47IHZhbHVlOiBUIH0ge1xuICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXG4gIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgbGV0IGwgPSBfMG47XG4gIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKSBsICs9IF8xbjtcbiAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAvLyBXZSBuZWVkIDJuICoqIGMxIGFuZCAybiAqKiAoYzEtMSkuIFdlIGNhbid0IHVzZSAqKjsgYnV0IHdlIGNhbiB1c2UgPDwuXG4gIC8vIDJuICoqIGMxID09IDJuIDw8IChjMS0xKVxuICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgY29uc3QgXzJuX3Bvd19jMSA9IF8ybl9wb3dfYzFfMSAqIF8ybjtcbiAgY29uc3QgYzIgPSAocSAtIF8xbikgLyBfMm5fcG93X2MxOyAvLyAyLiBjMiA9IChxIC0gMSkgLyAoMl5jMSkgICMgSW50ZWdlciBhcml0aG1ldGljXG4gIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICBjb25zdCBjNCA9IF8ybl9wb3dfYzEgLSBfMW47IC8vIDQuIGM0ID0gMl5jMSAtIDEgICAgICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgY29uc3QgYzUgPSBfMm5fcG93X2MxXzE7IC8vIDUuIGM1ID0gMl4oYzEgLSAxKSAgICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gIGNvbnN0IGM3ID0gRnAucG93KFosIChjMiArIF8xbikgLyBfMm4pOyAvLyA3LiBjNyA9IFpeKChjMiArIDEpIC8gMilcbiAgbGV0IHNxcnRSYXRpbyA9ICh1OiBULCB2OiBUKTogeyBpc1ZhbGlkOiBib29sZWFuOyB2YWx1ZTogVCB9ID0+IHtcbiAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcbiAgICBsZXQgdHYzID0gRnAuc3FyKHR2Mik7IC8vIDMuIHR2MyA9IHR2Ml4yXG4gICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcbiAgICB0djUgPSBGcC5wb3codHY1LCBjMyk7IC8vIDYuIHR2NSA9IHR2NV5jM1xuICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XG4gICAgdHYzID0gRnAubXVsKHR2NSwgdSk7IC8vIDkuIHR2MyA9IHR2NSAqIHVcbiAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxuICAgIGxldCBpc1FSID0gRnAuZXFsKHR2NSwgRnAuT05FKTsgLy8gMTIuIGlzUVIgPSB0djUgPT0gMVxuICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxuICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGlzUVIpOyAvLyAxNS4gdHYzID0gQ01PVih0djIsIHR2MywgaXNRUilcbiAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxuICAgIGZvciAobGV0IGkgPSBjMTsgaSA+IF8xbjsgaS0tKSB7XG4gICAgICBsZXQgdHY1ID0gaSAtIF8ybjsgLy8gMTguICAgIHR2NSA9IGkgLSAyXG4gICAgICB0djUgPSBfMm4gPDwgKHR2NSAtIF8xbik7IC8vIDE5LiAgICB0djUgPSAyXnR2NVxuICAgICAgbGV0IHR2djUgPSBGcC5wb3codHY0LCB0djUpOyAvLyAyMC4gICAgdHY1ID0gdHY0XnR2NVxuICAgICAgY29uc3QgZTEgPSBGcC5lcWwodHZ2NSwgRnAuT05FKTsgLy8gMjEuICAgIGUxID0gdHY1ID09IDFcbiAgICAgIHR2MiA9IEZwLm11bCh0djMsIHR2MSk7IC8vIDIyLiAgICB0djIgPSB0djMgKiB0djFcbiAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2MSk7IC8vIDIzLiAgICB0djEgPSB0djEgKiB0djFcbiAgICAgIHR2djUgPSBGcC5tdWwodHY0LCB0djEpOyAvLyAyNC4gICAgdHY1ID0gdHY0ICogdHYxXG4gICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBlMSk7IC8vIDI1LiAgICB0djMgPSBDTU9WKHR2MiwgdHYzLCBlMSlcbiAgICAgIHR2NCA9IEZwLmNtb3YodHZ2NSwgdHY0LCBlMSk7IC8vIDI2LiAgICB0djQgPSBDTU9WKHR2NSwgdHY0LCBlMSlcbiAgICB9XG4gICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xuICB9O1xuICBpZiAoRnAuT1JERVIgJSBfNG4gPT09IF8zbikge1xuICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICBjb25zdCBjMSA9IChGcC5PUkRFUiAtIF8zbikgLyBfNG47IC8vIDEuIGMxID0gKHEgLSAzKSAvIDQgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzIgPSBGcC5zcXJ0KEZwLm5lZyhaKSk7IC8vIDIuIGMyID0gc3FydCgtWilcbiAgICBzcXJ0UmF0aW8gPSAodTogVCwgdjogVCkgPT4ge1xuICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgfTtcbiAgfVxuICAvLyBObyBjdXJ2ZXMgdXNlcyB0aGF0XG4gIC8vIGlmIChGcC5PUkRFUiAlIF84biA9PT0gXzVuKSAvLyBzcXJ0X3JhdGlvXzVtb2Q4XG4gIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVPFQ+KFxuICBGcDogSUZpZWxkPFQ+LFxuICBvcHRzOiB7XG4gICAgQTogVDtcbiAgICBCOiBUO1xuICAgIFo6IFQ7XG4gIH1cbik6ICh1OiBUKSA9PiB7IHg6IFQ7IHk6IFQgfSB7XG4gIHZhbGlkYXRlRmllbGQoRnApO1xuICBjb25zdCB7IEEsIEIsIFogfSA9IG9wdHM7XG4gIGlmICghRnAuaXNWYWxpZChBKSB8fCAhRnAuaXNWYWxpZChCKSB8fCAhRnAuaXNWYWxpZChaKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xuICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgWik7XG4gIGlmICghRnAuaXNPZGQpIHRocm93IG5ldyBFcnJvcignRmllbGQgZG9lcyBub3QgaGF2ZSAuaXNPZGQoKScpO1xuICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAvLyBPdXRwdXQ6ICh4LCB5KSwgYSBwb2ludCBvbiBFLlxuICByZXR1cm4gKHU6IFQpOiB7IHg6IFQ7IHk6IFQgfSA9PiB7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHR2MSwgdHYyLCB0djMsIHR2NCwgdHY1LCB0djYsIHgsIHk7XG4gICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgdHYxID0gRnAubXVsKHR2MSwgWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2MSk7IC8vIDQuICB0djIgPSB0djIgKyB0djFcbiAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgIHR2MyA9IEZwLm11bCh0djMsIEIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgIHR2NCA9IEZwLmNtb3YoWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgIHR2NCA9IEZwLm11bCh0djQsIEEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcbiAgICB0djYgPSBGcC5zcXIodHY0KTsgLy8gMTAuIHR2NiA9IHR2NF4yXG4gICAgdHY1ID0gRnAubXVsKHR2NiwgQSk7IC8vIDExLiB0djUgPSBBICogdHY2XG4gICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcbiAgICB0djYgPSBGcC5tdWwodHY2LCB0djQpOyAvLyAxNC4gdHY2ID0gdHY2ICogdHY0XG4gICAgdHY1ID0gRnAubXVsKHR2NiwgQik7IC8vIDE1LiB0djUgPSBCICogdHY2XG4gICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgIHggPSBGcC5tdWwodHYxLCB0djMpOyAvLyAxNy4gICB4ID0gdHYxICogdHYzXG4gICAgY29uc3QgeyBpc1ZhbGlkLCB2YWx1ZSB9ID0gc3FydFJhdGlvKHR2MiwgdHY2KTsgLy8gMTguIChpc19neDFfc3F1YXJlLCB5MSkgPSBzcXJ0X3JhdGlvKHR2MiwgdHY2KVxuICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgIHkgPSBGcC5tdWwoeSwgdmFsdWUpOyAvLyAyMC4gICB5ID0geSAqIHkxXG4gICAgeCA9IEZwLmNtb3YoeCwgdHYzLCBpc1ZhbGlkKTsgLy8gMjEuICAgeCA9IENNT1YoeCwgdHYzLCBpc19neDFfc3F1YXJlKVxuICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgY29uc3QgZTEgPSBGcC5pc09kZCEodSkgPT09IEZwLmlzT2RkISh5KTsgLy8gMjMuICBlMSA9IHNnbjAodSkgPT0gc2duMCh5KVxuICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgY29uc3QgdHY0X2ludiA9IEZwSW52ZXJ0QmF0Y2goRnAsIFt0djRdLCB0cnVlKVswXTtcbiAgICB4ID0gRnAubXVsKHgsIHR2NF9pbnYpOyAvLyAyNS4gICB4ID0geCAvIHR2NFxuICAgIHJldHVybiB7IHgsIHkgfTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0V0xlbmd0aHM8VD4oRnA6IElGaWVsZDxUPiwgRm46IElGaWVsZDxiaWdpbnQ+KSB7XG4gIHJldHVybiB7XG4gICAgc2VjcmV0S2V5OiBGbi5CWVRFUyxcbiAgICBwdWJsaWNLZXk6IDEgKyBGcC5CWVRFUyxcbiAgICBwdWJsaWNLZXlVbmNvbXByZXNzZWQ6IDEgKyAyICogRnAuQllURVMsXG4gICAgcHVibGljS2V5SGFzUHJlZml4OiB0cnVlLFxuICAgIHNpZ25hdHVyZTogMiAqIEZuLkJZVEVTLFxuICB9O1xufVxuXG4vKipcbiAqIFNvbWV0aW1lcyB1c2VycyBvbmx5IG5lZWQgZ2V0UHVibGljS2V5LCBnZXRTaGFyZWRTZWNyZXQsIGFuZCBzZWNyZXQga2V5IGhhbmRsaW5nLlxuICogVGhpcyBoZWxwZXIgZW5zdXJlcyBubyBzaWduYXR1cmUgZnVuY3Rpb25hbGl0eSBpcyBwcmVzZW50LiBMZXNzIGNvZGUsIHNtYWxsZXIgYnVuZGxlIHNpemUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlY2RoKFxuICBQb2ludDogV2VpZXJzdHJhc3NQb2ludENvbnM8YmlnaW50PixcbiAgZWNkaE9wdHM6IHsgcmFuZG9tQnl0ZXM/OiAoYnl0ZXNMZW5ndGg/OiBudW1iZXIpID0+IFVpbnQ4QXJyYXkgfSA9IHt9XG4pOiBFQ0RIIHtcbiAgY29uc3QgeyBGbiB9ID0gUG9pbnQ7XG4gIGNvbnN0IHJhbmRvbUJ5dGVzXyA9IGVjZGhPcHRzLnJhbmRvbUJ5dGVzIHx8IHJhbmRvbUJ5dGVzV2ViO1xuICBjb25zdCBsZW5ndGhzID0gT2JqZWN0LmFzc2lnbihnZXRXTGVuZ3RocyhQb2ludC5GcCwgRm4pLCB7IHNlZWQ6IGdldE1pbkhhc2hMZW5ndGgoRm4uT1JERVIpIH0pO1xuXG4gIGZ1bmN0aW9uIGlzVmFsaWRTZWNyZXRLZXkoc2VjcmV0S2V5OiBQcml2S2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAhIV9ub3JtRm5FbGVtZW50KEZuLCBzZWNyZXRLZXkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNWYWxpZFB1YmxpY0tleShwdWJsaWNLZXk6IFVpbnQ4QXJyYXksIGlzQ29tcHJlc3NlZD86IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgICBjb25zdCB7IHB1YmxpY0tleTogY29tcCwgcHVibGljS2V5VW5jb21wcmVzc2VkIH0gPSBsZW5ndGhzO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBsID0gcHVibGljS2V5Lmxlbmd0aDtcbiAgICAgIGlmIChpc0NvbXByZXNzZWQgPT09IHRydWUgJiYgbCAhPT0gY29tcCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGlzQ29tcHJlc3NlZCA9PT0gZmFsc2UgJiYgbCAhPT0gcHVibGljS2V5VW5jb21wcmVzc2VkKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gISFQb2ludC5mcm9tQnl0ZXMocHVibGljS2V5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgc2VjcmV0IGtleSBmcm9tIHJhbmRvbSBvZiBzaXplXG4gICAqIChncm91cExlbiArIGNlaWwoZ3JvdXBMZW4gLyAyKSkgd2l0aCBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmFuZG9tU2VjcmV0S2V5KHNlZWQgPSByYW5kb21CeXRlc18obGVuZ3Rocy5zZWVkKSk6IFVpbnQ4QXJyYXkge1xuICAgIHJldHVybiBtYXBIYXNoVG9GaWVsZChhYnl0ZXMoc2VlZCwgbGVuZ3Rocy5zZWVkLCAnc2VlZCcpLCBGbi5PUkRFUik7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgcHVibGljIGtleSBmb3IgYSBzZWNyZXQga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBzZWNyZXQga2V5LlxuICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgKiBAcmV0dXJucyBQdWJsaWMga2V5LCBmdWxsIHdoZW4gaXNDb21wcmVzc2VkPWZhbHNlOyBzaG9ydCB3aGVuIGlzQ29tcHJlc3NlZD10cnVlXG4gICAqL1xuICBmdW5jdGlvbiBnZXRQdWJsaWNLZXkoc2VjcmV0S2V5OiBQcml2S2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKTogVWludDhBcnJheSB7XG4gICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkoX25vcm1GbkVsZW1lbnQoRm4sIHNlY3JldEtleSkpLnRvQnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGtleWdlbihzZWVkPzogVWludDhBcnJheSkge1xuICAgIGNvbnN0IHNlY3JldEtleSA9IHJhbmRvbVNlY3JldEtleShzZWVkKTtcbiAgICByZXR1cm4geyBzZWNyZXRLZXksIHB1YmxpY0tleTogZ2V0UHVibGljS2V5KHNlY3JldEtleSkgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWljayBhbmQgZGlydHkgY2hlY2sgZm9yIGl0ZW0gYmVpbmcgcHVibGljIGtleS4gRG9lcyBub3QgdmFsaWRhdGUgaGV4LCBvciBiZWluZyBvbi1jdXJ2ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtOiBQcml2S2V5IHwgUHViS2V5KTogYm9vbGVhbiB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHR5cGVvZiBpdGVtID09PSAnYmlnaW50JykgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQpIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IHsgc2VjcmV0S2V5LCBwdWJsaWNLZXksIHB1YmxpY0tleVVuY29tcHJlc3NlZCB9ID0gbGVuZ3RocztcbiAgICBpZiAoRm4uYWxsb3dlZExlbmd0aHMgfHwgc2VjcmV0S2V5ID09PSBwdWJsaWNLZXkpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbCA9IGVuc3VyZUJ5dGVzKCdrZXknLCBpdGVtKS5sZW5ndGg7XG4gICAgcmV0dXJuIGwgPT09IHB1YmxpY0tleSB8fCBsID09PSBwdWJsaWNLZXlVbmNvbXByZXNzZWQ7XG4gIH1cblxuICAvKipcbiAgICogRUNESCAoRWxsaXB0aWMgQ3VydmUgRGlmZmllIEhlbGxtYW4pLlxuICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHNlY3JldCBrZXkgQSBhbmQgcHVibGljIGtleSBCLlxuICAgKiBDaGVja3M6IDEpIHNlY3JldCBrZXkgdmFsaWRpdHkgMikgc2hhcmVkIGtleSBpcyBvbi1jdXJ2ZS5cbiAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxuICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgKiBAcmV0dXJucyBzaGFyZWQgcHVibGljIGtleVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHNlY3JldEtleUE6IFByaXZLZXksIHB1YmxpY0tleUI6IEhleCwgaXNDb21wcmVzc2VkID0gdHJ1ZSk6IFVpbnQ4QXJyYXkge1xuICAgIGlmIChpc1Byb2JQdWIoc2VjcmV0S2V5QSkgPT09IHRydWUpIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICBpZiAoaXNQcm9iUHViKHB1YmxpY0tleUIpID09PSBmYWxzZSkgdGhyb3cgbmV3IEVycm9yKCdzZWNvbmQgYXJnIG11c3QgYmUgcHVibGljIGtleScpO1xuICAgIGNvbnN0IHMgPSBfbm9ybUZuRWxlbWVudChGbiwgc2VjcmV0S2V5QSk7XG4gICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljS2V5Qik7IC8vIGNoZWNrcyBmb3IgYmVpbmcgb24tY3VydmVcbiAgICByZXR1cm4gYi5tdWx0aXBseShzKS50b0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gIH1cblxuICBjb25zdCB1dGlscyA9IHtcbiAgICBpc1ZhbGlkU2VjcmV0S2V5LFxuICAgIGlzVmFsaWRQdWJsaWNLZXksXG4gICAgcmFuZG9tU2VjcmV0S2V5LFxuXG4gICAgLy8gVE9ETzogcmVtb3ZlXG4gICAgaXNWYWxpZFByaXZhdGVLZXk6IGlzVmFsaWRTZWNyZXRLZXksXG4gICAgcmFuZG9tUHJpdmF0ZUtleTogcmFuZG9tU2VjcmV0S2V5LFxuICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXI6IChrZXk6IFByaXZLZXkpID0+IF9ub3JtRm5FbGVtZW50KEZuLCBrZXkpLFxuICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSk6IFdlaWVyc3RyYXNzUG9pbnQ8YmlnaW50PiB7XG4gICAgICByZXR1cm4gcG9pbnQucHJlY29tcHV0ZSh3aW5kb3dTaXplLCBmYWxzZSk7XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGdldFB1YmxpY0tleSwgZ2V0U2hhcmVkU2VjcmV0LCBrZXlnZW4sIFBvaW50LCB1dGlscywgbGVuZ3RocyB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIEVDRFNBIHNpZ25pbmcgaW50ZXJmYWNlIGZvciBnaXZlbiBlbGxpcHRpYyBjdXJ2ZSBgUG9pbnRgIGFuZCBgaGFzaGAgZnVuY3Rpb24uXG4gKiBXZSBuZWVkIGBoYXNoYCBmb3IgMiBmZWF0dXJlczpcbiAqIDEuIE1lc3NhZ2UgcHJlaGFzaC1pbmcuIE5PVCB1c2VkIGlmIGBzaWduYCAvIGB2ZXJpZnlgIGFyZSBjYWxsZWQgd2l0aCBgcHJlaGFzaDogZmFsc2VgXG4gKiAyLiBrIGdlbmVyYXRpb24gaW4gYHNpZ25gLCB1c2luZyBITUFDLWRyYmcoaGFzaClcbiAqXG4gKiBFQ0RTQU9wdHMgYXJlIG9ubHkgcmFyZWx5IG5lZWRlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGNvbnN0IHAyNTZfUG9pbnQgPSB3ZWllcnN0cmFzcyguLi4pO1xuICogY29uc3QgcDI1Nl9zaGEyNTYgPSBlY2RzYShwMjU2X1BvaW50LCBzaGEyNTYpO1xuICogY29uc3QgcDI1Nl9zaGEyMjQgPSBlY2RzYShwMjU2X1BvaW50LCBzaGEyMjQpO1xuICogY29uc3QgcDI1Nl9zaGEyMjRfciA9IGVjZHNhKHAyNTZfUG9pbnQsIHNoYTIyNCwgeyByYW5kb21CeXRlczogKGxlbmd0aCkgPT4geyAuLi4gfSB9KTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZWNkc2EoXG4gIFBvaW50OiBXZWllcnN0cmFzc1BvaW50Q29uczxiaWdpbnQ+LFxuICBoYXNoOiBDSGFzaCxcbiAgZWNkc2FPcHRzOiBFQ0RTQU9wdHMgPSB7fVxuKTogRUNEU0Ege1xuICBhaGFzaChoYXNoKTtcbiAgX3ZhbGlkYXRlT2JqZWN0KFxuICAgIGVjZHNhT3B0cyxcbiAgICB7fSxcbiAgICB7XG4gICAgICBobWFjOiAnZnVuY3Rpb24nLFxuICAgICAgbG93UzogJ2Jvb2xlYW4nLFxuICAgICAgcmFuZG9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICBiaXRzMmludDogJ2Z1bmN0aW9uJyxcbiAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgfVxuICApO1xuXG4gIGNvbnN0IHJhbmRvbUJ5dGVzID0gZWNkc2FPcHRzLnJhbmRvbUJ5dGVzIHx8IHJhbmRvbUJ5dGVzV2ViO1xuICBjb25zdCBobWFjOiBIbWFjRm5TeW5jID1cbiAgICBlY2RzYU9wdHMuaG1hYyB8fFxuICAgICgoKGtleSwgLi4ubXNncykgPT4gbm9ibGVIbWFjKGhhc2gsIGtleSwgY29uY2F0Qnl0ZXMoLi4ubXNncykpKSBzYXRpc2ZpZXMgSG1hY0ZuU3luYyk7XG5cbiAgY29uc3QgeyBGcCwgRm4gfSA9IFBvaW50O1xuICBjb25zdCB7IE9SREVSOiBDVVJWRV9PUkRFUiwgQklUUzogZm5CaXRzIH0gPSBGbjtcbiAgY29uc3QgeyBrZXlnZW4sIGdldFB1YmxpY0tleSwgZ2V0U2hhcmVkU2VjcmV0LCB1dGlscywgbGVuZ3RocyB9ID0gZWNkaChQb2ludCwgZWNkc2FPcHRzKTtcbiAgY29uc3QgZGVmYXVsdFNpZ09wdHM6IFJlcXVpcmVkPEVDRFNBU2lnbk9wdHM+ID0ge1xuICAgIHByZWhhc2g6IGZhbHNlLFxuICAgIGxvd1M6IHR5cGVvZiBlY2RzYU9wdHMubG93UyA9PT0gJ2Jvb2xlYW4nID8gZWNkc2FPcHRzLmxvd1MgOiBmYWxzZSxcbiAgICBmb3JtYXQ6IHVuZGVmaW5lZCBhcyBhbnksIC8vJ2NvbXBhY3QnIGFzIEVDRFNBU2lnRm9ybWF0LFxuICAgIGV4dHJhRW50cm9weTogZmFsc2UsXG4gIH07XG4gIGNvbnN0IGRlZmF1bHRTaWdPcHRzX2Zvcm1hdCA9ICdjb21wYWN0JztcblxuICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyOiBiaWdpbnQpIHtcbiAgICBjb25zdCBIQUxGID0gQ1VSVkVfT1JERVIgPj4gXzFuO1xuICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICB9XG4gIGZ1bmN0aW9uIHZhbGlkYXRlUlModGl0bGU6IHN0cmluZywgbnVtOiBiaWdpbnQpOiBiaWdpbnQge1xuICAgIGlmICghRm4uaXNWYWxpZE5vdDAobnVtKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBzaWduYXR1cmUgJHt0aXRsZX06IG91dCBvZiByYW5nZSAxLi5Qb2ludC5Gbi5PUkRFUmApO1xuICAgIHJldHVybiBudW07XG4gIH1cbiAgZnVuY3Rpb24gdmFsaWRhdGVTaWdMZW5ndGgoYnl0ZXM6IFVpbnQ4QXJyYXksIGZvcm1hdDogRUNEU0FTaWdGb3JtYXQpIHtcbiAgICB2YWxpZGF0ZVNpZ0Zvcm1hdChmb3JtYXQpO1xuICAgIGNvbnN0IHNpemUgPSBsZW5ndGhzLnNpZ25hdHVyZSE7XG4gICAgY29uc3Qgc2l6ZXIgPSBmb3JtYXQgPT09ICdjb21wYWN0JyA/IHNpemUgOiBmb3JtYXQgPT09ICdyZWNvdmVyZWQnID8gc2l6ZSArIDEgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGFieXRlcyhieXRlcywgc2l6ZXIsIGAke2Zvcm1hdH0gc2lnbmF0dXJlYCk7XG4gIH1cblxuICAvKipcbiAgICogRUNEU0Egc2lnbmF0dXJlIHdpdGggaXRzIChyLCBzKSBwcm9wZXJ0aWVzLiBTdXBwb3J0cyBjb21wYWN0LCByZWNvdmVyZWQgJiBERVIgcmVwcmVzZW50YXRpb25zLlxuICAgKi9cbiAgY2xhc3MgU2lnbmF0dXJlIGltcGxlbWVudHMgRUNEU0FTaWduYXR1cmUge1xuICAgIHJlYWRvbmx5IHI6IGJpZ2ludDtcbiAgICByZWFkb25seSBzOiBiaWdpbnQ7XG4gICAgcmVhZG9ubHkgcmVjb3Zlcnk/OiBudW1iZXI7XG4gICAgY29uc3RydWN0b3IocjogYmlnaW50LCBzOiBiaWdpbnQsIHJlY292ZXJ5PzogbnVtYmVyKSB7XG4gICAgICB0aGlzLnIgPSB2YWxpZGF0ZVJTKCdyJywgcik7IC8vIHIgaW4gWzEuLk4tMV07XG4gICAgICB0aGlzLnMgPSB2YWxpZGF0ZVJTKCdzJywgcyk7IC8vIHMgaW4gWzEuLk4tMV07XG4gICAgICBpZiAocmVjb3ZlcnkgIT0gbnVsbCkgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzOiBVaW50OEFycmF5LCBmb3JtYXQ6IEVDRFNBU2lnRm9ybWF0ID0gZGVmYXVsdFNpZ09wdHNfZm9ybWF0KTogU2lnbmF0dXJlIHtcbiAgICAgIHZhbGlkYXRlU2lnTGVuZ3RoKGJ5dGVzLCBmb3JtYXQpO1xuICAgICAgbGV0IHJlY2lkOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgICBpZiAoZm9ybWF0ID09PSAnZGVyJykge1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IERFUi50b1NpZyhhYnl0ZXMoYnl0ZXMpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0ID09PSAncmVjb3ZlcmVkJykge1xuICAgICAgICByZWNpZCA9IGJ5dGVzWzBdO1xuICAgICAgICBmb3JtYXQgPSAnY29tcGFjdCc7XG4gICAgICAgIGJ5dGVzID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICB9XG4gICAgICBjb25zdCBMID0gRm4uQllURVM7XG4gICAgICBjb25zdCByID0gYnl0ZXMuc3ViYXJyYXkoMCwgTCk7XG4gICAgICBjb25zdCBzID0gYnl0ZXMuc3ViYXJyYXkoTCwgTCAqIDIpO1xuICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoRm4uZnJvbUJ5dGVzKHIpLCBGbi5mcm9tQnl0ZXMocyksIHJlY2lkKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbUhleChoZXg6IHN0cmluZywgZm9ybWF0PzogRUNEU0FTaWdGb3JtYXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyb21CeXRlcyhoZXhUb0J5dGVzKGhleCksIGZvcm1hdCk7XG4gICAgfVxuXG4gICAgYWRkUmVjb3ZlcnlCaXQocmVjb3Zlcnk6IG51bWJlcik6IFJlY292ZXJlZFNpZ25hdHVyZSB7XG4gICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpIGFzIFJlY292ZXJlZFNpZ25hdHVyZTtcbiAgICB9XG5cbiAgICByZWNvdmVyUHVibGljS2V5KG1lc3NhZ2VIYXNoOiBIZXgpOiBXZWllcnN0cmFzc1BvaW50PGJpZ2ludD4ge1xuICAgICAgY29uc3QgRklFTERfT1JERVIgPSBGcC5PUkRFUjtcbiAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgIGlmIChyZWMgPT0gbnVsbCB8fCAhWzAsIDEsIDIsIDNdLmluY2x1ZGVzKHJlYykpIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuXG4gICAgICAvLyBFQ0RTQSByZWNvdmVyeSBpcyBoYXJkIGZvciBjb2ZhY3RvciA+IDEgY3VydmVzLlxuICAgICAgLy8gSW4gc2lnbiwgYHIgPSBxLnggbW9kIG5gLCBhbmQgaGVyZSB3ZSByZWNvdmVyIHEueCBmcm9tIHIuXG4gICAgICAvLyBXaGlsZSByZWNvdmVyaW5nIHEueCA+PSBuLCB3ZSBuZWVkIHRvIGFkZCByK24gZm9yIGNvZmFjdG9yPTEgY3VydmVzLlxuICAgICAgLy8gSG93ZXZlciwgZm9yIGNvZmFjdG9yPjEsIHIrbiBtYXkgbm90IGdldCBxLng6XG4gICAgICAvLyByK24qaSB3b3VsZCBuZWVkIHRvIGJlIGRvbmUgaW5zdGVhZCB3aGVyZSBpIGlzIHVua25vd24uXG4gICAgICAvLyBUbyBlYXNpbHkgZ2V0IGksIHdlIGVpdGhlciBuZWVkIHRvOlxuICAgICAgLy8gYS4gaW5jcmVhc2UgYW1vdW50IG9mIHZhbGlkIHJlY2lkIHZhbHVlcyAoNCwgNS4uLik7IE9SXG4gICAgICAvLyBiLiBwcm9oaWJpdCBub24tcHJpbWUtb3JkZXIgc2lnbmF0dXJlcyAocmVjaWQgPiAxKS5cbiAgICAgIGNvbnN0IGhhc0NvZmFjdG9yID0gQ1VSVkVfT1JERVIgKiBfMm4gPCBGSUVMRF9PUkRFUjtcbiAgICAgIGlmIChoYXNDb2ZhY3RvciAmJiByZWMgPiAxKSB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIGlzIGFtYmlndW91cyBmb3IgaD4xIGN1cnZlJyk7XG5cbiAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFX09SREVSIDogcjtcbiAgICAgIGlmICghRnAuaXNWYWxpZChyYWRqKSkgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZCcpO1xuICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMocmFkaik7XG4gICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUJ5dGVzKGNvbmNhdEJ5dGVzKHBwcmVmaXgoKHJlYyAmIDEpID09PSAwKSwgeCkpO1xuICAgICAgY29uc3QgaXIgPSBGbi5pbnYocmFkaik7IC8vIHJeLTFcbiAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbWVzc2FnZUhhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxuICAgICAgY29uc3QgdTEgPSBGbi5jcmVhdGUoLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgY29uc3QgdTIgPSBGbi5jcmVhdGUocyAqIGlyKTsgLy8gc3JeLTFcbiAgICAgIC8vIChzcl4tMSlSLShocl4tMSlHID0gLShocl4tMSlHICsgKHNyXi0xKS4gdW5zYWZlIGlzIGZpbmU6IHRoZXJlIGlzIG5vIHByaXZhdGUgZGF0YS5cbiAgICAgIGNvbnN0IFEgPSBQb2ludC5CQVNFLm11bHRpcGx5VW5zYWZlKHUxKS5hZGQoUi5tdWx0aXBseVVuc2FmZSh1MikpO1xuICAgICAgaWYgKFEuaXMwKCkpIHRocm93IG5ldyBFcnJvcigncG9pbnQgYXQgaW5maW5pZnknKTtcbiAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgIHJldHVybiBRO1xuICAgIH1cblxuICAgIC8vIFNpZ25hdHVyZXMgc2hvdWxkIGJlIGxvdy1zLCB0byBwcmV2ZW50IG1hbGxlYWJpbGl0eS5cbiAgICBoYXNIaWdoUygpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIodGhpcy5zKTtcbiAgICB9XG5cbiAgICB0b0J5dGVzKGZvcm1hdDogRUNEU0FTaWdGb3JtYXQgPSBkZWZhdWx0U2lnT3B0c19mb3JtYXQpIHtcbiAgICAgIHZhbGlkYXRlU2lnRm9ybWF0KGZvcm1hdCk7XG4gICAgICBpZiAoZm9ybWF0ID09PSAnZGVyJykgcmV0dXJuIGhleFRvQnl0ZXMoREVSLmhleEZyb21TaWcodGhpcykpO1xuICAgICAgY29uc3QgciA9IEZuLnRvQnl0ZXModGhpcy5yKTtcbiAgICAgIGNvbnN0IHMgPSBGbi50b0J5dGVzKHRoaXMucyk7XG4gICAgICBpZiAoZm9ybWF0ID09PSAncmVjb3ZlcmVkJykge1xuICAgICAgICBpZiAodGhpcy5yZWNvdmVyeSA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGJpdCBtdXN0IGJlIHByZXNlbnQnKTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKFVpbnQ4QXJyYXkub2YodGhpcy5yZWNvdmVyeSksIHIsIHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKHIsIHMpO1xuICAgIH1cblxuICAgIHRvSGV4KGZvcm1hdD86IEVDRFNBU2lnRm9ybWF0KSB7XG4gICAgICByZXR1cm4gYnl0ZXNUb0hleCh0aGlzLnRvQnl0ZXMoZm9ybWF0KSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlXG4gICAgYXNzZXJ0VmFsaWRpdHkoKTogdm9pZCB7fVxuICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXg6IEhleCkge1xuICAgICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3NpZycsIGhleCksICdjb21wYWN0Jyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tREVSKGhleDogSGV4KSB7XG4gICAgICByZXR1cm4gU2lnbmF0dXJlLmZyb21CeXRlcyhlbnN1cmVCeXRlcygnc2lnJywgaGV4KSwgJ2RlcicpO1xuICAgIH1cbiAgICBub3JtYWxpemVTKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzSGlnaFMoKSA/IG5ldyBTaWduYXR1cmUodGhpcy5yLCBGbi5uZWcodGhpcy5zKSwgdGhpcy5yZWNvdmVyeSkgOiB0aGlzO1xuICAgIH1cbiAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9CeXRlcygnZGVyJyk7XG4gICAgfVxuICAgIHRvREVSSGV4KCkge1xuICAgICAgcmV0dXJuIGJ5dGVzVG9IZXgodGhpcy50b0J5dGVzKCdkZXInKSk7XG4gICAgfVxuICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9CeXRlcygnY29tcGFjdCcpO1xuICAgIH1cbiAgICB0b0NvbXBhY3RIZXgoKSB7XG4gICAgICByZXR1cm4gYnl0ZXNUb0hleCh0aGlzLnRvQnl0ZXMoJ2NvbXBhY3QnKSk7XG4gICAgfVxuICB9XG4gIHR5cGUgUmVjb3ZlcmVkU2lnbmF0dXJlID0gU2lnbmF0dXJlICYgeyByZWNvdmVyeTogbnVtYmVyIH07XG5cbiAgLy8gUkZDNjk3OTogZW5zdXJlIEVDRFNBIG1zZyBpcyBYIGJ5dGVzIGFuZCA8IE4uIFJGQyBzdWdnZXN0cyBvcHRpb25hbCB0cnVuY2F0aW5nIHZpYSBiaXRzMm9jdGV0cy5cbiAgLy8gRklQUyAxODYtNCA0LjYgc3VnZ2VzdHMgdGhlIGxlZnRtb3N0IG1pbihuQml0TGVuLCBvdXRMZW4pIGJpdHMsIHdoaWNoIG1hdGNoZXMgYml0czJpbnQuXG4gIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgLy8gaW50Mm9jdGV0cyBjYW4ndCBiZSB1c2VkOyBwYWRzIHNtYWxsIG1zZ3Mgd2l0aCAwOiB1bmFjY2VwdGF0YmxlIGZvciB0cnVuYyBhcyBwZXIgUkZDIHZlY3RvcnNcbiAgY29uc3QgYml0czJpbnQgPVxuICAgIGVjZHNhT3B0cy5iaXRzMmludCB8fFxuICAgIGZ1bmN0aW9uIGJpdHMyaW50X2RlZihieXRlczogVWludDhBcnJheSk6IGJpZ2ludCB7XG4gICAgICAvLyBPdXIgY3VzdG9tIGNoZWNrIFwianVzdCBpbiBjYXNlXCIsIGZvciBwcm90ZWN0aW9uIGFnYWluc3QgRG9TXG4gICAgICBpZiAoYnl0ZXMubGVuZ3RoID4gODE5MikgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBpcyB0b28gbGFyZ2UnKTtcbiAgICAgIC8vIEZvciBjdXJ2ZXMgd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMDogYml0czJvY3RldHMoYml0czJvY3RldHMobSkpICE9PSBiaXRzMm9jdGV0cyhtKVxuICAgICAgLy8gZm9yIHNvbWUgY2FzZXMsIHNpbmNlIGJ5dGVzLmxlbmd0aCAqIDggaXMgbm90IGFjdHVhbCBiaXRMZW5ndGguXG4gICAgICBjb25zdCBudW0gPSBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpOyAvLyBjaGVjayBmb3IgPT0gdTggZG9uZSBoZXJlXG4gICAgICBjb25zdCBkZWx0YSA9IGJ5dGVzLmxlbmd0aCAqIDggLSBmbkJpdHM7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgIH07XG4gIGNvbnN0IGJpdHMyaW50X21vZE4gPVxuICAgIGVjZHNhT3B0cy5iaXRzMmludF9tb2ROIHx8XG4gICAgZnVuY3Rpb24gYml0czJpbnRfbW9kTl9kZWYoYnl0ZXM6IFVpbnQ4QXJyYXkpOiBiaWdpbnQge1xuICAgICAgcmV0dXJuIEZuLmNyZWF0ZShiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICB9O1xuICAvLyBQYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgY29uc3QgT1JERVJfTUFTSyA9IGJpdE1hc2soZm5CaXRzKTtcbiAgLyoqIENvbnZlcnRzIHRvIGJ5dGVzLiBDaGVja3MgaWYgbnVtIGluIGBbMC4uT1JERVJfTUFTSy0xXWAgZS5nLjogYFswLi4yXjI1Ni0xXWAuICovXG4gIGZ1bmN0aW9uIGludDJvY3RldHMobnVtOiBiaWdpbnQpOiBVaW50OEFycmF5IHtcbiAgICAvLyBJTVBPUlRBTlQ6IHRoZSBjaGVjayBlbnN1cmVzIHdvcmtpbmcgZm9yIGNhc2UgYEZuLkJZVEVTICE9IEZuLkJJVFMgKiA4YFxuICAgIGFJblJhbmdlKCdudW0gPCAyXicgKyBmbkJpdHMsIG51bSwgXzBuLCBPUkRFUl9NQVNLKTtcbiAgICByZXR1cm4gRm4udG9CeXRlcyhudW0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVNc2dBbmRIYXNoKG1lc3NhZ2U6IFVpbnQ4QXJyYXksIHByZWhhc2g6IGJvb2xlYW4pIHtcbiAgICBhYnl0ZXMobWVzc2FnZSwgdW5kZWZpbmVkLCAnbWVzc2FnZScpO1xuICAgIHJldHVybiBwcmVoYXNoID8gYWJ5dGVzKGhhc2gobWVzc2FnZSksIHVuZGVmaW5lZCwgJ3ByZWhhc2hlZCBtZXNzYWdlJykgOiBtZXNzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXG4gICAqIENyZWF0ZXMgUkZDNjk3OSBzZWVkOyBjb252ZXJ0cyBtc2cvcHJpdktleSB0byBudW1iZXJzLlxuICAgKiBVc2VkIG9ubHkgaW4gc2lnbiwgbm90IGluIHZlcmlmeS5cbiAgICpcbiAgICogV2FybmluZzogd2UgY2Fubm90IGFzc3VtZSBoZXJlIHRoYXQgbWVzc2FnZSBoYXMgc2FtZSBhbW91bnQgb2YgYnl0ZXMgYXMgY3VydmUgb3JkZXIsXG4gICAqIHRoaXMgd2lsbCBiZSBpbnZhbGlkIGF0IGxlYXN0IGZvciBQNTIxLiBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTYuXG4gICAqL1xuICBmdW5jdGlvbiBwcmVwU2lnKG1lc3NhZ2U6IFVpbnQ4QXJyYXksIHByaXZhdGVLZXk6IFByaXZLZXksIG9wdHM6IEVDRFNBU2lnbk9wdHMpIHtcbiAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICBjb25zdCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weSB9ID0gdmFsaWRhdGVTaWdPcHRzKG9wdHMsIGRlZmF1bHRTaWdPcHRzKTtcbiAgICBtZXNzYWdlID0gdmFsaWRhdGVNc2dBbmRIYXNoKG1lc3NhZ2UsIHByZWhhc2gpOyAvLyBSRkM2OTc5IDMuMiBBOiBoMSA9IEgobSlcbiAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAvLyB3aXRoIGZuQml0cyAlIDggIT09IDAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgdW53cmFwIGl0IGhlcmUgYXMgaW50Mm9jdGV0cyBjYWxsLlxuICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICBjb25zdCBoMWludCA9IGJpdHMyaW50X21vZE4obWVzc2FnZSk7XG4gICAgY29uc3QgZCA9IF9ub3JtRm5FbGVtZW50KEZuLCBwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgc2VjcmV0IGtleSwgY29udmVydCB0byBiaWdpbnRcbiAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XG4gICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgIGlmIChleHRyYUVudHJvcHkgIT0gbnVsbCAmJiBleHRyYUVudHJvcHkgIT09IGZhbHNlKSB7XG4gICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcbiAgICAgIC8vIGdlbiByYW5kb20gYnl0ZXMgT1IgcGFzcyBhcy1pc1xuICAgICAgY29uc3QgZSA9IGV4dHJhRW50cm9weSA9PT0gdHJ1ZSA/IHJhbmRvbUJ5dGVzKGxlbmd0aHMuc2VjcmV0S2V5KSA6IGV4dHJhRW50cm9weTtcbiAgICAgIHNlZWRBcmdzLnB1c2goZW5zdXJlQnl0ZXMoJ2V4dHJhRW50cm9weScsIGUpKTsgLy8gY2hlY2sgZm9yIGJlaW5nIGJ5dGVzXG4gICAgfVxuICAgIGNvbnN0IHNlZWQgPSBjb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgIGNvbnN0IG0gPSBoMWludDsgLy8gTk9URTogbm8gbmVlZCB0byBjYWxsIGJpdHMyaW50IHNlY29uZCB0aW1lIGhlcmUsIGl0IGlzIGluc2lkZSB0cnVuY2F0ZUhhc2ghXG4gICAgLy8gQ29udmVydHMgc2lnbmF0dXJlIHBhcmFtcyBpbnRvIHBvaW50IHcgci9zLCBjaGVja3MgcmVzdWx0IGZvciB2YWxpZGl0eS5cbiAgICAvLyBUbyB0cmFuc2Zvcm0gayA9PiBTaWduYXR1cmU6XG4gICAgLy8gcSA9IGtcdTIyQzVHXG4gICAgLy8gciA9IHEueCBtb2QgblxuICAgIC8vIHMgPSBrXi0xKG0gKyByZCkgbW9kIG5cbiAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIFx1MjIwOCBbMSxxXHUyMjEyMV0gYWNjb3JkaW5nIHRvXG4gICAgLy8gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzczMzcvNjUwOS4gV2UndmUgZGVjaWRlZCBhZ2FpbnN0IGl0OlxuICAgIC8vIGEpIGRlcGVuZGVuY3kgb24gQ1NQUk5HIGIpIDE1JSBzbG93ZG93biBjKSBkb2Vzbid0IHJlYWxseSBoZWxwIHNpbmNlIGJpZ2ludHMgYXJlIG5vdCBDVFxuICAgIGZ1bmN0aW9uIGsyc2lnKGtCeXRlczogVWludDhBcnJheSk6IFJlY292ZXJlZFNpZ25hdHVyZSB8IHVuZGVmaW5lZCB7XG4gICAgICAvLyBSRkMgNjk3OSBTZWN0aW9uIDMuMiwgc3RlcCAzOiBrID0gYml0czJpbnQoVClcbiAgICAgIC8vIEltcG9ydGFudDogYWxsIG1vZCgpIGNhbGxzIGhlcmUgbXVzdCBiZSBkb25lIG92ZXIgTlxuICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIG1vZCBuLCBub3QgbW9kIHBcbiAgICAgIGlmICghRm4uaXNWYWxpZE5vdDAoaykpIHJldHVybjsgLy8gVmFsaWQgc2NhbGFycyAoaW5jbHVkaW5nIGspIG11c3QgYmUgaW4gMS4uTi0xXG4gICAgICBjb25zdCBpayA9IEZuLmludihrKTsgLy8ga14tMSBtb2QgblxuICAgICAgY29uc3QgcSA9IFBvaW50LkJBU0UubXVsdGlwbHkoaykudG9BZmZpbmUoKTsgLy8gcSA9IGtcdTIyQzVHXG4gICAgICBjb25zdCByID0gRm4uY3JlYXRlKHEueCk7IC8vIHIgPSBxLnggbW9kIG5cbiAgICAgIGlmIChyID09PSBfMG4pIHJldHVybjtcbiAgICAgIGNvbnN0IHMgPSBGbi5jcmVhdGUoaWsgKiBGbi5jcmVhdGUobSArIHIgKiBkKSk7IC8vIE5vdCB1c2luZyBibGluZGluZyBoZXJlLCBzZWUgY29tbWVudCBhYm92ZVxuICAgICAgaWYgKHMgPT09IF8wbikgcmV0dXJuO1xuICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICBub3JtUyA9IEZuLm5lZyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgcmVjb3ZlcnkgXj0gMTsgLy8gLy8gaW4gdGhlIGJvdHRvbSBoYWxmIG9mIE5cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIG5vcm1TLCByZWNvdmVyeSkgYXMgUmVjb3ZlcmVkU2lnbmF0dXJlOyAvLyB1c2Ugbm9ybVMsIG5vdCBzXG4gICAgfVxuICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gIH1cblxuICAvKipcbiAgICogU2lnbnMgbWVzc2FnZSBoYXNoIHdpdGggYSBzZWNyZXQga2V5LlxuICAgKlxuICAgKiBgYGBcbiAgICogc2lnbihtLCBkKSB3aGVyZVxuICAgKiAgIGsgPSByZmM2OTc5X2htYWNfZHJiZyhtLCBkKVxuICAgKiAgICh4LCB5KSA9IEcgXHUwMEQ3IGtcbiAgICogICByID0geCBtb2QgblxuICAgKiAgIHMgPSAobSArIGRyKSAvIGsgbW9kIG5cbiAgICogYGBgXG4gICAqL1xuICBmdW5jdGlvbiBzaWduKG1lc3NhZ2U6IEhleCwgc2VjcmV0S2V5OiBQcml2S2V5LCBvcHRzOiBFQ0RTQVNpZ25PcHRzID0ge30pOiBSZWNvdmVyZWRTaWduYXR1cmUge1xuICAgIG1lc3NhZ2UgPSBlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgIGNvbnN0IHsgc2VlZCwgazJzaWcgfSA9IHByZXBTaWcobWVzc2FnZSwgc2VjcmV0S2V5LCBvcHRzKTsgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMi5cbiAgICBjb25zdCBkcmJnID0gY3JlYXRlSG1hY0RyYmc8UmVjb3ZlcmVkU2lnbmF0dXJlPihoYXNoLm91dHB1dExlbiwgRm4uQllURVMsIGhtYWMpO1xuICAgIGNvbnN0IHNpZyA9IGRyYmcoc2VlZCwgazJzaWcpOyAvLyBTdGVwcyBCLCBDLCBELCBFLCBGLCBHXG4gICAgcmV0dXJuIHNpZztcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVBhcnNpbmdTaWcoc2c6IEhleCB8IFNpZ25hdHVyZUxpa2UpIHtcbiAgICAvLyBUcnkgdG8gZGVkdWNlIGZvcm1hdFxuICAgIGxldCBzaWc6IFNpZ25hdHVyZSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBpc0hleCA9IHR5cGVvZiBzZyA9PT0gJ3N0cmluZycgfHwgaXNCeXRlcyhzZyk7XG4gICAgY29uc3QgaXNPYmogPVxuICAgICAgIWlzSGV4ICYmXG4gICAgICBzZyAhPT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHNnID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHNnLnIgPT09ICdiaWdpbnQnICYmXG4gICAgICB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCc7XG4gICAgaWYgKCFpc0hleCAmJiAhaXNPYmopXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnbmF0dXJlLCBleHBlY3RlZCBVaW50OEFycmF5LCBoZXggc3RyaW5nIG9yIFNpZ25hdHVyZSBpbnN0YW5jZScpO1xuICAgIGlmIChpc09iaikge1xuICAgICAgc2lnID0gbmV3IFNpZ25hdHVyZShzZy5yLCBzZy5zKTtcbiAgICB9IGVsc2UgaWYgKGlzSGV4KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzaWcgPSBTaWduYXR1cmUuZnJvbUJ5dGVzKGVuc3VyZUJ5dGVzKCdzaWcnLCBzZyksICdkZXInKTtcbiAgICAgIH0gY2F0Y2ggKGRlckVycm9yKSB7XG4gICAgICAgIGlmICghKGRlckVycm9yIGluc3RhbmNlb2YgREVSLkVycikpIHRocm93IGRlckVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKCFzaWcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzaWcgPSBTaWduYXR1cmUuZnJvbUJ5dGVzKGVuc3VyZUJ5dGVzKCdzaWcnLCBzZyksICdjb21wYWN0Jyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc2lnKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHNpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgYW5kIHB1YmxpYyBrZXkuXG4gICAqIFJlamVjdHMgbG93UyBzaWduYXR1cmVzIGJ5IGRlZmF1bHQ6IHNlZSB7QGxpbmsgRUNEU0FWZXJpZnlPcHRzfS5cbiAgICogSW1wbGVtZW50cyBzZWN0aW9uIDQuMS40IGZyb20gaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMS12Mi5wZGY6XG4gICAqXG4gICAqIGBgYFxuICAgKiB2ZXJpZnkociwgcywgaCwgUCkgd2hlcmVcbiAgICogICB1MSA9IGhzXi0xIG1vZCBuXG4gICAqICAgdTIgPSByc14tMSBtb2QgblxuICAgKiAgIFIgPSB1MVx1MjJDNUcgKyB1Mlx1MjJDNVBcbiAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAqIGBgYFxuICAgKi9cbiAgZnVuY3Rpb24gdmVyaWZ5KFxuICAgIHNpZ25hdHVyZTogSGV4IHwgU2lnbmF0dXJlTGlrZSxcbiAgICBtZXNzYWdlOiBIZXgsXG4gICAgcHVibGljS2V5OiBIZXgsXG4gICAgb3B0czogRUNEU0FWZXJpZnlPcHRzID0ge31cbiAgKTogYm9vbGVhbiB7XG4gICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoLCBmb3JtYXQgfSA9IHZhbGlkYXRlU2lnT3B0cyhvcHRzLCBkZWZhdWx0U2lnT3B0cyk7XG4gICAgcHVibGljS2V5ID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSk7XG4gICAgbWVzc2FnZSA9IHZhbGlkYXRlTXNnQW5kSGFzaChlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1lc3NhZ2UpLCBwcmVoYXNoKTtcbiAgICBpZiAoJ3N0cmljdCcgaW4gb3B0cykgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLnN0cmljdCB3YXMgcmVuYW1lZCB0byBsb3dTJyk7XG4gICAgY29uc3Qgc2lnID1cbiAgICAgIGZvcm1hdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gdHJ5UGFyc2luZ1NpZyhzaWduYXR1cmUpXG4gICAgICAgIDogU2lnbmF0dXJlLmZyb21CeXRlcyhlbnN1cmVCeXRlcygnc2lnJywgc2lnbmF0dXJlIGFzIEhleCksIGZvcm1hdCk7XG4gICAgaWYgKHNpZyA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21CeXRlcyhwdWJsaWNLZXkpO1xuICAgICAgaWYgKGxvd1MgJiYgc2lnLmhhc0hpZ2hTKCkpIHJldHVybiBmYWxzZTtcbiAgICAgIGNvbnN0IHsgciwgcyB9ID0gc2lnO1xuICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obWVzc2FnZSk7IC8vIG1vZCBuLCBub3QgbW9kIHBcbiAgICAgIGNvbnN0IGlzID0gRm4uaW52KHMpOyAvLyBzXi0xIG1vZCBuXG4gICAgICBjb25zdCB1MSA9IEZuLmNyZWF0ZShoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICBjb25zdCB1MiA9IEZuLmNyZWF0ZShyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseVVuc2FmZSh1MSkuYWRkKFAubXVsdGlwbHlVbnNhZmUodTIpKTsgLy8gdTFcdTIyQzVHICsgdTJcdTIyQzVQXG4gICAgICBpZiAoUi5pczAoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgY29uc3QgdiA9IEZuLmNyZWF0ZShSLngpOyAvLyB2ID0gci54IG1vZCBuXG4gICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShcbiAgICBzaWduYXR1cmU6IFVpbnQ4QXJyYXksXG4gICAgbWVzc2FnZTogVWludDhBcnJheSxcbiAgICBvcHRzOiBFQ0RTQVJlY292ZXJPcHRzID0ge31cbiAgKTogVWludDhBcnJheSB7XG4gICAgY29uc3QgeyBwcmVoYXNoIH0gPSB2YWxpZGF0ZVNpZ09wdHMob3B0cywgZGVmYXVsdFNpZ09wdHMpO1xuICAgIG1lc3NhZ2UgPSB2YWxpZGF0ZU1zZ0FuZEhhc2gobWVzc2FnZSwgcHJlaGFzaCk7XG4gICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tQnl0ZXMoc2lnbmF0dXJlLCAncmVjb3ZlcmVkJykucmVjb3ZlclB1YmxpY0tleShtZXNzYWdlKS50b0J5dGVzKCk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAga2V5Z2VuLFxuICAgIGdldFB1YmxpY0tleSxcbiAgICBnZXRTaGFyZWRTZWNyZXQsXG4gICAgdXRpbHMsXG4gICAgbGVuZ3RocyxcbiAgICBQb2ludCxcbiAgICBzaWduLFxuICAgIHZlcmlmeSxcbiAgICByZWNvdmVyUHVibGljS2V5LFxuICAgIFNpZ25hdHVyZSxcbiAgICBoYXNoLFxuICB9KTtcbn1cblxuLy8gVE9ETzogcmVtb3ZlIGV2ZXJ5dGhpbmcgYmVsb3dcbi8qKiBAZGVwcmVjYXRlZCB1c2UgRUNEU0FTaWduYXR1cmUgKi9cbmV4cG9ydCB0eXBlIFNpZ25hdHVyZVR5cGUgPSBFQ0RTQVNpZ25hdHVyZTtcbi8qKiBAZGVwcmVjYXRlZCB1c2UgRUNEU0FTaWdSZWNvdmVyZWQgKi9cbmV4cG9ydCB0eXBlIFJlY292ZXJlZFNpZ25hdHVyZVR5cGUgPSBFQ0RTQVNpZ1JlY292ZXJlZDtcbi8qKiBAZGVwcmVjYXRlZCBzd2l0Y2ggdG8gVWludDhBcnJheSBzaWduYXR1cmVzIGluIGZvcm1hdCAnY29tcGFjdCcgKi9cbmV4cG9ydCB0eXBlIFNpZ25hdHVyZUxpa2UgPSB7IHI6IGJpZ2ludDsgczogYmlnaW50IH07XG5leHBvcnQgdHlwZSBFQ0RTQUV4dHJhRW50cm9weSA9IEhleCB8IGJvb2xlYW47XG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBFQ0RTQUV4dHJhRW50cm9weWAgKi9cbmV4cG9ydCB0eXBlIEVudHJvcHkgPSBIZXggfCBib29sZWFuO1xuZXhwb3J0IHR5cGUgQmFzaWNXQ3VydmU8VD4gPSBCYXNpY0N1cnZlPFQ+ICYge1xuICAvLyBQYXJhbXM6IGEsIGJcbiAgYTogVDtcbiAgYjogVDtcblxuICAvLyBPcHRpb25hbCBwYXJhbXNcbiAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzPzogcmVhZG9ubHkgbnVtYmVyW107IC8vIGZvciBQNTIxXG4gIHdyYXBQcml2YXRlS2V5PzogYm9vbGVhbjsgLy8gYmxzMTItMzgxIHJlcXVpcmVzIG1vZChuKSBpbnN0ZWFkIG9mIHJlamVjdGluZyBrZXlzID49IG5cbiAgZW5kbz86IEVuZG9tb3JwaGlzbU9wdHM7XG4gIC8vIFdoZW4gYSBjb2ZhY3RvciAhPSAxLCB0aGVyZSBjYW4gYmUgYW4gZWZmZWN0aXZlIG1ldGhvZHMgdG86XG4gIC8vIDEuIERldGVybWluZSB3aGV0aGVyIGEgcG9pbnQgaXMgdG9yc2lvbi1mcmVlXG4gIGlzVG9yc2lvbkZyZWU/OiAoYzogV2VpZXJzdHJhc3NQb2ludENvbnM8VD4sIHBvaW50OiBXZWllcnN0cmFzc1BvaW50PFQ+KSA9PiBib29sZWFuO1xuICAvLyAyLiBDbGVhciB0b3JzaW9uIGNvbXBvbmVudFxuICBjbGVhckNvZmFjdG9yPzogKGM6IFdlaWVyc3RyYXNzUG9pbnRDb25zPFQ+LCBwb2ludDogV2VpZXJzdHJhc3NQb2ludDxUPikgPT4gV2VpZXJzdHJhc3NQb2ludDxUPjtcbn07XG4vKiogQGRlcHJlY2F0ZWQgdXNlIEVDRFNBU2lnbk9wdHMgKi9cbmV4cG9ydCB0eXBlIFNpZ25PcHRzID0gRUNEU0FTaWduT3B0cztcbi8qKiBAZGVwcmVjYXRlZCB1c2UgRUNEU0FTaWduT3B0cyAqL1xuZXhwb3J0IHR5cGUgVmVyT3B0cyA9IEVDRFNBVmVyaWZ5T3B0cztcblxuLyoqIEBkZXByZWNhdGVkIHVzZSBXZWllcnN0cmFzc1BvaW50ICovXG5leHBvcnQgdHlwZSBQcm9qUG9pbnRUeXBlPFQ+ID0gV2VpZXJzdHJhc3NQb2ludDxUPjtcbi8qKiBAZGVwcmVjYXRlZCB1c2UgV2VpZXJzdHJhc3NQb2ludENvbnMgKi9cbmV4cG9ydCB0eXBlIFByb2pDb25zdHJ1Y3RvcjxUPiA9IFdlaWVyc3RyYXNzUG9pbnRDb25zPFQ+O1xuLyoqIEBkZXByZWNhdGVkIHVzZSBFQ0RTQVNpZ25hdHVyZUNvbnMgKi9cbmV4cG9ydCB0eXBlIFNpZ25hdHVyZUNvbnN0cnVjdG9yID0gRUNEU0FTaWduYXR1cmVDb25zO1xuXG4vLyBUT0RPOiByZW1vdmVcbmV4cG9ydCB0eXBlIEN1cnZlUG9pbnRzVHlwZTxUPiA9IEJhc2ljV0N1cnZlPFQ+ICYge1xuICBmcm9tQnl0ZXM/OiAoYnl0ZXM6IFVpbnQ4QXJyYXkpID0+IEFmZmluZVBvaW50PFQ+O1xuICB0b0J5dGVzPzogKFxuICAgIGM6IFdlaWVyc3RyYXNzUG9pbnRDb25zPFQ+LFxuICAgIHBvaW50OiBXZWllcnN0cmFzc1BvaW50PFQ+LFxuICAgIGlzQ29tcHJlc3NlZDogYm9vbGVhblxuICApID0+IFVpbnQ4QXJyYXk7XG59O1xuXG4vLyBMZWdhY3lXZWllcnN0cmFzc09wdHNcbmV4cG9ydCB0eXBlIEN1cnZlUG9pbnRzVHlwZVdpdGhMZW5ndGg8VD4gPSBSZWFkb25seTxDdXJ2ZVBvaW50c1R5cGU8VD4gJiBQYXJ0aWFsPE5MZW5ndGg+PjtcblxuLy8gTGVnYWN5V2VpZXJzdHJhc3NcbmV4cG9ydCB0eXBlIEN1cnZlUG9pbnRzUmVzPFQ+ID0ge1xuICBQb2ludDogV2VpZXJzdHJhc3NQb2ludENvbnM8VD47XG5cbiAgLyoqIEBkZXByZWNhdGVkIHVzZSBgUG9pbnQuQ1VSVkUoKWAgKi9cbiAgQ1VSVkU6IEN1cnZlUG9pbnRzVHlwZTxUPjtcbiAgLyoqIEBkZXByZWNhdGVkIHVzZSBgUG9pbnRgICovXG4gIFByb2plY3RpdmVQb2ludDogV2VpZXJzdHJhc3NQb2ludENvbnM8VD47XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgYFBvaW50LkZuLmZyb21CeXRlcyhwcml2YXRlS2V5KWAgKi9cbiAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogKGtleTogUHJpdktleSkgPT4gYmlnaW50O1xuICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgd2VpZXJzdHJhc3NFcXVhdGlvbjogKHg6IFQpID0+IFQ7XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgYFBvaW50LkZuLmlzVmFsaWROb3QwKG51bSlgICovXG4gIGlzV2l0aGluQ3VydmVPcmRlcjogKG51bTogYmlnaW50KSA9PiBib29sZWFuO1xufTtcblxuLy8gQWxpYXNlcyB0byBsZWdhY3kgdHlwZXNcbi8vIGV4cG9ydCB0eXBlIEN1cnZlVHlwZSA9IExlZ2FjeUVDRFNBT3B0cztcbi8vIGV4cG9ydCB0eXBlIEN1cnZlRm4gPSBMZWdhY3lFQ0RTQTtcbi8vIGV4cG9ydCB0eXBlIEN1cnZlUG9pbnRzUmVzPFQ+ID0gTGVnYWN5V2VpZXJzdHJhc3M8VD47XG4vLyBleHBvcnQgdHlwZSBDdXJ2ZVBvaW50c1R5cGU8VD4gPSBMZWdhY3lXZWllcnN0cmFzc09wdHM8VD47XG4vLyBleHBvcnQgdHlwZSBDdXJ2ZVBvaW50c1R5cGVXaXRoTGVuZ3RoPFQ+ID0gTGVnYWN5V2VpZXJzdHJhc3NPcHRzPFQ+O1xuLy8gZXhwb3J0IHR5cGUgQmFzaWNXQ3VydmU8VD4gPSBMZWdhY3lXZWllcnN0cmFzc09wdHM8VD47XG5cbi8qKiBAZGVwcmVjYXRlZCB1c2UgYFVpbnQ4QXJyYXlgICovXG5leHBvcnQgdHlwZSBQdWJLZXkgPSBIZXggfCBXZWllcnN0cmFzc1BvaW50PGJpZ2ludD47XG5leHBvcnQgdHlwZSBDdXJ2ZVR5cGUgPSBCYXNpY1dDdXJ2ZTxiaWdpbnQ+ICYge1xuICBoYXNoOiBDSGFzaDsgLy8gQ0hhc2ggbm90IEZIYXNoIGJlY2F1c2Ugd2UgbmVlZCBvdXRwdXRMZW4gZm9yIERSQkdcbiAgaG1hYz86IEhtYWNGblN5bmM7XG4gIHJhbmRvbUJ5dGVzPzogKGJ5dGVzTGVuZ3RoPzogbnVtYmVyKSA9PiBVaW50OEFycmF5O1xuICBsb3dTPzogYm9vbGVhbjtcbiAgYml0czJpbnQ/OiAoYnl0ZXM6IFVpbnQ4QXJyYXkpID0+IGJpZ2ludDtcbiAgYml0czJpbnRfbW9kTj86IChieXRlczogVWludDhBcnJheSkgPT4gYmlnaW50O1xufTtcbmV4cG9ydCB0eXBlIEN1cnZlRm4gPSB7XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgYFBvaW50LkNVUlZFKClgICovXG4gIENVUlZFOiBDdXJ2ZVBvaW50c1R5cGU8YmlnaW50PjtcbiAga2V5Z2VuOiBFQ0RTQVsna2V5Z2VuJ107XG4gIGdldFB1YmxpY0tleTogRUNEU0FbJ2dldFB1YmxpY0tleSddO1xuICBnZXRTaGFyZWRTZWNyZXQ6IEVDRFNBWydnZXRTaGFyZWRTZWNyZXQnXTtcbiAgc2lnbjogRUNEU0FbJ3NpZ24nXTtcbiAgdmVyaWZ5OiBFQ0RTQVsndmVyaWZ5J107XG4gIFBvaW50OiBXZWllcnN0cmFzc1BvaW50Q29uczxiaWdpbnQ+O1xuICAvKiogQGRlcHJlY2F0ZWQgdXNlIGBQb2ludGAgKi9cbiAgUHJvamVjdGl2ZVBvaW50OiBXZWllcnN0cmFzc1BvaW50Q29uczxiaWdpbnQ+O1xuICBTaWduYXR1cmU6IEVDRFNBU2lnbmF0dXJlQ29ucztcbiAgdXRpbHM6IEVDRFNBWyd1dGlscyddO1xuICBsZW5ndGhzOiBFQ0RTQVsnbGVuZ3RocyddO1xufTtcbi8qKiBAZGVwcmVjYXRlZCB1c2UgYHdlaWVyc3RyYXNzYCBpbiBuZXdlciByZWxlYXNlcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzPFQ+KGM6IEN1cnZlUG9pbnRzVHlwZVdpdGhMZW5ndGg8VD4pOiBDdXJ2ZVBvaW50c1JlczxUPiB7XG4gIGNvbnN0IHsgQ1VSVkUsIGN1cnZlT3B0cyB9ID0gX3dlaWVyc3RyYXNzX2xlZ2FjeV9vcHRzX3RvX25ldyhjKTtcbiAgY29uc3QgUG9pbnQgPSB3ZWllcnN0cmFzc04oQ1VSVkUsIGN1cnZlT3B0cyk7XG4gIHJldHVybiBfd2VpZXJzdHJhc3NfbmV3X291dHB1dF90b19sZWdhY3koYywgUG9pbnQpO1xufVxuZXhwb3J0IHR5cGUgV3NQb2ludENvbXBvc2VkPFQ+ID0ge1xuICBDVVJWRTogV2VpZXJzdHJhc3NPcHRzPFQ+O1xuICBjdXJ2ZU9wdHM6IFdlaWVyc3RyYXNzRXh0cmFPcHRzPFQ+O1xufTtcbmV4cG9ydCB0eXBlIFdzQ29tcG9zZWQgPSB7XG4gIC8qKiBAZGVwcmVjYXRlZCB1c2UgYFBvaW50LkNVUlZFKClgICovXG4gIENVUlZFOiBXZWllcnN0cmFzc09wdHM8YmlnaW50PjtcbiAgaGFzaDogQ0hhc2g7XG4gIGN1cnZlT3B0czogV2VpZXJzdHJhc3NFeHRyYU9wdHM8YmlnaW50PjtcbiAgZWNkc2FPcHRzOiBFQ0RTQU9wdHM7XG59O1xuZnVuY3Rpb24gX3dlaWVyc3RyYXNzX2xlZ2FjeV9vcHRzX3RvX25ldzxUPihjOiBDdXJ2ZVBvaW50c1R5cGU8VD4pOiBXc1BvaW50Q29tcG9zZWQ8VD4ge1xuICBjb25zdCBDVVJWRTogV2VpZXJzdHJhc3NPcHRzPFQ+ID0ge1xuICAgIGE6IGMuYSxcbiAgICBiOiBjLmIsXG4gICAgcDogYy5GcC5PUkRFUixcbiAgICBuOiBjLm4sXG4gICAgaDogYy5oLFxuICAgIEd4OiBjLkd4LFxuICAgIEd5OiBjLkd5LFxuICB9O1xuICBjb25zdCBGcCA9IGMuRnA7XG4gIGxldCBhbGxvd2VkTGVuZ3RocyA9IGMuYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzXG4gICAgPyBBcnJheS5mcm9tKG5ldyBTZXQoYy5hbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMubWFwKChsKSA9PiBNYXRoLmNlaWwobCAvIDIpKSkpXG4gICAgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IEZuID0gRmllbGQoQ1VSVkUubiwge1xuICAgIEJJVFM6IGMubkJpdExlbmd0aCxcbiAgICBhbGxvd2VkTGVuZ3RoczogYWxsb3dlZExlbmd0aHMsXG4gICAgbW9kRnJvbUJ5dGVzOiBjLndyYXBQcml2YXRlS2V5LFxuICB9KTtcbiAgY29uc3QgY3VydmVPcHRzOiBXZWllcnN0cmFzc0V4dHJhT3B0czxUPiA9IHtcbiAgICBGcCxcbiAgICBGbixcbiAgICBhbGxvd0luZmluaXR5UG9pbnQ6IGMuYWxsb3dJbmZpbml0eVBvaW50LFxuICAgIGVuZG86IGMuZW5kbyxcbiAgICBpc1RvcnNpb25GcmVlOiBjLmlzVG9yc2lvbkZyZWUsXG4gICAgY2xlYXJDb2ZhY3RvcjogYy5jbGVhckNvZmFjdG9yLFxuICAgIGZyb21CeXRlczogYy5mcm9tQnl0ZXMsXG4gICAgdG9CeXRlczogYy50b0J5dGVzLFxuICB9O1xuICByZXR1cm4geyBDVVJWRSwgY3VydmVPcHRzIH07XG59XG5mdW5jdGlvbiBfZWNkc2FfbGVnYWN5X29wdHNfdG9fbmV3KGM6IEN1cnZlVHlwZSk6IFdzQ29tcG9zZWQge1xuICBjb25zdCB7IENVUlZFLCBjdXJ2ZU9wdHMgfSA9IF93ZWllcnN0cmFzc19sZWdhY3lfb3B0c190b19uZXcoYyk7XG4gIGNvbnN0IGVjZHNhT3B0czogRUNEU0FPcHRzID0ge1xuICAgIGhtYWM6IGMuaG1hYyxcbiAgICByYW5kb21CeXRlczogYy5yYW5kb21CeXRlcyxcbiAgICBsb3dTOiBjLmxvd1MsXG4gICAgYml0czJpbnQ6IGMuYml0czJpbnQsXG4gICAgYml0czJpbnRfbW9kTjogYy5iaXRzMmludF9tb2ROLFxuICB9O1xuICByZXR1cm4geyBDVVJWRSwgY3VydmVPcHRzLCBoYXNoOiBjLmhhc2gsIGVjZHNhT3B0cyB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9sZWdhY3lIZWxwZXJFcXVhdDxUPihGcDogSUZpZWxkPFQ+LCBhOiBULCBiOiBUKTogKHg6IFQpID0+IFQge1xuICAvKipcbiAgICogeVx1MDBCMiA9IHhcdTAwQjMgKyBheCArIGI6IFNob3J0IHdlaWVyc3RyYXNzIGN1cnZlIGZvcm11bGEuIFRha2VzIHgsIHJldHVybnMgeVx1MDBCMi5cbiAgICogQHJldHVybnMgeVx1MDBCMlxuICAgKi9cbiAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4OiBUKTogVCB7XG4gICAgY29uc3QgeDIgPSBGcC5zcXIoeCk7IC8vIHggKiB4XG4gICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4XHUwMEIyICogeFxuICAgIHJldHVybiBGcC5hZGQoRnAuYWRkKHgzLCBGcC5tdWwoeCwgYSkpLCBiKTsgLy8geFx1MDBCMyArIGEgKiB4ICsgYlxuICB9XG4gIHJldHVybiB3ZWllcnN0cmFzc0VxdWF0aW9uO1xufVxuZnVuY3Rpb24gX3dlaWVyc3RyYXNzX25ld19vdXRwdXRfdG9fbGVnYWN5PFQ+KFxuICBjOiBDdXJ2ZVBvaW50c1R5cGU8VD4sXG4gIFBvaW50OiBXZWllcnN0cmFzc1BvaW50Q29uczxUPlxuKTogQ3VydmVQb2ludHNSZXM8VD4ge1xuICBjb25zdCB7IEZwLCBGbiB9ID0gUG9pbnQ7XG4gIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW06IGJpZ2ludCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpblJhbmdlKG51bSwgXzFuLCBGbi5PUkRFUik7XG4gIH1cbiAgY29uc3Qgd2VpZXJzdHJhc3NFcXVhdGlvbiA9IF9sZWdhY3lIZWxwZXJFcXVhdChGcCwgYy5hLCBjLmIpO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICB7fSxcbiAgICB7XG4gICAgICBDVVJWRTogYyxcbiAgICAgIFBvaW50OiBQb2ludCxcbiAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiAoa2V5OiBQcml2S2V5KSA9PiBfbm9ybUZuRWxlbWVudChGbiwga2V5KSxcbiAgICAgIHdlaWVyc3RyYXNzRXF1YXRpb24sXG4gICAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gX2VjZHNhX25ld19vdXRwdXRfdG9fbGVnYWN5KGM6IEN1cnZlVHlwZSwgX2VjZHNhOiBFQ0RTQSk6IEN1cnZlRm4ge1xuICBjb25zdCBQb2ludCA9IF9lY2RzYS5Qb2ludDtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIF9lY2RzYSwge1xuICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgQ1VSVkU6IE9iamVjdC5hc3NpZ24oe30sIGMsIG5MZW5ndGgoUG9pbnQuRm4uT1JERVIsIFBvaW50LkZuLkJJVFMpKSxcbiAgfSk7XG59XG5cbi8vIF9lY2RzYV9sZWdhY3lcbmV4cG9ydCBmdW5jdGlvbiB3ZWllcnN0cmFzcyhjOiBDdXJ2ZVR5cGUpOiBDdXJ2ZUZuIHtcbiAgY29uc3QgeyBDVVJWRSwgY3VydmVPcHRzLCBoYXNoLCBlY2RzYU9wdHMgfSA9IF9lY2RzYV9sZWdhY3lfb3B0c190b19uZXcoYyk7XG4gIGNvbnN0IFBvaW50ID0gd2VpZXJzdHJhc3NOKENVUlZFLCBjdXJ2ZU9wdHMpO1xuICBjb25zdCBzaWducyA9IGVjZHNhKFBvaW50LCBoYXNoLCBlY2RzYU9wdHMpO1xuICByZXR1cm4gX2VjZHNhX25ld19vdXRwdXRfdG9fbGVnYWN5KGMsIHNpZ25zKTtcbn1cbiIsICIvKipcbiAqIFV0aWxpdGllcyBmb3Igc2hvcnQgd2VpZXJzdHJhc3MgY3VydmVzLCBjb21iaW5lZCB3aXRoIG5vYmxlLWhhc2hlcy5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgdHlwZSBDdXJ2ZUZuLCB0eXBlIEN1cnZlVHlwZSwgd2VpZXJzdHJhc3MgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLnRzJztcbmltcG9ydCB0eXBlIHsgQ0hhc2ggfSBmcm9tICcuL3V0aWxzLnRzJztcblxuLyoqIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXMgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRIYXNoKGhhc2g6IENIYXNoKTogeyBoYXNoOiBDSGFzaCB9IHtcbiAgcmV0dXJuIHsgaGFzaCB9O1xufVxuLyoqIFNhbWUgQVBJIGFzIEBub2JsZS9oYXNoZXMsIHdpdGggYWJpbGl0eSB0byBjcmVhdGUgY3VydmUgd2l0aCBjdXN0b20gaGFzaCAqL1xuZXhwb3J0IHR5cGUgQ3VydmVEZWYgPSBSZWFkb25seTxPbWl0PEN1cnZlVHlwZSwgJ2hhc2gnPj47XG5leHBvcnQgdHlwZSBDdXJ2ZUZuV2l0aENyZWF0ZSA9IEN1cnZlRm4gJiB7IGNyZWF0ZTogKGhhc2g6IENIYXNoKSA9PiBDdXJ2ZUZuIH07XG5cbi8qKiBAZGVwcmVjYXRlZCB1c2UgbmV3IGB3ZWllcnN0cmFzcygpYCBhbmQgYGVjZHNhKClgIG1ldGhvZHMgKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDdXJ2ZShjdXJ2ZURlZjogQ3VydmVEZWYsIGRlZkhhc2g6IENIYXNoKTogQ3VydmVGbldpdGhDcmVhdGUge1xuICBjb25zdCBjcmVhdGUgPSAoaGFzaDogQ0hhc2gpOiBDdXJ2ZUZuID0+IHdlaWVyc3RyYXNzKHsgLi4uY3VydmVEZWYsIGhhc2g6IGhhc2ggfSk7XG4gIHJldHVybiB7IC4uLmNyZWF0ZShkZWZIYXNoKSwgY3JlYXRlIH07XG59XG4iLCAiLyoqXG4gKiBTRUNHIHNlY3AyNTZrMS4gU2VlIFtwZGZdKGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzItdjIucGRmKS5cbiAqXG4gKiBCZWxvbmdzIHRvIEtvYmxpdHogY3VydmVzOiBpdCBoYXMgZWZmaWNpZW50bHktY29tcHV0YWJsZSBHTFYgZW5kb21vcnBoaXNtIFx1MDNDOCxcbiAqIGNoZWNrIG91dCB7QGxpbmsgRW5kb21vcnBoaXNtT3B0c30uIFNlZW1zIHRvIGJlIHJpZ2lkIChub3QgYmFja2Rvb3JlZCkuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMi5qcyc7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlQ3VydmUsIHR5cGUgQ3VydmVGbldpdGhDcmVhdGUgfSBmcm9tICcuL19zaG9ydHdfdXRpbHMudHMnO1xuaW1wb3J0IHR5cGUgeyBDdXJ2ZUxlbmd0aHMgfSBmcm9tICcuL2Fic3RyYWN0L2N1cnZlLnRzJztcbmltcG9ydCB7XG4gIGNyZWF0ZUhhc2hlcixcbiAgdHlwZSBIMkNIYXNoZXIsXG4gIHR5cGUgSDJDTWV0aG9kLFxuICBpc29nZW55TWFwLFxufSBmcm9tICcuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUudHMnO1xuaW1wb3J0IHsgRmllbGQsIG1hcEhhc2hUb0ZpZWxkLCBtb2QsIHBvdzIgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIudHMnO1xuaW1wb3J0IHtcbiAgX25vcm1GbkVsZW1lbnQsXG4gIHR5cGUgRW5kb21vcnBoaXNtT3B0cyxcbiAgbWFwVG9DdXJ2ZVNpbXBsZVNXVSxcbiAgdHlwZSBXZWllcnN0cmFzc1BvaW50IGFzIFBvaW50VHlwZSxcbiAgdHlwZSBXZWllcnN0cmFzc09wdHMsXG4gIHR5cGUgV2VpZXJzdHJhc3NQb2ludENvbnMsXG59IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MudHMnO1xuaW1wb3J0IHR5cGUgeyBIZXgsIFByaXZLZXkgfSBmcm9tICcuL3V0aWxzLnRzJztcbmltcG9ydCB7XG4gIGJ5dGVzVG9OdW1iZXJCRSxcbiAgY29uY2F0Qnl0ZXMsXG4gIGVuc3VyZUJ5dGVzLFxuICBpblJhbmdlLFxuICBudW1iZXJUb0J5dGVzQkUsXG4gIHV0ZjhUb0J5dGVzLFxufSBmcm9tICcuL3V0aWxzLnRzJztcblxuLy8gU2VlbXMgbGlrZSBnZW5lcmF0b3Igd2FzIHByb2R1Y2VkIGZyb20gc29tZSBzZWVkOlxuLy8gYFBvaW50LkJBU0UubXVsdGlwbHkoUG9pbnQuRm4uaW52KDJuLCBOKSkudG9BZmZpbmUoKS54YFxuLy8gLy8gZ2l2ZXMgc2hvcnQgeCAweDNiNzhjZTU2M2Y4OWEwZWQ5NDE0ZjVhYTI4YWQwZDk2ZDY3OTVmOWM2M25cbmNvbnN0IHNlY3AyNTZrMV9DVVJWRTogV2VpZXJzdHJhc3NPcHRzPGJpZ2ludD4gPSB7XG4gIHA6IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyksXG4gIG46IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyksXG4gIGg6IEJpZ0ludCgxKSxcbiAgYTogQmlnSW50KDApLFxuICBiOiBCaWdJbnQoNyksXG4gIEd4OiBCaWdJbnQoJzB4NzliZTY2N2VmOWRjYmJhYzU1YTA2Mjk1Y2U4NzBiMDcwMjliZmNkYjJkY2UyOGQ5NTlmMjgxNWIxNmY4MTc5OCcpLFxuICBHeTogQmlnSW50KCcweDQ4M2FkYTc3MjZhM2M0NjU1ZGE0ZmJmYzBlMTEwOGE4ZmQxN2I0NDhhNjg1NTQxOTljNDdkMDhmZmIxMGQ0YjgnKSxcbn07XG5cbmNvbnN0IHNlY3AyNTZrMV9FTkRPOiBFbmRvbW9ycGhpc21PcHRzID0ge1xuICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICBiYXNpc2VzOiBbXG4gICAgW0JpZ0ludCgnMHgzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScpLCAtQmlnSW50KCcweGU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJyldLFxuICAgIFtCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4JyksIEJpZ0ludCgnMHgzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScpXSxcbiAgXSxcbn07XG5cbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKTtcblxuLyoqXG4gKiBcdTIyMUFuID0gbl4oKHArMSkvNCkgZm9yIGZpZWxkcyBwID0gMyBtb2QgNC4gV2UgdW53cmFwIHRoZSBsb29wIGFuZCBtdWx0aXBseSBiaXQtYnktYml0LlxuICogKFArMW4vNG4pLnRvU3RyaW5nKDIpIHdvdWxkIHByb2R1Y2UgYml0cyBbMjIzeCAxLCAwLCAyMnggMSwgNHggMCwgMTEsIDAwXVxuICovXG5mdW5jdGlvbiBzcXJ0TW9kKHk6IGJpZ2ludCk6IGJpZ2ludCB7XG4gIGNvbnN0IFAgPSBzZWNwMjU2azFfQ1VSVkUucDtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIGNvbnN0IF8zbiA9IEJpZ0ludCgzKSwgXzZuID0gQmlnSW50KDYpLCBfMTFuID0gQmlnSW50KDExKSwgXzIybiA9IEJpZ0ludCgyMik7XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBjb25zdCBfMjNuID0gQmlnSW50KDIzKSwgXzQ0biA9IEJpZ0ludCg0NCksIF84OG4gPSBCaWdJbnQoODgpO1xuICBjb25zdCBiMiA9ICh5ICogeSAqIHkpICUgUDsgLy8geF4zLCAxMVxuICBjb25zdCBiMyA9IChiMiAqIGIyICogeSkgJSBQOyAvLyB4XjdcbiAgY29uc3QgYjYgPSAocG93MihiMywgXzNuLCBQKSAqIGIzKSAlIFA7XG4gIGNvbnN0IGI5ID0gKHBvdzIoYjYsIF8zbiwgUCkgKiBiMykgJSBQO1xuICBjb25zdCBiMTEgPSAocG93MihiOSwgXzJuLCBQKSAqIGIyKSAlIFA7XG4gIGNvbnN0IGIyMiA9IChwb3cyKGIxMSwgXzExbiwgUCkgKiBiMTEpICUgUDtcbiAgY29uc3QgYjQ0ID0gKHBvdzIoYjIyLCBfMjJuLCBQKSAqIGIyMikgJSBQO1xuICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gIGNvbnN0IGIxNzYgPSAocG93MihiODgsIF84OG4sIFApICogYjg4KSAlIFA7XG4gIGNvbnN0IGIyMjAgPSAocG93MihiMTc2LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gIGNvbnN0IHQxID0gKHBvdzIoYjIyMywgXzIzbiwgUCkgKiBiMjIpICUgUDtcbiAgY29uc3QgdDIgPSAocG93Mih0MSwgXzZuLCBQKSAqIGIyKSAlIFA7XG4gIGNvbnN0IHJvb3QgPSBwb3cyKHQyLCBfMm4sIFApO1xuICBpZiAoIUZwazEuZXFsKEZwazEuc3FyKHJvb3QpLCB5KSkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICByZXR1cm4gcm9vdDtcbn1cblxuY29uc3QgRnBrMSA9IEZpZWxkKHNlY3AyNTZrMV9DVVJWRS5wLCB7IHNxcnQ6IHNxcnRNb2QgfSk7XG5cbi8qKlxuICogc2VjcDI1NmsxIGN1cnZlLCBFQ0RTQSBhbmQgRUNESCBtZXRob2RzLlxuICpcbiAqIEZpZWxkOiBgMm4qKjI1Nm4gLSAybioqMzJuIC0gMm4qKjluIC0gMm4qKjhuIC0gMm4qKjduIC0gMm4qKjZuIC0gMm4qKjRuIC0gMW5gXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMSc7XG4gKiBjb25zdCB7IHNlY3JldEtleSwgcHVibGljS2V5IH0gPSBzZWNwMjU2azEua2V5Z2VuKCk7XG4gKiBjb25zdCBtc2cgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoJ2hlbGxvJyk7XG4gKiBjb25zdCBzaWcgPSBzZWNwMjU2azEuc2lnbihtc2csIHNlY3JldEtleSk7XG4gKiBjb25zdCBpc1ZhbGlkID0gc2VjcDI1NmsxLnZlcmlmeShzaWcsIG1zZywgcHVibGljS2V5KSA9PT0gdHJ1ZTtcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3Qgc2VjcDI1NmsxOiBDdXJ2ZUZuV2l0aENyZWF0ZSA9IGNyZWF0ZUN1cnZlKFxuICB7IC4uLnNlY3AyNTZrMV9DVVJWRSwgRnA6IEZwazEsIGxvd1M6IHRydWUsIGVuZG86IHNlY3AyNTZrMV9FTkRPIH0sXG4gIHNoYTI1NlxuKTtcblxuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG4vKiogQW4gb2JqZWN0IG1hcHBpbmcgdGFncyB0byB0aGVpciB0YWdnZWQgaGFzaCBwcmVmaXggb2YgW1NIQTI1Nih0YWcpIHwgU0hBMjU2KHRhZyldICovXG5jb25zdCBUQUdHRURfSEFTSF9QUkVGSVhFUzogeyBbdGFnOiBzdHJpbmddOiBVaW50OEFycmF5IH0gPSB7fTtcbmZ1bmN0aW9uIHRhZ2dlZEhhc2godGFnOiBzdHJpbmcsIC4uLm1lc3NhZ2VzOiBVaW50OEFycmF5W10pOiBVaW50OEFycmF5IHtcbiAgbGV0IHRhZ1AgPSBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddO1xuICBpZiAodGFnUCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgdGFnSCA9IHNoYTI1Nih1dGY4VG9CeXRlcyh0YWcpKTtcbiAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXSA9IHRhZ1A7XG4gIH1cbiAgcmV0dXJuIHNoYTI1Nihjb25jYXRCeXRlcyh0YWdQLCAuLi5tZXNzYWdlcykpO1xufVxuXG4vLyBFQ0RTQSBjb21wYWN0IHBvaW50cyBhcmUgMzMtYnl0ZS4gU2Nobm9yciBpcyAzMjogd2Ugc3RyaXAgZmlyc3QgYnl0ZSAweDAyIG9yIDB4MDNcbmNvbnN0IHBvaW50VG9CeXRlcyA9IChwb2ludDogUG9pbnRUeXBlPGJpZ2ludD4pID0+IHBvaW50LnRvQnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG5jb25zdCBQb2ludGsxID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBzZWNwMjU2azEuUG9pbnQpKCk7XG5jb25zdCBoYXNFdmVuID0gKHk6IGJpZ2ludCkgPT4geSAlIF8ybiA9PT0gXzBuO1xuXG4vLyBDYWxjdWxhdGUgcG9pbnQsIHNjYWxhciBhbmQgYnl0ZXNcbmZ1bmN0aW9uIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdjogUHJpdktleSkge1xuICBjb25zdCB7IEZuLCBCQVNFIH0gPSBQb2ludGsxO1xuICBjb25zdCBkXyA9IF9ub3JtRm5FbGVtZW50KEZuLCBwcml2KTtcbiAgY29uc3QgcCA9IEJBU0UubXVsdGlwbHkoZF8pOyAvLyBQID0gZCdcdTIyQzVHOyAwIDwgZCcgPCBuIGNoZWNrIGlzIGRvbmUgaW5zaWRlXG4gIGNvbnN0IHNjYWxhciA9IGhhc0V2ZW4ocC55KSA/IGRfIDogRm4ubmVnKGRfKTtcbiAgcmV0dXJuIHsgc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4OiBiaWdpbnQpOiBQb2ludFR5cGU8YmlnaW50PiB7XG4gIGNvbnN0IEZwID0gRnBrMTtcbiAgaWYgKCFGcC5pc1ZhbGlkTm90MCh4KSkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHg6IEZhaWwgaWYgeCBcdTIyNjUgcCcpO1xuICBjb25zdCB4eCA9IEZwLmNyZWF0ZSh4ICogeCk7XG4gIGNvbnN0IGMgPSBGcC5jcmVhdGUoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4XHUwMEIzICsgNyBtb2QgcC5cbiAgbGV0IHkgPSBGcC5zcXJ0KGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC4gU2FtZSBhcyBzcXJ0KCkuXG4gIC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAvLyB5KFApID0geSBpZiB5IG1vZCAyID0gMCBvciB5KFApID0gcC15IG90aGVyd2lzZS5cbiAgaWYgKCFoYXNFdmVuKHkpKSB5ID0gRnAubmVnKHkpO1xuICBjb25zdCBwID0gUG9pbnRrMS5mcm9tQWZmaW5lKHsgeCwgeSB9KTtcbiAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICByZXR1cm4gcDtcbn1cbmNvbnN0IG51bSA9IGJ5dGVzVG9OdW1iZXJCRTtcbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJnczogVWludDhBcnJheVtdKTogYmlnaW50IHtcbiAgcmV0dXJuIFBvaW50azEuRm4uY3JlYXRlKG51bSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG5cbi8qKlxuICogU2Nobm9yciBwdWJsaWMga2V5IGlzIGp1c3QgYHhgIGNvb3JkaW5hdGUgb2YgUG9pbnQgYXMgcGVyIEJJUDM0MC5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShzZWNyZXRLZXk6IEhleCk6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gc2Nobm9yckdldEV4dFB1YktleShzZWNyZXRLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCdcdTIyNjVuLiBSZXQgYnl0ZXMoZCdcdTIyQzVHKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgU2Nobm9yciBzaWduYXR1cmUgYXMgcGVyIEJJUDM0MC4gVmVyaWZpZXMgaXRzZWxmIGJlZm9yZSByZXR1cm5pbmcgYW55dGhpbmcuXG4gKiBhdXhSYW5kIGlzIG9wdGlvbmFsIGFuZCBpcyBub3QgdGhlIHNvbGUgc291cmNlIG9mIGsgZ2VuZXJhdGlvbjogYmFkIENTUFJORyB3b24ndCBiZSBkYW5nZXJvdXMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJTaWduKG1lc3NhZ2U6IEhleCwgc2VjcmV0S2V5OiBQcml2S2V5LCBhdXhSYW5kOiBIZXggPSByYW5kb21CeXRlcygzMikpOiBVaW50OEFycmF5IHtcbiAgY29uc3QgeyBGbiB9ID0gUG9pbnRrMTtcbiAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gIGNvbnN0IHsgYnl0ZXM6IHB4LCBzY2FsYXI6IGQgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoc2VjcmV0S2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgY29uc3QgYSA9IGVuc3VyZUJ5dGVzKCdhdXhSYW5kJywgYXV4UmFuZCwgMzIpOyAvLyBBdXhpbGlhcnkgcmFuZG9tIGRhdGEgYTogYSAzMi1ieXRlIGFycmF5XG4gIGNvbnN0IHQgPSBGbi50b0J5dGVzKGQgXiBudW0odGFnZ2VkSGFzaCgnQklQMDM0MC9hdXgnLCBhKSkpOyAvLyBMZXQgdCBiZSB0aGUgYnl0ZS13aXNlIHhvciBvZiBieXRlcyhkKSBhbmQgaGFzaC9hdXgoYSlcbiAgY29uc3QgcmFuZCA9IHRhZ2dlZEhhc2goJ0JJUDAzNDAvbm9uY2UnLCB0LCBweCwgbSk7IC8vIExldCByYW5kID0gaGFzaC9ub25jZSh0IHx8IGJ5dGVzKFApIHx8IG0pXG4gIC8vIExldCBrJyA9IGludChyYW5kKSBtb2Qgbi4gRmFpbCBpZiBrJyA9IDAuIExldCBSID0gaydcdTIyQzVHXG4gIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkocmFuZCk7XG4gIGNvbnN0IGUgPSBjaGFsbGVuZ2UocngsIHB4LCBtKTsgLy8gTGV0IGUgPSBpbnQoaGFzaC9jaGFsbGVuZ2UoYnl0ZXMoUikgfHwgYnl0ZXMoUCkgfHwgbSkpIG1vZCBuLlxuICBjb25zdCBzaWcgPSBuZXcgVWludDhBcnJheSg2NCk7IC8vIExldCBzaWcgPSBieXRlcyhSKSB8fCBieXRlcygoayArIGVkKSBtb2QgbikuXG4gIHNpZy5zZXQocngsIDApO1xuICBzaWcuc2V0KEZuLnRvQnl0ZXMoRm4uY3JlYXRlKGsgKyBlICogZCkpLCAzMik7XG4gIC8vIElmIFZlcmlmeShieXRlcyhQKSwgbSwgc2lnKSAoc2VlIGJlbG93KSByZXR1cm5zIGZhaWx1cmUsIGFib3J0XG4gIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSkgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICByZXR1cm4gc2lnO1xufVxuXG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuICogV2lsbCBzd2FsbG93IGVycm9ycyAmIHJldHVybiBmYWxzZSBleGNlcHQgZm9yIGluaXRpYWwgdHlwZSB2YWxpZGF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmU6IEhleCwgbWVzc2FnZTogSGV4LCBwdWJsaWNLZXk6IEhleCk6IGJvb2xlYW4ge1xuICBjb25zdCB7IEZuLCBCQVNFIH0gPSBQb2ludGsxO1xuICBjb25zdCBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XG4gIGNvbnN0IG0gPSBlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICBjb25zdCBwdWIgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5LCAzMik7XG4gIHRyeSB7XG4gICAgY29uc3QgUCA9IGxpZnRfeChudW0ocHViKSk7IC8vIFAgPSBsaWZ0X3goaW50KHBrKSk7IGZhaWwgaWYgdGhhdCBmYWlsc1xuICAgIGNvbnN0IHIgPSBudW0oc2lnLnN1YmFycmF5KDAsIDMyKSk7IC8vIExldCByID0gaW50KHNpZ1swOjMyXSk7IGZhaWwgaWYgciBcdTIyNjUgcC5cbiAgICBpZiAoIWluUmFuZ2UociwgXzFuLCBzZWNwMjU2azFfQ1VSVkUucCkpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBzID0gbnVtKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyBcdTIyNjUgbi5cbiAgICBpZiAoIWluUmFuZ2UocywgXzFuLCBzZWNwMjU2azFfQ1VSVkUubikpIHJldHVybiBmYWxzZTtcbiAgICAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKEZuLnRvQnl0ZXMociksIHBvaW50VG9CeXRlcyhQKSwgbSk7XG4gICAgLy8gUiA9IHNcdTIyQzVHIC0gZVx1MjJDNVAsIHdoZXJlIC1lUCA9PSAobi1lKVBcbiAgICBjb25zdCBSID0gQkFTRS5tdWx0aXBseVVuc2FmZShzKS5hZGQoUC5tdWx0aXBseVVuc2FmZShGbi5uZWcoZSkpKTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IFIudG9BZmZpbmUoKTtcbiAgICAvLyBGYWlsIGlmIGlzX2luZmluaXRlKFIpIC8gbm90IGhhc19ldmVuX3koUikgLyB4KFIpIFx1MjI2MCByLlxuICAgIGlmIChSLmlzMCgpIHx8ICFoYXNFdmVuKHkpIHx8IHggIT09IHIpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgU2VjcFNjaG5vcnIgPSB7XG4gIGtleWdlbjogKHNlZWQ/OiBVaW50OEFycmF5KSA9PiB7IHNlY3JldEtleTogVWludDhBcnJheTsgcHVibGljS2V5OiBVaW50OEFycmF5IH07XG4gIGdldFB1YmxpY0tleTogdHlwZW9mIHNjaG5vcnJHZXRQdWJsaWNLZXk7XG4gIHNpZ246IHR5cGVvZiBzY2hub3JyU2lnbjtcbiAgdmVyaWZ5OiB0eXBlb2Ygc2Nobm9yclZlcmlmeTtcbiAgUG9pbnQ6IFdlaWVyc3RyYXNzUG9pbnRDb25zPGJpZ2ludD47XG4gIHV0aWxzOiB7XG4gICAgcmFuZG9tU2VjcmV0S2V5OiAoc2VlZD86IFVpbnQ4QXJyYXkpID0+IFVpbnQ4QXJyYXk7XG4gICAgcG9pbnRUb0J5dGVzOiAocG9pbnQ6IFBvaW50VHlwZTxiaWdpbnQ+KSA9PiBVaW50OEFycmF5O1xuICAgIGxpZnRfeDogdHlwZW9mIGxpZnRfeDtcbiAgICB0YWdnZWRIYXNoOiB0eXBlb2YgdGFnZ2VkSGFzaDtcblxuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgYHJhbmRvbVNlY3JldEtleWAgKi9cbiAgICByYW5kb21Qcml2YXRlS2V5OiAoc2VlZD86IFVpbnQ4QXJyYXkpID0+IFVpbnQ4QXJyYXk7XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBgdXRpbHNgICovXG4gICAgbnVtYmVyVG9CeXRlc0JFOiB0eXBlb2YgbnVtYmVyVG9CeXRlc0JFO1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgYHV0aWxzYCAqL1xuICAgIGJ5dGVzVG9OdW1iZXJCRTogdHlwZW9mIGJ5dGVzVG9OdW1iZXJCRTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIGBtb2R1bGFyYCAqL1xuICAgIG1vZDogdHlwZW9mIG1vZDtcbiAgfTtcbiAgbGVuZ3RoczogQ3VydmVMZW5ndGhzO1xufTtcbi8qKlxuICogU2Nobm9yciBzaWduYXR1cmVzIG92ZXIgc2VjcDI1NmsxLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgc2Nobm9yciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbiAqIGNvbnN0IHsgc2VjcmV0S2V5LCBwdWJsaWNLZXkgfSA9IHNjaG5vcnIua2V5Z2VuKCk7XG4gKiAvLyBjb25zdCBwdWJsaWNLZXkgPSBzY2hub3JyLmdldFB1YmxpY0tleShzZWNyZXRLZXkpO1xuICogY29uc3QgbXNnID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdoZWxsbycpO1xuICogY29uc3Qgc2lnID0gc2Nobm9yci5zaWduKG1zZywgc2VjcmV0S2V5KTtcbiAqIGNvbnN0IGlzVmFsaWQgPSBzY2hub3JyLnZlcmlmeShzaWcsIG1zZywgcHVibGljS2V5KTtcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3Qgc2Nobm9ycjogU2VjcFNjaG5vcnIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgY29uc3Qgc2l6ZSA9IDMyO1xuICBjb25zdCBzZWVkTGVuZ3RoID0gNDg7XG4gIGNvbnN0IHJhbmRvbVNlY3JldEtleSA9IChzZWVkID0gcmFuZG9tQnl0ZXMoc2VlZExlbmd0aCkpOiBVaW50OEFycmF5ID0+IHtcbiAgICByZXR1cm4gbWFwSGFzaFRvRmllbGQoc2VlZCwgc2VjcDI1NmsxX0NVUlZFLm4pO1xuICB9O1xuICAvLyBUT0RPOiByZW1vdmVcbiAgc2VjcDI1NmsxLnV0aWxzLnJhbmRvbVNlY3JldEtleTtcbiAgZnVuY3Rpb24ga2V5Z2VuKHNlZWQ/OiBVaW50OEFycmF5KSB7XG4gICAgY29uc3Qgc2VjcmV0S2V5ID0gcmFuZG9tU2VjcmV0S2V5KHNlZWQpO1xuICAgIHJldHVybiB7IHNlY3JldEtleSwgcHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5KHNlY3JldEtleSkgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGtleWdlbixcbiAgICBnZXRQdWJsaWNLZXk6IHNjaG5vcnJHZXRQdWJsaWNLZXksXG4gICAgc2lnbjogc2Nobm9yclNpZ24sXG4gICAgdmVyaWZ5OiBzY2hub3JyVmVyaWZ5LFxuICAgIFBvaW50OiBQb2ludGsxLFxuICAgIHV0aWxzOiB7XG4gICAgICByYW5kb21TZWNyZXRLZXk6IHJhbmRvbVNlY3JldEtleSxcbiAgICAgIHJhbmRvbVByaXZhdGVLZXk6IHJhbmRvbVNlY3JldEtleSxcbiAgICAgIHRhZ2dlZEhhc2gsXG5cbiAgICAgIC8vIFRPRE86IHJlbW92ZVxuICAgICAgbGlmdF94LFxuICAgICAgcG9pbnRUb0J5dGVzLFxuICAgICAgbnVtYmVyVG9CeXRlc0JFLFxuICAgICAgYnl0ZXNUb051bWJlckJFLFxuICAgICAgbW9kLFxuICAgIH0sXG4gICAgbGVuZ3Roczoge1xuICAgICAgc2VjcmV0S2V5OiBzaXplLFxuICAgICAgcHVibGljS2V5OiBzaXplLFxuICAgICAgcHVibGljS2V5SGFzUHJlZml4OiBmYWxzZSxcbiAgICAgIHNpZ25hdHVyZTogc2l6ZSAqIDIsXG4gICAgICBzZWVkOiBzZWVkTGVuZ3RoLFxuICAgIH0sXG4gIH07XG59KSgpO1xuXG5jb25zdCBpc29NYXAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+XG4gIGlzb2dlbnlNYXAoXG4gICAgRnBrMSxcbiAgICBbXG4gICAgICAvLyB4TnVtXG4gICAgICBbXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4YzcnLFxuICAgICAgICAnMHg3ZDNkNGM4MGJjMzIxZDViOWYzMTVjZWE3ZmQ0NGM1ZDU5NWQyZmMwYmY2M2I5MmRmZmYxMDQ0ZjE3YzY1ODEnLFxuICAgICAgICAnMHg1MzRjMzI4ZDIzZjIzNGU2ZTJhNDEzZGVjYTI1Y2FlY2U0NTA2MTQ0MDM3YzQwMzE0ZWNiZDBiNTNkOWRkMjYyJyxcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYTg4YycsXG4gICAgICBdLFxuICAgICAgLy8geERlblxuICAgICAgW1xuICAgICAgICAnMHhkMzU3NzExOTNkOTQ5MThhOWNhMzRjY2JiN2I2NDBkZDg2Y2Q0MDk1NDJmODQ4N2Q5ZmU2Yjc0NTc4MWViNDliJyxcbiAgICAgICAgJzB4ZWRhZGM2ZjY0MzgzZGMxZGY3YzRiMmQ1MWI1NDIyNTQwNmQzNmI2NDFmNWU0MWJiYzUyYTU2NjEyYThjNmQxNCcsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICAgIF0sXG4gICAgICAvLyB5TnVtXG4gICAgICBbXG4gICAgICAgICcweDRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiOGUzOGUyM2MnLFxuICAgICAgICAnMHhjNzVlMGMzMmQ1Y2I3YzBmYTlkMGE1NGIxMmEwYTZkNTY0N2FiMDQ2ZDY4NmRhNmZkZmZjOTBmYzIwMWQ3MWEzJyxcbiAgICAgICAgJzB4MjlhNjE5NDY5MWY5MWE3MzcxNTIwOWVmNjUxMmU1NzY3MjI4MzBhMjAxYmUyMDE4YTc2NWU4NWE5ZWNlZTkzMScsXG4gICAgICAgICcweDJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmMzhlMzhkODQnLFxuICAgICAgXSxcbiAgICAgIC8vIHlEZW5cbiAgICAgIFtcbiAgICAgICAgJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZjkzYicsXG4gICAgICAgICcweDdhMDY1MzRiYjhiZGI0OWZkNWU5ZTY2MzI3MjJjMjk4OTQ2N2MxYmZjOGU4ZDk3OGRmYjQyNWQyNjg1YzI1NzMnLFxuICAgICAgICAnMHg2NDg0YWE3MTY1NDVjYTJjZjNhNzBjM2ZhOGZlMzM3ZTBhM2QyMTE2MmYwZDYyOTlhN2JmODE5MmJmZDJhNzZmJyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgICAgXSxcbiAgICBdLm1hcCgoaSkgPT4gaS5tYXAoKGopID0+IEJpZ0ludChqKSkpIGFzIFtiaWdpbnRbXSwgYmlnaW50W10sIGJpZ2ludFtdLCBiaWdpbnRbXV1cbiAgKSkoKTtcbmNvbnN0IG1hcFNXVSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT5cbiAgbWFwVG9DdXJ2ZVNpbXBsZVNXVShGcGsxLCB7XG4gICAgQTogQmlnSW50KCcweDNmODczMWFiZGQ2NjFhZGNhMDhhNTU1OGYwZjVkMjcyZTk1M2QzNjNjYjZmMGU1ZDQwNTQ0N2MwMWE0NDQ1MzMnKSxcbiAgICBCOiBCaWdJbnQoJzE3NzEnKSxcbiAgICBaOiBGcGsxLmNyZWF0ZShCaWdJbnQoJy0xMScpKSxcbiAgfSkpKCk7XG5cbi8qKiBIYXNoaW5nIC8gZW5jb2RpbmcgdG8gc2VjcDI1NmsxIHBvaW50cyAvIGZpZWxkLiBSRkMgOTM4MCBtZXRob2RzLiAqL1xuZXhwb3J0IGNvbnN0IHNlY3AyNTZrMV9oYXNoZXI6IEgyQ0hhc2hlcjxiaWdpbnQ+ID0gLyogQF9fUFVSRV9fICovICgoKSA9PlxuICBjcmVhdGVIYXNoZXIoXG4gICAgc2VjcDI1NmsxLlBvaW50LFxuICAgIChzY2FsYXJzOiBiaWdpbnRbXSkgPT4ge1xuICAgICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnBrMS5jcmVhdGUoc2NhbGFyc1swXSkpO1xuICAgICAgcmV0dXJuIGlzb01hcCh4LCB5KTtcbiAgICB9LFxuICAgIHtcbiAgICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgICBlbmNvZGVEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9OVV8nLFxuICAgICAgcDogRnBrMS5PUkRFUixcbiAgICAgIG06IDEsXG4gICAgICBrOiAxMjgsXG4gICAgICBleHBhbmQ6ICd4bWQnLFxuICAgICAgaGFzaDogc2hhMjU2LFxuICAgIH1cbiAgKSkoKTtcblxuLyoqIEBkZXByZWNhdGVkIHVzZSBgaW1wb3J0IHsgc2VjcDI1NmsxX2hhc2hlciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxLmpzJztgICovXG5leHBvcnQgY29uc3QgaGFzaFRvQ3VydmU6IEgyQ01ldGhvZDxiaWdpbnQ+ID0gLyogQF9fUFVSRV9fICovICgoKSA9PlxuICBzZWNwMjU2azFfaGFzaGVyLmhhc2hUb0N1cnZlKSgpO1xuXG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBpbXBvcnQgeyBzZWNwMjU2azFfaGFzaGVyIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEuanMnO2AgKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVUb0N1cnZlOiBIMkNNZXRob2Q8YmlnaW50PiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT5cbiAgc2VjcDI1NmsxX2hhc2hlci5lbmNvZGVUb0N1cnZlKSgpO1xuIiwgIi8qXHJcbiAqICAgICAgYmlnbnVtYmVyLmpzIHY5LjMuMVxyXG4gKiAgICAgIEEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBhcmJpdHJhcnktcHJlY2lzaW9uIGFyaXRobWV0aWMuXHJcbiAqICAgICAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnbnVtYmVyLmpzXHJcbiAqICAgICAgQ29weXJpZ2h0IChjKSAyMDI1IE1pY2hhZWwgTWNsYXVnaGxpbiA8TThjaDg4bEBnbWFpbC5jb20+XHJcbiAqICAgICAgTUlUIExpY2Vuc2VkLlxyXG4gKlxyXG4gKiAgICAgIEJpZ051bWJlci5wcm90b3R5cGUgbWV0aG9kcyAgICAgfCAgQmlnTnVtYmVyIG1ldGhvZHNcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBhYnNvbHV0ZVZhbHVlICAgICAgICAgICAgYWJzICAgIHwgIGNsb25lXHJcbiAqICAgICAgY29tcGFyZWRUbyAgICAgICAgICAgICAgICAgICAgICB8ICBjb25maWcgICAgICAgICAgICAgICBzZXRcclxuICogICAgICBkZWNpbWFsUGxhY2VzICAgICAgICAgICAgZHAgICAgIHwgICAgICBERUNJTUFMX1BMQUNFU1xyXG4gKiAgICAgIGRpdmlkZWRCeSAgICAgICAgICAgICAgICBkaXYgICAgfCAgICAgIFJPVU5ESU5HX01PREVcclxuICogICAgICBkaXZpZGVkVG9JbnRlZ2VyQnkgICAgICAgaWRpdiAgIHwgICAgICBFWFBPTkVOVElBTF9BVFxyXG4gKiAgICAgIGV4cG9uZW50aWF0ZWRCeSAgICAgICAgICBwb3cgICAgfCAgICAgIFJBTkdFXHJcbiAqICAgICAgaW50ZWdlclZhbHVlICAgICAgICAgICAgICAgICAgICB8ICAgICAgQ1JZUFRPXHJcbiAqICAgICAgaXNFcXVhbFRvICAgICAgICAgICAgICAgIGVxICAgICB8ICAgICAgTU9EVUxPX01PREVcclxuICogICAgICBpc0Zpbml0ZSAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICBQT1dfUFJFQ0lTSU9OXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbiAgICAgICAgICAgIGd0ICAgICB8ICAgICAgRk9STUFUXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyAgIGd0ZSAgICB8ICAgICAgQUxQSEFCRVRcclxuICogICAgICBpc0ludGVnZXIgICAgICAgICAgICAgICAgICAgICAgIHwgIGlzQmlnTnVtYmVyXHJcbiAqICAgICAgaXNMZXNzVGhhbiAgICAgICAgICAgICAgIGx0ICAgICB8ICBtYXhpbXVtICAgICAgICAgICAgICBtYXhcclxuICogICAgICBpc0xlc3NUaGFuT3JFcXVhbFRvICAgICAgbHRlICAgIHwgIG1pbmltdW0gICAgICAgICAgICAgIG1pblxyXG4gKiAgICAgIGlzTmFOICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgcmFuZG9tXHJcbiAqICAgICAgaXNOZWdhdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8ICBzdW1cclxuICogICAgICBpc1Bvc2l0aXZlICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBpc1plcm8gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtaW51cyAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtb2R1bG8gICAgICAgICAgICAgICAgICAgbW9kICAgIHxcclxuICogICAgICBtdWx0aXBsaWVkQnkgICAgICAgICAgICAgdGltZXMgIHxcclxuICogICAgICBuZWdhdGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwbHVzICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwcmVjaXNpb24gICAgICAgICAgICAgICAgc2QgICAgIHxcclxuICogICAgICBzaGlmdGVkQnkgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBzcXVhcmVSb290ICAgICAgICAgICAgICAgc3FydCAgIHxcclxuICogICAgICB0b0V4cG9uZW50aWFsICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZpeGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0Zvcm1hdCAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZyYWN0aW9uICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0pTT04gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b051bWJlciAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1ByZWNpc2lvbiAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1N0cmluZyAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB2YWx1ZU9mICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICpcclxuICovXHJcblxyXG5cclxudmFyXHJcbiAgaXNOdW1lcmljID0gL14tPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoPzplWystXT9cXGQrKT8kL2ksXHJcbiAgbWF0aGNlaWwgPSBNYXRoLmNlaWwsXHJcbiAgbWF0aGZsb29yID0gTWF0aC5mbG9vcixcclxuXHJcbiAgYmlnbnVtYmVyRXJyb3IgPSAnW0JpZ051bWJlciBFcnJvcl0gJyxcclxuICB0b29NYW55RGlnaXRzID0gYmlnbnVtYmVyRXJyb3IgKyAnTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czogJyxcclxuXHJcbiAgQkFTRSA9IDFlMTQsXHJcbiAgTE9HX0JBU0UgPSAxNCxcclxuICBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZiwgICAgICAgICAvLyAyXjUzIC0gMVxyXG4gIC8vIE1BWF9JTlQzMiA9IDB4N2ZmZmZmZmYsICAgICAgICAgICAgICAgICAgIC8vIDJeMzEgLSAxXHJcbiAgUE9XU19URU4gPSBbMSwgMTAsIDEwMCwgMWUzLCAxZTQsIDFlNSwgMWU2LCAxZTcsIDFlOCwgMWU5LCAxZTEwLCAxZTExLCAxZTEyLCAxZTEzXSxcclxuICBTUVJUX0JBU0UgPSAxZTcsXHJcblxyXG4gIC8vIEVESVRBQkxFXHJcbiAgLy8gVGhlIGxpbWl0IG9uIHRoZSB2YWx1ZSBvZiBERUNJTUFMX1BMQUNFUywgVE9fRVhQX05FRywgVE9fRVhQX1BPUywgTUlOX0VYUCwgTUFYX0VYUCwgYW5kXHJcbiAgLy8gdGhlIGFyZ3VtZW50cyB0byB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCwgYW5kIHRvUHJlY2lzaW9uLlxyXG4gIE1BWCA9IDFFOTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYX0lOVDMyXHJcblxyXG5cclxuLypcclxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBCaWdOdW1iZXIgY29uc3RydWN0b3IuXHJcbiAqL1xyXG5mdW5jdGlvbiBjbG9uZShjb25maWdPYmplY3QpIHtcclxuICB2YXIgZGl2LCBjb252ZXJ0QmFzZSwgcGFyc2VOdW1lcmljLFxyXG4gICAgUCA9IEJpZ051bWJlci5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBCaWdOdW1iZXIsIHRvU3RyaW5nOiBudWxsLCB2YWx1ZU9mOiBudWxsIH0sXHJcbiAgICBPTkUgPSBuZXcgQmlnTnVtYmVyKDEpLFxyXG5cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVESVRBQkxFIENPTkZJRyBERUZBVUxUUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlcyBiZWxvdyBtdXN0IGJlIGludGVnZXJzIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlcyBzdGF0ZWQuXHJcbiAgICAvLyBUaGUgdmFsdWVzIGNhbiBhbHNvIGJlIGNoYW5nZWQgYXQgcnVuLXRpbWUgdXNpbmcgQmlnTnVtYmVyLnNldC5cclxuXHJcbiAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIG9wZXJhdGlvbnMgaW52b2x2aW5nIGRpdmlzaW9uLlxyXG4gICAgREVDSU1BTF9QTEFDRVMgPSAyMCwgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgIC8vIFRoZSByb3VuZGluZyBtb2RlIHVzZWQgd2hlbiByb3VuZGluZyB0byB0aGUgYWJvdmUgZGVjaW1hbCBwbGFjZXMsIGFuZCB3aGVuIHVzaW5nXHJcbiAgICAvLyB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCBhbmQgdG9QcmVjaXNpb24sIGFuZCByb3VuZCAoZGVmYXVsdCB2YWx1ZSkuXHJcbiAgICAvLyBVUCAgICAgICAgIDAgQXdheSBmcm9tIHplcm8uXHJcbiAgICAvLyBET1dOICAgICAgIDEgVG93YXJkcyB6ZXJvLlxyXG4gICAgLy8gQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgLy8gRkxPT1IgICAgICAzIFRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgLy8gSEFMRl9VUCAgICA0IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB1cC5cclxuICAgIC8vIEhBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cclxuICAgIC8vIEhBTEZfRVZFTiAgNiBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyBldmVuIG5laWdoYm91ci5cclxuICAgIC8vIEhBTEZfQ0VJTCAgNyBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAvLyBIQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgUk9VTkRJTkdfTU9ERSA9IDQsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDhcclxuXHJcbiAgICAvLyBFWFBPTkVOVElBTF9BVCA6IFtUT19FWFBfTkVHICwgVE9fRVhQX1BPU11cclxuXHJcbiAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGJlbmVhdGggd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgIC8vIE51bWJlciB0eXBlOiAtN1xyXG4gICAgVE9fRVhQX05FRyA9IC03LCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIC1NQVhcclxuXHJcbiAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAvLyBOdW1iZXIgdHlwZTogMjFcclxuICAgIFRPX0VYUF9QT1MgPSAyMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAvLyBSQU5HRSA6IFtNSU5fRVhQLCBNQVhfRVhQXVxyXG5cclxuICAgIC8vIFRoZSBtaW5pbXVtIGV4cG9uZW50IHZhbHVlLCBiZW5lYXRoIHdoaWNoIHVuZGVyZmxvdyB0byB6ZXJvIG9jY3Vycy5cclxuICAgIC8vIE51bWJlciB0eXBlOiAtMzI0ICAoNWUtMzI0KVxyXG4gICAgTUlOX0VYUCA9IC0xZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtMSB0byAtTUFYXHJcblxyXG4gICAgLy8gVGhlIG1heGltdW0gZXhwb25lbnQgdmFsdWUsIGFib3ZlIHdoaWNoIG92ZXJmbG93IHRvIEluZmluaXR5IG9jY3Vycy5cclxuICAgIC8vIE51bWJlciB0eXBlOiAgMzA4ICAoMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpXHJcbiAgICAvLyBGb3IgTUFYX0VYUCA+IDFlNywgZS5nLiBuZXcgQmlnTnVtYmVyKCcxZTEwMDAwMDAwMCcpLnBsdXMoMSkgbWF5IGJlIHNsb3cuXHJcbiAgICBNQVhfRVhQID0gMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEgdG8gTUFYXHJcblxyXG4gICAgLy8gV2hldGhlciB0byB1c2UgY3J5cHRvZ3JhcGhpY2FsbHktc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiwgaWYgYXZhaWxhYmxlLlxyXG4gICAgQ1JZUFRPID0gZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlIG9yIGZhbHNlXHJcblxyXG4gICAgLy8gVGhlIG1vZHVsbyBtb2RlIHVzZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgbW9kdWx1czogYSBtb2Qgbi5cclxuICAgIC8vIFRoZSBxdW90aWVudCAocSA9IGEgLyBuKSBpcyBjYWxjdWxhdGVkIGFjY29yZGluZyB0byB0aGUgY29ycmVzcG9uZGluZyByb3VuZGluZyBtb2RlLlxyXG4gICAgLy8gVGhlIHJlbWFpbmRlciAocikgaXMgY2FsY3VsYXRlZCBhczogciA9IGEgLSBuICogcS5cclxuICAgIC8vXHJcbiAgICAvLyBVUCAgICAgICAgMCBUaGUgcmVtYWluZGVyIGlzIHBvc2l0aXZlIGlmIHRoZSBkaXZpZGVuZCBpcyBuZWdhdGl2ZSwgZWxzZSBpcyBuZWdhdGl2ZS5cclxuICAgIC8vIERPV04gICAgICAxIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlkZW5kLlxyXG4gICAgLy8gICAgICAgICAgICAgVGhpcyBtb2R1bG8gbW9kZSBpcyBjb21tb25seSBrbm93biBhcyAndHJ1bmNhdGVkIGRpdmlzaW9uJyBhbmQgaXNcclxuICAgIC8vICAgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gKGEgJSBuKSBpbiBKYXZhU2NyaXB0LlxyXG4gICAgLy8gRkxPT1IgICAgIDMgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aXNvciAoUHl0aG9uICUpLlxyXG4gICAgLy8gSEFMRl9FVkVOIDYgVGhpcyBtb2R1bG8gbW9kZSBpbXBsZW1lbnRzIHRoZSBJRUVFIDc1NCByZW1haW5kZXIgZnVuY3Rpb24uXHJcbiAgICAvLyBFVUNMSUQgICAgOSBFdWNsaWRpYW4gZGl2aXNpb24uIHEgPSBzaWduKG4pICogZmxvb3IoYSAvIGFicyhuKSkuXHJcbiAgICAvLyAgICAgICAgICAgICBUaGUgcmVtYWluZGVyIGlzIGFsd2F5cyBwb3NpdGl2ZS5cclxuICAgIC8vXHJcbiAgICAvLyBUaGUgdHJ1bmNhdGVkIGRpdmlzaW9uLCBmbG9vcmVkIGRpdmlzaW9uLCBFdWNsaWRpYW4gZGl2aXNpb24gYW5kIElFRUUgNzU0IHJlbWFpbmRlclxyXG4gICAgLy8gbW9kZXMgYXJlIGNvbW1vbmx5IHVzZWQgZm9yIHRoZSBtb2R1bHVzIG9wZXJhdGlvbi5cclxuICAgIC8vIEFsdGhvdWdoIHRoZSBvdGhlciByb3VuZGluZyBtb2RlcyBjYW4gYWxzbyBiZSB1c2VkLCB0aGV5IG1heSBub3QgZ2l2ZSB1c2VmdWwgcmVzdWx0cy5cclxuICAgIE1PRFVMT19NT0RFID0gMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA5XHJcblxyXG4gICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIHRoZSBleHBvbmVudGlhdGVkQnkgb3BlcmF0aW9uLlxyXG4gICAgLy8gSWYgUE9XX1BSRUNJU0lPTiBpcyAwLCB0aGVyZSB3aWxsIGJlIHVubGltaXRlZCBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICBQT1dfUFJFQ0lTSU9OID0gMCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgLy8gVGhlIGZvcm1hdCBzcGVjaWZpY2F0aW9uIHVzZWQgYnkgdGhlIEJpZ051bWJlci5wcm90b3R5cGUudG9Gb3JtYXQgbWV0aG9kLlxyXG4gICAgRk9STUFUID0ge1xyXG4gICAgICBwcmVmaXg6ICcnLFxyXG4gICAgICBncm91cFNpemU6IDMsXHJcbiAgICAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICBzdWZmaXg6ICcnXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFRoZSBhbHBoYWJldCB1c2VkIGZvciBiYXNlIGNvbnZlcnNpb24uIEl0IG11c3QgYmUgYXQgbGVhc3QgMiBjaGFyYWN0ZXJzIGxvbmcsIHdpdGggbm8gJysnLFxyXG4gICAgLy8gJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgIC8vICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiRfJ1xyXG4gICAgQUxQSEFCRVQgPSAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyxcclxuICAgIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyA9IHRydWU7XHJcblxyXG5cclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgLy8gQ09OU1RSVUNUT1JcclxuXHJcblxyXG4gIC8qXHJcbiAgICogVGhlIEJpZ051bWJlciBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXHJcbiAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBCaWdOdW1iZXIgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogdiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgKiBbYl0ge251bWJlcn0gVGhlIGJhc2Ugb2Ygdi4gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIEJpZ051bWJlcih2LCBiKSB7XHJcbiAgICB2YXIgYWxwaGFiZXQsIGMsIGNhc2VDaGFuZ2VkLCBlLCBpLCBpc051bSwgbGVuLCBzdHIsXHJcbiAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgIC8vIEVuYWJsZSBjb25zdHJ1Y3RvciBjYWxsIHdpdGhvdXQgYG5ld2AuXHJcbiAgICBpZiAoISh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSkgcmV0dXJuIG5ldyBCaWdOdW1iZXIodiwgYik7XHJcblxyXG4gICAgaWYgKGIgPT0gbnVsbCkge1xyXG5cclxuICAgICAgaWYgKHYgJiYgdi5faXNCaWdOdW1iZXIgPT09IHRydWUpIHtcclxuICAgICAgICB4LnMgPSB2LnM7XHJcblxyXG4gICAgICAgIGlmICghdi5jIHx8IHYuZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIGlmICh2LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguZSA9IHYuZTtcclxuICAgICAgICAgIHguYyA9IHYuYy5zbGljZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpICYmIHYgKiAwID09IDApIHtcclxuXHJcbiAgICAgICAgLy8gVXNlIGAxIC8gbmAgdG8gaGFuZGxlIG1pbnVzIHplcm8gYWxzby5cclxuICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAodiA9IC12LCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAvLyBGYXN0IHBhdGggZm9yIGludGVnZXJzLCB3aGVyZSBuIDwgMjE0NzQ4MzY0OCAoMioqMzEpLlxyXG4gICAgICAgIGlmICh2ID09PSB+fnYpIHtcclxuICAgICAgICAgIGZvciAoZSA9IDAsIGkgPSB2OyBpID49IDEwOyBpIC89IDEwLCBlKyspO1xyXG5cclxuICAgICAgICAgIGlmIChlID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgICAgeC5jID0gW3ZdO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgaWYgKCFpc051bWVyaWMudGVzdChzdHIgPSBTdHJpbmcodikpKSByZXR1cm4gcGFyc2VOdW1lcmljKHgsIHN0ciwgaXNOdW0pO1xyXG5cclxuICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG5cclxuICAgICAgLy8gRXhwb25lbnRpYWwgZm9ybT9cclxuICAgICAgaWYgKChpID0gc3RyLnNlYXJjaCgvZS9pKSkgPiAwKSB7XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgICAgICBpZiAoZSA8IDApIGUgPSBpO1xyXG4gICAgICAgIGUgKz0gK3N0ci5zbGljZShpICsgMSk7XHJcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpKTtcclxuICAgICAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgICAvLyBJbnRlZ2VyLlxyXG4gICAgICAgIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG5cclxuICAgICAgLy8gQWxsb3cgZXhwb25lbnRpYWwgbm90YXRpb24gdG8gYmUgdXNlZCB3aXRoIGJhc2UgMTAgYXJndW1lbnQsIHdoaWxlXHJcbiAgICAgIC8vIGFsc28gcm91bmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYXMgd2l0aCBvdGhlciBiYXNlcy5cclxuICAgICAgaWYgKGIgPT0gMTAgJiYgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzKSB7XHJcbiAgICAgICAgeCA9IG5ldyBCaWdOdW1iZXIodik7XHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKHgsIERFQ0lNQUxfUExBQ0VTICsgeC5lICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuXHJcbiAgICAgIGlmIChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSB7XHJcblxyXG4gICAgICAgIC8vIEF2b2lkIHBvdGVudGlhbCBpbnRlcnByZXRhdGlvbiBvZiBJbmZpbml0eSBhbmQgTmFOIGFzIGJhc2UgNDQrIHZhbHVlcy5cclxuICAgICAgICBpZiAodiAqIDAgIT0gMCkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtLCBiKTtcclxuXHJcbiAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHICYmIHN0ci5yZXBsYWNlKC9eMFxcLjAqfFxcLi8sICcnKS5sZW5ndGggPiAxNSkge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAodG9vTWFueURpZ2l0cyArIHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhbHBoYWJldCA9IEFMUEhBQkVULnNsaWNlKDAsIGIpO1xyXG4gICAgICBlID0gaSA9IDA7XHJcblxyXG4gICAgICAvLyBDaGVjayB0aGF0IHN0ciBpcyBhIHZhbGlkIGJhc2UgYiBudW1iZXIuXHJcbiAgICAgIC8vIERvbid0IHVzZSBSZWdFeHAsIHNvIGFscGhhYmV0IGNhbiBjb250YWluIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICAgICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBpZiAoYWxwaGFiZXQuaW5kZXhPZihjID0gc3RyLmNoYXJBdChpKSkgPCAwKSB7XHJcbiAgICAgICAgICBpZiAoYyA9PSAnLicpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIElmICcuJyBpcyBub3QgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgaXQgaGFzIG5vdCBiZSBmb3VuZCBiZWZvcmUuXHJcbiAgICAgICAgICAgIGlmIChpID4gZSkge1xyXG4gICAgICAgICAgICAgIGUgPSBsZW47XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAoIWNhc2VDaGFuZ2VkKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBBbGxvdyBlLmcuIGhleGFkZWNpbWFsICdGRicgYXMgd2VsbCBhcyAnZmYnLlxyXG4gICAgICAgICAgICBpZiAoc3RyID09IHN0ci50b1VwcGVyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9Mb3dlckNhc2UoKSkgfHxcclxuICAgICAgICAgICAgICAgIHN0ciA9PSBzdHIudG9Mb3dlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvVXBwZXJDYXNlKCkpKSB7XHJcbiAgICAgICAgICAgICAgY2FzZUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIGkgPSAtMTtcclxuICAgICAgICAgICAgICBlID0gMDtcclxuICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWMoeCwgU3RyaW5nKHYpLCBpc051bSwgYik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQcmV2ZW50IGxhdGVyIGNoZWNrIGZvciBsZW5ndGggb24gY29udmVydGVkIG51bWJlci5cclxuICAgICAgaXNOdW0gPSBmYWxzZTtcclxuICAgICAgc3RyID0gY29udmVydEJhc2Uoc3RyLCBiLCAxMCwgeC5zKTtcclxuXHJcbiAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICBlbHNlIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgZm9yIChpID0gMDsgc3RyLmNoYXJDb2RlQXQoaSkgPT09IDQ4OyBpKyspO1xyXG5cclxuICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgc3RyLmNoYXJDb2RlQXQoLS1sZW4pID09PSA0ODspO1xyXG5cclxuICAgIGlmIChzdHIgPSBzdHIuc2xpY2UoaSwgKytsZW4pKSB7XHJcbiAgICAgIGxlbiAtPSBpO1xyXG5cclxuICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgaWYgKGlzTnVtICYmIEJpZ051bWJlci5ERUJVRyAmJlxyXG4gICAgICAgIGxlbiA+IDE1ICYmICh2ID4gTUFYX1NBRkVfSU5URUdFUiB8fCB2ICE9PSBtYXRoZmxvb3IodikpKSB7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICh0b29NYW55RGlnaXRzICsgKHgucyAqIHYpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICBpZiAoKGUgPSBlIC0gaSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgeC5jID0gW107XHJcblxyXG4gICAgICAgIC8vIFRyYW5zZm9ybSBiYXNlXHJcblxyXG4gICAgICAgIC8vIGUgaXMgdGhlIGJhc2UgMTAgZXhwb25lbnQuXHJcbiAgICAgICAgLy8gaSBpcyB3aGVyZSB0byBzbGljZSBzdHIgdG8gZ2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2VmZmljaWVudCBhcnJheS5cclxuICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgIGlmIChlIDwgMCkgaSArPSBMT0dfQkFTRTsgIC8vIGkgPCAxXHJcblxyXG4gICAgICAgIGlmIChpIDwgbGVuKSB7XHJcbiAgICAgICAgICBpZiAoaSkgeC5jLnB1c2goK3N0ci5zbGljZSgwLCBpKSk7XHJcblxyXG4gICAgICAgICAgZm9yIChsZW4gLT0gTE9HX0JBU0U7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICAgIHguYy5wdXNoKCtzdHIuc2xpY2UoaSwgaSArPSBMT0dfQkFTRSkpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGkgPSBMT0dfQkFTRSAtIChzdHIgPSBzdHIuc2xpY2UoaSkpLmxlbmd0aDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSAtPSBsZW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICB4LmMucHVzaCgrc3RyKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgIC8vIFplcm8uXHJcbiAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvLyBDT05TVFJVQ1RPUiBQUk9QRVJUSUVTXHJcblxyXG5cclxuICBCaWdOdW1iZXIuY2xvbmUgPSBjbG9uZTtcclxuXHJcbiAgQmlnTnVtYmVyLlJPVU5EX1VQID0gMDtcclxuICBCaWdOdW1iZXIuUk9VTkRfRE9XTiA9IDE7XHJcbiAgQmlnTnVtYmVyLlJPVU5EX0NFSUwgPSAyO1xyXG4gIEJpZ051bWJlci5ST1VORF9GTE9PUiA9IDM7XHJcbiAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfVVAgPSA0O1xyXG4gIEJpZ051bWJlci5ST1VORF9IQUxGX0RPV04gPSA1O1xyXG4gIEJpZ051bWJlci5ST1VORF9IQUxGX0VWRU4gPSA2O1xyXG4gIEJpZ051bWJlci5ST1VORF9IQUxGX0NFSUwgPSA3O1xyXG4gIEJpZ051bWJlci5ST1VORF9IQUxGX0ZMT09SID0gODtcclxuICBCaWdOdW1iZXIuRVVDTElEID0gOTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ29uZmlndXJlIGluZnJlcXVlbnRseS1jaGFuZ2luZyBsaWJyYXJ5LXdpZGUgc2V0dGluZ3MuXHJcbiAgICpcclxuICAgKiBBY2NlcHQgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBvcHRpb25hbCBwcm9wZXJ0aWVzIChpZiB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpc1xyXG4gICAqIGEgbnVtYmVyLCBpdCBtdXN0IGJlIGFuIGludGVnZXIgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2Ugc3RhdGVkKTpcclxuICAgKlxyXG4gICAqICAgREVDSU1BTF9QTEFDRVMgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgKiAgIFJPVU5ESU5HX01PREUgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOFxyXG4gICAqICAgRVhQT05FTlRJQUxfQVQgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggIG9yICBbLU1BWCB0byAwLCAwIHRvIE1BWF1cclxuICAgKiAgIFJBTkdFICAgICAgICAgICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYIChub3QgemVybykgIG9yICBbLU1BWCB0byAtMSwgMSB0byBNQVhdXHJcbiAgICogICBDUllQVE8gICAgICAgICAgIHtib29sZWFufSAgICAgICAgICB0cnVlIG9yIGZhbHNlXHJcbiAgICogICBNT0RVTE9fTU9ERSAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDlcclxuICAgKiAgIFBPV19QUkVDSVNJT04gICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICogICBBTFBIQUJFVCAgICAgICAgIHtzdHJpbmd9ICAgICAgICAgICBBIHN0cmluZyBvZiB0d28gb3IgbW9yZSB1bmlxdWUgY2hhcmFjdGVycyB3aGljaCBkb2VzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3QgY29udGFpbiAnLicuXHJcbiAgICogICBGT1JNQVQgICAgICAgICAgIHtvYmplY3R9ICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBzb21lIG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgKiAgICAgcHJlZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAqICAgICBncm91cFNpemUgICAgICAgICAgICAgIHtudW1iZXJ9XHJcbiAgICogICAgIHNlY29uZGFyeUdyb3VwU2l6ZSAgICAge251bWJlcn1cclxuICAgKiAgICAgZ3JvdXBTZXBhcmF0b3IgICAgICAgICB7c3RyaW5nfVxyXG4gICAqICAgICBkZWNpbWFsU2VwYXJhdG9yICAgICAgIHtzdHJpbmd9XHJcbiAgICogICAgIGZyYWN0aW9uR3JvdXBTaXplICAgICAge251bWJlcn1cclxuICAgKiAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB7c3RyaW5nfVxyXG4gICAqICAgICBzdWZmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICpcclxuICAgKiAoVGhlIHZhbHVlcyBhc3NpZ25lZCB0byB0aGUgYWJvdmUgRk9STUFUIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3QgY2hlY2tlZCBmb3IgdmFsaWRpdHkuKVxyXG4gICAqXHJcbiAgICogRS5nLlxyXG4gICAqIEJpZ051bWJlci5jb25maWcoeyBERUNJTUFMX1BMQUNFUyA6IDIwLCBST1VORElOR19NT0RFIDogNCB9KVxyXG4gICAqXHJcbiAgICogSWdub3JlIHByb3BlcnRpZXMvcGFyYW1ldGVycyBzZXQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGV4Y2VwdCBmb3IgQUxQSEFCRVQuXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgY3VycmVudCB2YWx1ZXMuXHJcbiAgICovXHJcbiAgQmlnTnVtYmVyLmNvbmZpZyA9IEJpZ051bWJlci5zZXQgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICB2YXIgcCwgdjtcclxuXHJcbiAgICBpZiAob2JqICE9IG51bGwpIHtcclxuXHJcbiAgICAgIGlmICh0eXBlb2Ygb2JqID09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgIC8vIERFQ0lNQUxfUExBQ0VTIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gREVDSU1BTF9QTEFDRVMge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdERUNJTUFMX1BMQUNFUycpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgIERFQ0lNQUxfUExBQ0VTID0gdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJPVU5ESU5HX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUk9VTkRJTkdfTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JPVU5ESU5HX01PREUnKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgIGludENoZWNrKHYsIDAsIDgsIHApO1xyXG4gICAgICAgICAgUk9VTkRJTkdfTU9ERSA9IHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFWFBPTkVOVElBTF9BVCB7bnVtYmVyfG51bWJlcltdfVxyXG4gICAgICAgIC8vIEludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gMCBpbmNsdXNpdmUsIDAgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEVYUE9ORU5USUFMX0FUIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRVhQT05FTlRJQUxfQVQnKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIDAsIHApO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBUT19FWFBfTkVHID0gdlswXTtcclxuICAgICAgICAgICAgVE9fRVhQX1BPUyA9IHZbMV07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBUT19FWFBfTkVHID0gLShUT19FWFBfUE9TID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUkFOR0Uge251bWJlcnxudW1iZXJbXX0gTm9uLXplcm8gaW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAtMSBpbmNsdXNpdmUsIGludGVnZXIgMSB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUkFOR0Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfGNhbm5vdCBiZSB6ZXJvfToge3Z9J1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdSQU5HRScpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgLTEsIHApO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAxLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBNSU5fRVhQID0gdlswXTtcclxuICAgICAgICAgICAgTUFYX0VYUCA9IHZbMV07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgIE1JTl9FWFAgPSAtKE1BWF9FWFAgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgY2Fubm90IGJlIHplcm86ICcgKyB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ1JZUFRPIHtib29sZWFufSB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBDUllQVE8gbm90IHRydWUgb3IgZmFsc2U6IHt2fSdcclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdDUllQVE8nKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgIGlmICh2ID09PSAhIXYpIHtcclxuICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8gJiZcclxuICAgICAgICAgICAgICAgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgfHwgY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xyXG4gICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgQ1JZUFRPID0gIXY7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCB0cnVlIG9yIGZhbHNlOiAnICsgdik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBNT0RVTE9fTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDkgaW5jbHVzaXZlLlxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBNT0RVTE9fTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ01PRFVMT19NT0RFJykpIHtcclxuICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICBpbnRDaGVjayh2LCAwLCA5LCBwKTtcclxuICAgICAgICAgIE1PRFVMT19NT0RFID0gdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFBPV19QUkVDSVNJT04ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBQT1dfUFJFQ0lTSU9OIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUE9XX1BSRUNJU0lPTicpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRk9STUFUIHtvYmplY3R9XHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEZPUk1BVCBub3QgYW4gb2JqZWN0OiB7dn0nXHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0ZPUk1BVCcpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdvYmplY3QnKSBGT1JNQVQgPSB2O1xyXG4gICAgICAgICAgZWxzZSB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCBhbiBvYmplY3Q6ICcgKyB2KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFMUEhBQkVUIHtzdHJpbmd9XHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEFMUEhBQkVUIGludmFsaWQ6IHt2fSdcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQUxQSEFCRVQnKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuXHJcbiAgICAgICAgICAvLyBEaXNhbGxvdyBpZiBsZXNzIHRoYW4gdHdvIGNoYXJhY3RlcnMsXHJcbiAgICAgICAgICAvLyBvciBpZiBpdCBjb250YWlucyAnKycsICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciBhIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnc3RyaW5nJyAmJiAhL14uPyR8WytcXC0uXFxzXXwoLikuKlxcMS8udGVzdCh2KSkge1xyXG4gICAgICAgICAgICBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMgPSB2LnNsaWNlKDAsIDEwKSA9PSAnMDEyMzQ1Njc4OSc7XHJcbiAgICAgICAgICAgIEFMUEhBQkVUID0gdjtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBpbnZhbGlkOiAnICsgdik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE9iamVjdCBleHBlY3RlZDoge3Z9J1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdPYmplY3QgZXhwZWN0ZWQ6ICcgKyBvYmopO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgREVDSU1BTF9QTEFDRVM6IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICBST1VORElOR19NT0RFOiBST1VORElOR19NT0RFLFxyXG4gICAgICBFWFBPTkVOVElBTF9BVDogW1RPX0VYUF9ORUcsIFRPX0VYUF9QT1NdLFxyXG4gICAgICBSQU5HRTogW01JTl9FWFAsIE1BWF9FWFBdLFxyXG4gICAgICBDUllQVE86IENSWVBUTyxcclxuICAgICAgTU9EVUxPX01PREU6IE1PRFVMT19NT0RFLFxyXG4gICAgICBQT1dfUFJFQ0lTSU9OOiBQT1dfUFJFQ0lTSU9OLFxyXG4gICAgICBGT1JNQVQ6IEZPUk1BVCxcclxuICAgICAgQUxQSEFCRVQ6IEFMUEhBQkVUXHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHYgaXMgYSBCaWdOdW1iZXIgaW5zdGFuY2UsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICpcclxuICAgKiBJZiBCaWdOdW1iZXIuREVCVUcgaXMgdHJ1ZSwgdGhyb3cgaWYgYSBCaWdOdW1iZXIgaW5zdGFuY2UgaXMgbm90IHdlbGwtZm9ybWVkLlxyXG4gICAqXHJcbiAgICogdiB7YW55fVxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEludmFsaWQgQmlnTnVtYmVyOiB7dn0nXHJcbiAgICovXHJcbiAgQmlnTnVtYmVyLmlzQmlnTnVtYmVyID0gZnVuY3Rpb24gKHYpIHtcclxuICAgIGlmICghdiB8fCB2Ll9pc0JpZ051bWJlciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgaWYgKCFCaWdOdW1iZXIuREVCVUcpIHJldHVybiB0cnVlO1xyXG5cclxuICAgIHZhciBpLCBuLFxyXG4gICAgICBjID0gdi5jLFxyXG4gICAgICBlID0gdi5lLFxyXG4gICAgICBzID0gdi5zO1xyXG5cclxuICAgIG91dDogaWYgKHt9LnRvU3RyaW5nLmNhbGwoYykgPT0gJ1tvYmplY3QgQXJyYXldJykge1xyXG5cclxuICAgICAgaWYgKChzID09PSAxIHx8IHMgPT09IC0xKSAmJiBlID49IC1NQVggJiYgZSA8PSBNQVggJiYgZSA9PT0gbWF0aGZsb29yKGUpKSB7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBmaXJzdCBlbGVtZW50IGlzIHplcm8sIHRoZSBCaWdOdW1iZXIgdmFsdWUgbXVzdCBiZSB6ZXJvLlxyXG4gICAgICAgIGlmIChjWzBdID09PSAwKSB7XHJcbiAgICAgICAgICBpZiAoZSA9PT0gMCAmJiBjLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyB0aGF0IGNbMF0gc2hvdWxkIGhhdmUsIGJhc2VkIG9uIHRoZSBleHBvbmVudC5cclxuICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgIGlmIChpIDwgMSkgaSArPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgICAvL2lmIChNYXRoLmNlaWwoTWF0aC5sb2coY1swXSArIDEpIC8gTWF0aC5MTjEwKSA9PSBpKSB7XHJcbiAgICAgICAgaWYgKFN0cmluZyhjWzBdKS5sZW5ndGggPT0gaSkge1xyXG5cclxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG4gPSBjW2ldO1xyXG4gICAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+PSBCQVNFIHx8IG4gIT09IG1hdGhmbG9vcihuKSkgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIExhc3QgZWxlbWVudCBjYW5ub3QgYmUgemVybywgdW5sZXNzIGl0IGlzIHRoZSBvbmx5IGVsZW1lbnQuXHJcbiAgICAgICAgICBpZiAobiAhPT0gMCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgLy8gSW5maW5pdHkvTmFOXHJcbiAgICB9IGVsc2UgaWYgKGMgPT09IG51bGwgJiYgZSA9PT0gbnVsbCAmJiAocyA9PT0gbnVsbCB8fCBzID09PSAxIHx8IHMgPT09IC0xKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB0aHJvdyBFcnJvclxyXG4gICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnSW52YWxpZCBCaWdOdW1iZXI6ICcgKyB2KTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICpcclxuICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAqL1xyXG4gIEJpZ051bWJlci5tYXhpbXVtID0gQmlnTnVtYmVyLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIC0xKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICpcclxuICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAqL1xyXG4gIEJpZ051bWJlci5taW5pbXVtID0gQmlnTnVtYmVyLm1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIDEpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2l0aCBhIHJhbmRvbSB2YWx1ZSBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMCBhbmQgbGVzcyB0aGFuIDEsXHJcbiAgICogYW5kIHdpdGggZHAsIG9yIERFQ0lNQUxfUExBQ0VTIGlmIGRwIGlzIG9taXR0ZWQsIGRlY2ltYWwgcGxhY2VzIChvciBsZXNzIGlmIHRyYWlsaW5nXHJcbiAgICogemVyb3MgYXJlIHByb2R1Y2VkKS5cclxuICAgKlxyXG4gICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB9J1xyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICovXHJcbiAgQmlnTnVtYmVyLnJhbmRvbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcG93Ml81MyA9IDB4MjAwMDAwMDAwMDAwMDA7XHJcblxyXG4gICAgLy8gUmV0dXJuIGEgNTMgYml0IGludGVnZXIgbiwgd2hlcmUgMCA8PSBuIDwgOTAwNzE5OTI1NDc0MDk5Mi5cclxuICAgIC8vIENoZWNrIGlmIE1hdGgucmFuZG9tKCkgcHJvZHVjZXMgbW9yZSB0aGFuIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cclxuICAgIC8vIElmIGl0IGRvZXMsIGFzc3VtZSBhdCBsZWFzdCA1MyBiaXRzIGFyZSBwcm9kdWNlZCwgb3RoZXJ3aXNlIGFzc3VtZSBhdCBsZWFzdCAzMCBiaXRzLlxyXG4gICAgLy8gMHg0MDAwMDAwMCBpcyAyXjMwLCAweDgwMDAwMCBpcyAyXjIzLCAweDFmZmZmZiBpcyAyXjIxIC0gMS5cclxuICAgIHZhciByYW5kb201M2JpdEludCA9IChNYXRoLnJhbmRvbSgpICogcG93Ml81MykgJiAweDFmZmZmZlxyXG4gICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aGZsb29yKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKTsgfVxyXG4gICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKChNYXRoLnJhbmRvbSgpICogMHg0MDAwMDAwMCB8IDApICogMHg4MDAwMDApICtcclxuICAgICAgIChNYXRoLnJhbmRvbSgpICogMHg4MDAwMDAgfCAwKTsgfTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRwKSB7XHJcbiAgICAgIHZhciBhLCBiLCBlLCBrLCB2LFxyXG4gICAgICAgIGkgPSAwLFxyXG4gICAgICAgIGMgPSBbXSxcclxuICAgICAgICByYW5kID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgaWYgKGRwID09IG51bGwpIGRwID0gREVDSU1BTF9QTEFDRVM7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcblxyXG4gICAgICBrID0gbWF0aGNlaWwoZHAgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICBpZiAoQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgIC8vIEJyb3dzZXJzIHN1cHBvcnRpbmcgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5cclxuICAgICAgICBpZiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xyXG5cclxuICAgICAgICAgIGEgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShrICo9IDIpKTtcclxuXHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAvLyA1MyBiaXRzOlxyXG4gICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpICogTWF0aC5wb3coMiwgMjEpKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTEwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMFxyXG4gICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpID4+PiAxMSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgLy8gMHgyMDAwMCBpcyAyXjIxLlxyXG4gICAgICAgICAgICB2ID0gYVtpXSAqIDB4MjAwMDAgKyAoYVtpICsgMV0gPj4+IDExKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlamVjdGlvbiBzYW1wbGluZzpcclxuICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAvLyBQcm9iYWJpbGl0eSB0aGF0IHYgPj0gOWUxNSwgaXNcclxuICAgICAgICAgICAgLy8gNzE5OTI1NDc0MDk5MiAvIDkwMDcxOTkyNTQ3NDA5OTIgfj0gMC4wMDA4LCBpLmUuIDEgaW4gMTI1MVxyXG4gICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgYiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDIpKTtcclxuICAgICAgICAgICAgICBhW2ldID0gYlswXTtcclxuICAgICAgICAgICAgICBhW2kgKyAxXSA9IGJbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8PSA4OTk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGkgPSBrIC8gMjtcclxuXHJcbiAgICAgICAgLy8gTm9kZS5qcyBzdXBwb3J0aW5nIGNyeXB0by5yYW5kb21CeXRlcy5cclxuICAgICAgICB9IGVsc2UgaWYgKGNyeXB0by5yYW5kb21CeXRlcykge1xyXG5cclxuICAgICAgICAgIC8vIGJ1ZmZlclxyXG4gICAgICAgICAgYSA9IGNyeXB0by5yYW5kb21CeXRlcyhrICo9IDcpO1xyXG5cclxuICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwMDAwMCBpcyAyXjQ4LCAweDEwMDAwMDAwMDAwIGlzIDJeNDBcclxuICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAgaXMgMl4zMiwgMHgxMDAwMDAwIGlzIDJeMjRcclxuICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICB2ID0gKChhW2ldICYgMzEpICogMHgxMDAwMDAwMDAwMDAwKSArIChhW2kgKyAxXSAqIDB4MTAwMDAwMDAwMDApICtcclxuICAgICAgICAgICAgICAgKGFbaSArIDJdICogMHgxMDAwMDAwMDApICsgKGFbaSArIDNdICogMHgxMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgIChhW2kgKyA0XSA8PCAxNikgKyAoYVtpICsgNV0gPDwgOCkgKyBhW2kgKyA2XTtcclxuXHJcbiAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weShhLCBpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICBpICs9IDc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGkgPSBrIC8gNztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgQ1JZUFRPID0gZmFsc2U7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFVzZSBNYXRoLnJhbmRvbS5cclxuICAgICAgaWYgKCFDUllQVE8pIHtcclxuXHJcbiAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG4gICAgICAgICAgdiA9IHJhbmRvbTUzYml0SW50KCk7XHJcbiAgICAgICAgICBpZiAodiA8IDllMTUpIGNbaSsrXSA9IHYgJSAxZTE0O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgayA9IGNbLS1pXTtcclxuICAgICAgZHAgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IHRyYWlsaW5nIGRpZ2l0cyB0byB6ZXJvcyBhY2NvcmRpbmcgdG8gZHAuXHJcbiAgICAgIGlmIChrICYmIGRwKSB7XHJcbiAgICAgICAgdiA9IFBPV1NfVEVOW0xPR19CQVNFIC0gZHBdO1xyXG4gICAgICAgIGNbaV0gPSBtYXRoZmxvb3IoayAvIHYpICogdjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvLlxyXG4gICAgICBmb3IgKDsgY1tpXSA9PT0gMDsgYy5wb3AoKSwgaS0tKTtcclxuXHJcbiAgICAgIC8vIFplcm8/XHJcbiAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgIGMgPSBbZSA9IDBdO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVybyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgIGZvciAoZSA9IC0xIDsgY1swXSA9PT0gMDsgYy5zcGxpY2UoMCwgMSksIGUgLT0gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAvLyBDb3VudCB0aGUgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIGMgdG8gZGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MsIGFuZC4uLlxyXG4gICAgICAgIGZvciAoaSA9IDEsIHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAvLyBhZGp1c3QgdGhlIGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgIGlmIChpIDwgTE9HX0JBU0UpIGUgLT0gTE9HX0JBU0UgLSBpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByYW5kLmUgPSBlO1xyXG4gICAgICByYW5kLmMgPSBjO1xyXG4gICAgICByZXR1cm4gcmFuZDtcclxuICAgIH07XHJcbiAgfSkoKTtcclxuXHJcblxyXG4gICAvKlxyXG4gICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICpcclxuICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAqL1xyXG4gIEJpZ051bWJlci5zdW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgaSA9IDEsXHJcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICAgIHN1bSA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcbiAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOykgc3VtID0gc3VtLnBsdXMoYXJnc1tpKytdKTtcclxuICAgIHJldHVybiBzdW07XHJcbiAgfTtcclxuXHJcblxyXG4gIC8vIFBSSVZBVEUgRlVOQ1RJT05TXHJcblxyXG5cclxuICAvLyBDYWxsZWQgYnkgQmlnTnVtYmVyIGFuZCBCaWdOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nLlxyXG4gIGNvbnZlcnRCYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBkZWNpbWFsID0gJzAxMjM0NTY3ODknO1xyXG5cclxuICAgIC8qXHJcbiAgICAgKiBDb252ZXJ0IHN0cmluZyBvZiBiYXNlSW4gdG8gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBiYXNlT3V0LlxyXG4gICAgICogRWcuIHRvQmFzZU91dCgnMjU1JywgMTAsIDE2KSByZXR1cm5zIFsxNSwgMTVdLlxyXG4gICAgICogRWcuIHRvQmFzZU91dCgnZmYnLCAxNiwgMTApIHJldHVybnMgWzIsIDUsIDVdLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGFscGhhYmV0KSB7XHJcbiAgICAgIHZhciBqLFxyXG4gICAgICAgIGFyciA9IFswXSxcclxuICAgICAgICBhcnJMLFxyXG4gICAgICAgIGkgPSAwLFxyXG4gICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICBmb3IgKDsgaSA8IGxlbjspIHtcclxuICAgICAgICBmb3IgKGFyckwgPSBhcnIubGVuZ3RoOyBhcnJMLS07IGFyclthcnJMXSAqPSBiYXNlSW4pO1xyXG5cclxuICAgICAgICBhcnJbMF0gKz0gYWxwaGFiZXQuaW5kZXhPZihzdHIuY2hhckF0KGkrKykpO1xyXG5cclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgYXJyLmxlbmd0aDsgaisrKSB7XHJcblxyXG4gICAgICAgICAgaWYgKGFycltqXSA+IGJhc2VPdXQgLSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChhcnJbaiArIDFdID09IG51bGwpIGFycltqICsgMV0gPSAwO1xyXG4gICAgICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSAvIGJhc2VPdXQgfCAwO1xyXG4gICAgICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBhcnIucmV2ZXJzZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbnZlcnQgYSBudW1lcmljIHN0cmluZyBvZiBiYXNlSW4gdG8gYSBudW1lcmljIHN0cmluZyBvZiBiYXNlT3V0LlxyXG4gICAgLy8gSWYgdGhlIGNhbGxlciBpcyB0b1N0cmluZywgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlIDEwIHRvIGJhc2VPdXQuXHJcbiAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIEJpZ051bWJlciwgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlSW4gdG8gYmFzZSAxMC5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIHNpZ24sIGNhbGxlcklzVG9TdHJpbmcpIHtcclxuICAgICAgdmFyIGFscGhhYmV0LCBkLCBlLCBrLCByLCB4LCB4YywgeSxcclxuICAgICAgICBpID0gc3RyLmluZGV4T2YoJy4nKSxcclxuICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuXHJcbiAgICAgIC8vIE5vbi1pbnRlZ2VyLlxyXG4gICAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgICAgayA9IFBPV19QUkVDSVNJT047XHJcblxyXG4gICAgICAgIC8vIFVubGltaXRlZCBwcmVjaXNpb24uXHJcbiAgICAgICAgUE9XX1BSRUNJU0lPTiA9IDA7XHJcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoYmFzZUluKTtcclxuICAgICAgICB4ID0geS5wb3coc3RyLmxlbmd0aCAtIGkpO1xyXG4gICAgICAgIFBPV19QUkVDSVNJT04gPSBrO1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHN0ciBhcyBpZiBhbiBpbnRlZ2VyLCB0aGVuIHJlc3RvcmUgdGhlIGZyYWN0aW9uIHBhcnQgYnkgZGl2aWRpbmcgdGhlXHJcbiAgICAgICAgLy8gcmVzdWx0IGJ5IGl0cyBiYXNlIHJhaXNlZCB0byBhIHBvd2VyLlxyXG5cclxuICAgICAgICB5LmMgPSB0b0Jhc2VPdXQodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcoeC5jKSwgeC5lLCAnMCcpLFxyXG4gICAgICAgICAxMCwgYmFzZU91dCwgZGVjaW1hbCk7XHJcbiAgICAgICAgeS5lID0geS5jLmxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29udmVydCB0aGUgbnVtYmVyIGFzIGludGVnZXIuXHJcblxyXG4gICAgICB4YyA9IHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgY2FsbGVySXNUb1N0cmluZ1xyXG4gICAgICAgPyAoYWxwaGFiZXQgPSBBTFBIQUJFVCwgZGVjaW1hbClcclxuICAgICAgIDogKGFscGhhYmV0ID0gZGVjaW1hbCwgQUxQSEFCRVQpKTtcclxuXHJcbiAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBhcyBhbiBpbnRlZ2VyIGFuZCBjb252ZXJ0ZWQgdG8gYmFzZU91dC4gZSBpcyB0aGUgZXhwb25lbnQuXHJcbiAgICAgIGUgPSBrID0geGMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKDsgeGNbLS1rXSA9PSAwOyB4Yy5wb3AoKSk7XHJcblxyXG4gICAgICAvLyBaZXJvP1xyXG4gICAgICBpZiAoIXhjWzBdKSByZXR1cm4gYWxwaGFiZXQuY2hhckF0KDApO1xyXG5cclxuICAgICAgLy8gRG9lcyBzdHIgcmVwcmVzZW50IGFuIGludGVnZXI/IElmIHNvLCBubyBuZWVkIGZvciB0aGUgZGl2aXNpb24uXHJcbiAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgIC0tZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB4LmMgPSB4YztcclxuICAgICAgICB4LmUgPSBlO1xyXG5cclxuICAgICAgICAvLyBUaGUgc2lnbiBpcyBuZWVkZWQgZm9yIGNvcnJlY3Qgcm91bmRpbmcuXHJcbiAgICAgICAgeC5zID0gc2lnbjtcclxuICAgICAgICB4ID0gZGl2KHgsIHksIGRwLCBybSwgYmFzZU91dCk7XHJcbiAgICAgICAgeGMgPSB4LmM7XHJcbiAgICAgICAgciA9IHgucjtcclxuICAgICAgICBlID0geC5lO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgY29udmVydGVkIHRvIGJhc2VPdXQuXHJcblxyXG4gICAgICAvLyBUaGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICBkID0gZSArIGRwICsgMTtcclxuXHJcbiAgICAgIC8vIFRoZSByb3VuZGluZyBkaWdpdDogdGhlIGRpZ2l0IHRvIHRoZSByaWdodCBvZiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgaSA9IHhjW2RdO1xyXG5cclxuICAgICAgLy8gTG9vayBhdCB0aGUgcm91bmRpbmcgZGlnaXRzIGFuZCBtb2RlIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJvdW5kIHVwLlxyXG5cclxuICAgICAgayA9IGJhc2VPdXQgLyAyO1xyXG4gICAgICByID0gciB8fCBkIDwgMCB8fCB4Y1tkICsgMV0gIT0gbnVsbDtcclxuXHJcbiAgICAgIHIgPSBybSA8IDQgPyAoaSAhPSBudWxsIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgICA6IGkgPiBrIHx8IGkgPT0gayAmJihybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJiB4Y1tkIC0gMV0gJiAxIHx8XHJcbiAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAvLyBJZiB0aGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG5vdCBncmVhdGVyIHRoYW4gemVybywgb3IgeGMgcmVwcmVzZW50c1xyXG4gICAgICAvLyB6ZXJvLCB0aGVuIHRoZSByZXN1bHQgb2YgdGhlIGJhc2UgY29udmVyc2lvbiBpcyB6ZXJvIG9yLCBpZiByb3VuZGluZyB1cCwgYSB2YWx1ZVxyXG4gICAgICAvLyBzdWNoIGFzIDAuMDAwMDEuXHJcbiAgICAgIGlmIChkIDwgMSB8fCAheGNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gMV4tZHAgb3IgMFxyXG4gICAgICAgIHN0ciA9IHIgPyB0b0ZpeGVkUG9pbnQoYWxwaGFiZXQuY2hhckF0KDEpLCAtZHAsIGFscGhhYmV0LmNoYXJBdCgwKSkgOiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFRydW5jYXRlIHhjIHRvIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgeGMubGVuZ3RoID0gZDtcclxuXHJcbiAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAvLyBSb3VuZGluZyB1cCBtYXkgbWVhbiB0aGUgcHJldmlvdXMgZGlnaXQgaGFzIHRvIGJlIHJvdW5kZWQgdXAgYW5kIHNvIG9uLlxyXG4gICAgICAgICAgZm9yICgtLWJhc2VPdXQ7ICsreGNbLS1kXSA+IGJhc2VPdXQ7KSB7XHJcbiAgICAgICAgICAgIHhjW2RdID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmICghZCkge1xyXG4gICAgICAgICAgICAgICsrZTtcclxuICAgICAgICAgICAgICB4YyA9IFsxXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yIChrID0geGMubGVuZ3RoOyAheGNbLS1rXTspO1xyXG5cclxuICAgICAgICAvLyBFLmcuIFs0LCAxMSwgMTVdIGJlY29tZXMgNGJmLlxyXG4gICAgICAgIGZvciAoaSA9IDAsIHN0ciA9ICcnOyBpIDw9IGs7IHN0ciArPSBhbHBoYWJldC5jaGFyQXQoeGNbaSsrXSkpO1xyXG5cclxuICAgICAgICAvLyBBZGQgbGVhZGluZyB6ZXJvcywgZGVjaW1hbCBwb2ludCBhbmQgdHJhaWxpbmcgemVyb3MgYXMgcmVxdWlyZWQuXHJcbiAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgYWxwaGFiZXQuY2hhckF0KDApKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVGhlIGNhbGxlciB3aWxsIGFkZCB0aGUgc2lnbi5cclxuICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH07XHJcbiAgfSkoKTtcclxuXHJcblxyXG4gIC8vIFBlcmZvcm0gZGl2aXNpb24gaW4gdGhlIHNwZWNpZmllZCBiYXNlLiBDYWxsZWQgYnkgZGl2IGFuZCBjb252ZXJ0QmFzZS5cclxuICBkaXYgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIC8vIEFzc3VtZSBub24temVybyB4IGFuZCBrLlxyXG4gICAgZnVuY3Rpb24gbXVsdGlwbHkoeCwgaywgYmFzZSkge1xyXG4gICAgICB2YXIgbSwgdGVtcCwgeGxvLCB4aGksXHJcbiAgICAgICAgY2FycnkgPSAwLFxyXG4gICAgICAgIGkgPSB4Lmxlbmd0aCxcclxuICAgICAgICBrbG8gPSBrICUgU1FSVF9CQVNFLFxyXG4gICAgICAgIGtoaSA9IGsgLyBTUVJUX0JBU0UgfCAwO1xyXG5cclxuICAgICAgZm9yICh4ID0geC5zbGljZSgpOyBpLS07KSB7XHJcbiAgICAgICAgeGxvID0geFtpXSAlIFNRUlRfQkFTRTtcclxuICAgICAgICB4aGkgPSB4W2ldIC8gU1FSVF9CQVNFIHwgMDtcclxuICAgICAgICBtID0ga2hpICogeGxvICsgeGhpICoga2xvO1xyXG4gICAgICAgIHRlbXAgPSBrbG8gKiB4bG8gKyAoKG0gJSBTUVJUX0JBU0UpICogU1FSVF9CQVNFKSArIGNhcnJ5O1xyXG4gICAgICAgIGNhcnJ5ID0gKHRlbXAgLyBiYXNlIHwgMCkgKyAobSAvIFNRUlRfQkFTRSB8IDApICsga2hpICogeGhpO1xyXG4gICAgICAgIHhbaV0gPSB0ZW1wICUgYmFzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNhcnJ5KSB4ID0gW2NhcnJ5XS5jb25jYXQoeCk7XHJcblxyXG4gICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIsIGFMLCBiTCkge1xyXG4gICAgICB2YXIgaSwgY21wO1xyXG5cclxuICAgICAgaWYgKGFMICE9IGJMKSB7XHJcbiAgICAgICAgY21wID0gYUwgPiBiTCA/IDEgOiAtMTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgZm9yIChpID0gY21wID0gMDsgaSA8IGFMOyBpKyspIHtcclxuXHJcbiAgICAgICAgICBpZiAoYVtpXSAhPSBiW2ldKSB7XHJcbiAgICAgICAgICAgIGNtcCA9IGFbaV0gPiBiW2ldID8gMSA6IC0xO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBjbXA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgYUwsIGJhc2UpIHtcclxuICAgICAgdmFyIGkgPSAwO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgYiBmcm9tIGEuXHJcbiAgICAgIGZvciAoOyBhTC0tOykge1xyXG4gICAgICAgIGFbYUxdIC09IGk7XHJcbiAgICAgICAgaSA9IGFbYUxdIDwgYlthTF0gPyAxIDogMDtcclxuICAgICAgICBhW2FMXSA9IGkgKiBiYXNlICsgYVthTF0gLSBiW2FMXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoOyAhYVswXSAmJiBhLmxlbmd0aCA+IDE7IGEuc3BsaWNlKDAsIDEpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB4OiBkaXZpZGVuZCwgeTogZGl2aXNvci5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSwgZHAsIHJtLCBiYXNlKSB7XHJcbiAgICAgIHZhciBjbXAsIGUsIGksIG1vcmUsIG4sIHByb2QsIHByb2RMLCBxLCBxYywgcmVtLCByZW1MLCByZW0wLCB4aSwgeEwsIHljMCxcclxuICAgICAgICB5TCwgeXosXHJcbiAgICAgICAgcyA9IHgucyA9PSB5LnMgPyAxIDogLTEsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOLCBJbmZpbml0eSBvciAwP1xyXG4gICAgICBpZiAoIXhjIHx8ICF4Y1swXSB8fCAheWMgfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKFxyXG5cclxuICAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgTmFOLCBvciBib3RoIEluZmluaXR5IG9yIDAuXHJcbiAgICAgICAgICF4LnMgfHwgIXkucyB8fCAoeGMgPyB5YyAmJiB4Y1swXSA9PSB5Y1swXSA6ICF5YykgPyBOYU4gOlxyXG5cclxuICAgICAgICAgIC8vIFJldHVybiBcdTAwQjEwIGlmIHggaXMgXHUwMEIxMCBvciB5IGlzIFx1MDBCMUluZmluaXR5LCBvciByZXR1cm4gXHUwMEIxSW5maW5pdHkgYXMgeSBpcyBcdTAwQjEwLlxyXG4gICAgICAgICAgeGMgJiYgeGNbMF0gPT0gMCB8fCAheWMgPyBzICogMCA6IHMgLyAwXHJcbiAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBxID0gbmV3IEJpZ051bWJlcihzKTtcclxuICAgICAgcWMgPSBxLmMgPSBbXTtcclxuICAgICAgZSA9IHguZSAtIHkuZTtcclxuICAgICAgcyA9IGRwICsgZSArIDE7XHJcblxyXG4gICAgICBpZiAoIWJhc2UpIHtcclxuICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpIC0gYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICAgIHMgPSBzIC8gTE9HX0JBU0UgfCAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZXN1bHQgZXhwb25lbnQgbWF5IGJlIG9uZSBsZXNzIHRoZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgZS5cclxuICAgICAgLy8gVGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgQmlnTnVtYmVycyBmcm9tIGNvbnZlcnRCYXNlIG1heSBoYXZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSAwOyB5Y1tpXSA9PSAoeGNbaV0gfHwgMCk7IGkrKyk7XHJcblxyXG4gICAgICBpZiAoeWNbaV0gPiAoeGNbaV0gfHwgMCkpIGUtLTtcclxuXHJcbiAgICAgIGlmIChzIDwgMCkge1xyXG4gICAgICAgIHFjLnB1c2goMSk7XHJcbiAgICAgICAgbW9yZSA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgcyArPSAyO1xyXG5cclxuICAgICAgICAvLyBOb3JtYWxpc2UgeGMgYW5kIHljIHNvIGhpZ2hlc3Qgb3JkZXIgZGlnaXQgb2YgeWMgaXMgPj0gYmFzZSAvIDIuXHJcblxyXG4gICAgICAgIG4gPSBtYXRoZmxvb3IoYmFzZSAvICh5Y1swXSArIDEpKTtcclxuXHJcbiAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIGhhbmRsZSBvZGQgYmFzZXMgd2hlcmUgeWNbMF0gPT0gKGJhc2UgLyAyKSAtIDEuXHJcbiAgICAgICAgLy8gaWYgKG4gPiAxIHx8IG4rKyA9PSAxICYmIHljWzBdIDwgYmFzZSAvIDIpIHtcclxuICAgICAgICBpZiAobiA+IDEpIHtcclxuICAgICAgICAgIHljID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgeGMgPSBtdWx0aXBseSh4YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeGkgPSB5TDtcclxuICAgICAgICByZW0gPSB4Yy5zbGljZSgwLCB5TCk7XHJcbiAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIEFkZCB6ZXJvcyB0byBtYWtlIHJlbWFpbmRlciBhcyBsb25nIGFzIGRpdmlzb3IuXHJcbiAgICAgICAgZm9yICg7IHJlbUwgPCB5TDsgcmVtW3JlbUwrK10gPSAwKTtcclxuICAgICAgICB5eiA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgeXogPSBbMF0uY29uY2F0KHl6KTtcclxuICAgICAgICB5YzAgPSB5Y1swXTtcclxuICAgICAgICBpZiAoeWNbMV0gPj0gYmFzZSAvIDIpIHljMCsrO1xyXG4gICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBwcmV2ZW50IHRyaWFsIGRpZ2l0IG4gPiBiYXNlLCB3aGVuIHVzaW5nIGJhc2UgMy5cclxuICAgICAgICAvLyBlbHNlIGlmIChiYXNlID09IDMgJiYgeWMwID09IDEpIHljMCA9IDEgKyAxZS0xNTtcclxuXHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgbiA9IDA7XHJcblxyXG4gICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICBjbXAgPSBjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKTtcclxuXHJcbiAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0cmlhbCBkaWdpdCwgbi5cclxuXHJcbiAgICAgICAgICAgIHJlbTAgPSByZW1bMF07XHJcbiAgICAgICAgICAgIGlmICh5TCAhPSByZW1MKSByZW0wID0gcmVtMCAqIGJhc2UgKyAocmVtWzFdIHx8IDApO1xyXG5cclxuICAgICAgICAgICAgLy8gbiBpcyBob3cgbWFueSB0aW1lcyB0aGUgZGl2aXNvciBnb2VzIGludG8gdGhlIGN1cnJlbnQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBuID0gbWF0aGZsb29yKHJlbTAgLyB5YzApO1xyXG5cclxuICAgICAgICAgICAgLy8gIEFsZ29yaXRobTpcclxuICAgICAgICAgICAgLy8gIHByb2R1Y3QgPSBkaXZpc29yIG11bHRpcGxpZWQgYnkgdHJpYWwgZGlnaXQgKG4pLlxyXG4gICAgICAgICAgICAvLyAgQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IGlzIGdyZWF0ZXIgdGhhbiByZW1haW5kZXI6XHJcbiAgICAgICAgICAgIC8vICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LCBkZWNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgIC8vICBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCB3YXMgbGVzcyB0aGFuIHJlbWFpbmRlciBhdCB0aGUgbGFzdCBjb21wYXJlOlxyXG4gICAgICAgICAgICAvLyAgICBDb21wYXJlIG5ldyByZW1haW5kZXIgYW5kIGRpdmlzb3IuXHJcbiAgICAgICAgICAgIC8vICAgIElmIHJlbWFpbmRlciBpcyBncmVhdGVyIHRoYW4gZGl2aXNvcjpcclxuICAgICAgICAgICAgLy8gICAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLCBpbmNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcblxyXG4gICAgICAgICAgICBpZiAobiA+IDEpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gbiBtYXkgYmUgPiBiYXNlIG9ubHkgd2hlbiBiYXNlIGlzIDMuXHJcbiAgICAgICAgICAgICAgaWYgKG4gPj0gYmFzZSkgbiA9IGJhc2UgLSAxO1xyXG5cclxuICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvciAqIHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgIHByb2QgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCA+IHJlbWFpbmRlciB0aGVuIHRyaWFsIGRpZ2l0IG4gdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBoaWdoIGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgaXMgbm90IGtub3duIHRvIGhhdmVcclxuICAgICAgICAgICAgICAvLyBldmVyIGJlZW4gbW9yZSB0aGFuIDEgdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUocHJvZCwgcmVtLCBwcm9kTCwgcmVtTCkgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgbi0tO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LlxyXG4gICAgICAgICAgICAgICAgc3VidHJhY3QocHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWMsIHByb2RMLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBjbXAgPSAxO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gbiBpcyAwIG9yIDEsIGNtcCBpcyAtMS5cclxuICAgICAgICAgICAgICAvLyBJZiBuIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5YyBhbmQgcmVtIGFnYWluIGJlbG93LFxyXG4gICAgICAgICAgICAgIC8vIHNvIGNoYW5nZSBjbXAgdG8gMSB0byBhdm9pZCBpdC5cclxuICAgICAgICAgICAgICAvLyBJZiBuIGlzIDEsIGxlYXZlIGNtcCBhcyAtMSwgc28geWMgYW5kIHJlbSBhcmUgY29tcGFyZWQgYWdhaW4uXHJcbiAgICAgICAgICAgICAgaWYgKG4gPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGRpdmlzb3IgPCByZW1haW5kZXIsIHNvIG4gbXVzdCBiZSBhdCBsZWFzdCAxLlxyXG4gICAgICAgICAgICAgICAgY21wID0gbiA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvclxyXG4gICAgICAgICAgICAgIHByb2QgPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChwcm9kTCA8IHJlbUwpIHByb2QgPSBbMF0uY29uY2F0KHByb2QpO1xyXG5cclxuICAgICAgICAgICAgLy8gU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgc3VidHJhY3QocmVtLCBwcm9kLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCBuZXcgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCBuZXcgcmVtYWluZGVyLCBzdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vIFRyaWFsIGRpZ2l0IG4gdG9vIGxvdy5cclxuICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGxvdyBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIHZlcnkgcmFyZWx5IDIgdG9vIGxvdy5cclxuICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCkgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICBuKys7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgeUwgPCByZW1MID8geXogOiB5YywgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIG4rKztcclxuICAgICAgICAgICAgcmVtID0gWzBdO1xyXG4gICAgICAgICAgfSAvLyBlbHNlIGNtcCA9PT0gMSBhbmQgbiB3aWxsIGJlIDBcclxuXHJcbiAgICAgICAgICAvLyBBZGQgdGhlIG5leHQgZGlnaXQsIG4sIHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICAgICAgICBxY1tpKytdID0gbjtcclxuXHJcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmRlci5cclxuICAgICAgICAgIGlmIChyZW1bMF0pIHtcclxuICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4Y1t4aV0gfHwgMDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlbSA9IFt4Y1t4aV1dO1xyXG4gICAgICAgICAgICByZW1MID0gMTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlICgoeGkrKyA8IHhMIHx8IHJlbVswXSAhPSBudWxsKSAmJiBzLS0pO1xyXG5cclxuICAgICAgICBtb3JlID0gcmVtWzBdICE9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIExlYWRpbmcgemVybz9cclxuICAgICAgICBpZiAoIXFjWzBdKSBxYy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChiYXNlID09IEJBU0UpIHtcclxuXHJcbiAgICAgICAgLy8gVG8gY2FsY3VsYXRlIHEuZSwgZmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHFjWzBdLlxyXG4gICAgICAgIGZvciAoaSA9IDEsIHMgPSBxY1swXTsgcyA+PSAxMDsgcyAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgcm91bmQocSwgZHAgKyAocS5lID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpICsgMSwgcm0sIG1vcmUpO1xyXG5cclxuICAgICAgLy8gQ2FsbGVyIGlzIGNvbnZlcnRCYXNlLlxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHEuZSA9IGU7XHJcbiAgICAgICAgcS5yID0gK21vcmU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBxO1xyXG4gICAgfTtcclxuICB9KSgpO1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIgbiBpbiBmaXhlZC1wb2ludCBvciBleHBvbmVudGlhbFxyXG4gICAqIG5vdGF0aW9uIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBkZWNpbWFsIHBsYWNlcyBvciBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICpcclxuICAgKiBuOiBhIEJpZ051bWJlci5cclxuICAgKiBpOiB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZGlnaXQgcmVxdWlyZWQgKGkuZS4gdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXApLlxyXG4gICAqIHJtOiB0aGUgcm91bmRpbmcgbW9kZS5cclxuICAgKiBpZDogMSAodG9FeHBvbmVudGlhbCkgb3IgMiAodG9QcmVjaXNpb24pLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGZvcm1hdChuLCBpLCBybSwgaWQpIHtcclxuICAgIHZhciBjMCwgZSwgbmUsIGxlbiwgc3RyO1xyXG5cclxuICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICBpZiAoIW4uYykgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICBjMCA9IG4uY1swXTtcclxuICAgIG5lID0gbi5lO1xyXG5cclxuICAgIGlmIChpID09IG51bGwpIHtcclxuICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICBzdHIgPSBpZCA9PSAxIHx8IGlkID09IDIgJiYgKG5lIDw9IFRPX0VYUF9ORUcgfHwgbmUgPj0gVE9fRVhQX1BPUylcclxuICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIG5lKVxyXG4gICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBuZSwgJzAnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBpLCBybSk7XHJcblxyXG4gICAgICAvLyBuLmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgd2FzIHJvdW5kZWQgdXAuXHJcbiAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAvLyB0b1ByZWNpc2lvbiByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgIC8vIHNwZWNpZmllZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHMgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlclxyXG4gICAgICAvLyBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbi5cclxuXHJcbiAgICAgIC8vIEV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICBpZiAoaWQgPT0gMSB8fCBpZCA9PSAyICYmIChpIDw9IGUgfHwgZSA8PSBUT19FWFBfTkVHKSkge1xyXG5cclxuICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgZm9yICg7IGxlbiA8IGk7IHN0ciArPSAnMCcsIGxlbisrKTtcclxuICAgICAgICBzdHIgPSB0b0V4cG9uZW50aWFsKHN0ciwgZSk7XHJcblxyXG4gICAgICAvLyBGaXhlZC1wb2ludCBub3RhdGlvbi5cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpIC09IG5lICsgKGlkID09PSAyICYmIGUgPiBuZSk7XHJcbiAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgIGlmIChlICsgMSA+IGxlbikge1xyXG4gICAgICAgICAgaWYgKC0taSA+IDApIGZvciAoc3RyICs9ICcuJzsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSArPSBlIC0gbGVuO1xyXG4gICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmIChlICsgMSA9PSBsZW4pIHN0ciArPSAnLic7XHJcbiAgICAgICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuLnMgPCAwICYmIGMwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEhhbmRsZSBCaWdOdW1iZXIubWF4IGFuZCBCaWdOdW1iZXIubWluLlxyXG4gIC8vIElmIGFueSBudW1iZXIgaXMgTmFOLCByZXR1cm4gTmFOLlxyXG4gIGZ1bmN0aW9uIG1heE9yTWluKGFyZ3MsIG4pIHtcclxuICAgIHZhciBrLCB5LFxyXG4gICAgICBpID0gMSxcclxuICAgICAgeCA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcblxyXG4gICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKGFyZ3NbaV0pO1xyXG4gICAgICBpZiAoIXkucyB8fCAoayA9IGNvbXBhcmUoeCwgeSkpID09PSBuIHx8IGsgPT09IDAgJiYgeC5zID09PSBuKSB7XHJcbiAgICAgICAgeCA9IHk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geDtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFN0cmlwIHRyYWlsaW5nIHplcm9zLCBjYWxjdWxhdGUgYmFzZSAxMCBleHBvbmVudCBhbmQgY2hlY2sgYWdhaW5zdCBNSU5fRVhQIGFuZCBNQVhfRVhQLlxyXG4gICAqIENhbGxlZCBieSBtaW51cywgcGx1cyBhbmQgdGltZXMuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gbm9ybWFsaXNlKG4sIGMsIGUpIHtcclxuICAgIHZhciBpID0gMSxcclxuICAgICAgaiA9IGMubGVuZ3RoO1xyXG5cclxuICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKDsgIWNbLS1qXTsgYy5wb3AoKSk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50LiBGaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgIGZvciAoaiA9IGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgLy8gT3ZlcmZsb3c/XHJcbiAgICBpZiAoKGUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgbi5jID0gbi5lID0gbnVsbDtcclxuXHJcbiAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAvLyBaZXJvLlxyXG4gICAgICBuLmMgPSBbbi5lID0gMF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuLmUgPSBlO1xyXG4gICAgICBuLmMgPSBjO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEhhbmRsZSB2YWx1ZXMgdGhhdCBmYWlsIHRoZSB2YWxpZGl0eSB0ZXN0IGluIEJpZ051bWJlci5cclxuICBwYXJzZU51bWVyaWMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pLFxyXG4gICAgICBkb3RBZnRlciA9IC9eKFteLl0rKVxcLiQvLFxyXG4gICAgICBkb3RCZWZvcmUgPSAvXlxcLihbXi5dKykkLyxcclxuICAgICAgaXNJbmZpbml0eU9yTmFOID0gL14tPyhJbmZpbml0eXxOYU4pJC8sXHJcbiAgICAgIHdoaXRlc3BhY2VPclBsdXMgPSAvXlxccypcXCsoPz1bXFx3Ll0pfF5cXHMrfFxccyskL2c7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBzdHIsIGlzTnVtLCBiKSB7XHJcbiAgICAgIHZhciBiYXNlLFxyXG4gICAgICAgIHMgPSBpc051bSA/IHN0ciA6IHN0ci5yZXBsYWNlKHdoaXRlc3BhY2VPclBsdXMsICcnKTtcclxuXHJcbiAgICAgIC8vIE5vIGV4Y2VwdGlvbiBvbiBcdTAwQjFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgIGlmIChpc0luZmluaXR5T3JOYU4udGVzdChzKSkge1xyXG4gICAgICAgIHgucyA9IGlzTmFOKHMpID8gbnVsbCA6IHMgPCAwID8gLTEgOiAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICghaXNOdW0pIHtcclxuXHJcbiAgICAgICAgICAvLyBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaVxyXG4gICAgICAgICAgcyA9IHMucmVwbGFjZShiYXNlUHJlZml4LCBmdW5jdGlvbiAobSwgcDEsIHAyKSB7XHJcbiAgICAgICAgICAgIGJhc2UgPSAocDIgPSBwMi50b0xvd2VyQ2FzZSgpKSA9PSAneCcgPyAxNiA6IHAyID09ICdiJyA/IDIgOiA4O1xyXG4gICAgICAgICAgICByZXR1cm4gIWIgfHwgYiA9PSBiYXNlID8gcDEgOiBtO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgaWYgKGIpIHtcclxuICAgICAgICAgICAgYmFzZSA9IGI7XHJcblxyXG4gICAgICAgICAgICAvLyBFLmcuICcxLicgdG8gJzEnLCAnLjEnIHRvICcwLjEnXHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoZG90QWZ0ZXIsICckMScpLnJlcGxhY2UoZG90QmVmb3JlLCAnMC4kMScpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChzdHIgIT0gcykgcmV0dXJuIG5ldyBCaWdOdW1iZXIocywgYmFzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTm90IGEgbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIGJhc2Uge2J9IG51bWJlcjoge259J1xyXG4gICAgICAgIGlmIChCaWdOdW1iZXIuREVCVUcpIHtcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdOb3QgYScgKyAoYiA/ICcgYmFzZSAnICsgYiA6ICcnKSArICcgbnVtYmVyOiAnICsgc3RyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE5hTlxyXG4gICAgICAgIHgucyA9IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgfSkoKTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUm91bmQgeCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybS4gQ2hlY2sgZm9yIG92ZXIvdW5kZXItZmxvdy5cclxuICAgKiBJZiByIGlzIHRydXRoeSwgaXQgaXMga25vd24gdGhhdCB0aGVyZSBhcmUgbW9yZSBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHJvdW5kKHgsIHNkLCBybSwgcikge1xyXG4gICAgdmFyIGQsIGksIGosIGssIG4sIG5pLCByZCxcclxuICAgICAgeGMgPSB4LmMsXHJcbiAgICAgIHBvd3MxMCA9IFBPV1NfVEVOO1xyXG5cclxuICAgIC8vIGlmIHggaXMgbm90IEluZmluaXR5IG9yIE5hTi4uLlxyXG4gICAgaWYgKHhjKSB7XHJcblxyXG4gICAgICAvLyByZCBpcyB0aGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAvLyBuIGlzIGEgYmFzZSAxZTE0IG51bWJlciwgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IG9mIGFycmF5IHguYyBjb250YWluaW5nIHJkLlxyXG4gICAgICAvLyBuaSBpcyB0aGUgaW5kZXggb2YgbiB3aXRoaW4geC5jLlxyXG4gICAgICAvLyBkIGlzIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgIC8vIGkgaXMgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuIGluY2x1ZGluZyBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAvLyBqIGlzIHRoZSBhY3R1YWwgaW5kZXggb2YgcmQgd2l0aGluIG4gKGlmIDwgMCwgcmQgaXMgYSBsZWFkaW5nIHplcm8pLlxyXG4gICAgICBvdXQ6IHtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLlxyXG4gICAgICAgIGZvciAoZCA9IDEsIGsgPSB4Y1swXTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuICAgICAgICBpID0gc2QgLSBkO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgIGkgKz0gTE9HX0JBU0U7XHJcbiAgICAgICAgICBqID0gc2Q7XHJcbiAgICAgICAgICBuID0geGNbbmkgPSAwXTtcclxuXHJcbiAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgIHJkID0gbWF0aGZsb29yKG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbmkgPSBtYXRoY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgIGlmIChuaSA+PSB4Yy5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIE5lZWRlZCBieSBzcXJ0LlxyXG4gICAgICAgICAgICAgIGZvciAoOyB4Yy5sZW5ndGggPD0gbmk7IHhjLnB1c2goMCkpO1xyXG4gICAgICAgICAgICAgIG4gPSByZCA9IDA7XHJcbiAgICAgICAgICAgICAgZCA9IDE7XHJcbiAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG4gPSBrID0geGNbbmldO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgICAgIGZvciAoZCA9IDE7IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLlxyXG4gICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiwgYWRqdXN0ZWQgZm9yIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuIGlzIGdpdmVuIGJ5IExPR19CQVNFIC0gZC5cclxuICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIGQ7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgcmQgPSBqIDwgMCA/IDAgOiBtYXRoZmxvb3IobiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgciA9IHIgfHwgc2QgPCAwIHx8XHJcblxyXG4gICAgICAgIC8vIEFyZSB0aGVyZSBhbnkgbm9uLXplcm8gZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdD9cclxuICAgICAgICAvLyBUaGUgZXhwcmVzc2lvbiAgbiAlIHBvd3MxMFtkIC0gaiAtIDFdICByZXR1cm5zIGFsbCBkaWdpdHMgb2YgbiB0byB0aGUgcmlnaHRcclxuICAgICAgICAvLyBvZiB0aGUgZGlnaXQgYXQgaiwgZS5nLiBpZiBuIGlzIDkwODcxNCBhbmQgaiBpcyAyLCB0aGUgZXhwcmVzc2lvbiBnaXZlcyA3MTQuXHJcbiAgICAgICAgIHhjW25pICsgMV0gIT0gbnVsbCB8fCAoaiA8IDAgPyBuIDogbiAlIHBvd3MxMFtkIC0gaiAtIDFdKTtcclxuXHJcbiAgICAgICAgciA9IHJtIDwgNFxyXG4gICAgICAgICA/IChyZCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgOiByZCA+IDUgfHwgcmQgPT0gNSAmJiAocm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiZcclxuXHJcbiAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkaWdpdCB0byB0aGUgbGVmdCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgb2RkLlxyXG4gICAgICAgICAgKChpID4gMCA/IGogPiAwID8gbiAvIHBvd3MxMFtkIC0gal0gOiAwIDogeGNbbmkgLSAxXSkgJSAxMCkgJiAxIHx8XHJcbiAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICBpZiAoc2QgPCAxIHx8ICF4Y1swXSkge1xyXG4gICAgICAgICAgeGMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydCBzZCB0byBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgICAgc2QgLT0geC5lICsgMTtcclxuXHJcbiAgICAgICAgICAgIC8vIDEsIDAuMSwgMC4wMSwgMC4wMDEsIDAuMDAwMSBldGMuXHJcbiAgICAgICAgICAgIHhjWzBdID0gcG93czEwWyhMT0dfQkFTRSAtIHNkICUgTE9HX0JBU0UpICUgTE9HX0JBU0VdO1xyXG4gICAgICAgICAgICB4LmUgPSAtc2QgfHwgMDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgICB4Y1swXSA9IHguZSA9IDA7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgZXhjZXNzIGRpZ2l0cy5cclxuICAgICAgICBpZiAoaSA9PSAwKSB7XHJcbiAgICAgICAgICB4Yy5sZW5ndGggPSBuaTtcclxuICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgbmktLTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeGMubGVuZ3RoID0gbmkgKyAxO1xyXG4gICAgICAgICAgayA9IHBvd3MxMFtMT0dfQkFTRSAtIGldO1xyXG5cclxuICAgICAgICAgIC8vIEUuZy4gNTY3MDAgYmVjb21lcyA1NjAwMCBpZiA3IGlzIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgIC8vIGogPiAwIG1lYW5zIGkgPiBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuLlxyXG4gICAgICAgICAgeGNbbmldID0gaiA+IDAgPyBtYXRoZmxvb3IobiAvIHBvd3MxMFtkIC0gal0gJSBwb3dzMTBbal0pICogayA6IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlnaXQgdG8gYmUgcm91bmRlZCB1cCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgICBpZiAobmkgPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBpIHdpbGwgYmUgdGhlIGxlbmd0aCBvZiB4Y1swXSBiZWZvcmUgayBpcyBhZGRlZC5cclxuICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBqID0geGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcbiAgICAgICAgICAgICAgaiA9IHhjWzBdICs9IGs7XHJcbiAgICAgICAgICAgICAgZm9yIChrID0gMTsgaiA+PSAxMDsgaiAvPSAxMCwgaysrKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gaWYgaSAhPSBrIHRoZSBsZW5ndGggaGFzIGluY3JlYXNlZC5cclxuICAgICAgICAgICAgICBpZiAoaSAhPSBrKSB7XHJcbiAgICAgICAgICAgICAgICB4LmUrKztcclxuICAgICAgICAgICAgICAgIGlmICh4Y1swXSA9PSBCQVNFKSB4Y1swXSA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB4Y1tuaV0gKz0gaztcclxuICAgICAgICAgICAgICBpZiAoeGNbbmldICE9IEJBU0UpIGJyZWFrO1xyXG4gICAgICAgICAgICAgIHhjW25pLS1dID0gMDtcclxuICAgICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoaSA9IHhjLmxlbmd0aDsgeGNbLS1pXSA9PT0gMDsgeGMucG9wKCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdz8gSW5maW5pdHkuXHJcbiAgICAgIGlmICh4LmUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIFVuZGVyZmxvdz8gWmVyby5cclxuICAgICAgfSBlbHNlIGlmICh4LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHg7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdmFsdWVPZihuKSB7XHJcbiAgICB2YXIgc3RyLFxyXG4gICAgICBlID0gbi5lO1xyXG5cclxuICAgIGlmIChlID09PSBudWxsKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuXHJcbiAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIGUpXHJcbiAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICByZXR1cm4gbi5zIDwgMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICB9XHJcblxyXG5cclxuICAvLyBQUk9UT1RZUEUvSU5TVEFOQ0UgTUVUSE9EU1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlci5cclxuICAgKi9cclxuICBQLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgIGlmICh4LnMgPCAwKSB4LnMgPSAxO1xyXG4gICAgcmV0dXJuIHg7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuXHJcbiAgICogICAxIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgKiAgIC0xIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgKiAgIDAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLFxyXG4gICAqICAgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgZWl0aGVyIGlzIE5hTi5cclxuICAgKi9cclxuICBQLmNvbXBhcmVkVG8gPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogSWYgZHAgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb2YgdGhlXHJcbiAgICogdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIFx1MDBCMUluZmluaXR5IG9yIE5hTi5cclxuICAgKlxyXG4gICAqIE90aGVyd2lzZSwgaWYgZHAgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2YgZHAgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICpcclxuICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzOiBpbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICovXHJcbiAgUC5kZWNpbWFsUGxhY2VzID0gUC5kcCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICB4ID0gdGhpcztcclxuXHJcbiAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgZHAgKyB4LmUgKyAxLCBybSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgbiA9ICgodiA9IGMubGVuZ3RoIC0gMSkgLSBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkpICogTE9HX0JBU0U7XHJcblxyXG4gICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBudW1iZXIuXHJcbiAgICBpZiAodiA9IGNbdl0pIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuICAgIGlmIChuIDwgMCkgbiA9IDA7XHJcblxyXG4gICAgcmV0dXJuIG47XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIG4gLyAwID0gSVxyXG4gICAqICBuIC8gTiA9IE5cclxuICAgKiAgbiAvIEkgPSAwXHJcbiAgICogIDAgLyBuID0gMFxyXG4gICAqICAwIC8gMCA9IE5cclxuICAgKiAgMCAvIE4gPSBOXHJcbiAgICogIDAgLyBJID0gMFxyXG4gICAqICBOIC8gbiA9IE5cclxuICAgKiAgTiAvIDAgPSBOXHJcbiAgICogIE4gLyBOID0gTlxyXG4gICAqICBOIC8gSSA9IE5cclxuICAgKiAgSSAvIG4gPSBJXHJcbiAgICogIEkgLyAwID0gSVxyXG4gICAqICBJIC8gTiA9IE5cclxuICAgKiAgSSAvIEkgPSBOXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBkaXZpZGVkIGJ5IHRoZSB2YWx1ZSBvZlxyXG4gICAqIEJpZ051bWJlcih5LCBiKSwgcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICovXHJcbiAgUC5kaXZpZGVkQnkgPSBQLmRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIERFQ0lNQUxfUExBQ0VTLCBST1VORElOR19NT0RFKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBpbnRlZ2VyIHBhcnQgb2YgZGl2aWRpbmcgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgKiBCaWdOdW1iZXIgYnkgdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgKi9cclxuICBQLmRpdmlkZWRUb0ludGVnZXJCeSA9IFAuaWRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIDAsIDEpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZXhwb25lbnRpYXRlZCBieSBuLlxyXG4gICAqXHJcbiAgICogSWYgbSBpcyBwcmVzZW50LCByZXR1cm4gdGhlIHJlc3VsdCBtb2R1bG8gbS5cclxuICAgKiBJZiBuIGlzIG5lZ2F0aXZlIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgKiBJZiBQT1dfUFJFQ0lTSU9OIGlzIG5vbi16ZXJvIGFuZCBtIGlzIG5vdCBwcmVzZW50LCByb3VuZCB0byBQT1dfUFJFQ0lTSU9OIHVzaW5nIFJPVU5ESU5HX01PREUuXHJcbiAgICpcclxuICAgKiBUaGUgbW9kdWxhciBwb3dlciBvcGVyYXRpb24gd29ya3MgZWZmaWNpZW50bHkgd2hlbiB4LCBuLCBhbmQgbSBhcmUgaW50ZWdlcnMsIG90aGVyd2lzZSBpdFxyXG4gICAqIGlzIGVxdWl2YWxlbnQgdG8gY2FsY3VsYXRpbmcgeC5leHBvbmVudGlhdGVkQnkobikubW9kdWxvKG0pIHdpdGggYSBQT1dfUFJFQ0lTSU9OIG9mIDAuXHJcbiAgICpcclxuICAgKiBuIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIGV4cG9uZW50LiBBbiBpbnRlZ2VyLlxyXG4gICAqIFttXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBtb2R1bHVzLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEV4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiB7bn0nXHJcbiAgICovXHJcbiAgUC5leHBvbmVudGlhdGVkQnkgPSBQLnBvdyA9IGZ1bmN0aW9uIChuLCBtKSB7XHJcbiAgICB2YXIgaGFsZiwgaXNNb2RFeHAsIGksIGssIG1vcmUsIG5Jc0JpZywgbklzTmVnLCBuSXNPZGQsIHksXHJcbiAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgIG4gPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG5cclxuICAgIC8vIEFsbG93IE5hTiBhbmQgXHUwMEIxSW5maW5pdHksIGJ1dCBub3Qgb3RoZXIgbm9uLWludGVnZXJzLlxyXG4gICAgaWYgKG4uYyAmJiAhbi5pc0ludGVnZXIoKSkge1xyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgIChiaWdudW1iZXJFcnJvciArICdFeHBvbmVudCBub3QgYW4gaW50ZWdlcjogJyArIHZhbHVlT2YobikpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtICE9IG51bGwpIG0gPSBuZXcgQmlnTnVtYmVyKG0pO1xyXG5cclxuICAgIC8vIEV4cG9uZW50IG9mIE1BWF9TQUZFX0lOVEVHRVIgaXMgMTUuXHJcbiAgICBuSXNCaWcgPSBuLmUgPiAxNDtcclxuXHJcbiAgICAvLyBJZiB4IGlzIE5hTiwgXHUwMEIxSW5maW5pdHksIFx1MDBCMTAgb3IgXHUwMEIxMSwgb3IgbiBpcyBcdTAwQjFJbmZpbml0eSwgTmFOIG9yIFx1MDBCMTAuXHJcbiAgICBpZiAoIXguYyB8fCAheC5jWzBdIHx8IHguY1swXSA9PSAxICYmICF4LmUgJiYgeC5jLmxlbmd0aCA9PSAxIHx8ICFuLmMgfHwgIW4uY1swXSkge1xyXG5cclxuICAgICAgLy8gVGhlIHNpZ24gb2YgdGhlIHJlc3VsdCBvZiBwb3cgd2hlbiB4IGlzIG5lZ2F0aXZlIGRlcGVuZHMgb24gdGhlIGV2ZW5uZXNzIG9mIG4uXHJcbiAgICAgIC8vIElmICtuIG92ZXJmbG93cyB0byBcdTAwQjFJbmZpbml0eSwgdGhlIGV2ZW5uZXNzIG9mIG4gd291bGQgYmUgbm90IGJlIGtub3duLlxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcihNYXRoLnBvdygrdmFsdWVPZih4KSwgbklzQmlnID8gbi5zICogKDIgLSBpc09kZChuKSkgOiArdmFsdWVPZihuKSkpO1xyXG4gICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogeTtcclxuICAgIH1cclxuXHJcbiAgICBuSXNOZWcgPSBuLnMgPCAwO1xyXG5cclxuICAgIGlmIChtKSB7XHJcblxyXG4gICAgICAvLyB4ICUgbSByZXR1cm5zIE5hTiBpZiBhYnMobSkgaXMgemVybywgb3IgbSBpcyBOYU4uXHJcbiAgICAgIGlmIChtLmMgPyAhbS5jWzBdIDogIW0ucykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIGlzTW9kRXhwID0gIW5Jc05lZyAmJiB4LmlzSW50ZWdlcigpICYmIG0uaXNJbnRlZ2VyKCk7XHJcblxyXG4gICAgICBpZiAoaXNNb2RFeHApIHggPSB4Lm1vZChtKTtcclxuXHJcbiAgICAvLyBPdmVyZmxvdyB0byBcdTAwQjFJbmZpbml0eTogPj0yKioxZTEwIG9yID49MS4wMDAwMDI0KioxZTE1LlxyXG4gICAgLy8gVW5kZXJmbG93IHRvIFx1MDBCMTA6IDw9MC43OSoqMWUxMCBvciA8PTAuOTk5OTk3NSoqMWUxNS5cclxuICAgIH0gZWxzZSBpZiAobi5lID4gOSAmJiAoeC5lID4gMCB8fCB4LmUgPCAtMSB8fCAoeC5lID09IDBcclxuICAgICAgLy8gWzEsIDI0MDAwMDAwMF1cclxuICAgICAgPyB4LmNbMF0gPiAxIHx8IG5Jc0JpZyAmJiB4LmNbMV0gPj0gMjRlN1xyXG4gICAgICAvLyBbODAwMDAwMDAwMDAwMDBdICBbOTk5OTk3NTAwMDAwMDBdXHJcbiAgICAgIDogeC5jWzBdIDwgOGUxMyB8fCBuSXNCaWcgJiYgeC5jWzBdIDw9IDk5OTk5NzVlNykpKSB7XHJcblxyXG4gICAgICAvLyBJZiB4IGlzIG5lZ2F0aXZlIGFuZCBuIGlzIG9kZCwgayA9IC0wLCBlbHNlIGsgPSAwLlxyXG4gICAgICBrID0geC5zIDwgMCAmJiBpc09kZChuKSA/IC0wIDogMDtcclxuXHJcbiAgICAgIC8vIElmIHggPj0gMSwgayA9IFx1MDBCMUluZmluaXR5LlxyXG4gICAgICBpZiAoeC5lID4gLTEpIGsgPSAxIC8gaztcclxuXHJcbiAgICAgIC8vIElmIG4gaXMgbmVnYXRpdmUgcmV0dXJuIFx1MDBCMTAsIGVsc2UgcmV0dXJuIFx1MDBCMUluZmluaXR5LlxyXG4gICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihuSXNOZWcgPyAxIC8gayA6IGspO1xyXG5cclxuICAgIH0gZWxzZSBpZiAoUE9XX1BSRUNJU0lPTikge1xyXG5cclxuICAgICAgLy8gVHJ1bmNhdGluZyBlYWNoIGNvZWZmaWNpZW50IGFycmF5IHRvIGEgbGVuZ3RoIG9mIGsgYWZ0ZXIgZWFjaCBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAvLyBlcXVhdGVzIHRvIHRydW5jYXRpbmcgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIFBPV19QUkVDSVNJT04gKyBbMjgsIDQxXSxcclxuICAgICAgLy8gaS5lLiB0aGVyZSB3aWxsIGJlIGEgbWluaW11bSBvZiAyOCBndWFyZCBkaWdpdHMgcmV0YWluZWQuXHJcbiAgICAgIGsgPSBtYXRoY2VpbChQT1dfUFJFQ0lTSU9OIC8gTE9HX0JBU0UgKyAyKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobklzQmlnKSB7XHJcbiAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKDAuNSk7XHJcbiAgICAgIGlmIChuSXNOZWcpIG4ucyA9IDE7XHJcbiAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaSA9IE1hdGguYWJzKCt2YWx1ZU9mKG4pKTtcclxuICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICB9XHJcblxyXG4gICAgeSA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAvLyBQZXJmb3JtcyA1NCBsb29wIGl0ZXJhdGlvbnMgZm9yIG4gb2YgOTAwNzE5OTI1NDc0MDk5MS5cclxuICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICBpZiAobklzT2RkKSB7XHJcbiAgICAgICAgeSA9IHkudGltZXMoeCk7XHJcbiAgICAgICAgaWYgKCF5LmMpIGJyZWFrO1xyXG5cclxuICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgaWYgKHkuYy5sZW5ndGggPiBrKSB5LmMubGVuZ3RoID0gaztcclxuICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICB5ID0geS5tb2QobSk7ICAgIC8veSA9IHkubWludXMoZGl2KHksIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaSkge1xyXG4gICAgICAgIGkgPSBtYXRoZmxvb3IoaSAvIDIpO1xyXG4gICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuID0gbi50aW1lcyhoYWxmKTtcclxuICAgICAgICByb3VuZChuLCBuLmUgKyAxLCAxKTtcclxuXHJcbiAgICAgICAgaWYgKG4uZSA+IDE0KSB7XHJcbiAgICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSA9ICt2YWx1ZU9mKG4pO1xyXG4gICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB4ID0geC50aW1lcyh4KTtcclxuXHJcbiAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgaWYgKHguYyAmJiB4LmMubGVuZ3RoID4gaykgeC5jLmxlbmd0aCA9IGs7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICB4ID0geC5tb2QobSk7ICAgIC8veCA9IHgubWludXMoZGl2KHgsIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNNb2RFeHApIHJldHVybiB5O1xyXG4gICAgaWYgKG5Jc05lZykgeSA9IE9ORS5kaXYoeSk7XHJcblxyXG4gICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IGsgPyByb3VuZCh5LCBQT1dfUFJFQ0lTSU9OLCBST1VORElOR19NT0RFLCBtb3JlKSA6IHk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBhbiBpbnRlZ2VyXHJcbiAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAqXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtybX0nXHJcbiAgICovXHJcbiAgUC5pbnRlZ2VyVmFsdWUgPSBmdW5jdGlvbiAocm0pIHtcclxuICAgIHZhciBuID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuICAgIHJldHVybiByb3VuZChuLCBuLmUgKyAxLCBybSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzRXF1YWxUbyA9IFAuZXEgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPT09IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGEgZmluaXRlIG51bWJlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzRmluaXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICEhdGhpcy5jO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNHcmVhdGVyVGhhbiA9IFAuZ3QgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPiAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyA9IFAuZ3RlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAxIHx8IGIgPT09IDA7XHJcblxyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhbiBpbnRlZ2VyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNJbnRlZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICEhdGhpcy5jICYmIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSA+IHRoaXMuYy5sZW5ndGggLSAyO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNMZXNzVGhhbiA9IFAubHQgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPCAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNMZXNzVGhhbk9yRXF1YWxUbyA9IFAubHRlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAtMSB8fCBiID09PSAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBOYU4sIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc05hTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAhdGhpcy5zO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zIDwgMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgcG9zaXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucyA+IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIDAgb3IgLTAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gISF0aGlzLmMgJiYgdGhpcy5jWzBdID09IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIG4gLSAwID0gblxyXG4gICAqICBuIC0gTiA9IE5cclxuICAgKiAgbiAtIEkgPSAtSVxyXG4gICAqICAwIC0gbiA9IC1uXHJcbiAgICogIDAgLSAwID0gMFxyXG4gICAqICAwIC0gTiA9IE5cclxuICAgKiAgMCAtIEkgPSAtSVxyXG4gICAqICBOIC0gbiA9IE5cclxuICAgKiAgTiAtIDAgPSBOXHJcbiAgICogIE4gLSBOID0gTlxyXG4gICAqICBOIC0gSSA9IE5cclxuICAgKiAgSSAtIG4gPSBJXHJcbiAgICogIEkgLSAwID0gSVxyXG4gICAqICBJIC0gTiA9IE5cclxuICAgKiAgSSAtIEkgPSBOXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtaW51cyB0aGUgdmFsdWUgb2ZcclxuICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICovXHJcbiAgUC5taW51cyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICB2YXIgaSwgaiwgdCwgeExUeSxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICBiID0geS5zO1xyXG5cclxuICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgaWYgKGEgIT0gYikge1xyXG4gICAgICB5LnMgPSAtYjtcclxuICAgICAgcmV0dXJuIHgucGx1cyh5KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgeGMgPSB4LmMsXHJcbiAgICAgIHljID0geS5jO1xyXG5cclxuICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4geGMgPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih5YyA/IHggOiBOYU4pO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgIHJldHVybiB5Y1swXSA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6XHJcblxyXG4gICAgICAgICAvLyBJRUVFIDc1NCAoMjAwOCkgNi4zOiBuIC0gbiA9IC0wIHdoZW4gcm91bmRpbmcgdG8gLUluZmluaXR5XHJcbiAgICAgICAgIFJPVU5ESU5HX01PREUgPT0gMyA/IC0wIDogMCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgIC8vIERldGVybWluZSB3aGljaCBpcyB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG5cclxuICAgICAgaWYgKHhMVHkgPSBhIDwgMCkge1xyXG4gICAgICAgIGEgPSAtYTtcclxuICAgICAgICB0ID0geGM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICB0ID0geWM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHQucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgICAgIGZvciAoYiA9IGE7IGItLTsgdC5wdXNoKDApKTtcclxuICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgLy8gRXhwb25lbnRzIGVxdWFsLiBDaGVjayBkaWdpdCBieSBkaWdpdC5cclxuICAgICAgaiA9ICh4TFR5ID0gKGEgPSB4Yy5sZW5ndGgpIDwgKGIgPSB5Yy5sZW5ndGgpKSA/IGEgOiBiO1xyXG5cclxuICAgICAgZm9yIChhID0gYiA9IDA7IGIgPCBqOyBiKyspIHtcclxuXHJcbiAgICAgICAgaWYgKHhjW2JdICE9IHljW2JdKSB7XHJcbiAgICAgICAgICB4TFR5ID0geGNbYl0gPCB5Y1tiXTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHggPCB5PyBQb2ludCB4YyB0byB0aGUgYXJyYXkgb2YgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICBpZiAoeExUeSkge1xyXG4gICAgICB0ID0geGM7XHJcbiAgICAgIHhjID0geWM7XHJcbiAgICAgIHljID0gdDtcclxuICAgICAgeS5zID0gLXkucztcclxuICAgIH1cclxuXHJcbiAgICBiID0gKGogPSB5Yy5sZW5ndGgpIC0gKGkgPSB4Yy5sZW5ndGgpO1xyXG5cclxuICAgIC8vIEFwcGVuZCB6ZXJvcyB0byB4YyBpZiBzaG9ydGVyLlxyXG4gICAgLy8gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdCBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IHljLmxlbmd0aC5cclxuICAgIGlmIChiID4gMCkgZm9yICg7IGItLTsgeGNbaSsrXSA9IDApO1xyXG4gICAgYiA9IEJBU0UgLSAxO1xyXG5cclxuICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgICBmb3IgKDsgaiA+IGE7KSB7XHJcblxyXG4gICAgICBpZiAoeGNbLS1qXSA8IHljW2pdKSB7XHJcbiAgICAgICAgZm9yIChpID0gajsgaSAmJiAheGNbLS1pXTsgeGNbaV0gPSBiKTtcclxuICAgICAgICAtLXhjW2ldO1xyXG4gICAgICAgIHhjW2pdICs9IEJBU0U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhjW2pdIC09IHljW2pdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICBmb3IgKDsgeGNbMF0gPT0gMDsgeGMuc3BsaWNlKDAsIDEpLCAtLXllKTtcclxuXHJcbiAgICAvLyBaZXJvP1xyXG4gICAgaWYgKCF4Y1swXSkge1xyXG5cclxuICAgICAgLy8gRm9sbG93aW5nIElFRUUgNzU0ICgyMDA4KSA2LjMsXHJcbiAgICAgIC8vIG4gLSBuID0gKzAgIGJ1dCAgbiAtIG4gPSAtMCAgd2hlbiByb3VuZGluZyB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgeS5zID0gUk9VTkRJTkdfTU9ERSA9PSAzID8gLTEgOiAxO1xyXG4gICAgICB5LmMgPSBbeS5lID0gMF07XHJcbiAgICAgIHJldHVybiB5O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIEluZmluaXR5IGFzICt4IC0gK3kgIT0gSW5maW5pdHkgJiYgLXggLSAteSAhPSBJbmZpbml0eVxyXG4gICAgLy8gZm9yIGZpbml0ZSB4IGFuZCB5LlxyXG4gICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICAgbiAlIDAgPSAgTlxyXG4gICAqICAgbiAlIE4gPSAgTlxyXG4gICAqICAgbiAlIEkgPSAgblxyXG4gICAqICAgMCAlIG4gPSAgMFxyXG4gICAqICAtMCAlIG4gPSAtMFxyXG4gICAqICAgMCAlIDAgPSAgTlxyXG4gICAqICAgMCAlIE4gPSAgTlxyXG4gICAqICAgMCAlIEkgPSAgMFxyXG4gICAqICAgTiAlIG4gPSAgTlxyXG4gICAqICAgTiAlIDAgPSAgTlxyXG4gICAqICAgTiAlIE4gPSAgTlxyXG4gICAqICAgTiAlIEkgPSAgTlxyXG4gICAqICAgSSAlIG4gPSAgTlxyXG4gICAqICAgSSAlIDAgPSAgTlxyXG4gICAqICAgSSAlIE4gPSAgTlxyXG4gICAqICAgSSAlIEkgPSAgTlxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbW9kdWxvIHRoZSB2YWx1ZSBvZlxyXG4gICAqIEJpZ051bWJlcih5LCBiKS4gVGhlIHJlc3VsdCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiBNT0RVTE9fTU9ERS5cclxuICAgKi9cclxuICBQLm1vZHVsbyA9IFAubW9kID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHZhciBxLCBzLFxyXG4gICAgICB4ID0gdGhpcztcclxuXHJcbiAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuXHJcbiAgICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgSW5maW5pdHkgb3IgTmFOLCBvciB5IGlzIE5hTiBvciB6ZXJvLlxyXG4gICAgaWYgKCF4LmMgfHwgIXkucyB8fCB5LmMgJiYgIXkuY1swXSkge1xyXG4gICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgIC8vIFJldHVybiB4IGlmIHkgaXMgSW5maW5pdHkgb3IgeCBpcyB6ZXJvLlxyXG4gICAgfSBlbHNlIGlmICgheS5jIHx8IHguYyAmJiAheC5jWzBdKSB7XHJcbiAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChNT0RVTE9fTU9ERSA9PSA5KSB7XHJcblxyXG4gICAgICAvLyBFdWNsaWRpYW4gZGl2aXNpb246IHEgPSBzaWduKHkpICogZmxvb3IoeCAvIGFicyh5KSlcclxuICAgICAgLy8gciA9IHggLSBxeSAgICB3aGVyZSAgMCA8PSByIDwgYWJzKHkpXHJcbiAgICAgIHMgPSB5LnM7XHJcbiAgICAgIHkucyA9IDE7XHJcbiAgICAgIHEgPSBkaXYoeCwgeSwgMCwgMyk7XHJcbiAgICAgIHkucyA9IHM7XHJcbiAgICAgIHEucyAqPSBzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcSA9IGRpdih4LCB5LCAwLCBNT0RVTE9fTU9ERSk7XHJcbiAgICB9XHJcblxyXG4gICAgeSA9IHgubWludXMocS50aW1lcyh5KSk7XHJcblxyXG4gICAgLy8gVG8gbWF0Y2ggSmF2YVNjcmlwdCAlLCBlbnN1cmUgc2lnbiBvZiB6ZXJvIGlzIHNpZ24gb2YgZGl2aWRlbmQuXHJcbiAgICBpZiAoIXkuY1swXSAmJiBNT0RVTE9fTU9ERSA9PSAxKSB5LnMgPSB4LnM7XHJcblxyXG4gICAgcmV0dXJuIHk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIG4gKiAwID0gMFxyXG4gICAqICBuICogTiA9IE5cclxuICAgKiAgbiAqIEkgPSBJXHJcbiAgICogIDAgKiBuID0gMFxyXG4gICAqICAwICogMCA9IDBcclxuICAgKiAgMCAqIE4gPSBOXHJcbiAgICogIDAgKiBJID0gTlxyXG4gICAqICBOICogbiA9IE5cclxuICAgKiAgTiAqIDAgPSBOXHJcbiAgICogIE4gKiBOID0gTlxyXG4gICAqICBOICogSSA9IE5cclxuICAgKiAgSSAqIG4gPSBJXHJcbiAgICogIEkgKiAwID0gTlxyXG4gICAqICBJICogTiA9IE5cclxuICAgKiAgSSAqIEkgPSBJXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtdWx0aXBsaWVkIGJ5IHRoZSB2YWx1ZVxyXG4gICAqIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgKi9cclxuICBQLm11bHRpcGxpZWRCeSA9IFAudGltZXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgdmFyIGMsIGUsIGksIGosIGssIG0sIHhjTCwgeGxvLCB4aGksIHljTCwgeWxvLCB5aGksIHpjLFxyXG4gICAgICBiYXNlLCBzcXJ0QmFzZSxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICB5YyA9ICh5ID0gbmV3IEJpZ051bWJlcih5LCBiKSkuYztcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOLCBcdTAwQjFJbmZpbml0eSBvciBcdTAwQjEwP1xyXG4gICAgaWYgKCF4YyB8fCAheWMgfHwgIXhjWzBdIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgaXMgTmFOLCBvciBvbmUgaXMgMCBhbmQgdGhlIG90aGVyIGlzIEluZmluaXR5LlxyXG4gICAgICBpZiAoIXgucyB8fCAheS5zIHx8IHhjICYmICF4Y1swXSAmJiAheWMgfHwgeWMgJiYgIXljWzBdICYmICF4Yykge1xyXG4gICAgICAgIHkuYyA9IHkuZSA9IHkucyA9IG51bGw7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeS5zICo9IHgucztcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIFx1MDBCMUluZmluaXR5IGlmIGVpdGhlciBpcyBcdTAwQjFJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXhjIHx8ICF5Yykge1xyXG4gICAgICAgICAgeS5jID0geS5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIFx1MDBCMTAgaWYgZWl0aGVyIGlzIFx1MDBCMTAuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHkuYyA9IFswXTtcclxuICAgICAgICAgIHkuZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4geTtcclxuICAgIH1cclxuXHJcbiAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpICsgYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgeS5zICo9IHgucztcclxuICAgIHhjTCA9IHhjLmxlbmd0aDtcclxuICAgIHljTCA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAvLyBFbnN1cmUgeGMgcG9pbnRzIHRvIGxvbmdlciBhcnJheSBhbmQgeGNMIHRvIGl0cyBsZW5ndGguXHJcbiAgICBpZiAoeGNMIDwgeWNMKSB7XHJcbiAgICAgIHpjID0geGM7XHJcbiAgICAgIHhjID0geWM7XHJcbiAgICAgIHljID0gemM7XHJcbiAgICAgIGkgPSB4Y0w7XHJcbiAgICAgIHhjTCA9IHljTDtcclxuICAgICAgeWNMID0gaTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cclxuICAgIGZvciAoaSA9IHhjTCArIHljTCwgemMgPSBbXTsgaS0tOyB6Yy5wdXNoKDApKTtcclxuXHJcbiAgICBiYXNlID0gQkFTRTtcclxuICAgIHNxcnRCYXNlID0gU1FSVF9CQVNFO1xyXG5cclxuICAgIGZvciAoaSA9IHljTDsgLS1pID49IDA7KSB7XHJcbiAgICAgIGMgPSAwO1xyXG4gICAgICB5bG8gPSB5Y1tpXSAlIHNxcnRCYXNlO1xyXG4gICAgICB5aGkgPSB5Y1tpXSAvIHNxcnRCYXNlIHwgMDtcclxuXHJcbiAgICAgIGZvciAoayA9IHhjTCwgaiA9IGkgKyBrOyBqID4gaTspIHtcclxuICAgICAgICB4bG8gPSB4Y1stLWtdICUgc3FydEJhc2U7XHJcbiAgICAgICAgeGhpID0geGNba10gLyBzcXJ0QmFzZSB8IDA7XHJcbiAgICAgICAgbSA9IHloaSAqIHhsbyArIHhoaSAqIHlsbztcclxuICAgICAgICB4bG8gPSB5bG8gKiB4bG8gKyAoKG0gJSBzcXJ0QmFzZSkgKiBzcXJ0QmFzZSkgKyB6Y1tqXSArIGM7XHJcbiAgICAgICAgYyA9ICh4bG8gLyBiYXNlIHwgMCkgKyAobSAvIHNxcnRCYXNlIHwgMCkgKyB5aGkgKiB4aGk7XHJcbiAgICAgICAgemNbai0tXSA9IHhsbyAlIGJhc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHpjW2pdID0gYztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYykge1xyXG4gICAgICArK2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB6Yy5zcGxpY2UoMCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB6YywgZSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbmVnYXRlZCxcclxuICAgKiBpLmUuIG11bHRpcGxpZWQgYnkgLTEuXHJcbiAgICovXHJcbiAgUC5uZWdhdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgeC5zID0gLXgucyB8fCBudWxsO1xyXG4gICAgcmV0dXJuIHg7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIG4gKyAwID0gblxyXG4gICAqICBuICsgTiA9IE5cclxuICAgKiAgbiArIEkgPSBJXHJcbiAgICogIDAgKyBuID0gblxyXG4gICAqICAwICsgMCA9IDBcclxuICAgKiAgMCArIE4gPSBOXHJcbiAgICogIDAgKyBJID0gSVxyXG4gICAqICBOICsgbiA9IE5cclxuICAgKiAgTiArIDAgPSBOXHJcbiAgICogIE4gKyBOID0gTlxyXG4gICAqICBOICsgSSA9IE5cclxuICAgKiAgSSArIG4gPSBJXHJcbiAgICogIEkgKyAwID0gSVxyXG4gICAqICBJICsgTiA9IE5cclxuICAgKiAgSSArIEkgPSBJXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBwbHVzIHRoZSB2YWx1ZSBvZlxyXG4gICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgKi9cclxuICBQLnBsdXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgdmFyIHQsXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBhID0geC5zO1xyXG5cclxuICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgYiA9IHkucztcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgIHkucyA9IC1iO1xyXG4gICAgICByZXR1cm4geC5taW51cyh5KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgeGMgPSB4LmMsXHJcbiAgICAgIHljID0geS5jO1xyXG5cclxuICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gXHUwMEIxSW5maW5pdHkgaWYgZWl0aGVyIFx1MDBCMUluZmluaXR5LlxyXG4gICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoYSAvIDApO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkgcmV0dXJuIHljWzBdID8geSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDogYSAqIDApO1xyXG4gICAgfVxyXG5cclxuICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuIEZhc3RlciB0byB1c2UgcmV2ZXJzZSB0aGVuIGRvIHVuc2hpZnRzLlxyXG4gICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcbiAgICAgIGlmIChhID4gMCkge1xyXG4gICAgICAgIHllID0geGU7XHJcbiAgICAgICAgdCA9IHljO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGEgPSAtYTtcclxuICAgICAgICB0ID0geGM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICBmb3IgKDsgYS0tOyB0LnB1c2goMCkpO1xyXG4gICAgICB0LnJldmVyc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBhID0geGMubGVuZ3RoO1xyXG4gICAgYiA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAvLyBQb2ludCB4YyB0byB0aGUgbG9uZ2VyIGFycmF5LCBhbmQgYiB0byB0aGUgc2hvcnRlciBsZW5ndGguXHJcbiAgICBpZiAoYSAtIGIgPCAwKSB7XHJcbiAgICAgIHQgPSB5YztcclxuICAgICAgeWMgPSB4YztcclxuICAgICAgeGMgPSB0O1xyXG4gICAgICBiID0gYTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBPbmx5IHN0YXJ0IGFkZGluZyBhdCB5Yy5sZW5ndGggLSAxIGFzIHRoZSBmdXJ0aGVyIGRpZ2l0cyBvZiB4YyBjYW4gYmUgaWdub3JlZC5cclxuICAgIGZvciAoYSA9IDA7IGI7KSB7XHJcbiAgICAgIGEgPSAoeGNbLS1iXSA9IHhjW2JdICsgeWNbYl0gKyBhKSAvIEJBU0UgfCAwO1xyXG4gICAgICB4Y1tiXSA9IEJBU0UgPT09IHhjW2JdID8gMCA6IHhjW2JdICUgQkFTRTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYSkge1xyXG4gICAgICB4YyA9IFthXS5jb25jYXQoeGMpO1xyXG4gICAgICArK3llO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIHplcm8sIGFzICt4ICsgK3kgIT0gMCAmJiAteCArIC15ICE9IDBcclxuICAgIC8vIHllID0gTUFYX0VYUCArIDEgcG9zc2libGVcclxuICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBJZiBzZCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2ZcclxuICAgKiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIFx1MDBCMUluZmluaXR5IG9yIE5hTi5cclxuICAgKiBJZiBzZCBpcyB0cnVlIGluY2x1ZGUgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zIGluIHRoZSBjb3VudC5cclxuICAgKlxyXG4gICAqIE90aGVyd2lzZSwgaWYgc2QgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2Ygc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAqXHJcbiAgICogc2Qge251bWJlcnxib29sZWFufSBudW1iZXI6IHNpZ25pZmljYW50IGRpZ2l0czogaW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogd2hldGhlciB0byBjb3VudCBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3M6IHRydWUgb3IgZmFsc2UuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICovXHJcbiAgUC5wcmVjaXNpb24gPSBQLnNkID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgIGlmIChzZCAhPSBudWxsICYmIHNkICE9PSAhIXNkKSB7XHJcbiAgICAgIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBzZCwgcm0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgIHYgPSBjLmxlbmd0aCAtIDE7XHJcbiAgICBuID0gdiAqIExPR19CQVNFICsgMTtcclxuXHJcbiAgICBpZiAodiA9IGNbdl0pIHtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgZWxlbWVudC5cclxuICAgICAgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG5cclxuICAgICAgLy8gQWRkIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50LlxyXG4gICAgICBmb3IgKHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBuKyspO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZCAmJiB4LmUgKyAxID4gbikgbiA9IHguZSArIDE7XHJcblxyXG4gICAgcmV0dXJuIG47XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgc2hpZnRlZCBieSBrIHBsYWNlc1xyXG4gICAqIChwb3dlcnMgb2YgMTApLiBTaGlmdCB0byB0aGUgcmlnaHQgaWYgbiA+IDAsIGFuZCB0byB0aGUgbGVmdCBpZiBuIDwgMC5cclxuICAgKlxyXG4gICAqIGsge251bWJlcn0gSW50ZWdlciwgLU1BWF9TQUZFX0lOVEVHRVIgdG8gTUFYX1NBRkVfSU5URUdFUiBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2t9J1xyXG4gICAqL1xyXG4gIFAuc2hpZnRlZEJ5ID0gZnVuY3Rpb24gKGspIHtcclxuICAgIGludENoZWNrKGssIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKTtcclxuICAgIHJldHVybiB0aGlzLnRpbWVzKCcxZScgKyBrKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiAgc3FydCgtbikgPSAgTlxyXG4gICAqICBzcXJ0KE4pID0gIE5cclxuICAgKiAgc3FydCgtSSkgPSAgTlxyXG4gICAqICBzcXJ0KEkpID0gIElcclxuICAgKiAgc3FydCgwKSA9ICAwXHJcbiAgICogIHNxcnQoLTApID0gLTBcclxuICAgKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlcixcclxuICAgKiByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgKi9cclxuICBQLnNxdWFyZVJvb3QgPSBQLnNxcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbSwgbiwgciwgcmVwLCB0LFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgYyA9IHguYyxcclxuICAgICAgcyA9IHgucyxcclxuICAgICAgZSA9IHguZSxcclxuICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyArIDQsXHJcbiAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKCcwLjUnKTtcclxuXHJcbiAgICAvLyBOZWdhdGl2ZS9OYU4vSW5maW5pdHkvemVybz9cclxuICAgIGlmIChzICE9PSAxIHx8ICFjIHx8ICFjWzBdKSB7XHJcbiAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCFzIHx8IHMgPCAwICYmICghYyB8fCBjWzBdKSA/IE5hTiA6IGMgPyB4IDogMSAvIDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEluaXRpYWwgZXN0aW1hdGUuXHJcbiAgICBzID0gTWF0aC5zcXJ0KCt2YWx1ZU9mKHgpKTtcclxuXHJcbiAgICAvLyBNYXRoLnNxcnQgdW5kZXJmbG93L292ZXJmbG93P1xyXG4gICAgLy8gUGFzcyB4IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgZXhwb25lbnQgb2YgdGhlIHJlc3VsdC5cclxuICAgIGlmIChzID09IDAgfHwgcyA9PSAxIC8gMCkge1xyXG4gICAgICBuID0gY29lZmZUb1N0cmluZyhjKTtcclxuICAgICAgaWYgKChuLmxlbmd0aCArIGUpICUgMiA9PSAwKSBuICs9ICcwJztcclxuICAgICAgcyA9IE1hdGguc3FydCgrbik7XHJcbiAgICAgIGUgPSBiaXRGbG9vcigoZSArIDEpIC8gMikgLSAoZSA8IDAgfHwgZSAlIDIpO1xyXG5cclxuICAgICAgaWYgKHMgPT0gMSAvIDApIHtcclxuICAgICAgICBuID0gJzVlJyArIGU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xyXG4gICAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZignZScpICsgMSkgKyBlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByID0gbmV3IEJpZ051bWJlcihuKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKHMgKyAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgZm9yIHplcm8uXHJcbiAgICAvLyByIGNvdWxkIGJlIHplcm8gaWYgTUlOX0VYUCBpcyBjaGFuZ2VkIGFmdGVyIHRoZSB0aGlzIHZhbHVlIHdhcyBjcmVhdGVkLlxyXG4gICAgLy8gVGhpcyB3b3VsZCBjYXVzZSBhIGRpdmlzaW9uIGJ5IHplcm8gKHgvdCkgYW5kIGhlbmNlIEluZmluaXR5IGJlbG93LCB3aGljaCB3b3VsZCBjYXVzZVxyXG4gICAgLy8gY29lZmZUb1N0cmluZyB0byB0aHJvdy5cclxuICAgIGlmIChyLmNbMF0pIHtcclxuICAgICAgZSA9IHIuZTtcclxuICAgICAgcyA9IGUgKyBkcDtcclxuICAgICAgaWYgKHMgPCAzKSBzID0gMDtcclxuXHJcbiAgICAgIC8vIE5ld3Rvbi1SYXBoc29uIGl0ZXJhdGlvbi5cclxuICAgICAgZm9yICg7IDspIHtcclxuICAgICAgICB0ID0gcjtcclxuICAgICAgICByID0gaGFsZi50aW1lcyh0LnBsdXMoZGl2KHgsIHQsIGRwLCAxKSkpO1xyXG5cclxuICAgICAgICBpZiAoY29lZmZUb1N0cmluZyh0LmMpLnNsaWNlKDAsIHMpID09PSAobiA9IGNvZWZmVG9TdHJpbmcoci5jKSkuc2xpY2UoMCwgcykpIHtcclxuXHJcbiAgICAgICAgICAvLyBUaGUgZXhwb25lbnQgb2YgciBtYXkgaGVyZSBiZSBvbmUgbGVzcyB0aGFuIHRoZSBmaW5hbCByZXN1bHQgZXhwb25lbnQsXHJcbiAgICAgICAgICAvLyBlLmcgMC4wMDA5OTk5IChlLTQpIC0tPiAwLjAwMSAoZS0zKSwgc28gYWRqdXN0IHMgc28gdGhlIHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgLy8gYXJlIGluZGV4ZWQgY29ycmVjdGx5LlxyXG4gICAgICAgICAgaWYgKHIuZSA8IGUpIC0tcztcclxuICAgICAgICAgIG4gPSBuLnNsaWNlKHMgLSAzLCBzICsgMSk7XHJcblxyXG4gICAgICAgICAgLy8gVGhlIDR0aCByb3VuZGluZyBkaWdpdCBtYXkgYmUgaW4gZXJyb3IgYnkgLTEgc28gaWYgdGhlIDQgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAvLyBhcmUgOTk5OSBvciA0OTk5IChpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnkpIGNvbnRpbnVlIHRoZVxyXG4gICAgICAgICAgLy8gaXRlcmF0aW9uLlxyXG4gICAgICAgICAgaWYgKG4gPT0gJzk5OTknIHx8ICFyZXAgJiYgbiA9PSAnNDk5OScpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIE9uIHRoZSBmaXJzdCBpdGVyYXRpb24gb25seSwgY2hlY2sgdG8gc2VlIGlmIHJvdW5kaW5nIHVwIGdpdmVzIHRoZVxyXG4gICAgICAgICAgICAvLyBleGFjdCByZXN1bHQgYXMgdGhlIG5pbmVzIG1heSBpbmZpbml0ZWx5IHJlcGVhdC5cclxuICAgICAgICAgICAgaWYgKCFyZXApIHtcclxuICAgICAgICAgICAgICByb3VuZCh0LCB0LmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDApO1xyXG5cclxuICAgICAgICAgICAgICBpZiAodC50aW1lcyh0KS5lcSh4KSkge1xyXG4gICAgICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRwICs9IDQ7XHJcbiAgICAgICAgICAgIHMgKz0gNDtcclxuICAgICAgICAgICAgcmVwID0gMTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiByb3VuZGluZyBkaWdpdHMgYXJlIG51bGwsIDB7MCw0fSBvciA1MHswLDN9LCBjaGVjayBmb3IgZXhhY3RcclxuICAgICAgICAgICAgLy8gcmVzdWx0LiBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgICAgICBpZiAoIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSAnNScpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAgIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMSk7XHJcbiAgICAgICAgICAgICAgbSA9ICFyLnRpbWVzKHIpLmVxKHgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAxLCBST1VORElOR19NT0RFLCBtKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBleHBvbmVudGlhbCBub3RhdGlvbiBhbmRcclxuICAgKiByb3VuZGVkIHVzaW5nIFJPVU5ESU5HX01PREUgdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICpcclxuICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICovXHJcbiAgUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgIGRwKys7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSwgMSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRpbmdcclxuICAgKiB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICpcclxuICAgKiBOb3RlOiBhcyB3aXRoIEphdmFTY3JpcHQncyBudW1iZXIgdHlwZSwgKC0wKS50b0ZpeGVkKDApIGlzICcwJyxcclxuICAgKiBidXQgZS5nLiAoLTAuMDAwMDEpLnRvRml4ZWQoMCkgaXMgJy0wJy5cclxuICAgKlxyXG4gICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgKi9cclxuICBQLnRvRml4ZWQgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgZHAgPSBkcCArIHRoaXMuZSArIDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRlZFxyXG4gICAqIHVzaW5nIHJtIG9yIFJPVU5ESU5HX01PREUgdG8gZHAgZGVjaW1hbCBwbGFjZXMsIGFuZCBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm9wZXJ0aWVzXHJcbiAgICogb2YgdGhlIGZvcm1hdCBvciBGT1JNQVQgb2JqZWN0IChzZWUgQmlnTnVtYmVyLnNldCkuXHJcbiAgICpcclxuICAgKiBUaGUgZm9ybWF0dGluZyBvYmplY3QgbWF5IGNvbnRhaW4gc29tZSBvciBhbGwgb2YgdGhlIHByb3BlcnRpZXMgc2hvd24gYmVsb3cuXHJcbiAgICpcclxuICAgKiBGT1JNQVQgPSB7XHJcbiAgICogICBwcmVmaXg6ICcnLFxyXG4gICAqICAgZ3JvdXBTaXplOiAzLFxyXG4gICAqICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAqICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgKiAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgKiAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAqICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgKiAgIHN1ZmZpeDogJydcclxuICAgKiB9O1xyXG4gICAqXHJcbiAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgKiBbZm9ybWF0XSB7b2JqZWN0fSBGb3JtYXR0aW5nIG9wdGlvbnMuIFNlZSBGT1JNQVQgcGJqZWN0IGFib3ZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IG5vdCBhbiBvYmplY3Q6IHtmb3JtYXR9J1xyXG4gICAqL1xyXG4gIFAudG9Gb3JtYXQgPSBmdW5jdGlvbiAoZHAsIHJtLCBmb3JtYXQpIHtcclxuICAgIHZhciBzdHIsXHJcbiAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCAmJiBybSAmJiB0eXBlb2Ygcm0gPT0gJ29iamVjdCcpIHtcclxuICAgICAgICBmb3JtYXQgPSBybTtcclxuICAgICAgICBybSA9IG51bGw7XHJcbiAgICAgIH0gZWxzZSBpZiAoZHAgJiYgdHlwZW9mIGRwID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgZm9ybWF0ID0gZHA7XHJcbiAgICAgICAgZHAgPSBybSA9IG51bGw7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9ybWF0ID0gRk9STUFUO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXQgIT0gJ29iamVjdCcpIHtcclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgbm90IGFuIG9iamVjdDogJyArIGZvcm1hdCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RyID0geC50b0ZpeGVkKGRwLCBybSk7XHJcblxyXG4gICAgaWYgKHguYykge1xyXG4gICAgICB2YXIgaSxcclxuICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJy4nKSxcclxuICAgICAgICBnMSA9ICtmb3JtYXQuZ3JvdXBTaXplLFxyXG4gICAgICAgIGcyID0gK2Zvcm1hdC5zZWNvbmRhcnlHcm91cFNpemUsXHJcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3IgPSBmb3JtYXQuZ3JvdXBTZXBhcmF0b3IgfHwgJycsXHJcbiAgICAgICAgaW50UGFydCA9IGFyclswXSxcclxuICAgICAgICBmcmFjdGlvblBhcnQgPSBhcnJbMV0sXHJcbiAgICAgICAgaXNOZWcgPSB4LnMgPCAwLFxyXG4gICAgICAgIGludERpZ2l0cyA9IGlzTmVnID8gaW50UGFydC5zbGljZSgxKSA6IGludFBhcnQsXHJcbiAgICAgICAgbGVuID0gaW50RGlnaXRzLmxlbmd0aDtcclxuXHJcbiAgICAgIGlmIChnMikge1xyXG4gICAgICAgIGkgPSBnMTtcclxuICAgICAgICBnMSA9IGcyO1xyXG4gICAgICAgIGcyID0gaTtcclxuICAgICAgICBsZW4gLT0gaTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGcxID4gMCAmJiBsZW4gPiAwKSB7XHJcbiAgICAgICAgaSA9IGxlbiAlIGcxIHx8IGcxO1xyXG4gICAgICAgIGludFBhcnQgPSBpbnREaWdpdHMuc3Vic3RyKDAsIGkpO1xyXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpICs9IGcxKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnN1YnN0cihpLCBnMSk7XHJcbiAgICAgICAgaWYgKGcyID4gMCkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zbGljZShpKTtcclxuICAgICAgICBpZiAoaXNOZWcpIGludFBhcnQgPSAnLScgKyBpbnRQYXJ0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdHIgPSBmcmFjdGlvblBhcnRcclxuICAgICAgID8gaW50UGFydCArIChmb3JtYXQuZGVjaW1hbFNlcGFyYXRvciB8fCAnJykgKyAoKGcyID0gK2Zvcm1hdC5mcmFjdGlvbkdyb3VwU2l6ZSlcclxuICAgICAgICA/IGZyYWN0aW9uUGFydC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxkeycgKyBnMiArICd9XFxcXEInLCAnZycpLFxyXG4gICAgICAgICAnJCYnICsgKGZvcm1hdC5mcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHx8ICcnKSlcclxuICAgICAgICA6IGZyYWN0aW9uUGFydClcclxuICAgICAgIDogaW50UGFydDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKGZvcm1hdC5wcmVmaXggfHwgJycpICsgc3RyICsgKGZvcm1hdC5zdWZmaXggfHwgJycpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiB0d28gQmlnTnVtYmVycyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGFzIGEgc2ltcGxlXHJcbiAgICogZnJhY3Rpb24gd2l0aCBhbiBpbnRlZ2VyIG51bWVyYXRvciBhbmQgYW4gaW50ZWdlciBkZW5vbWluYXRvci5cclxuICAgKiBUaGUgZGVub21pbmF0b3Igd2lsbCBiZSBhIHBvc2l0aXZlIG5vbi16ZXJvIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc3BlY2lmaWVkXHJcbiAgICogbWF4aW11bSBkZW5vbWluYXRvci4gSWYgYSBtYXhpbXVtIGRlbm9taW5hdG9yIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBkZW5vbWluYXRvciB3aWxsIGJlXHJcbiAgICogdGhlIGxvd2VzdCB2YWx1ZSBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBudW1iZXIgZXhhY3RseS5cclxuICAgKlxyXG4gICAqIFttZF0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBJbnRlZ2VyID49IDEsIG9yIEluZmluaXR5LiBUaGUgbWF4aW11bSBkZW5vbWluYXRvci5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfSA6IHttZH0nXHJcbiAgICovXHJcbiAgUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24gKG1kKSB7XHJcbiAgICB2YXIgZCwgZDAsIGQxLCBkMiwgZSwgZXhwLCBuLCBuMCwgbjEsIHEsIHIsIHMsXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICB4YyA9IHguYztcclxuXHJcbiAgICBpZiAobWQgIT0gbnVsbCkge1xyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihtZCk7XHJcblxyXG4gICAgICAvLyBUaHJvdyBpZiBtZCBpcyBsZXNzIHRoYW4gb25lIG9yIGlzIG5vdCBhbiBpbnRlZ2VyLCB1bmxlc3MgaXQgaXMgSW5maW5pdHkuXHJcbiAgICAgIGlmICghbi5pc0ludGVnZXIoKSAmJiAobi5jIHx8IG4ucyAhPT0gMSkgfHwgbi5sdChPTkUpKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCAnICtcclxuICAgICAgICAgICAgKG4uaXNJbnRlZ2VyKCkgPyAnb3V0IG9mIHJhbmdlOiAnIDogJ25vdCBhbiBpbnRlZ2VyOiAnKSArIHZhbHVlT2YobikpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF4YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XHJcblxyXG4gICAgZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgIG4xID0gZDAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICBkMSA9IG4wID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgcyA9IGNvZWZmVG9TdHJpbmcoeGMpO1xyXG5cclxuICAgIC8vIERldGVybWluZSBpbml0aWFsIGRlbm9taW5hdG9yLlxyXG4gICAgLy8gZCBpcyBhIHBvd2VyIG9mIDEwIGFuZCB0aGUgbWluaW11bSBtYXggZGVub21pbmF0b3IgdGhhdCBzcGVjaWZpZXMgdGhlIHZhbHVlIGV4YWN0bHkuXHJcbiAgICBlID0gZC5lID0gcy5sZW5ndGggLSB4LmUgLSAxO1xyXG4gICAgZC5jWzBdID0gUE9XU19URU5bKGV4cCA9IGUgJSBMT0dfQkFTRSkgPCAwID8gTE9HX0JBU0UgKyBleHAgOiBleHBdO1xyXG4gICAgbWQgPSAhbWQgfHwgbi5jb21wYXJlZFRvKGQpID4gMCA/IChlID4gMCA/IGQgOiBuMSkgOiBuO1xyXG5cclxuICAgIGV4cCA9IE1BWF9FWFA7XHJcbiAgICBNQVhfRVhQID0gMSAvIDA7XHJcbiAgICBuID0gbmV3IEJpZ051bWJlcihzKTtcclxuXHJcbiAgICAvLyBuMCA9IGQxID0gMFxyXG4gICAgbjAuY1swXSA9IDA7XHJcblxyXG4gICAgZm9yICg7IDspICB7XHJcbiAgICAgIHEgPSBkaXYobiwgZCwgMCwgMSk7XHJcbiAgICAgIGQyID0gZDAucGx1cyhxLnRpbWVzKGQxKSk7XHJcbiAgICAgIGlmIChkMi5jb21wYXJlZFRvKG1kKSA9PSAxKSBicmVhaztcclxuICAgICAgZDAgPSBkMTtcclxuICAgICAgZDEgPSBkMjtcclxuICAgICAgbjEgPSBuMC5wbHVzKHEudGltZXMoZDIgPSBuMSkpO1xyXG4gICAgICBuMCA9IGQyO1xyXG4gICAgICBkID0gbi5taW51cyhxLnRpbWVzKGQyID0gZCkpO1xyXG4gICAgICBuID0gZDI7XHJcbiAgICB9XHJcblxyXG4gICAgZDIgPSBkaXYobWQubWludXMoZDApLCBkMSwgMCwgMSk7XHJcbiAgICBuMCA9IG4wLnBsdXMoZDIudGltZXMobjEpKTtcclxuICAgIGQwID0gZDAucGx1cyhkMi50aW1lcyhkMSkpO1xyXG4gICAgbjAucyA9IG4xLnMgPSB4LnM7XHJcbiAgICBlID0gZSAqIDI7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMVxyXG4gICAgciA9IGRpdihuMSwgZDEsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpLmNvbXBhcmVkVG8oXHJcbiAgICAgICAgZGl2KG4wLCBkMCwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkpIDwgMSA/IFtuMSwgZDFdIDogW24wLCBkMF07XHJcblxyXG4gICAgTUFYX0VYUCA9IGV4cDtcclxuXHJcbiAgICByZXR1cm4gcjtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGNvbnZlcnRlZCB0byBhIG51bWJlciBwcmltaXRpdmUuXHJcbiAgICovXHJcbiAgUC50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiArdmFsdWVPZih0aGlzKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0gb3IgUk9VTkRJTkdfTU9ERS4gSWYgc2QgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzXHJcbiAgICogbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiwgdGhlbiB1c2VcclxuICAgKiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgKlxyXG4gICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICovXHJcbiAgUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgIGlmIChzZCAhPSBudWxsKSBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgIHJldHVybiBmb3JtYXQodGhpcywgc2QsIHJtLCAyKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBiYXNlIGIsIG9yIGJhc2UgMTAgaWYgYiBpc1xyXG4gICAqIG9taXR0ZWQuIElmIGEgYmFzZSBpcyBzcGVjaWZpZWQsIGluY2x1ZGluZyBiYXNlIDEwLCByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kXHJcbiAgICogUk9VTkRJTkdfTU9ERS4gSWYgYSBiYXNlIGlzIG5vdCBzcGVjaWZpZWQsIGFuZCB0aGlzIEJpZ051bWJlciBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudFxyXG4gICAqIHRoYXQgaXMgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIFRPX0VYUF9QT1MsIG9yIGEgbmVnYXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuXHJcbiAgICogVE9fRVhQX05FRywgcmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAqXHJcbiAgICogW2JdIHtudW1iZXJ9IEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgKi9cclxuICBQLnRvU3RyaW5nID0gZnVuY3Rpb24gKGIpIHtcclxuICAgIHZhciBzdHIsXHJcbiAgICAgIG4gPSB0aGlzLFxyXG4gICAgICBzID0gbi5zLFxyXG4gICAgICBlID0gbi5lO1xyXG5cclxuICAgIC8vIEluZmluaXR5IG9yIE5hTj9cclxuICAgIGlmIChlID09PSBudWxsKSB7XHJcbiAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgc3RyID0gJ0luZmluaXR5JztcclxuICAgICAgICBpZiAocyA8IDApIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdHIgPSAnTmFOJztcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG4gICAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICAgPyB0b0V4cG9uZW50aWFsKGNvZWZmVG9TdHJpbmcobi5jKSwgZSlcclxuICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpO1xyXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDEwICYmIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cykge1xyXG4gICAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBERUNJTUFMX1BMQUNFUyArIGUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBuLmUsICcwJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG4gICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyksIDEwLCBiLCBzLCB0cnVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHMgPCAwICYmIG4uY1swXSkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHI7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGFzIHRvU3RyaW5nLCBidXQgZG8gbm90IGFjY2VwdCBhIGJhc2UgYXJndW1lbnQsIGFuZCBpbmNsdWRlIHRoZSBtaW51cyBzaWduIGZvclxyXG4gICAqIG5lZ2F0aXZlIHplcm8uXHJcbiAgICovXHJcbiAgUC52YWx1ZU9mID0gUC50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdmFsdWVPZih0aGlzKTtcclxuICB9O1xyXG5cclxuXHJcbiAgUC5faXNCaWdOdW1iZXIgPSB0cnVlO1xyXG5cclxuICBQW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAnQmlnTnVtYmVyJztcclxuXHJcbiAgLy8gTm9kZS5qcyB2MTAuMTIuMCtcclxuICBQW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldID0gUC52YWx1ZU9mO1xyXG5cclxuICBpZiAoY29uZmlnT2JqZWN0ICE9IG51bGwpIEJpZ051bWJlci5zZXQoY29uZmlnT2JqZWN0KTtcclxuXHJcbiAgcmV0dXJuIEJpZ051bWJlcjtcclxufVxyXG5cclxuXHJcbi8vIFBSSVZBVEUgSEVMUEVSIEZVTkNUSU9OU1xyXG5cclxuLy8gVGhlc2UgZnVuY3Rpb25zIGRvbid0IG5lZWQgYWNjZXNzIHRvIHZhcmlhYmxlcyxcclxuLy8gZS5nLiBERUNJTUFMX1BMQUNFUywgaW4gdGhlIHNjb3BlIG9mIHRoZSBgY2xvbmVgIGZ1bmN0aW9uIGFib3ZlLlxyXG5cclxuXHJcbmZ1bmN0aW9uIGJpdEZsb29yKG4pIHtcclxuICB2YXIgaSA9IG4gfCAwO1xyXG4gIHJldHVybiBuID4gMCB8fCBuID09PSBpID8gaSA6IGkgLSAxO1xyXG59XHJcblxyXG5cclxuLy8gUmV0dXJuIGEgY29lZmZpY2llbnQgYXJyYXkgYXMgYSBzdHJpbmcgb2YgYmFzZSAxMCBkaWdpdHMuXHJcbmZ1bmN0aW9uIGNvZWZmVG9TdHJpbmcoYSkge1xyXG4gIHZhciBzLCB6LFxyXG4gICAgaSA9IDEsXHJcbiAgICBqID0gYS5sZW5ndGgsXHJcbiAgICByID0gYVswXSArICcnO1xyXG5cclxuICBmb3IgKDsgaSA8IGo7KSB7XHJcbiAgICBzID0gYVtpKytdICsgJyc7XHJcbiAgICB6ID0gTE9HX0JBU0UgLSBzLmxlbmd0aDtcclxuICAgIGZvciAoOyB6LS07IHMgPSAnMCcgKyBzKTtcclxuICAgIHIgKz0gcztcclxuICB9XHJcblxyXG4gIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICBmb3IgKGogPSByLmxlbmd0aDsgci5jaGFyQ29kZUF0KC0taikgPT09IDQ4Oyk7XHJcblxyXG4gIHJldHVybiByLnNsaWNlKDAsIGogKyAxIHx8IDEpO1xyXG59XHJcblxyXG5cclxuLy8gQ29tcGFyZSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVycyB4IGFuZCB5LlxyXG5mdW5jdGlvbiBjb21wYXJlKHgsIHkpIHtcclxuICB2YXIgYSwgYixcclxuICAgIHhjID0geC5jLFxyXG4gICAgeWMgPSB5LmMsXHJcbiAgICBpID0geC5zLFxyXG4gICAgaiA9IHkucyxcclxuICAgIGsgPSB4LmUsXHJcbiAgICBsID0geS5lO1xyXG5cclxuICAvLyBFaXRoZXIgTmFOP1xyXG4gIGlmICghaSB8fCAhaikgcmV0dXJuIG51bGw7XHJcblxyXG4gIGEgPSB4YyAmJiAheGNbMF07XHJcbiAgYiA9IHljICYmICF5Y1swXTtcclxuXHJcbiAgLy8gRWl0aGVyIHplcm8/XHJcbiAgaWYgKGEgfHwgYikgcmV0dXJuIGEgPyBiID8gMCA6IC1qIDogaTtcclxuXHJcbiAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gIGlmIChpICE9IGopIHJldHVybiBpO1xyXG5cclxuICBhID0gaSA8IDA7XHJcbiAgYiA9IGsgPT0gbDtcclxuXHJcbiAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gIGlmICgheGMgfHwgIXljKSByZXR1cm4gYiA/IDAgOiAheGMgXiBhID8gMSA6IC0xO1xyXG5cclxuICAvLyBDb21wYXJlIGV4cG9uZW50cy5cclxuICBpZiAoIWIpIHJldHVybiBrID4gbCBeIGEgPyAxIDogLTE7XHJcblxyXG4gIGogPSAoayA9IHhjLmxlbmd0aCkgPCAobCA9IHljLmxlbmd0aCkgPyBrIDogbDtcclxuXHJcbiAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdC5cclxuICBmb3IgKGkgPSAwOyBpIDwgajsgaSsrKSBpZiAoeGNbaV0gIT0geWNbaV0pIHJldHVybiB4Y1tpXSA+IHljW2ldIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gIHJldHVybiBrID09IGwgPyAwIDogayA+IGwgXiBhID8gMSA6IC0xO1xyXG59XHJcblxyXG5cclxuLypcclxuICogQ2hlY2sgdGhhdCBuIGlzIGEgcHJpbWl0aXZlIG51bWJlciwgYW4gaW50ZWdlciwgYW5kIGluIHJhbmdlLCBvdGhlcndpc2UgdGhyb3cuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnRDaGVjayhuLCBtaW4sIG1heCwgbmFtZSkge1xyXG4gIGlmIChuIDwgbWluIHx8IG4gPiBtYXggfHwgbiAhPT0gbWF0aGZsb29yKG4pKSB7XHJcbiAgICB0aHJvdyBFcnJvclxyXG4gICAgIChiaWdudW1iZXJFcnJvciArIChuYW1lIHx8ICdBcmd1bWVudCcpICsgKHR5cGVvZiBuID09ICdudW1iZXInXHJcbiAgICAgICA/IG4gPCBtaW4gfHwgbiA+IG1heCA/ICcgb3V0IG9mIHJhbmdlOiAnIDogJyBub3QgYW4gaW50ZWdlcjogJ1xyXG4gICAgICAgOiAnIG5vdCBhIHByaW1pdGl2ZSBudW1iZXI6ICcpICsgU3RyaW5nKG4pKTtcclxuICB9XHJcbn1cclxuXHJcblxyXG4vLyBBc3N1bWVzIGZpbml0ZSBuLlxyXG5mdW5jdGlvbiBpc09kZChuKSB7XHJcbiAgdmFyIGsgPSBuLmMubGVuZ3RoIC0gMTtcclxuICByZXR1cm4gYml0Rmxvb3Iobi5lIC8gTE9HX0JBU0UpID09IGsgJiYgbi5jW2tdICUgMiAhPSAwO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gdG9FeHBvbmVudGlhbChzdHIsIGUpIHtcclxuICByZXR1cm4gKHN0ci5sZW5ndGggPiAxID8gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKSA6IHN0cikgK1xyXG4gICAoZSA8IDAgPyAnZScgOiAnZSsnKSArIGU7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCB6KSB7XHJcbiAgdmFyIGxlbiwgenM7XHJcblxyXG4gIC8vIE5lZ2F0aXZlIGV4cG9uZW50P1xyXG4gIGlmIChlIDwgMCkge1xyXG5cclxuICAgIC8vIFByZXBlbmQgemVyb3MuXHJcbiAgICBmb3IgKHpzID0geiArICcuJzsgKytlOyB6cyArPSB6KTtcclxuICAgIHN0ciA9IHpzICsgc3RyO1xyXG5cclxuICAvLyBQb3NpdGl2ZSBleHBvbmVudFxyXG4gIH0gZWxzZSB7XHJcbiAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgIC8vIEFwcGVuZCB6ZXJvcy5cclxuICAgIGlmICgrK2UgPiBsZW4pIHtcclxuICAgICAgZm9yICh6cyA9IHosIGUgLT0gbGVuOyAtLWU7IHpzICs9IHopO1xyXG4gICAgICBzdHIgKz0genM7XHJcbiAgICB9IGVsc2UgaWYgKGUgPCBsZW4pIHtcclxuICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIGUpICsgJy4nICsgc3RyLnNsaWNlKGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0cjtcclxufVxyXG5cclxuXHJcbi8vIEVYUE9SVFxyXG5cclxuXHJcbmV4cG9ydCB2YXIgQmlnTnVtYmVyID0gY2xvbmUoKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJpZ051bWJlcjtcclxuIiwgImltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBTT0xBTkFfUFJPVE9DT0wgPSAnc29sYW5hOic7XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBIVFRQU19QUk9UT0NPTCA9ICdodHRwczonO1xuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgTUVNT19QUk9HUkFNX0lEID0gbmV3IFB1YmxpY0tleSgnTWVtb1NxNGdxQUJBWEtiOTZxbkg4VHlzTmNXeE15V0NxWGdETEdtZmNIcicpO1xuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgU09MX0RFQ0lNQUxTID0gOTtcblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IFRFTiA9IG5ldyBCaWdOdW1iZXIoMTApO1xuIiwgImltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5cbi8qKiBBZGRyZXNzIG9mIHRoZSBTUEwgVG9rZW4gcHJvZ3JhbSAqL1xuZXhwb3J0IGNvbnN0IFRPS0VOX1BST0dSQU1fSUQgPSBuZXcgUHVibGljS2V5KCdUb2tlbmtlZ1FmZVp5aU53QUpiTmJHS1BGWENXdUJ2ZjlTczYyM1ZRNURBJyk7XG5cbi8qKiBBZGRyZXNzIG9mIHRoZSBTUEwgVG9rZW4gMjAyMiBwcm9ncmFtICovXG5leHBvcnQgY29uc3QgVE9LRU5fMjAyMl9QUk9HUkFNX0lEID0gbmV3IFB1YmxpY0tleSgnVG9rZW56UWRCTmJMcVA1VkVoZGtBUzZFUEZMQzFQSG5CcUNYRXBQeHVFYicpO1xuXG4vKiogQWRkcmVzcyBvZiB0aGUgU1BMIEFzc29jaWF0ZWQgVG9rZW4gQWNjb3VudCBwcm9ncmFtICovXG5leHBvcnQgY29uc3QgQVNTT0NJQVRFRF9UT0tFTl9QUk9HUkFNX0lEID0gbmV3IFB1YmxpY0tleSgnQVRva2VuR1B2YmRHVnhyMWIyaHZaYnNpcVc1eFdIMjVlZlROc0xKQThrbkwnKTtcblxuLyoqIEFkZHJlc3Mgb2YgdGhlIHNwZWNpYWwgbWludCBmb3Igd3JhcHBlZCBuYXRpdmUgU09MIGluIHNwbC10b2tlbiAqL1xuZXhwb3J0IGNvbnN0IE5BVElWRV9NSU5UID0gbmV3IFB1YmxpY0tleSgnU28xMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMicpO1xuXG4vKiogQWRkcmVzcyBvZiB0aGUgc3BlY2lhbCBtaW50IGZvciB3cmFwcGVkIG5hdGl2ZSBTT0wgaW4gc3BsLXRva2VuLTIwMjIgKi9cbmV4cG9ydCBjb25zdCBOQVRJVkVfTUlOVF8yMDIyID0gbmV3IFB1YmxpY0tleSgnOXBhbjliTW41SGF0WDRFSmRCd2c5VmdDYTdVejVITDhOMW01RDNOZFhlalAnKTtcblxuLyoqIENoZWNrIHRoYXQgdGhlIHRva2VuIHByb2dyYW0gcHJvdmlkZWQgaXMgbm90IGBUb2tlbmtlZy4uLmAsIHVzZWZ1bCB3aGVuIHVzaW5nIGV4dGVuc2lvbnMgKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9ncmFtU3VwcG9ydHNFeHRlbnNpb25zKHByb2dyYW1JZDogUHVibGljS2V5KTogYm9vbGVhbiB7XG4gICAgaWYgKHByb2dyYW1JZC5lcXVhbHMoVE9LRU5fUFJPR1JBTV9JRCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBMYXlvdXQgfSBmcm9tICdAc29sYW5hL2J1ZmZlci1sYXlvdXQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEVuY29kZURlY29kZTxUPiB7XG4gICAgZGVjb2RlKGJ1ZmZlcjogQnVmZmVyLCBvZmZzZXQ/OiBudW1iZXIpOiBUO1xuICAgIGVuY29kZShzcmM6IFQsIGJ1ZmZlcjogQnVmZmVyLCBvZmZzZXQ/OiBudW1iZXIpOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBlbmNvZGVEZWNvZGUgPSA8VD4obGF5b3V0OiBMYXlvdXQ8VD4pOiBFbmNvZGVEZWNvZGU8VD4gPT4ge1xuICAgIGNvbnN0IGRlY29kZSA9IGxheW91dC5kZWNvZGUuYmluZChsYXlvdXQpO1xuICAgIGNvbnN0IGVuY29kZSA9IGxheW91dC5lbmNvZGUuYmluZChsYXlvdXQpO1xuICAgIHJldHVybiB7IGRlY29kZSwgZW5jb2RlIH07XG59O1xuIiwgImltcG9ydCB7IGJsb2IsIExheW91dCB9IGZyb20gJ0Bzb2xhbmEvYnVmZmVyLWxheW91dCc7XG5pbXBvcnQgeyB0b0JpZ0ludEJFLCB0b0JpZ0ludExFLCB0b0J1ZmZlckJFLCB0b0J1ZmZlckxFIH0gZnJvbSAnYmlnaW50LWJ1ZmZlcic7XG5pbXBvcnQgeyBlbmNvZGVEZWNvZGUgfSBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgY29uc3QgYmlnSW50ID1cbiAgICAobGVuZ3RoOiBudW1iZXIpID0+XG4gICAgKHByb3BlcnR5Pzogc3RyaW5nKTogTGF5b3V0PGJpZ2ludD4gPT4ge1xuICAgICAgICBjb25zdCBsYXlvdXQgPSBibG9iKGxlbmd0aCwgcHJvcGVydHkpO1xuICAgICAgICBjb25zdCB7IGVuY29kZSwgZGVjb2RlIH0gPSBlbmNvZGVEZWNvZGUobGF5b3V0KTtcblxuICAgICAgICBjb25zdCBiaWdJbnRMYXlvdXQgPSBsYXlvdXQgYXMgTGF5b3V0PHVua25vd24+IGFzIExheW91dDxiaWdpbnQ+O1xuXG4gICAgICAgIGJpZ0ludExheW91dC5kZWNvZGUgPSAoYnVmZmVyOiBCdWZmZXIsIG9mZnNldDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSBkZWNvZGUoYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQmlnSW50TEUoQnVmZmVyLmZyb20oc3JjKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgYmlnSW50TGF5b3V0LmVuY29kZSA9IChiaWdJbnQ6IGJpZ2ludCwgYnVmZmVyOiBCdWZmZXIsIG9mZnNldDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSB0b0J1ZmZlckxFKGJpZ0ludCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGUoc3JjLCBidWZmZXIsIG9mZnNldCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGJpZ0ludExheW91dDtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgYmlnSW50QkUgPVxuICAgIChsZW5ndGg6IG51bWJlcikgPT5cbiAgICAocHJvcGVydHk/OiBzdHJpbmcpOiBMYXlvdXQ8YmlnaW50PiA9PiB7XG4gICAgICAgIGNvbnN0IGxheW91dCA9IGJsb2IobGVuZ3RoLCBwcm9wZXJ0eSk7XG4gICAgICAgIGNvbnN0IHsgZW5jb2RlLCBkZWNvZGUgfSA9IGVuY29kZURlY29kZShsYXlvdXQpO1xuXG4gICAgICAgIGNvbnN0IGJpZ0ludExheW91dCA9IGxheW91dCBhcyBMYXlvdXQ8dW5rbm93bj4gYXMgTGF5b3V0PGJpZ2ludD47XG5cbiAgICAgICAgYmlnSW50TGF5b3V0LmRlY29kZSA9IChidWZmZXI6IEJ1ZmZlciwgb2Zmc2V0OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNyYyA9IGRlY29kZShidWZmZXIsIG9mZnNldCk7XG4gICAgICAgICAgICByZXR1cm4gdG9CaWdJbnRCRShCdWZmZXIuZnJvbShzcmMpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBiaWdJbnRMYXlvdXQuZW5jb2RlID0gKGJpZ0ludDogYmlnaW50LCBidWZmZXI6IEJ1ZmZlciwgb2Zmc2V0OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNyYyA9IHRvQnVmZmVyQkUoYmlnSW50LCBsZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZShzcmMsIGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYmlnSW50TGF5b3V0O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCB1NjQgPSBiaWdJbnQoOCk7XG5cbmV4cG9ydCBjb25zdCB1NjRiZSA9IGJpZ0ludEJFKDgpO1xuXG5leHBvcnQgY29uc3QgdTEyOCA9IGJpZ0ludCgxNik7XG5cbmV4cG9ydCBjb25zdCB1MTI4YmUgPSBiaWdJbnRCRSgxNik7XG5cbmV4cG9ydCBjb25zdCB1MTkyID0gYmlnSW50KDI0KTtcblxuZXhwb3J0IGNvbnN0IHUxOTJiZSA9IGJpZ0ludEJFKDI0KTtcblxuZXhwb3J0IGNvbnN0IHUyNTYgPSBiaWdJbnQoMzIpO1xuXG5leHBvcnQgY29uc3QgdTI1NmJlID0gYmlnSW50QkUoMzIpO1xuIiwgImltcG9ydCB7IExheW91dCB9IGZyb20gJ0Bzb2xhbmEvYnVmZmVyLWxheW91dCc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBlbmNvZGVEZWNvZGUgfSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHsgdTEyOCB9IGZyb20gJy4vYmlnaW50JztcblxuZXhwb3J0IGNvbnN0IFdBRCA9IG5ldyBCaWdOdW1iZXIoJzFlKzE4Jyk7XG5cbmV4cG9ydCBjb25zdCBkZWNpbWFsID0gKHByb3BlcnR5Pzogc3RyaW5nKTogTGF5b3V0PEJpZ051bWJlcj4gPT4ge1xuICAgIGNvbnN0IGxheW91dCA9IHUxMjgocHJvcGVydHkpO1xuICAgIGNvbnN0IHsgZW5jb2RlLCBkZWNvZGUgfSA9IGVuY29kZURlY29kZShsYXlvdXQpO1xuXG4gICAgY29uc3QgZGVjaW1hbExheW91dCA9IGxheW91dCBhcyBMYXlvdXQ8dW5rbm93bj4gYXMgTGF5b3V0PEJpZ051bWJlcj47XG5cbiAgICBkZWNpbWFsTGF5b3V0LmRlY29kZSA9IChidWZmZXI6IEJ1ZmZlciwgb2Zmc2V0OiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3Qgc3JjID0gZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0KS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihzcmMpLmRpdihXQUQpO1xuICAgIH07XG5cbiAgICBkZWNpbWFsTGF5b3V0LmVuY29kZSA9IChkZWNpbWFsOiBCaWdOdW1iZXIsIGJ1ZmZlcjogQnVmZmVyLCBvZmZzZXQ6IG51bWJlcikgPT4ge1xuICAgICAgICBjb25zdCBzcmMgPSBCaWdJbnQoZGVjaW1hbC50aW1lcyhXQUQpLmludGVnZXJWYWx1ZSgpLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gZW5jb2RlKHNyYywgYnVmZmVyLCBvZmZzZXQpO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVjaW1hbExheW91dDtcbn07XG4iLCAiaW1wb3J0IHsgTGF5b3V0LCB1OCB9IGZyb20gJ0Bzb2xhbmEvYnVmZmVyLWxheW91dCc7XG5pbXBvcnQgeyBlbmNvZGVEZWNvZGUgfSBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgY29uc3QgYm9vbCA9IChwcm9wZXJ0eT86IHN0cmluZyk6IExheW91dDxib29sZWFuPiA9PiB7XG4gICAgY29uc3QgbGF5b3V0ID0gdTgocHJvcGVydHkpO1xuICAgIGNvbnN0IHsgZW5jb2RlLCBkZWNvZGUgfSA9IGVuY29kZURlY29kZShsYXlvdXQpO1xuXG4gICAgY29uc3QgYm9vbExheW91dCA9IGxheW91dCBhcyBMYXlvdXQ8dW5rbm93bj4gYXMgTGF5b3V0PGJvb2xlYW4+O1xuXG4gICAgYm9vbExheW91dC5kZWNvZGUgPSAoYnVmZmVyOiBCdWZmZXIsIG9mZnNldDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHNyYyA9IGRlY29kZShidWZmZXIsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiAhIXNyYztcbiAgICB9O1xuXG4gICAgYm9vbExheW91dC5lbmNvZGUgPSAoYm9vbDogYm9vbGVhbiwgYnVmZmVyOiBCdWZmZXIsIG9mZnNldDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHNyYyA9IE51bWJlcihib29sKTtcbiAgICAgICAgcmV0dXJuIGVuY29kZShzcmMsIGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGJvb2xMYXlvdXQ7XG59O1xuIiwgImltcG9ydCB7IGJsb2IsIExheW91dCB9IGZyb20gJ0Bzb2xhbmEvYnVmZmVyLWxheW91dCc7XG5pbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuaW1wb3J0IHsgZW5jb2RlRGVjb2RlIH0gZnJvbSAnLi9iYXNlJztcblxuZXhwb3J0IGNvbnN0IHB1YmxpY0tleSA9IChwcm9wZXJ0eT86IHN0cmluZyk6IExheW91dDxQdWJsaWNLZXk+ID0+IHtcbiAgICBjb25zdCBsYXlvdXQgPSBibG9iKDMyLCBwcm9wZXJ0eSk7XG4gICAgY29uc3QgeyBlbmNvZGUsIGRlY29kZSB9ID0gZW5jb2RlRGVjb2RlKGxheW91dCk7XG5cbiAgICBjb25zdCBwdWJsaWNLZXlMYXlvdXQgPSBsYXlvdXQgYXMgTGF5b3V0PHVua25vd24+IGFzIExheW91dDxQdWJsaWNLZXk+O1xuXG4gICAgcHVibGljS2V5TGF5b3V0LmRlY29kZSA9IChidWZmZXI6IEJ1ZmZlciwgb2Zmc2V0OiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3Qgc3JjID0gZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkoc3JjKTtcbiAgICB9O1xuXG4gICAgcHVibGljS2V5TGF5b3V0LmVuY29kZSA9IChwdWJsaWNLZXk6IFB1YmxpY0tleSwgYnVmZmVyOiBCdWZmZXIsIG9mZnNldDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHNyYyA9IHB1YmxpY0tleS50b0J1ZmZlcigpO1xuICAgICAgICByZXR1cm4gZW5jb2RlKHNyYywgYnVmZmVyLCBvZmZzZXQpO1xuICAgIH07XG5cbiAgICByZXR1cm4gcHVibGljS2V5TGF5b3V0O1xufTtcbiIsICIvKiogQmFzZSBjbGFzcyBmb3IgZXJyb3JzICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVG9rZW5FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIH1cbn1cblxuLyoqIFRocm93biBpZiBhbiBhY2NvdW50IGlzIG5vdCBmb3VuZCBhdCB0aGUgZXhwZWN0ZWQgYWRkcmVzcyAqL1xuZXhwb3J0IGNsYXNzIFRva2VuQWNjb3VudE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBUb2tlbkVycm9yIHtcbiAgICBuYW1lID0gJ1Rva2VuQWNjb3VudE5vdEZvdW5kRXJyb3InO1xufVxuXG4vKiogVGhyb3duIGlmIGEgcHJvZ3JhbSBzdGF0ZSBhY2NvdW50IGlzIG5vdCBhIHZhbGlkIEFjY291bnQgKi9cbmV4cG9ydCBjbGFzcyBUb2tlbkludmFsaWRBY2NvdW50RXJyb3IgZXh0ZW5kcyBUb2tlbkVycm9yIHtcbiAgICBuYW1lID0gJ1Rva2VuSW52YWxpZEFjY291bnRFcnJvcic7XG59XG5cbi8qKiBUaHJvd24gaWYgYSBwcm9ncmFtIHN0YXRlIGFjY291bnQgZG9lcyBub3QgY29udGFpbiB2YWxpZCBkYXRhICovXG5leHBvcnQgY2xhc3MgVG9rZW5JbnZhbGlkQWNjb3VudERhdGFFcnJvciBleHRlbmRzIFRva2VuRXJyb3Ige1xuICAgIG5hbWUgPSAnVG9rZW5JbnZhbGlkQWNjb3VudERhdGFFcnJvcic7XG59XG5cbi8qKiBUaHJvd24gaWYgYSBwcm9ncmFtIHN0YXRlIGFjY291bnQgaXMgbm90IG93bmVkIGJ5IHRoZSBleHBlY3RlZCB0b2tlbiBwcm9ncmFtICovXG5leHBvcnQgY2xhc3MgVG9rZW5JbnZhbGlkQWNjb3VudE93bmVyRXJyb3IgZXh0ZW5kcyBUb2tlbkVycm9yIHtcbiAgICBuYW1lID0gJ1Rva2VuSW52YWxpZEFjY291bnRPd25lckVycm9yJztcbn1cblxuLyoqIFRocm93biBpZiB0aGUgYnl0ZSBsZW5ndGggb2YgYW4gcHJvZ3JhbSBzdGF0ZSBhY2NvdW50IGRvZXNuJ3QgbWF0Y2ggdGhlIGV4cGVjdGVkIHNpemUgKi9cbmV4cG9ydCBjbGFzcyBUb2tlbkludmFsaWRBY2NvdW50U2l6ZUVycm9yIGV4dGVuZHMgVG9rZW5FcnJvciB7XG4gICAgbmFtZSA9ICdUb2tlbkludmFsaWRBY2NvdW50U2l6ZUVycm9yJztcbn1cblxuLyoqIFRocm93biBpZiB0aGUgbWludCBvZiBhIHRva2VuIGFjY291bnQgZG9lc24ndCBtYXRjaCB0aGUgZXhwZWN0ZWQgbWludCAqL1xuZXhwb3J0IGNsYXNzIFRva2VuSW52YWxpZE1pbnRFcnJvciBleHRlbmRzIFRva2VuRXJyb3Ige1xuICAgIG5hbWUgPSAnVG9rZW5JbnZhbGlkTWludEVycm9yJztcbn1cblxuLyoqIFRocm93biBpZiB0aGUgb3duZXIgb2YgYSB0b2tlbiBhY2NvdW50IGRvZXNuJ3QgbWF0Y2ggdGhlIGV4cGVjdGVkIG93bmVyICovXG5leHBvcnQgY2xhc3MgVG9rZW5JbnZhbGlkT3duZXJFcnJvciBleHRlbmRzIFRva2VuRXJyb3Ige1xuICAgIG5hbWUgPSAnVG9rZW5JbnZhbGlkT3duZXJFcnJvcic7XG59XG5cbi8qKiBUaHJvd24gaWYgdGhlIG93bmVyIG9mIGEgdG9rZW4gYWNjb3VudCBpcyBhIFBEQSAoUHJvZ3JhbSBEZXJpdmVkIEFkZHJlc3MpICovXG5leHBvcnQgY2xhc3MgVG9rZW5Pd25lck9mZkN1cnZlRXJyb3IgZXh0ZW5kcyBUb2tlbkVycm9yIHtcbiAgICBuYW1lID0gJ1Rva2VuT3duZXJPZmZDdXJ2ZUVycm9yJztcbn1cblxuLyoqIFRocm93biBpZiBhbiBpbnN0cnVjdGlvbidzIHByb2dyYW0gaXMgaW52YWxpZCAqL1xuZXhwb3J0IGNsYXNzIFRva2VuSW52YWxpZEluc3RydWN0aW9uUHJvZ3JhbUVycm9yIGV4dGVuZHMgVG9rZW5FcnJvciB7XG4gICAgbmFtZSA9ICdUb2tlbkludmFsaWRJbnN0cnVjdGlvblByb2dyYW1FcnJvcic7XG59XG5cbi8qKiBUaHJvd24gaWYgYW4gaW5zdHJ1Y3Rpb24ncyBrZXlzIGFyZSBpbnZhbGlkICovXG5leHBvcnQgY2xhc3MgVG9rZW5JbnZhbGlkSW5zdHJ1Y3Rpb25LZXlzRXJyb3IgZXh0ZW5kcyBUb2tlbkVycm9yIHtcbiAgICBuYW1lID0gJ1Rva2VuSW52YWxpZEluc3RydWN0aW9uS2V5c0Vycm9yJztcbn1cblxuLyoqIFRocm93biBpZiBhbiBpbnN0cnVjdGlvbidzIGRhdGEgaXMgaW52YWxpZCAqL1xuZXhwb3J0IGNsYXNzIFRva2VuSW52YWxpZEluc3RydWN0aW9uRGF0YUVycm9yIGV4dGVuZHMgVG9rZW5FcnJvciB7XG4gICAgbmFtZSA9ICdUb2tlbkludmFsaWRJbnN0cnVjdGlvbkRhdGFFcnJvcic7XG59XG5cbi8qKiBUaHJvd24gaWYgYW4gaW5zdHJ1Y3Rpb24ncyB0eXBlIGlzIGludmFsaWQgKi9cbmV4cG9ydCBjbGFzcyBUb2tlbkludmFsaWRJbnN0cnVjdGlvblR5cGVFcnJvciBleHRlbmRzIFRva2VuRXJyb3Ige1xuICAgIG5hbWUgPSAnVG9rZW5JbnZhbGlkSW5zdHJ1Y3Rpb25UeXBlRXJyb3InO1xufVxuXG4vKiogVGhyb3duIGlmIHRoZSBwcm9ncmFtIGRvZXMgbm90IHN1cHBvcnQgdGhlIGRlc2lyZWQgaW5zdHJ1Y3Rpb24gKi9cbmV4cG9ydCBjbGFzcyBUb2tlblVuc3VwcG9ydGVkSW5zdHJ1Y3Rpb25FcnJvciBleHRlbmRzIFRva2VuRXJyb3Ige1xuICAgIG5hbWUgPSAnVG9rZW5VbnN1cHBvcnRlZEluc3RydWN0aW9uRXJyb3InO1xufVxuXG4vKiogVGhyb3duIGlmIHRoZSB0cmFuc2ZlciBob29rIGV4dHJhIGFjY291bnRzIGNvbnRhaW5zIGFuIGludmFsaWQgYWNjb3VudCBpbmRleCAqL1xuZXhwb3J0IGNsYXNzIFRva2VuVHJhbnNmZXJIb29rQWNjb3VudE5vdEZvdW5kIGV4dGVuZHMgVG9rZW5FcnJvciB7XG4gICAgbmFtZSA9ICdUb2tlblRyYW5zZmVySG9va0FjY291bnROb3RGb3VuZCc7XG59XG5cbi8qKiBUaHJvd24gaWYgdGhlIHRyYW5zZmVyIGhvb2sgZXh0cmEgYWNjb3VudHMgY29udGFpbnMgYW4gaW52YWxpZCBzZWVkICovXG5leHBvcnQgY2xhc3MgVG9rZW5UcmFuc2Zlckhvb2tJbnZhbGlkU2VlZCBleHRlbmRzIFRva2VuRXJyb3Ige1xuICAgIG5hbWUgPSAnVG9rZW5UcmFuc2Zlckhvb2tJbnZhbGlkU2VlZCc7XG59XG5cbi8qKiBUaHJvd24gaWYgYWNjb3VudCBkYXRhIHJlcXVpcmVkIGJ5IGFuIGV4dHJhIGFjY291bnQgbWV0YSBzZWVkIGNvbmZpZyBjb3VsZCBub3QgYmUgZmV0Y2hlZCAqL1xuZXhwb3J0IGNsYXNzIFRva2VuVHJhbnNmZXJIb29rQWNjb3VudERhdGFOb3RGb3VuZCBleHRlbmRzIFRva2VuRXJyb3Ige1xuICAgIG5hbWUgPSAnVG9rZW5UcmFuc2Zlckhvb2tBY2NvdW50RGF0YU5vdEZvdW5kJztcbn1cblxuLyoqIFRocm93biBpZiBwdWJrZXkgZGF0YSBleHRyYSBhY2NvdW50cyBjb25maWcgaXMgaW52YWxpZCAqL1xuZXhwb3J0IGNsYXNzIFRva2VuVHJhbnNmZXJIb29rSW52YWxpZFB1YmtleURhdGEgZXh0ZW5kcyBUb2tlbkVycm9yIHtcbiAgICBuYW1lID0gJ1Rva2VuVHJhbnNmZXJIb29rSW52YWxpZFB1YmtleURhdGEnO1xufVxuXG4vKiogVGhyb3duIGlmIHB1YmtleSBkYXRhIHNvdXJjZSBpcyB0b28gc21hbGwgZm9yIGEgcHVia2V5ICovXG5leHBvcnQgY2xhc3MgVG9rZW5UcmFuc2Zlckhvb2tQdWJrZXlEYXRhVG9vU21hbGwgZXh0ZW5kcyBUb2tlbkVycm9yIHtcbiAgICBuYW1lID0gJ1Rva2VuVHJhbnNmZXJIb29rUHVia2V5RGF0YVRvb1NtYWxsJztcbn1cbiIsICIvKiogSW5zdHJ1Y3Rpb25zIGRlZmluZWQgYnkgdGhlIHByb2dyYW0gKi9cbmV4cG9ydCBlbnVtIFRva2VuSW5zdHJ1Y3Rpb24ge1xuICAgIEluaXRpYWxpemVNaW50ID0gMCxcbiAgICBJbml0aWFsaXplQWNjb3VudCA9IDEsXG4gICAgSW5pdGlhbGl6ZU11bHRpc2lnID0gMixcbiAgICBUcmFuc2ZlciA9IDMsXG4gICAgQXBwcm92ZSA9IDQsXG4gICAgUmV2b2tlID0gNSxcbiAgICBTZXRBdXRob3JpdHkgPSA2LFxuICAgIE1pbnRUbyA9IDcsXG4gICAgQnVybiA9IDgsXG4gICAgQ2xvc2VBY2NvdW50ID0gOSxcbiAgICBGcmVlemVBY2NvdW50ID0gMTAsXG4gICAgVGhhd0FjY291bnQgPSAxMSxcbiAgICBUcmFuc2ZlckNoZWNrZWQgPSAxMixcbiAgICBBcHByb3ZlQ2hlY2tlZCA9IDEzLFxuICAgIE1pbnRUb0NoZWNrZWQgPSAxNCxcbiAgICBCdXJuQ2hlY2tlZCA9IDE1LFxuICAgIEluaXRpYWxpemVBY2NvdW50MiA9IDE2LFxuICAgIFN5bmNOYXRpdmUgPSAxNyxcbiAgICBJbml0aWFsaXplQWNjb3VudDMgPSAxOCxcbiAgICBJbml0aWFsaXplTXVsdGlzaWcyID0gMTksXG4gICAgSW5pdGlhbGl6ZU1pbnQyID0gMjAsXG4gICAgR2V0QWNjb3VudERhdGFTaXplID0gMjEsXG4gICAgSW5pdGlhbGl6ZUltbXV0YWJsZU93bmVyID0gMjIsXG4gICAgQW1vdW50VG9VaUFtb3VudCA9IDIzLFxuICAgIFVpQW1vdW50VG9BbW91bnQgPSAyNCxcbiAgICBJbml0aWFsaXplTWludENsb3NlQXV0aG9yaXR5ID0gMjUsXG4gICAgVHJhbnNmZXJGZWVFeHRlbnNpb24gPSAyNixcbiAgICBDb25maWRlbnRpYWxUcmFuc2ZlckV4dGVuc2lvbiA9IDI3LFxuICAgIERlZmF1bHRBY2NvdW50U3RhdGVFeHRlbnNpb24gPSAyOCxcbiAgICBSZWFsbG9jYXRlID0gMjksXG4gICAgTWVtb1RyYW5zZmVyRXh0ZW5zaW9uID0gMzAsXG4gICAgQ3JlYXRlTmF0aXZlTWludCA9IDMxLFxuICAgIEluaXRpYWxpemVOb25UcmFuc2ZlcmFibGVNaW50ID0gMzIsXG4gICAgSW50ZXJlc3RCZWFyaW5nTWludEV4dGVuc2lvbiA9IDMzLFxuICAgIENwaUd1YXJkRXh0ZW5zaW9uID0gMzQsXG4gICAgSW5pdGlhbGl6ZVBlcm1hbmVudERlbGVnYXRlID0gMzUsXG4gICAgVHJhbnNmZXJIb29rRXh0ZW5zaW9uID0gMzYsXG4gICAgLy8gQ29uZmlkZW50aWFsVHJhbnNmZXJGZWVFeHRlbnNpb24gPSAzNyxcbiAgICAvLyBXaXRoZHJhd2FsRXhjZXNzTGFtcG9ydHMgPSAzOCxcbiAgICBNZXRhZGF0YVBvaW50ZXJFeHRlbnNpb24gPSAzOSxcbiAgICBHcm91cFBvaW50ZXJFeHRlbnNpb24gPSA0MCxcbiAgICBHcm91cE1lbWJlclBvaW50ZXJFeHRlbnNpb24gPSA0MSxcbiAgICAvLyBDb25maWRlbnRpYWxNaW50QnVybkV4dGVuc2lvbiA9IDQyLFxuICAgIFNjYWxlZFVpQW1vdW50RXh0ZW5zaW9uID0gNDMsXG4gICAgUGF1c2FibGVFeHRlbnNpb24gPSA0NCxcbn1cbiIsICJpbXBvcnQgeyBzdHJ1Y3QsIHUzMiwgdTggfSBmcm9tICdAc29sYW5hL2J1ZmZlci1sYXlvdXQnO1xuaW1wb3J0IHsgYm9vbCwgcHVibGljS2V5LCB1NjQgfSBmcm9tICdAc29sYW5hL2J1ZmZlci1sYXlvdXQtdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBBY2NvdW50SW5mbywgQ29tbWl0bWVudCwgQ29ubmVjdGlvbiB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5pbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuaW1wb3J0IHsgQVNTT0NJQVRFRF9UT0tFTl9QUk9HUkFNX0lELCBUT0tFTl9QUk9HUkFNX0lEIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7XG4gICAgVG9rZW5BY2NvdW50Tm90Rm91bmRFcnJvcixcbiAgICBUb2tlbkludmFsaWRBY2NvdW50T3duZXJFcnJvcixcbiAgICBUb2tlbkludmFsaWRBY2NvdW50U2l6ZUVycm9yLFxuICAgIFRva2VuSW52YWxpZE1pbnRFcnJvcixcbiAgICBUb2tlbk93bmVyT2ZmQ3VydmVFcnJvcixcbn0gZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IEFDQ09VTlRfVFlQRV9TSVpFLCBBY2NvdW50VHlwZSB9IGZyb20gJy4uL2V4dGVuc2lvbnMvYWNjb3VudFR5cGUuanMnO1xuaW1wb3J0IHR5cGUgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vZXh0ZW5zaW9ucy9leHRlbnNpb25UeXBlLmpzJztcbmltcG9ydCB7IGdldE1pbnRMZW4gfSBmcm9tICcuLi9leHRlbnNpb25zL2V4dGVuc2lvblR5cGUuanMnO1xuaW1wb3J0IHsgQUNDT1VOVF9TSVpFIH0gZnJvbSAnLi9hY2NvdW50LmpzJztcbmltcG9ydCB7IE1VTFRJU0lHX1NJWkUgfSBmcm9tICcuL211bHRpc2lnLmpzJztcblxuLyoqIEluZm9ybWF0aW9uIGFib3V0IGEgbWludCAqL1xuZXhwb3J0IGludGVyZmFjZSBNaW50IHtcbiAgICAvKiogQWRkcmVzcyBvZiB0aGUgbWludCAqL1xuICAgIGFkZHJlc3M6IFB1YmxpY0tleTtcbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBhdXRob3JpdHkgdXNlZCB0byBtaW50IG5ldyB0b2tlbnMuIFRoZSBtaW50IGF1dGhvcml0eSBtYXkgb25seSBiZSBwcm92aWRlZCBkdXJpbmcgbWludCBjcmVhdGlvbi5cbiAgICAgKiBJZiBubyBtaW50IGF1dGhvcml0eSBpcyBwcmVzZW50IHRoZW4gdGhlIG1pbnQgaGFzIGEgZml4ZWQgc3VwcGx5IGFuZCBubyBmdXJ0aGVyIHRva2VucyBtYXkgYmUgbWludGVkLlxuICAgICAqL1xuICAgIG1pbnRBdXRob3JpdHk6IFB1YmxpY0tleSB8IG51bGw7XG4gICAgLyoqIFRvdGFsIHN1cHBseSBvZiB0b2tlbnMgKi9cbiAgICBzdXBwbHk6IGJpZ2ludDtcbiAgICAvKiogTnVtYmVyIG9mIGJhc2UgMTAgZGlnaXRzIHRvIHRoZSByaWdodCBvZiB0aGUgZGVjaW1hbCBwbGFjZSAqL1xuICAgIGRlY2ltYWxzOiBudW1iZXI7XG4gICAgLyoqIElzIHRoaXMgbWludCBpbml0aWFsaXplZCAqL1xuICAgIGlzSW5pdGlhbGl6ZWQ6IGJvb2xlYW47XG4gICAgLyoqIE9wdGlvbmFsIGF1dGhvcml0eSB0byBmcmVlemUgdG9rZW4gYWNjb3VudHMgKi9cbiAgICBmcmVlemVBdXRob3JpdHk6IFB1YmxpY0tleSB8IG51bGw7XG4gICAgLyoqIEFkZGl0aW9uYWwgZGF0YSBmb3IgZXh0ZW5zaW9uICovXG4gICAgdGx2RGF0YTogQnVmZmVyO1xufVxuXG4vKiogTWludCBhcyBzdG9yZWQgYnkgdGhlIHByb2dyYW0gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmF3TWludCB7XG4gICAgbWludEF1dGhvcml0eU9wdGlvbjogMSB8IDA7XG4gICAgbWludEF1dGhvcml0eTogUHVibGljS2V5O1xuICAgIHN1cHBseTogYmlnaW50O1xuICAgIGRlY2ltYWxzOiBudW1iZXI7XG4gICAgaXNJbml0aWFsaXplZDogYm9vbGVhbjtcbiAgICBmcmVlemVBdXRob3JpdHlPcHRpb246IDEgfCAwO1xuICAgIGZyZWV6ZUF1dGhvcml0eTogUHVibGljS2V5O1xufVxuXG4vKiogQnVmZmVyIGxheW91dCBmb3IgZGUvc2VyaWFsaXppbmcgYSBtaW50ICovXG5leHBvcnQgY29uc3QgTWludExheW91dCA9IHN0cnVjdDxSYXdNaW50PihbXG4gICAgdTMyKCdtaW50QXV0aG9yaXR5T3B0aW9uJyksXG4gICAgcHVibGljS2V5KCdtaW50QXV0aG9yaXR5JyksXG4gICAgdTY0KCdzdXBwbHknKSxcbiAgICB1OCgnZGVjaW1hbHMnKSxcbiAgICBib29sKCdpc0luaXRpYWxpemVkJyksXG4gICAgdTMyKCdmcmVlemVBdXRob3JpdHlPcHRpb24nKSxcbiAgICBwdWJsaWNLZXkoJ2ZyZWV6ZUF1dGhvcml0eScpLFxuXSk7XG5cbi8qKiBCeXRlIGxlbmd0aCBvZiBhIG1pbnQgKi9cbmV4cG9ydCBjb25zdCBNSU5UX1NJWkUgPSBNaW50TGF5b3V0LnNwYW47XG5cbi8qKlxuICogUmV0cmlldmUgaW5mb3JtYXRpb24gYWJvdXQgYSBtaW50XG4gKlxuICogQHBhcmFtIGNvbm5lY3Rpb24gQ29ubmVjdGlvbiB0byB1c2VcbiAqIEBwYXJhbSBhZGRyZXNzICAgIE1pbnQgYWNjb3VudFxuICogQHBhcmFtIGNvbW1pdG1lbnQgRGVzaXJlZCBsZXZlbCBvZiBjb21taXRtZW50IGZvciBxdWVyeWluZyB0aGUgc3RhdGVcbiAqIEBwYXJhbSBwcm9ncmFtSWQgIFNQTCBUb2tlbiBwcm9ncmFtIGFjY291bnRcbiAqXG4gKiBAcmV0dXJuIE1pbnQgaW5mb3JtYXRpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE1pbnQoXG4gICAgY29ubmVjdGlvbjogQ29ubmVjdGlvbixcbiAgICBhZGRyZXNzOiBQdWJsaWNLZXksXG4gICAgY29tbWl0bWVudD86IENvbW1pdG1lbnQsXG4gICAgcHJvZ3JhbUlkID0gVE9LRU5fUFJPR1JBTV9JRCxcbik6IFByb21pc2U8TWludD4ge1xuICAgIGNvbnN0IGluZm8gPSBhd2FpdCBjb25uZWN0aW9uLmdldEFjY291bnRJbmZvKGFkZHJlc3MsIGNvbW1pdG1lbnQpO1xuICAgIHJldHVybiB1bnBhY2tNaW50KGFkZHJlc3MsIGluZm8sIHByb2dyYW1JZCk7XG59XG5cbi8qKlxuICogVW5wYWNrIGEgbWludFxuICpcbiAqIEBwYXJhbSBhZGRyZXNzICAgTWludCBhY2NvdW50XG4gKiBAcGFyYW0gaW5mbyAgICAgIE1pbnQgYWNjb3VudCBkYXRhXG4gKiBAcGFyYW0gcHJvZ3JhbUlkIFNQTCBUb2tlbiBwcm9ncmFtIGFjY291bnRcbiAqXG4gKiBAcmV0dXJuIFVucGFja2VkIG1pbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVucGFja01pbnQoYWRkcmVzczogUHVibGljS2V5LCBpbmZvOiBBY2NvdW50SW5mbzxCdWZmZXI+IHwgbnVsbCwgcHJvZ3JhbUlkID0gVE9LRU5fUFJPR1JBTV9JRCk6IE1pbnQge1xuICAgIGlmICghaW5mbykgdGhyb3cgbmV3IFRva2VuQWNjb3VudE5vdEZvdW5kRXJyb3IoKTtcbiAgICBpZiAoIWluZm8ub3duZXIuZXF1YWxzKHByb2dyYW1JZCkpIHRocm93IG5ldyBUb2tlbkludmFsaWRBY2NvdW50T3duZXJFcnJvcigpO1xuICAgIGlmIChpbmZvLmRhdGEubGVuZ3RoIDwgTUlOVF9TSVpFKSB0aHJvdyBuZXcgVG9rZW5JbnZhbGlkQWNjb3VudFNpemVFcnJvcigpO1xuXG4gICAgY29uc3QgcmF3TWludCA9IE1pbnRMYXlvdXQuZGVjb2RlKGluZm8uZGF0YS5zbGljZSgwLCBNSU5UX1NJWkUpKTtcbiAgICBsZXQgdGx2RGF0YSA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpZiAoaW5mby5kYXRhLmxlbmd0aCA+IE1JTlRfU0laRSkge1xuICAgICAgICBpZiAoaW5mby5kYXRhLmxlbmd0aCA8PSBBQ0NPVU5UX1NJWkUpIHRocm93IG5ldyBUb2tlbkludmFsaWRBY2NvdW50U2l6ZUVycm9yKCk7XG4gICAgICAgIGlmIChpbmZvLmRhdGEubGVuZ3RoID09PSBNVUxUSVNJR19TSVpFKSB0aHJvdyBuZXcgVG9rZW5JbnZhbGlkQWNjb3VudFNpemVFcnJvcigpO1xuICAgICAgICBpZiAoaW5mby5kYXRhW0FDQ09VTlRfU0laRV0gIT0gQWNjb3VudFR5cGUuTWludCkgdGhyb3cgbmV3IFRva2VuSW52YWxpZE1pbnRFcnJvcigpO1xuICAgICAgICB0bHZEYXRhID0gaW5mby5kYXRhLnNsaWNlKEFDQ09VTlRfU0laRSArIEFDQ09VTlRfVFlQRV9TSVpFKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBtaW50QXV0aG9yaXR5OiByYXdNaW50Lm1pbnRBdXRob3JpdHlPcHRpb24gPyByYXdNaW50Lm1pbnRBdXRob3JpdHkgOiBudWxsLFxuICAgICAgICBzdXBwbHk6IHJhd01pbnQuc3VwcGx5LFxuICAgICAgICBkZWNpbWFsczogcmF3TWludC5kZWNpbWFscyxcbiAgICAgICAgaXNJbml0aWFsaXplZDogcmF3TWludC5pc0luaXRpYWxpemVkLFxuICAgICAgICBmcmVlemVBdXRob3JpdHk6IHJhd01pbnQuZnJlZXplQXV0aG9yaXR5T3B0aW9uID8gcmF3TWludC5mcmVlemVBdXRob3JpdHkgOiBudWxsLFxuICAgICAgICB0bHZEYXRhLFxuICAgIH07XG59XG5cbi8qKiBHZXQgdGhlIG1pbmltdW0gbGFtcG9ydCBiYWxhbmNlIGZvciBhIG1pbnQgdG8gYmUgcmVudCBleGVtcHRcbiAqXG4gKiBAcGFyYW0gY29ubmVjdGlvbiBDb25uZWN0aW9uIHRvIHVzZVxuICogQHBhcmFtIGNvbW1pdG1lbnQgRGVzaXJlZCBsZXZlbCBvZiBjb21taXRtZW50IGZvciBxdWVyeWluZyB0aGUgc3RhdGVcbiAqXG4gKiBAcmV0dXJuIEFtb3VudCBvZiBsYW1wb3J0cyByZXF1aXJlZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0TWludChcbiAgICBjb25uZWN0aW9uOiBDb25uZWN0aW9uLFxuICAgIGNvbW1pdG1lbnQ/OiBDb21taXRtZW50LFxuKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICByZXR1cm4gYXdhaXQgZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0TWludFdpdGhFeHRlbnNpb25zKGNvbm5lY3Rpb24sIFtdLCBjb21taXRtZW50KTtcbn1cblxuLyoqIEdldCB0aGUgbWluaW11bSBsYW1wb3J0IGJhbGFuY2UgZm9yIGEgcmVudC1leGVtcHQgbWludCB3aXRoIGV4dGVuc2lvbnNcbiAqXG4gKiBAcGFyYW0gY29ubmVjdGlvbiBDb25uZWN0aW9uIHRvIHVzZVxuICogQHBhcmFtIGV4dGVuc2lvbnMgRXh0ZW5zaW9uIHR5cGVzIGluY2x1ZGVkIGluIHRoZSBtaW50XG4gKiBAcGFyYW0gY29tbWl0bWVudCBEZXNpcmVkIGxldmVsIG9mIGNvbW1pdG1lbnQgZm9yIHF1ZXJ5aW5nIHRoZSBzdGF0ZVxuICpcbiAqIEByZXR1cm4gQW1vdW50IG9mIGxhbXBvcnRzIHJlcXVpcmVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRNaW50V2l0aEV4dGVuc2lvbnMoXG4gICAgY29ubmVjdGlvbjogQ29ubmVjdGlvbixcbiAgICBleHRlbnNpb25zOiBFeHRlbnNpb25UeXBlW10sXG4gICAgY29tbWl0bWVudD86IENvbW1pdG1lbnQsXG4pOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGNvbnN0IG1pbnRMZW4gPSBnZXRNaW50TGVuKGV4dGVuc2lvbnMpO1xuICAgIHJldHVybiBhd2FpdCBjb25uZWN0aW9uLmdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbihtaW50TGVuLCBjb21taXRtZW50KTtcbn1cblxuLyoqXG4gKiBBc3luYyB2ZXJzaW9uIG9mIGdldEFzc29jaWF0ZWRUb2tlbkFkZHJlc3NTeW5jXG4gKiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAqXG4gKiBAcGFyYW0gbWludCAgICAgICAgICAgICAgICAgICAgIFRva2VuIG1pbnQgYWNjb3VudFxuICogQHBhcmFtIG93bmVyICAgICAgICAgICAgICAgICAgICBPd25lciBvZiB0aGUgbmV3IGFjY291bnRcbiAqIEBwYXJhbSBhbGxvd093bmVyT2ZmQ3VydmUgICAgICAgQWxsb3cgdGhlIG93bmVyIGFjY291bnQgdG8gYmUgYSBQREEgKFByb2dyYW0gRGVyaXZlZCBBZGRyZXNzKVxuICogQHBhcmFtIHByb2dyYW1JZCAgICAgICAgICAgICAgICBTUEwgVG9rZW4gcHJvZ3JhbSBhY2NvdW50XG4gKiBAcGFyYW0gYXNzb2NpYXRlZFRva2VuUHJvZ3JhbUlkIFNQTCBBc3NvY2lhdGVkIFRva2VuIHByb2dyYW0gYWNjb3VudFxuICpcbiAqIEByZXR1cm4gUHJvbWlzZSBjb250YWluaW5nIHRoZSBhZGRyZXNzIG9mIHRoZSBhc3NvY2lhdGVkIHRva2VuIGFjY291bnRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFzc29jaWF0ZWRUb2tlbkFkZHJlc3MoXG4gICAgbWludDogUHVibGljS2V5LFxuICAgIG93bmVyOiBQdWJsaWNLZXksXG4gICAgYWxsb3dPd25lck9mZkN1cnZlID0gZmFsc2UsXG4gICAgcHJvZ3JhbUlkID0gVE9LRU5fUFJPR1JBTV9JRCxcbiAgICBhc3NvY2lhdGVkVG9rZW5Qcm9ncmFtSWQgPSBBU1NPQ0lBVEVEX1RPS0VOX1BST0dSQU1fSUQsXG4pOiBQcm9taXNlPFB1YmxpY0tleT4ge1xuICAgIGlmICghYWxsb3dPd25lck9mZkN1cnZlICYmICFQdWJsaWNLZXkuaXNPbkN1cnZlKG93bmVyLnRvQnVmZmVyKCkpKSB0aHJvdyBuZXcgVG9rZW5Pd25lck9mZkN1cnZlRXJyb3IoKTtcblxuICAgIGNvbnN0IFthZGRyZXNzXSA9IGF3YWl0IFB1YmxpY0tleS5maW5kUHJvZ3JhbUFkZHJlc3MoXG4gICAgICAgIFtvd25lci50b0J1ZmZlcigpLCBwcm9ncmFtSWQudG9CdWZmZXIoKSwgbWludC50b0J1ZmZlcigpXSxcbiAgICAgICAgYXNzb2NpYXRlZFRva2VuUHJvZ3JhbUlkLFxuICAgICk7XG5cbiAgICByZXR1cm4gYWRkcmVzcztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGFkZHJlc3Mgb2YgdGhlIGFzc29jaWF0ZWQgdG9rZW4gYWNjb3VudCBmb3IgYSBnaXZlbiBtaW50IGFuZCBvd25lclxuICpcbiAqIEBwYXJhbSBtaW50ICAgICAgICAgICAgICAgICAgICAgVG9rZW4gbWludCBhY2NvdW50XG4gKiBAcGFyYW0gb3duZXIgICAgICAgICAgICAgICAgICAgIE93bmVyIG9mIHRoZSBuZXcgYWNjb3VudFxuICogQHBhcmFtIGFsbG93T3duZXJPZmZDdXJ2ZSAgICAgICBBbGxvdyB0aGUgb3duZXIgYWNjb3VudCB0byBiZSBhIFBEQSAoUHJvZ3JhbSBEZXJpdmVkIEFkZHJlc3MpXG4gKiBAcGFyYW0gcHJvZ3JhbUlkICAgICAgICAgICAgICAgIFNQTCBUb2tlbiBwcm9ncmFtIGFjY291bnRcbiAqIEBwYXJhbSBhc3NvY2lhdGVkVG9rZW5Qcm9ncmFtSWQgU1BMIEFzc29jaWF0ZWQgVG9rZW4gcHJvZ3JhbSBhY2NvdW50XG4gKlxuICogQHJldHVybiBBZGRyZXNzIG9mIHRoZSBhc3NvY2lhdGVkIHRva2VuIGFjY291bnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFzc29jaWF0ZWRUb2tlbkFkZHJlc3NTeW5jKFxuICAgIG1pbnQ6IFB1YmxpY0tleSxcbiAgICBvd25lcjogUHVibGljS2V5LFxuICAgIGFsbG93T3duZXJPZmZDdXJ2ZSA9IGZhbHNlLFxuICAgIHByb2dyYW1JZCA9IFRPS0VOX1BST0dSQU1fSUQsXG4gICAgYXNzb2NpYXRlZFRva2VuUHJvZ3JhbUlkID0gQVNTT0NJQVRFRF9UT0tFTl9QUk9HUkFNX0lELFxuKTogUHVibGljS2V5IHtcbiAgICBpZiAoIWFsbG93T3duZXJPZmZDdXJ2ZSAmJiAhUHVibGljS2V5LmlzT25DdXJ2ZShvd25lci50b0J1ZmZlcigpKSkgdGhyb3cgbmV3IFRva2VuT3duZXJPZmZDdXJ2ZUVycm9yKCk7XG5cbiAgICBjb25zdCBbYWRkcmVzc10gPSBQdWJsaWNLZXkuZmluZFByb2dyYW1BZGRyZXNzU3luYyhcbiAgICAgICAgW293bmVyLnRvQnVmZmVyKCksIHByb2dyYW1JZC50b0J1ZmZlcigpLCBtaW50LnRvQnVmZmVyKCldLFxuICAgICAgICBhc3NvY2lhdGVkVG9rZW5Qcm9ncmFtSWQsXG4gICAgKTtcblxuICAgIHJldHVybiBhZGRyZXNzO1xufVxuIiwgImV4cG9ydCBlbnVtIEFjY291bnRUeXBlIHtcbiAgICBVbmluaXRpYWxpemVkLFxuICAgIE1pbnQsXG4gICAgQWNjb3VudCxcbn1cbmV4cG9ydCBjb25zdCBBQ0NPVU5UX1RZUEVfU0laRSA9IDE7XG4iLCAiaW1wb3J0IHsgc3RydWN0LCB1MzIsIHU4IH0gZnJvbSAnQHNvbGFuYS9idWZmZXItbGF5b3V0JztcbmltcG9ydCB7IHB1YmxpY0tleSwgdTY0IH0gZnJvbSAnQHNvbGFuYS9idWZmZXItbGF5b3V0LXV0aWxzJztcbmltcG9ydCB0eXBlIHsgQWNjb3VudEluZm8sIENvbW1pdG1lbnQsIENvbm5lY3Rpb24sIFB1YmxpY0tleSB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5pbXBvcnQgeyBUT0tFTl9QUk9HUkFNX0lEIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7XG4gICAgVG9rZW5BY2NvdW50Tm90Rm91bmRFcnJvcixcbiAgICBUb2tlbkludmFsaWRBY2NvdW50RXJyb3IsXG4gICAgVG9rZW5JbnZhbGlkQWNjb3VudE93bmVyRXJyb3IsXG4gICAgVG9rZW5JbnZhbGlkQWNjb3VudFNpemVFcnJvcixcbn0gZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IEFDQ09VTlRfVFlQRV9TSVpFLCBBY2NvdW50VHlwZSB9IGZyb20gJy4uL2V4dGVuc2lvbnMvYWNjb3VudFR5cGUuanMnO1xuaW1wb3J0IHR5cGUgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vZXh0ZW5zaW9ucy9leHRlbnNpb25UeXBlLmpzJztcbmltcG9ydCB7IGdldEFjY291bnRMZW4gfSBmcm9tICcuLi9leHRlbnNpb25zL2V4dGVuc2lvblR5cGUuanMnO1xuaW1wb3J0IHsgTVVMVElTSUdfU0laRSB9IGZyb20gJy4vbXVsdGlzaWcuanMnO1xuXG4vKiogSW5mb3JtYXRpb24gYWJvdXQgYSB0b2tlbiBhY2NvdW50ICovXG5leHBvcnQgaW50ZXJmYWNlIEFjY291bnQge1xuICAgIC8qKiBBZGRyZXNzIG9mIHRoZSBhY2NvdW50ICovXG4gICAgYWRkcmVzczogUHVibGljS2V5O1xuICAgIC8qKiBNaW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgYWNjb3VudCAqL1xuICAgIG1pbnQ6IFB1YmxpY0tleTtcbiAgICAvKiogT3duZXIgb2YgdGhlIGFjY291bnQgKi9cbiAgICBvd25lcjogUHVibGljS2V5O1xuICAgIC8qKiBOdW1iZXIgb2YgdG9rZW5zIHRoZSBhY2NvdW50IGhvbGRzICovXG4gICAgYW1vdW50OiBiaWdpbnQ7XG4gICAgLyoqIEF1dGhvcml0eSB0aGF0IGNhbiB0cmFuc2ZlciB0b2tlbnMgZnJvbSB0aGUgYWNjb3VudCAqL1xuICAgIGRlbGVnYXRlOiBQdWJsaWNLZXkgfCBudWxsO1xuICAgIC8qKiBOdW1iZXIgb2YgdG9rZW5zIHRoZSBkZWxlZ2F0ZSBpcyBhdXRob3JpemVkIHRvIHRyYW5zZmVyICovXG4gICAgZGVsZWdhdGVkQW1vdW50OiBiaWdpbnQ7XG4gICAgLyoqIFRydWUgaWYgdGhlIGFjY291bnQgaXMgaW5pdGlhbGl6ZWQgKi9cbiAgICBpc0luaXRpYWxpemVkOiBib29sZWFuO1xuICAgIC8qKiBUcnVlIGlmIHRoZSBhY2NvdW50IGlzIGZyb3plbiAqL1xuICAgIGlzRnJvemVuOiBib29sZWFuO1xuICAgIC8qKiBUcnVlIGlmIHRoZSBhY2NvdW50IGlzIGEgbmF0aXZlIHRva2VuIGFjY291bnQgKi9cbiAgICBpc05hdGl2ZTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgYWNjb3VudCBpcyBhIG5hdGl2ZSB0b2tlbiBhY2NvdW50LCBpdCBtdXN0IGJlIHJlbnQtZXhlbXB0LiBUaGUgcmVudC1leGVtcHQgcmVzZXJ2ZSBpcyB0aGUgYW1vdW50IHRoYXQgbXVzdFxuICAgICAqIHJlbWFpbiBpbiB0aGUgYmFsYW5jZSB1bnRpbCB0aGUgYWNjb3VudCBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgcmVudEV4ZW1wdFJlc2VydmU6IGJpZ2ludCB8IG51bGw7XG4gICAgLyoqIE9wdGlvbmFsIGF1dGhvcml0eSB0byBjbG9zZSB0aGUgYWNjb3VudCAqL1xuICAgIGNsb3NlQXV0aG9yaXR5OiBQdWJsaWNLZXkgfCBudWxsO1xuICAgIHRsdkRhdGE6IEJ1ZmZlcjtcbn1cblxuLyoqIFRva2VuIGFjY291bnQgc3RhdGUgYXMgc3RvcmVkIGJ5IHRoZSBwcm9ncmFtICovXG5leHBvcnQgZW51bSBBY2NvdW50U3RhdGUge1xuICAgIFVuaW5pdGlhbGl6ZWQgPSAwLFxuICAgIEluaXRpYWxpemVkID0gMSxcbiAgICBGcm96ZW4gPSAyLFxufVxuXG4vKiogVG9rZW4gYWNjb3VudCBhcyBzdG9yZWQgYnkgdGhlIHByb2dyYW0gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmF3QWNjb3VudCB7XG4gICAgbWludDogUHVibGljS2V5O1xuICAgIG93bmVyOiBQdWJsaWNLZXk7XG4gICAgYW1vdW50OiBiaWdpbnQ7XG4gICAgZGVsZWdhdGVPcHRpb246IDEgfCAwO1xuICAgIGRlbGVnYXRlOiBQdWJsaWNLZXk7XG4gICAgc3RhdGU6IEFjY291bnRTdGF0ZTtcbiAgICBpc05hdGl2ZU9wdGlvbjogMSB8IDA7XG4gICAgaXNOYXRpdmU6IGJpZ2ludDtcbiAgICBkZWxlZ2F0ZWRBbW91bnQ6IGJpZ2ludDtcbiAgICBjbG9zZUF1dGhvcml0eU9wdGlvbjogMSB8IDA7XG4gICAgY2xvc2VBdXRob3JpdHk6IFB1YmxpY0tleTtcbn1cblxuLyoqIEJ1ZmZlciBsYXlvdXQgZm9yIGRlL3NlcmlhbGl6aW5nIGEgdG9rZW4gYWNjb3VudCAqL1xuZXhwb3J0IGNvbnN0IEFjY291bnRMYXlvdXQgPSBzdHJ1Y3Q8UmF3QWNjb3VudD4oW1xuICAgIHB1YmxpY0tleSgnbWludCcpLFxuICAgIHB1YmxpY0tleSgnb3duZXInKSxcbiAgICB1NjQoJ2Ftb3VudCcpLFxuICAgIHUzMignZGVsZWdhdGVPcHRpb24nKSxcbiAgICBwdWJsaWNLZXkoJ2RlbGVnYXRlJyksXG4gICAgdTgoJ3N0YXRlJyksXG4gICAgdTMyKCdpc05hdGl2ZU9wdGlvbicpLFxuICAgIHU2NCgnaXNOYXRpdmUnKSxcbiAgICB1NjQoJ2RlbGVnYXRlZEFtb3VudCcpLFxuICAgIHUzMignY2xvc2VBdXRob3JpdHlPcHRpb24nKSxcbiAgICBwdWJsaWNLZXkoJ2Nsb3NlQXV0aG9yaXR5JyksXG5dKTtcblxuLyoqIEJ5dGUgbGVuZ3RoIG9mIGEgdG9rZW4gYWNjb3VudCAqL1xuZXhwb3J0IGNvbnN0IEFDQ09VTlRfU0laRSA9IEFjY291bnRMYXlvdXQuc3BhbjtcblxuLyoqXG4gKiBSZXRyaWV2ZSBpbmZvcm1hdGlvbiBhYm91dCBhIHRva2VuIGFjY291bnRcbiAqXG4gKiBAcGFyYW0gY29ubmVjdGlvbiBDb25uZWN0aW9uIHRvIHVzZVxuICogQHBhcmFtIGFkZHJlc3MgICAgVG9rZW4gYWNjb3VudFxuICogQHBhcmFtIGNvbW1pdG1lbnQgRGVzaXJlZCBsZXZlbCBvZiBjb21taXRtZW50IGZvciBxdWVyeWluZyB0aGUgc3RhdGVcbiAqIEBwYXJhbSBwcm9ncmFtSWQgIFNQTCBUb2tlbiBwcm9ncmFtIGFjY291bnRcbiAqXG4gKiBAcmV0dXJuIFRva2VuIGFjY291bnQgaW5mb3JtYXRpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFjY291bnQoXG4gICAgY29ubmVjdGlvbjogQ29ubmVjdGlvbixcbiAgICBhZGRyZXNzOiBQdWJsaWNLZXksXG4gICAgY29tbWl0bWVudD86IENvbW1pdG1lbnQsXG4gICAgcHJvZ3JhbUlkID0gVE9LRU5fUFJPR1JBTV9JRCxcbik6IFByb21pc2U8QWNjb3VudD4ge1xuICAgIGNvbnN0IGluZm8gPSBhd2FpdCBjb25uZWN0aW9uLmdldEFjY291bnRJbmZvKGFkZHJlc3MsIGNvbW1pdG1lbnQpO1xuICAgIHJldHVybiB1bnBhY2tBY2NvdW50KGFkZHJlc3MsIGluZm8sIHByb2dyYW1JZCk7XG59XG5cbi8qKlxuICogUmV0cmlldmUgaW5mb3JtYXRpb24gYWJvdXQgbXVsdGlwbGUgdG9rZW4gYWNjb3VudHMgaW4gYSBzaW5nbGUgUlBDIGNhbGxcbiAqXG4gKiBAcGFyYW0gY29ubmVjdGlvbiBDb25uZWN0aW9uIHRvIHVzZVxuICogQHBhcmFtIGFkZHJlc3NlcyAgVG9rZW4gYWNjb3VudHNcbiAqIEBwYXJhbSBjb21taXRtZW50IERlc2lyZWQgbGV2ZWwgb2YgY29tbWl0bWVudCBmb3IgcXVlcnlpbmcgdGhlIHN0YXRlXG4gKiBAcGFyYW0gcHJvZ3JhbUlkICBTUEwgVG9rZW4gcHJvZ3JhbSBhY2NvdW50XG4gKlxuICogQHJldHVybiBUb2tlbiBhY2NvdW50IGluZm9ybWF0aW9uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNdWx0aXBsZUFjY291bnRzKFxuICAgIGNvbm5lY3Rpb246IENvbm5lY3Rpb24sXG4gICAgYWRkcmVzc2VzOiBQdWJsaWNLZXlbXSxcbiAgICBjb21taXRtZW50PzogQ29tbWl0bWVudCxcbiAgICBwcm9ncmFtSWQgPSBUT0tFTl9QUk9HUkFNX0lELFxuKTogUHJvbWlzZTxBY2NvdW50W10+IHtcbiAgICBjb25zdCBpbmZvcyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0TXVsdGlwbGVBY2NvdW50c0luZm8oYWRkcmVzc2VzLCBjb21taXRtZW50KTtcbiAgICByZXR1cm4gYWRkcmVzc2VzLm1hcCgoYWRkcmVzcywgaSkgPT4gdW5wYWNrQWNjb3VudChhZGRyZXNzLCBpbmZvc1tpXSwgcHJvZ3JhbUlkKSk7XG59XG5cbi8qKiBHZXQgdGhlIG1pbmltdW0gbGFtcG9ydCBiYWxhbmNlIGZvciBhIGJhc2UgdG9rZW4gYWNjb3VudCB0byBiZSByZW50IGV4ZW1wdFxuICpcbiAqIEBwYXJhbSBjb25uZWN0aW9uIENvbm5lY3Rpb24gdG8gdXNlXG4gKiBAcGFyYW0gY29tbWl0bWVudCBEZXNpcmVkIGxldmVsIG9mIGNvbW1pdG1lbnQgZm9yIHF1ZXJ5aW5nIHRoZSBzdGF0ZVxuICpcbiAqIEByZXR1cm4gQW1vdW50IG9mIGxhbXBvcnRzIHJlcXVpcmVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRBY2NvdW50KFxuICAgIGNvbm5lY3Rpb246IENvbm5lY3Rpb24sXG4gICAgY29tbWl0bWVudD86IENvbW1pdG1lbnQsXG4pOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIHJldHVybiBhd2FpdCBnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRBY2NvdW50V2l0aEV4dGVuc2lvbnMoY29ubmVjdGlvbiwgW10sIGNvbW1pdG1lbnQpO1xufVxuXG4vKiogR2V0IHRoZSBtaW5pbXVtIGxhbXBvcnQgYmFsYW5jZSBmb3IgYSByZW50LWV4ZW1wdCB0b2tlbiBhY2NvdW50IHdpdGggZXh0ZW5zaW9uc1xuICpcbiAqIEBwYXJhbSBjb25uZWN0aW9uIENvbm5lY3Rpb24gdG8gdXNlXG4gKiBAcGFyYW0gY29tbWl0bWVudCBEZXNpcmVkIGxldmVsIG9mIGNvbW1pdG1lbnQgZm9yIHF1ZXJ5aW5nIHRoZSBzdGF0ZVxuICpcbiAqIEByZXR1cm4gQW1vdW50IG9mIGxhbXBvcnRzIHJlcXVpcmVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRBY2NvdW50V2l0aEV4dGVuc2lvbnMoXG4gICAgY29ubmVjdGlvbjogQ29ubmVjdGlvbixcbiAgICBleHRlbnNpb25zOiBFeHRlbnNpb25UeXBlW10sXG4gICAgY29tbWl0bWVudD86IENvbW1pdG1lbnQsXG4pOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGNvbnN0IGFjY291bnRMZW4gPSBnZXRBY2NvdW50TGVuKGV4dGVuc2lvbnMpO1xuICAgIHJldHVybiBhd2FpdCBjb25uZWN0aW9uLmdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbihhY2NvdW50TGVuLCBjb21taXRtZW50KTtcbn1cblxuLyoqXG4gKiBVbnBhY2sgYSB0b2tlbiBhY2NvdW50XG4gKlxuICogQHBhcmFtIGFkZHJlc3MgICBUb2tlbiBhY2NvdW50XG4gKiBAcGFyYW0gaW5mbyAgICAgIFRva2VuIGFjY291bnQgZGF0YVxuICogQHBhcmFtIHByb2dyYW1JZCBTUEwgVG9rZW4gcHJvZ3JhbSBhY2NvdW50XG4gKlxuICogQHJldHVybiBVbnBhY2tlZCB0b2tlbiBhY2NvdW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnBhY2tBY2NvdW50KFxuICAgIGFkZHJlc3M6IFB1YmxpY0tleSxcbiAgICBpbmZvOiBBY2NvdW50SW5mbzxCdWZmZXI+IHwgbnVsbCxcbiAgICBwcm9ncmFtSWQgPSBUT0tFTl9QUk9HUkFNX0lELFxuKTogQWNjb3VudCB7XG4gICAgaWYgKCFpbmZvKSB0aHJvdyBuZXcgVG9rZW5BY2NvdW50Tm90Rm91bmRFcnJvcigpO1xuICAgIGlmICghaW5mby5vd25lci5lcXVhbHMocHJvZ3JhbUlkKSkgdGhyb3cgbmV3IFRva2VuSW52YWxpZEFjY291bnRPd25lckVycm9yKCk7XG4gICAgaWYgKGluZm8uZGF0YS5sZW5ndGggPCBBQ0NPVU5UX1NJWkUpIHRocm93IG5ldyBUb2tlbkludmFsaWRBY2NvdW50U2l6ZUVycm9yKCk7XG5cbiAgICBjb25zdCByYXdBY2NvdW50ID0gQWNjb3VudExheW91dC5kZWNvZGUoaW5mby5kYXRhLnNsaWNlKDAsIEFDQ09VTlRfU0laRSkpO1xuICAgIGxldCB0bHZEYXRhID0gQnVmZmVyLmFsbG9jKDApO1xuICAgIGlmIChpbmZvLmRhdGEubGVuZ3RoID4gQUNDT1VOVF9TSVpFKSB7XG4gICAgICAgIGlmIChpbmZvLmRhdGEubGVuZ3RoID09PSBNVUxUSVNJR19TSVpFKSB0aHJvdyBuZXcgVG9rZW5JbnZhbGlkQWNjb3VudFNpemVFcnJvcigpO1xuICAgICAgICBpZiAoaW5mby5kYXRhW0FDQ09VTlRfU0laRV0gIT0gQWNjb3VudFR5cGUuQWNjb3VudCkgdGhyb3cgbmV3IFRva2VuSW52YWxpZEFjY291bnRFcnJvcigpO1xuICAgICAgICB0bHZEYXRhID0gaW5mby5kYXRhLnNsaWNlKEFDQ09VTlRfU0laRSArIEFDQ09VTlRfVFlQRV9TSVpFKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBtaW50OiByYXdBY2NvdW50Lm1pbnQsXG4gICAgICAgIG93bmVyOiByYXdBY2NvdW50Lm93bmVyLFxuICAgICAgICBhbW91bnQ6IHJhd0FjY291bnQuYW1vdW50LFxuICAgICAgICBkZWxlZ2F0ZTogcmF3QWNjb3VudC5kZWxlZ2F0ZU9wdGlvbiA/IHJhd0FjY291bnQuZGVsZWdhdGUgOiBudWxsLFxuICAgICAgICBkZWxlZ2F0ZWRBbW91bnQ6IHJhd0FjY291bnQuZGVsZWdhdGVkQW1vdW50LFxuICAgICAgICBpc0luaXRpYWxpemVkOiByYXdBY2NvdW50LnN0YXRlICE9PSBBY2NvdW50U3RhdGUuVW5pbml0aWFsaXplZCxcbiAgICAgICAgaXNGcm96ZW46IHJhd0FjY291bnQuc3RhdGUgPT09IEFjY291bnRTdGF0ZS5Gcm96ZW4sXG4gICAgICAgIGlzTmF0aXZlOiAhIXJhd0FjY291bnQuaXNOYXRpdmVPcHRpb24sXG4gICAgICAgIHJlbnRFeGVtcHRSZXNlcnZlOiByYXdBY2NvdW50LmlzTmF0aXZlT3B0aW9uID8gcmF3QWNjb3VudC5pc05hdGl2ZSA6IG51bGwsXG4gICAgICAgIGNsb3NlQXV0aG9yaXR5OiByYXdBY2NvdW50LmNsb3NlQXV0aG9yaXR5T3B0aW9uID8gcmF3QWNjb3VudC5jbG9zZUF1dGhvcml0eSA6IG51bGwsXG4gICAgICAgIHRsdkRhdGEsXG4gICAgfTtcbn1cbiIsICJpbXBvcnQgeyBzdHJ1Y3QsIHU4IH0gZnJvbSAnQHNvbGFuYS9idWZmZXItbGF5b3V0JztcbmltcG9ydCB7IGJvb2wsIHB1YmxpY0tleSB9IGZyb20gJ0Bzb2xhbmEvYnVmZmVyLWxheW91dC11dGlscyc7XG5pbXBvcnQgdHlwZSB7IEFjY291bnRJbmZvLCBDb21taXRtZW50LCBDb25uZWN0aW9uLCBQdWJsaWNLZXkgfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuaW1wb3J0IHsgVE9LRU5fUFJPR1JBTV9JRCB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBUb2tlbkFjY291bnROb3RGb3VuZEVycm9yLCBUb2tlbkludmFsaWRBY2NvdW50T3duZXJFcnJvciwgVG9rZW5JbnZhbGlkQWNjb3VudFNpemVFcnJvciB9IGZyb20gJy4uL2Vycm9ycy5qcyc7XG5cbi8qKiBJbmZvcm1hdGlvbiBhYm91dCBhIG11bHRpc2lnICovXG5leHBvcnQgaW50ZXJmYWNlIE11bHRpc2lnIHtcbiAgICAvKiogQWRkcmVzcyBvZiB0aGUgbXVsdGlzaWcgKi9cbiAgICBhZGRyZXNzOiBQdWJsaWNLZXk7XG4gICAgLyoqIE51bWJlciBvZiBzaWduZXJzIHJlcXVpcmVkICovXG4gICAgbTogbnVtYmVyO1xuICAgIC8qKiBOdW1iZXIgb2YgcG9zc2libGUgc2lnbmVycywgY29ycmVzcG9uZHMgdG8gdGhlIG51bWJlciBvZiBgc2lnbmVyc2AgdGhhdCBhcmUgdmFsaWQgKi9cbiAgICBuOiBudW1iZXI7XG4gICAgLyoqIElzIHRoaXMgbWludCBpbml0aWFsaXplZCAqL1xuICAgIGlzSW5pdGlhbGl6ZWQ6IGJvb2xlYW47XG4gICAgLyoqIEZ1bGwgc2V0IG9mIHNpZ25lcnMsIG9mIHdoaWNoIGBuYCBhcmUgdmFsaWQgKi9cbiAgICBzaWduZXIxOiBQdWJsaWNLZXk7XG4gICAgc2lnbmVyMjogUHVibGljS2V5O1xuICAgIHNpZ25lcjM6IFB1YmxpY0tleTtcbiAgICBzaWduZXI0OiBQdWJsaWNLZXk7XG4gICAgc2lnbmVyNTogUHVibGljS2V5O1xuICAgIHNpZ25lcjY6IFB1YmxpY0tleTtcbiAgICBzaWduZXI3OiBQdWJsaWNLZXk7XG4gICAgc2lnbmVyODogUHVibGljS2V5O1xuICAgIHNpZ25lcjk6IFB1YmxpY0tleTtcbiAgICBzaWduZXIxMDogUHVibGljS2V5O1xuICAgIHNpZ25lcjExOiBQdWJsaWNLZXk7XG59XG5cbi8qKiBNdWx0aXNpZyBhcyBzdG9yZWQgYnkgdGhlIHByb2dyYW0gKi9cbmV4cG9ydCB0eXBlIFJhd011bHRpc2lnID0gT21pdDxNdWx0aXNpZywgJ2FkZHJlc3MnPjtcblxuLyoqIEJ1ZmZlciBsYXlvdXQgZm9yIGRlL3NlcmlhbGl6aW5nIGEgbXVsdGlzaWcgKi9cbmV4cG9ydCBjb25zdCBNdWx0aXNpZ0xheW91dCA9IHN0cnVjdDxSYXdNdWx0aXNpZz4oW1xuICAgIHU4KCdtJyksXG4gICAgdTgoJ24nKSxcbiAgICBib29sKCdpc0luaXRpYWxpemVkJyksXG4gICAgcHVibGljS2V5KCdzaWduZXIxJyksXG4gICAgcHVibGljS2V5KCdzaWduZXIyJyksXG4gICAgcHVibGljS2V5KCdzaWduZXIzJyksXG4gICAgcHVibGljS2V5KCdzaWduZXI0JyksXG4gICAgcHVibGljS2V5KCdzaWduZXI1JyksXG4gICAgcHVibGljS2V5KCdzaWduZXI2JyksXG4gICAgcHVibGljS2V5KCdzaWduZXI3JyksXG4gICAgcHVibGljS2V5KCdzaWduZXI4JyksXG4gICAgcHVibGljS2V5KCdzaWduZXI5JyksXG4gICAgcHVibGljS2V5KCdzaWduZXIxMCcpLFxuICAgIHB1YmxpY0tleSgnc2lnbmVyMTEnKSxcbl0pO1xuXG4vKiogQnl0ZSBsZW5ndGggb2YgYSBtdWx0aXNpZyAqL1xuZXhwb3J0IGNvbnN0IE1VTFRJU0lHX1NJWkUgPSBNdWx0aXNpZ0xheW91dC5zcGFuO1xuXG4vKipcbiAqIFJldHJpZXZlIGluZm9ybWF0aW9uIGFib3V0IGEgbXVsdGlzaWdcbiAqXG4gKiBAcGFyYW0gY29ubmVjdGlvbiBDb25uZWN0aW9uIHRvIHVzZVxuICogQHBhcmFtIGFkZHJlc3MgICAgTXVsdGlzaWcgYWNjb3VudFxuICogQHBhcmFtIGNvbW1pdG1lbnQgRGVzaXJlZCBsZXZlbCBvZiBjb21taXRtZW50IGZvciBxdWVyeWluZyB0aGUgc3RhdGVcbiAqIEBwYXJhbSBwcm9ncmFtSWQgIFNQTCBUb2tlbiBwcm9ncmFtIGFjY291bnRcbiAqXG4gKiBAcmV0dXJuIE11bHRpc2lnIGluZm9ybWF0aW9uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNdWx0aXNpZyhcbiAgICBjb25uZWN0aW9uOiBDb25uZWN0aW9uLFxuICAgIGFkZHJlc3M6IFB1YmxpY0tleSxcbiAgICBjb21taXRtZW50PzogQ29tbWl0bWVudCxcbiAgICBwcm9ncmFtSWQgPSBUT0tFTl9QUk9HUkFNX0lELFxuKTogUHJvbWlzZTxNdWx0aXNpZz4ge1xuICAgIGNvbnN0IGluZm8gPSBhd2FpdCBjb25uZWN0aW9uLmdldEFjY291bnRJbmZvKGFkZHJlc3MsIGNvbW1pdG1lbnQpO1xuICAgIHJldHVybiB1bnBhY2tNdWx0aXNpZyhhZGRyZXNzLCBpbmZvLCBwcm9ncmFtSWQpO1xufVxuXG4vKipcbiAqIFVucGFjayBhIG11bHRpc2lnXG4gKlxuICogQHBhcmFtIGFkZHJlc3MgICBNdWx0aXNpZyBhY2NvdW50XG4gKiBAcGFyYW0gaW5mbyAgICAgIE11bHRpc2lnIGFjY291bnQgZGF0YVxuICogQHBhcmFtIHByb2dyYW1JZCBTUEwgVG9rZW4gcHJvZ3JhbSBhY2NvdW50XG4gKlxuICogQHJldHVybiBVbnBhY2tlZCBtdWx0aXNpZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gdW5wYWNrTXVsdGlzaWcoXG4gICAgYWRkcmVzczogUHVibGljS2V5LFxuICAgIGluZm86IEFjY291bnRJbmZvPEJ1ZmZlcj4gfCBudWxsLFxuICAgIHByb2dyYW1JZCA9IFRPS0VOX1BST0dSQU1fSUQsXG4pOiBNdWx0aXNpZyB7XG4gICAgaWYgKCFpbmZvKSB0aHJvdyBuZXcgVG9rZW5BY2NvdW50Tm90Rm91bmRFcnJvcigpO1xuICAgIGlmICghaW5mby5vd25lci5lcXVhbHMocHJvZ3JhbUlkKSkgdGhyb3cgbmV3IFRva2VuSW52YWxpZEFjY291bnRPd25lckVycm9yKCk7XG4gICAgaWYgKGluZm8uZGF0YS5sZW5ndGggIT0gTVVMVElTSUdfU0laRSkgdGhyb3cgbmV3IFRva2VuSW52YWxpZEFjY291bnRTaXplRXJyb3IoKTtcblxuICAgIGNvbnN0IG11bHRpc2lnID0gTXVsdGlzaWdMYXlvdXQuZGVjb2RlKGluZm8uZGF0YSk7XG5cbiAgICByZXR1cm4geyBhZGRyZXNzLCAuLi5tdWx0aXNpZyB9O1xufVxuXG4vKiogR2V0IHRoZSBtaW5pbXVtIGxhbXBvcnQgYmFsYW5jZSBmb3IgYSBtdWx0aXNpZyB0byBiZSByZW50IGV4ZW1wdFxuICpcbiAqIEBwYXJhbSBjb25uZWN0aW9uIENvbm5lY3Rpb24gdG8gdXNlXG4gKiBAcGFyYW0gY29tbWl0bWVudCBEZXNpcmVkIGxldmVsIG9mIGNvbW1pdG1lbnQgZm9yIHF1ZXJ5aW5nIHRoZSBzdGF0ZVxuICpcbiAqIEByZXR1cm4gQW1vdW50IG9mIGxhbXBvcnRzIHJlcXVpcmVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRNdWx0aXNpZyhcbiAgICBjb25uZWN0aW9uOiBDb25uZWN0aW9uLFxuICAgIGNvbW1pdG1lbnQ/OiBDb21taXRtZW50LFxuKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICByZXR1cm4gYXdhaXQgY29ubmVjdGlvbi5nZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb24oTVVMVElTSUdfU0laRSwgY29tbWl0bWVudCk7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBBY2NvdW50TWV0YSwgU2lnbmVyIH0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJztcbmltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRTaWduZXJzKFxuICAgIGtleXM6IEFjY291bnRNZXRhW10sXG4gICAgb3duZXJPckF1dGhvcml0eTogUHVibGljS2V5LFxuICAgIG11bHRpU2lnbmVyczogKFNpZ25lciB8IFB1YmxpY0tleSlbXSxcbik6IEFjY291bnRNZXRhW10ge1xuICAgIGlmIChtdWx0aVNpZ25lcnMubGVuZ3RoKSB7XG4gICAgICAgIGtleXMucHVzaCh7IHB1YmtleTogb3duZXJPckF1dGhvcml0eSwgaXNTaWduZXI6IGZhbHNlLCBpc1dyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICAgICAgZm9yIChjb25zdCBzaWduZXIgb2YgbXVsdGlTaWduZXJzKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goe1xuICAgICAgICAgICAgICAgIHB1YmtleTogc2lnbmVyIGluc3RhbmNlb2YgUHVibGljS2V5ID8gc2lnbmVyIDogc2lnbmVyLnB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5wdXNoKHsgcHVia2V5OiBvd25lck9yQXV0aG9yaXR5LCBpc1NpZ25lcjogdHJ1ZSwgaXNXcml0YWJsZTogZmFsc2UgfSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuIiwgImltcG9ydCB7IHN0cnVjdCwgdTggfSBmcm9tICdAc29sYW5hL2J1ZmZlci1sYXlvdXQnO1xuaW1wb3J0IHsgdTY0IH0gZnJvbSAnQHNvbGFuYS9idWZmZXItbGF5b3V0LXV0aWxzJztcbmltcG9ydCB0eXBlIHsgQWNjb3VudE1ldGEsIFB1YmxpY0tleSwgU2lnbmVyIH0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24gfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuaW1wb3J0IHsgVE9LRU5fUFJPR1JBTV9JRCB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQge1xuICAgIFRva2VuSW52YWxpZEluc3RydWN0aW9uRGF0YUVycm9yLFxuICAgIFRva2VuSW52YWxpZEluc3RydWN0aW9uS2V5c0Vycm9yLFxuICAgIFRva2VuSW52YWxpZEluc3RydWN0aW9uUHJvZ3JhbUVycm9yLFxuICAgIFRva2VuSW52YWxpZEluc3RydWN0aW9uVHlwZUVycm9yLFxufSBmcm9tICcuLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgYWRkU2lnbmVycyB9IGZyb20gJy4vaW50ZXJuYWwuanMnO1xuaW1wb3J0IHsgVG9rZW5JbnN0cnVjdGlvbiB9IGZyb20gJy4vdHlwZXMuanMnO1xuXG4vKiogVE9ETzogZG9jcyAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFuc2ZlckNoZWNrZWRJbnN0cnVjdGlvbkRhdGEge1xuICAgIGluc3RydWN0aW9uOiBUb2tlbkluc3RydWN0aW9uLlRyYW5zZmVyQ2hlY2tlZDtcbiAgICBhbW91bnQ6IGJpZ2ludDtcbiAgICBkZWNpbWFsczogbnVtYmVyO1xufVxuXG4vKiogVE9ETzogZG9jcyAqL1xuZXhwb3J0IGNvbnN0IHRyYW5zZmVyQ2hlY2tlZEluc3RydWN0aW9uRGF0YSA9IHN0cnVjdDxUcmFuc2ZlckNoZWNrZWRJbnN0cnVjdGlvbkRhdGE+KFtcbiAgICB1OCgnaW5zdHJ1Y3Rpb24nKSxcbiAgICB1NjQoJ2Ftb3VudCcpLFxuICAgIHU4KCdkZWNpbWFscycpLFxuXSk7XG5cbi8qKlxuICogQ29uc3RydWN0IGEgVHJhbnNmZXJDaGVja2VkIGluc3RydWN0aW9uXG4gKlxuICogQHBhcmFtIHNvdXJjZSAgICAgICBTb3VyY2UgYWNjb3VudFxuICogQHBhcmFtIG1pbnQgICAgICAgICBNaW50IGFjY291bnRcbiAqIEBwYXJhbSBkZXN0aW5hdGlvbiAgRGVzdGluYXRpb24gYWNjb3VudFxuICogQHBhcmFtIG93bmVyICAgICAgICBPd25lciBvZiB0aGUgc291cmNlIGFjY291bnRcbiAqIEBwYXJhbSBhbW91bnQgICAgICAgTnVtYmVyIG9mIHRva2VucyB0byB0cmFuc2ZlclxuICogQHBhcmFtIGRlY2ltYWxzICAgICBOdW1iZXIgb2YgZGVjaW1hbHMgaW4gdHJhbnNmZXIgYW1vdW50XG4gKiBAcGFyYW0gbXVsdGlTaWduZXJzIFNpZ25pbmcgYWNjb3VudHMgaWYgYG93bmVyYCBpcyBhIG11bHRpc2lnXG4gKiBAcGFyYW0gcHJvZ3JhbUlkICAgIFNQTCBUb2tlbiBwcm9ncmFtIGFjY291bnRcbiAqXG4gKiBAcmV0dXJuIEluc3RydWN0aW9uIHRvIGFkZCB0byBhIHRyYW5zYWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUcmFuc2ZlckNoZWNrZWRJbnN0cnVjdGlvbihcbiAgICBzb3VyY2U6IFB1YmxpY0tleSxcbiAgICBtaW50OiBQdWJsaWNLZXksXG4gICAgZGVzdGluYXRpb246IFB1YmxpY0tleSxcbiAgICBvd25lcjogUHVibGljS2V5LFxuICAgIGFtb3VudDogbnVtYmVyIHwgYmlnaW50LFxuICAgIGRlY2ltYWxzOiBudW1iZXIsXG4gICAgbXVsdGlTaWduZXJzOiAoU2lnbmVyIHwgUHVibGljS2V5KVtdID0gW10sXG4gICAgcHJvZ3JhbUlkID0gVE9LRU5fUFJPR1JBTV9JRCxcbik6IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0IGtleXMgPSBhZGRTaWduZXJzKFxuICAgICAgICBbXG4gICAgICAgICAgICB7IHB1YmtleTogc291cmNlLCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IHRydWUgfSxcbiAgICAgICAgICAgIHsgcHVia2V5OiBtaW50LCBpc1NpZ25lcjogZmFsc2UsIGlzV3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IHB1YmtleTogZGVzdGluYXRpb24sIGlzU2lnbmVyOiBmYWxzZSwgaXNXcml0YWJsZTogdHJ1ZSB9LFxuICAgICAgICBdLFxuICAgICAgICBvd25lcixcbiAgICAgICAgbXVsdGlTaWduZXJzLFxuICAgICk7XG5cbiAgICBjb25zdCBkYXRhID0gQnVmZmVyLmFsbG9jKHRyYW5zZmVyQ2hlY2tlZEluc3RydWN0aW9uRGF0YS5zcGFuKTtcbiAgICB0cmFuc2ZlckNoZWNrZWRJbnN0cnVjdGlvbkRhdGEuZW5jb2RlKFxuICAgICAgICB7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbjogVG9rZW5JbnN0cnVjdGlvbi5UcmFuc2ZlckNoZWNrZWQsXG4gICAgICAgICAgICBhbW91bnQ6IEJpZ0ludChhbW91bnQpLFxuICAgICAgICAgICAgZGVjaW1hbHMsXG4gICAgICAgIH0sXG4gICAgICAgIGRhdGEsXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7IGtleXMsIHByb2dyYW1JZCwgZGF0YSB9KTtcbn1cblxuLyoqIEEgZGVjb2RlZCwgdmFsaWQgVHJhbnNmZXJDaGVja2VkIGluc3RydWN0aW9uICovXG5leHBvcnQgaW50ZXJmYWNlIERlY29kZWRUcmFuc2ZlckNoZWNrZWRJbnN0cnVjdGlvbiB7XG4gICAgcHJvZ3JhbUlkOiBQdWJsaWNLZXk7XG4gICAga2V5czoge1xuICAgICAgICBzb3VyY2U6IEFjY291bnRNZXRhO1xuICAgICAgICBtaW50OiBBY2NvdW50TWV0YTtcbiAgICAgICAgZGVzdGluYXRpb246IEFjY291bnRNZXRhO1xuICAgICAgICBvd25lcjogQWNjb3VudE1ldGE7XG4gICAgICAgIG11bHRpU2lnbmVyczogQWNjb3VudE1ldGFbXTtcbiAgICB9O1xuICAgIGRhdGE6IHtcbiAgICAgICAgaW5zdHJ1Y3Rpb246IFRva2VuSW5zdHJ1Y3Rpb24uVHJhbnNmZXJDaGVja2VkO1xuICAgICAgICBhbW91bnQ6IGJpZ2ludDtcbiAgICAgICAgZGVjaW1hbHM6IG51bWJlcjtcbiAgICB9O1xufVxuXG4vKipcbiAqIERlY29kZSBhIFRyYW5zZmVyQ2hlY2tlZCBpbnN0cnVjdGlvbiBhbmQgdmFsaWRhdGUgaXRcbiAqXG4gKiBAcGFyYW0gaW5zdHJ1Y3Rpb24gVHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdG8gZGVjb2RlXG4gKiBAcGFyYW0gcHJvZ3JhbUlkICAgU1BMIFRva2VuIHByb2dyYW0gYWNjb3VudFxuICpcbiAqIEByZXR1cm4gRGVjb2RlZCwgdmFsaWQgaW5zdHJ1Y3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVRyYW5zZmVyQ2hlY2tlZEluc3RydWN0aW9uKFxuICAgIGluc3RydWN0aW9uOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uLFxuICAgIHByb2dyYW1JZCA9IFRPS0VOX1BST0dSQU1fSUQsXG4pOiBEZWNvZGVkVHJhbnNmZXJDaGVja2VkSW5zdHJ1Y3Rpb24ge1xuICAgIGlmICghaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkLmVxdWFscyhwcm9ncmFtSWQpKSB0aHJvdyBuZXcgVG9rZW5JbnZhbGlkSW5zdHJ1Y3Rpb25Qcm9ncmFtRXJyb3IoKTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24uZGF0YS5sZW5ndGggIT09IHRyYW5zZmVyQ2hlY2tlZEluc3RydWN0aW9uRGF0YS5zcGFuKSB0aHJvdyBuZXcgVG9rZW5JbnZhbGlkSW5zdHJ1Y3Rpb25EYXRhRXJyb3IoKTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAga2V5czogeyBzb3VyY2UsIG1pbnQsIGRlc3RpbmF0aW9uLCBvd25lciwgbXVsdGlTaWduZXJzIH0sXG4gICAgICAgIGRhdGEsXG4gICAgfSA9IGRlY29kZVRyYW5zZmVyQ2hlY2tlZEluc3RydWN0aW9uVW5jaGVja2VkKGluc3RydWN0aW9uKTtcbiAgICBpZiAoZGF0YS5pbnN0cnVjdGlvbiAhPT0gVG9rZW5JbnN0cnVjdGlvbi5UcmFuc2ZlckNoZWNrZWQpIHRocm93IG5ldyBUb2tlbkludmFsaWRJbnN0cnVjdGlvblR5cGVFcnJvcigpO1xuICAgIGlmICghc291cmNlIHx8ICFtaW50IHx8ICFkZXN0aW5hdGlvbiB8fCAhb3duZXIpIHRocm93IG5ldyBUb2tlbkludmFsaWRJbnN0cnVjdGlvbktleXNFcnJvcigpO1xuXG4gICAgLy8gVE9ETzoga2V5IGNoZWNrcz9cblxuICAgIHJldHVybiB7XG4gICAgICAgIHByb2dyYW1JZCxcbiAgICAgICAga2V5czoge1xuICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgbWludCxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgb3duZXIsXG4gICAgICAgICAgICBtdWx0aVNpZ25lcnMsXG4gICAgICAgIH0sXG4gICAgICAgIGRhdGEsXG4gICAgfTtcbn1cblxuLyoqIEEgZGVjb2RlZCwgbm9uLXZhbGlkYXRlZCBUcmFuc2ZlckNoZWNrZWQgaW5zdHJ1Y3Rpb24gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGVjb2RlZFRyYW5zZmVyQ2hlY2tlZEluc3RydWN0aW9uVW5jaGVja2VkIHtcbiAgICBwcm9ncmFtSWQ6IFB1YmxpY0tleTtcbiAgICBrZXlzOiB7XG4gICAgICAgIHNvdXJjZTogQWNjb3VudE1ldGEgfCB1bmRlZmluZWQ7XG4gICAgICAgIG1pbnQ6IEFjY291bnRNZXRhIHwgdW5kZWZpbmVkO1xuICAgICAgICBkZXN0aW5hdGlvbjogQWNjb3VudE1ldGEgfCB1bmRlZmluZWQ7XG4gICAgICAgIG93bmVyOiBBY2NvdW50TWV0YSB8IHVuZGVmaW5lZDtcbiAgICAgICAgbXVsdGlTaWduZXJzOiBBY2NvdW50TWV0YVtdO1xuICAgIH07XG4gICAgZGF0YToge1xuICAgICAgICBpbnN0cnVjdGlvbjogbnVtYmVyO1xuICAgICAgICBhbW91bnQ6IGJpZ2ludDtcbiAgICAgICAgZGVjaW1hbHM6IG51bWJlcjtcbiAgICB9O1xufVxuXG4vKipcbiAqIERlY29kZSBhIFRyYW5zZmVyQ2hlY2tlZCBpbnN0cnVjdGlvbiB3aXRob3V0IHZhbGlkYXRpbmcgaXRcbiAqXG4gKiBAcGFyYW0gaW5zdHJ1Y3Rpb24gVHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdG8gZGVjb2RlXG4gKlxuICogQHJldHVybiBEZWNvZGVkLCBub24tdmFsaWRhdGVkIGluc3RydWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUcmFuc2ZlckNoZWNrZWRJbnN0cnVjdGlvblVuY2hlY2tlZCh7XG4gICAgcHJvZ3JhbUlkLFxuICAgIGtleXM6IFtzb3VyY2UsIG1pbnQsIGRlc3RpbmF0aW9uLCBvd25lciwgLi4ubXVsdGlTaWduZXJzXSxcbiAgICBkYXRhLFxufTogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbik6IERlY29kZWRUcmFuc2ZlckNoZWNrZWRJbnN0cnVjdGlvblVuY2hlY2tlZCB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvZ3JhbUlkLFxuICAgICAgICBrZXlzOiB7XG4gICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICBtaW50LFxuICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICBvd25lcixcbiAgICAgICAgICAgIG11bHRpU2lnbmVycyxcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YTogdHJhbnNmZXJDaGVja2VkSW5zdHJ1Y3Rpb25EYXRhLmRlY29kZShkYXRhKSxcbiAgICB9O1xufVxuIiwgImltcG9ydCB7XG4gICAgY3JlYXRlVHJhbnNmZXJDaGVja2VkSW5zdHJ1Y3Rpb24sXG4gICAgZ2V0QWNjb3VudCxcbiAgICBnZXRBc3NvY2lhdGVkVG9rZW5BZGRyZXNzLFxuICAgIGdldE1pbnQsXG4gICAgVE9LRU5fMjAyMl9QUk9HUkFNX0lELFxuICAgIFRPS0VOX1BST0dSQU1fSUQsXG59IGZyb20gJ0Bzb2xhbmEvc3BsLXRva2VuJztcbmltcG9ydCB0eXBlIHsgQ29tbWl0bWVudCwgQ29ubmVjdGlvbiwgR2V0TGF0ZXN0QmxvY2toYXNoQ29uZmlnLCBQdWJsaWNLZXkgfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuaW1wb3J0IHsgTEFNUE9SVFNfUEVSX1NPTCwgU3lzdGVtUHJvZ3JhbSwgVHJhbnNhY3Rpb24sIFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24gfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgTUVNT19QUk9HUkFNX0lELCBTT0xfREVDSU1BTFMsIFRFTiB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB0eXBlIHsgQW1vdW50LCBNZW1vLCBSZWNpcGllbnQsIFJlZmVyZW5jZXMsIFNQTFRva2VuIH0gZnJvbSAnLi90eXBlcy5qcyc7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSBTb2xhbmEgUGF5IHRyYW5zZmVyIHRyYW5zYWN0aW9uIGNhbid0IGJlIGNyZWF0ZWQgZnJvbSB0aGUgZmllbGRzIHByb3ZpZGVkLlxuICovXG5leHBvcnQgY2xhc3MgQ3JlYXRlVHJhbnNmZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBuYW1lID0gJ0NyZWF0ZVRyYW5zZmVyRXJyb3InO1xufVxuXG4vKipcbiAqIEZpZWxkcyBvZiBhIFNvbGFuYSBQYXkgdHJhbnNmZXIgcmVxdWVzdCBVUkwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlVHJhbnNmZXJGaWVsZHMge1xuICAgIC8qKiBgcmVjaXBpZW50YCBpbiB0aGUgW1NvbGFuYSBQYXkgc3BlY10oaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS1wYXkvYmxvYi9tYXN0ZXIvU1BFQy5tZCNyZWNpcGllbnQpLiAqL1xuICAgIHJlY2lwaWVudDogUmVjaXBpZW50O1xuICAgIC8qKiBgYW1vdW50YCBpbiB0aGUgW1NvbGFuYSBQYXkgc3BlY10oaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS1wYXkvYmxvYi9tYXN0ZXIvU1BFQy5tZCNhbW91bnQpLiAqL1xuICAgIGFtb3VudDogQW1vdW50O1xuICAgIC8qKiBgc3BsLXRva2VuYCBpbiB0aGUgW1NvbGFuYSBQYXkgc3BlY10oaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS1wYXkvYmxvYi9tYXN0ZXIvU1BFQy5tZCNzcGwtdG9rZW4pLiAqL1xuICAgIHNwbFRva2VuPzogU1BMVG9rZW47XG4gICAgLyoqIGByZWZlcmVuY2VgIGluIHRoZSBbU29sYW5hIFBheSBzcGVjXShodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hLXBheS9ibG9iL21hc3Rlci9TUEVDLm1kI3JlZmVyZW5jZSkuICovXG4gICAgcmVmZXJlbmNlPzogUmVmZXJlbmNlcztcbiAgICAvKiogYG1lbW9gIGluIHRoZSBbU29sYW5hIFBheSBzcGVjXShodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hLXBheS9ibG9iL21hc3Rlci9TUEVDLm1kI21lbW8pLiAqL1xuICAgIG1lbW8/OiBNZW1vO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIFNvbGFuYSBQYXkgdHJhbnNmZXIgdHJhbnNhY3Rpb24uXG4gKlxuICogQHBhcmFtIGNvbm5lY3Rpb24gLSBBIGNvbm5lY3Rpb24gdG8gdGhlIGNsdXN0ZXIuXG4gKiBAcGFyYW0gc2VuZGVyIC0gQWNjb3VudCB0aGF0IHdpbGwgc2VuZCB0aGUgdHJhbnNmZXIuXG4gKiBAcGFyYW0gZmllbGRzIC0gRmllbGRzIG9mIGEgU29sYW5hIFBheSB0cmFuc2ZlciByZXF1ZXN0IFVSTC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgYGdldExhdGVzdEJsb2NraGFzaGAuXG4gKlxuICogQHRocm93cyB7Q3JlYXRlVHJhbnNmZXJFcnJvcn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRyYW5zZmVyKFxuICAgIGNvbm5lY3Rpb246IENvbm5lY3Rpb24sXG4gICAgc2VuZGVyOiBQdWJsaWNLZXksXG4gICAgeyByZWNpcGllbnQsIGFtb3VudCwgc3BsVG9rZW4sIHJlZmVyZW5jZSwgbWVtbyB9OiBDcmVhdGVUcmFuc2ZlckZpZWxkcyxcbiAgICB7IGNvbW1pdG1lbnQgfTogeyBjb21taXRtZW50PzogQ29tbWl0bWVudCB8IEdldExhdGVzdEJsb2NraGFzaENvbmZpZyB9ID0ge31cbik6IFByb21pc2U8VHJhbnNhY3Rpb24+IHtcbiAgICAvLyBDaGVjayB0aGF0IHRoZSBzZW5kZXIgYW5kIHJlY2lwaWVudCBhY2NvdW50cyBleGlzdFxuICAgIGNvbnN0IHNlbmRlckluZm8gPSBhd2FpdCBjb25uZWN0aW9uLmdldEFjY291bnRJbmZvKHNlbmRlcik7XG4gICAgaWYgKCFzZW5kZXJJbmZvKSB0aHJvdyBuZXcgQ3JlYXRlVHJhbnNmZXJFcnJvcignc2VuZGVyIG5vdCBmb3VuZCcpO1xuXG4gICAgY29uc3QgcmVjaXBpZW50SW5mbyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QWNjb3VudEluZm8ocmVjaXBpZW50KTtcbiAgICBpZiAoIXJlY2lwaWVudEluZm8pIHRocm93IG5ldyBDcmVhdGVUcmFuc2ZlckVycm9yKCdyZWNpcGllbnQgbm90IGZvdW5kJyk7XG5cbiAgICAvLyBBIG5hdGl2ZSBTT0wgb3IgU1BMIHRva2VuIHRyYW5zZmVyIGluc3RydWN0aW9uXG4gICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSBzcGxUb2tlblxuICAgICAgICA/IGF3YWl0IGNyZWF0ZVNQTFRva2VuSW5zdHJ1Y3Rpb24ocmVjaXBpZW50LCBhbW91bnQsIHNwbFRva2VuLCBzZW5kZXIsIGNvbm5lY3Rpb24pXG4gICAgICAgIDogYXdhaXQgY3JlYXRlU3lzdGVtSW5zdHJ1Y3Rpb24ocmVjaXBpZW50LCBhbW91bnQsIHNlbmRlciwgY29ubmVjdGlvbik7XG5cbiAgICAvLyBJZiByZWZlcmVuY2UgYWNjb3VudHMgYXJlIHByb3ZpZGVkLCBhZGQgdGhlbSB0byB0aGUgdHJhbnNmZXIgaW5zdHJ1Y3Rpb25cbiAgICBpZiAocmVmZXJlbmNlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICByZWZlcmVuY2UgPSBbcmVmZXJlbmNlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgcHVia2V5IG9mIHJlZmVyZW5jZSkge1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24ua2V5cy5wdXNoKHsgcHVia2V5LCBpc1dyaXRhYmxlOiBmYWxzZSwgaXNTaWduZXI6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHRoZSB0cmFuc2FjdGlvblxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSBzZW5kZXI7XG4gICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gKGF3YWl0IGNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKGNvbW1pdG1lbnQpKS5ibG9ja2hhc2g7XG5cbiAgICAvLyBJZiBhIG1lbW8gaXMgcHJvdmlkZWQsIGFkZCBpdCB0byB0aGUgdHJhbnNhY3Rpb24gYmVmb3JlIGFkZGluZyB0aGUgdHJhbnNmZXIgaW5zdHJ1Y3Rpb25cbiAgICBpZiAobWVtbyAhPSBudWxsKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmFkZChcbiAgICAgICAgICAgIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgICAgICAgICAgICBwcm9ncmFtSWQ6IE1FTU9fUFJPR1JBTV9JRCxcbiAgICAgICAgICAgICAgICBrZXlzOiBbXSxcbiAgICAgICAgICAgICAgICBkYXRhOiBCdWZmZXIuZnJvbShtZW1vLCAndXRmOCcpLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIHRyYW5zZmVyIGluc3RydWN0aW9uIHRvIHRoZSB0cmFuc2FjdGlvblxuICAgIHRyYW5zYWN0aW9uLmFkZChpbnN0cnVjdGlvbik7XG5cbiAgICByZXR1cm4gdHJhbnNhY3Rpb247XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVN5c3RlbUluc3RydWN0aW9uKFxuICAgIHJlY2lwaWVudDogUHVibGljS2V5LFxuICAgIGFtb3VudDogQmlnTnVtYmVyLFxuICAgIHNlbmRlcjogUHVibGljS2V5LFxuICAgIGNvbm5lY3Rpb246IENvbm5lY3Rpb25cbik6IFByb21pc2U8VHJhbnNhY3Rpb25JbnN0cnVjdGlvbj4ge1xuICAgIC8vIENoZWNrIHRoYXQgdGhlIHNlbmRlciBhbmQgcmVjaXBpZW50IGFjY291bnRzIGV4aXN0XG4gICAgY29uc3Qgc2VuZGVySW5mbyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QWNjb3VudEluZm8oc2VuZGVyKTtcbiAgICBpZiAoIXNlbmRlckluZm8pIHRocm93IG5ldyBDcmVhdGVUcmFuc2ZlckVycm9yKCdzZW5kZXIgbm90IGZvdW5kJyk7XG5cbiAgICBjb25zdCByZWNpcGllbnRJbmZvID0gYXdhaXQgY29ubmVjdGlvbi5nZXRBY2NvdW50SW5mbyhyZWNpcGllbnQpO1xuICAgIGlmICghcmVjaXBpZW50SW5mbykgdGhyb3cgbmV3IENyZWF0ZVRyYW5zZmVyRXJyb3IoJ3JlY2lwaWVudCBub3QgZm91bmQnKTtcblxuICAgIC8vIENoZWNrIHRoYXQgdGhlIHNlbmRlciBhbmQgcmVjaXBpZW50IGFyZSB2YWxpZCBuYXRpdmUgYWNjb3VudHNcbiAgICBpZiAoIXNlbmRlckluZm8ub3duZXIuZXF1YWxzKFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkKSkgdGhyb3cgbmV3IENyZWF0ZVRyYW5zZmVyRXJyb3IoJ3NlbmRlciBvd25lciBpbnZhbGlkJyk7XG4gICAgaWYgKHNlbmRlckluZm8uZXhlY3V0YWJsZSkgdGhyb3cgbmV3IENyZWF0ZVRyYW5zZmVyRXJyb3IoJ3NlbmRlciBleGVjdXRhYmxlJyk7XG4gICAgaWYgKCFyZWNpcGllbnRJbmZvLm93bmVyLmVxdWFscyhTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCkpIHRocm93IG5ldyBDcmVhdGVUcmFuc2ZlckVycm9yKCdyZWNpcGllbnQgb3duZXIgaW52YWxpZCcpO1xuICAgIGlmIChyZWNpcGllbnRJbmZvLmV4ZWN1dGFibGUpIHRocm93IG5ldyBDcmVhdGVUcmFuc2ZlckVycm9yKCdyZWNpcGllbnQgZXhlY3V0YWJsZScpO1xuXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgYW1vdW50IHByb3ZpZGVkIGRvZXNuJ3QgaGF2ZSBncmVhdGVyIHByZWNpc2lvbiB0aGFuIFNPTFxuICAgIGlmICgoYW1vdW50LmRlY2ltYWxQbGFjZXMoKSA/PyAwKSA+IFNPTF9ERUNJTUFMUykgdGhyb3cgbmV3IENyZWF0ZVRyYW5zZmVyRXJyb3IoJ2Ftb3VudCBkZWNpbWFscyBpbnZhbGlkJyk7XG5cbiAgICAvLyBDb252ZXJ0IGlucHV0IGRlY2ltYWwgYW1vdW50IHRvIGludGVnZXIgbGFtcG9ydHNcbiAgICBhbW91bnQgPSBhbW91bnQudGltZXMoTEFNUE9SVFNfUEVSX1NPTCkuaW50ZWdlclZhbHVlKEJpZ051bWJlci5ST1VORF9GTE9PUik7XG5cbiAgICAvLyBDaGVjayB0aGF0IHRoZSBzZW5kZXIgaGFzIGVub3VnaCBsYW1wb3J0c1xuICAgIGNvbnN0IGxhbXBvcnRzID0gYW1vdW50LnRvTnVtYmVyKCk7XG4gICAgaWYgKGxhbXBvcnRzID4gc2VuZGVySW5mby5sYW1wb3J0cykgdGhyb3cgbmV3IENyZWF0ZVRyYW5zZmVyRXJyb3IoJ2luc3VmZmljaWVudCBmdW5kcycpO1xuXG4gICAgLy8gQ3JlYXRlIGFuIGluc3RydWN0aW9uIHRvIHRyYW5zZmVyIG5hdGl2ZSBTT0xcbiAgICByZXR1cm4gU3lzdGVtUHJvZ3JhbS50cmFuc2Zlcih7XG4gICAgICAgIGZyb21QdWJrZXk6IHNlbmRlcixcbiAgICAgICAgdG9QdWJrZXk6IHJlY2lwaWVudCxcbiAgICAgICAgbGFtcG9ydHMsXG4gICAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNQTFRva2VuSW5zdHJ1Y3Rpb24oXG4gICAgcmVjaXBpZW50OiBQdWJsaWNLZXksXG4gICAgYW1vdW50OiBCaWdOdW1iZXIsXG4gICAgc3BsVG9rZW46IFB1YmxpY0tleSxcbiAgICBzZW5kZXI6IFB1YmxpY0tleSxcbiAgICBjb25uZWN0aW9uOiBDb25uZWN0aW9uXG4pOiBQcm9taXNlPFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24+IHtcbiAgICAvLyBDaGVjayBpZiB0b2tlbiBvd25zIHRoZSBUb2tlbi0yMDIyIFByb2dyYW1cbiAgICBjb25zdCBhY2NvdW50SW5mbyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0UGFyc2VkQWNjb3VudEluZm8oc3BsVG9rZW4pO1xuICAgIGNvbnN0IGFjY291bnRPd25lciA9IGFjY291bnRJbmZvLnZhbHVlPy5vd25lcjtcbiAgICBjb25zdCB0b2tlblByb2dyYW0gPVxuICAgICAgICBhY2NvdW50T3duZXIgJiYgYWNjb3VudE93bmVyID09PSBUT0tFTl8yMDIyX1BST0dSQU1fSUQgPyBUT0tFTl8yMDIyX1BST0dSQU1fSUQgOiBUT0tFTl9QUk9HUkFNX0lEO1xuXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgdG9rZW4gcHJvdmlkZWQgaXMgYW4gaW5pdGlhbGl6ZWQgbWludFxuICAgIGNvbnN0IG1pbnQgPSBhd2FpdCBnZXRNaW50KGNvbm5lY3Rpb24sIHNwbFRva2VuLCB1bmRlZmluZWQsIHRva2VuUHJvZ3JhbSk7XG4gICAgaWYgKCFtaW50LmlzSW5pdGlhbGl6ZWQpIHRocm93IG5ldyBDcmVhdGVUcmFuc2ZlckVycm9yKCdtaW50IG5vdCBpbml0aWFsaXplZCcpO1xuXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgYW1vdW50IHByb3ZpZGVkIGRvZXNuJ3QgaGF2ZSBncmVhdGVyIHByZWNpc2lvbiB0aGFuIHRoZSBtaW50XG4gICAgaWYgKChhbW91bnQuZGVjaW1hbFBsYWNlcygpID8/IDApID4gbWludC5kZWNpbWFscykgdGhyb3cgbmV3IENyZWF0ZVRyYW5zZmVyRXJyb3IoJ2Ftb3VudCBkZWNpbWFscyBpbnZhbGlkJyk7XG5cbiAgICAvLyBDb252ZXJ0IGlucHV0IGRlY2ltYWwgYW1vdW50IHRvIGludGVnZXIgdG9rZW5zIGFjY29yZGluZyB0byB0aGUgbWludCBkZWNpbWFsc1xuICAgIGFtb3VudCA9IGFtb3VudC50aW1lcyhURU4ucG93KG1pbnQuZGVjaW1hbHMpKS5pbnRlZ2VyVmFsdWUoQmlnTnVtYmVyLlJPVU5EX0ZMT09SKTtcblxuICAgIC8vIEdldCB0aGUgc2VuZGVyJ3MgQVRBIGFuZCBjaGVjayB0aGF0IHRoZSBhY2NvdW50IGV4aXN0cyBhbmQgY2FuIHNlbmQgdG9rZW5zXG4gICAgY29uc3Qgc2VuZGVyQVRBID0gYXdhaXQgZ2V0QXNzb2NpYXRlZFRva2VuQWRkcmVzcyhzcGxUb2tlbiwgc2VuZGVyLCB1bmRlZmluZWQsIHRva2VuUHJvZ3JhbSk7XG4gICAgY29uc3Qgc2VuZGVyQWNjb3VudCA9IGF3YWl0IGdldEFjY291bnQoY29ubmVjdGlvbiwgc2VuZGVyQVRBLCB1bmRlZmluZWQsIHRva2VuUHJvZ3JhbSk7XG4gICAgaWYgKCFzZW5kZXJBY2NvdW50LmlzSW5pdGlhbGl6ZWQpIHRocm93IG5ldyBDcmVhdGVUcmFuc2ZlckVycm9yKCdzZW5kZXIgbm90IGluaXRpYWxpemVkJyk7XG4gICAgaWYgKHNlbmRlckFjY291bnQuaXNGcm96ZW4pIHRocm93IG5ldyBDcmVhdGVUcmFuc2ZlckVycm9yKCdzZW5kZXIgZnJvemVuJyk7XG5cbiAgICAvLyBHZXQgdGhlIHJlY2lwaWVudCdzIEFUQSBhbmQgY2hlY2sgdGhhdCB0aGUgYWNjb3VudCBleGlzdHMgYW5kIGNhbiByZWNlaXZlIHRva2Vuc1xuICAgIGNvbnN0IHJlY2lwaWVudEFUQSA9IGF3YWl0IGdldEFzc29jaWF0ZWRUb2tlbkFkZHJlc3Moc3BsVG9rZW4sIHJlY2lwaWVudCwgdW5kZWZpbmVkLCB0b2tlblByb2dyYW0pO1xuICAgIGNvbnN0IHJlY2lwaWVudEFjY291bnQgPSBhd2FpdCBnZXRBY2NvdW50KGNvbm5lY3Rpb24sIHJlY2lwaWVudEFUQSwgdW5kZWZpbmVkLCB0b2tlblByb2dyYW0pO1xuICAgIGlmICghcmVjaXBpZW50QWNjb3VudC5pc0luaXRpYWxpemVkKSB0aHJvdyBuZXcgQ3JlYXRlVHJhbnNmZXJFcnJvcigncmVjaXBpZW50IG5vdCBpbml0aWFsaXplZCcpO1xuICAgIGlmIChyZWNpcGllbnRBY2NvdW50LmlzRnJvemVuKSB0aHJvdyBuZXcgQ3JlYXRlVHJhbnNmZXJFcnJvcigncmVjaXBpZW50IGZyb3plbicpO1xuXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgc2VuZGVyIGhhcyBlbm91Z2ggdG9rZW5zXG4gICAgY29uc3QgdG9rZW5zID0gQmlnSW50KFN0cmluZyhhbW91bnQpKTtcbiAgICBpZiAodG9rZW5zID4gc2VuZGVyQWNjb3VudC5hbW91bnQpIHRocm93IG5ldyBDcmVhdGVUcmFuc2ZlckVycm9yKCdpbnN1ZmZpY2llbnQgZnVuZHMnKTtcblxuICAgIC8vIENyZWF0ZSBhbiBpbnN0cnVjdGlvbiB0byB0cmFuc2ZlciBTUEwgdG9rZW5zLCBhc3NlcnRpbmcgdGhlIG1pbnQgYW5kIGRlY2ltYWxzIG1hdGNoXG4gICAgcmV0dXJuIGNyZWF0ZVRyYW5zZmVyQ2hlY2tlZEluc3RydWN0aW9uKFxuICAgICAgICBzZW5kZXJBVEEsXG4gICAgICAgIHNwbFRva2VuLFxuICAgICAgICByZWNpcGllbnRBVEEsXG4gICAgICAgIHNlbmRlcixcbiAgICAgICAgdG9rZW5zLFxuICAgICAgICBtaW50LmRlY2ltYWxzLFxuICAgICAgICBbXSxcbiAgICAgICAgdG9rZW5Qcm9ncmFtXG4gICAgKTtcbn1cbiIsICJpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgSFRUUFNfUFJPVE9DT0wsIFNPTEFOQV9QUk9UT0NPTCB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB0eXBlIHsgQW1vdW50LCBMYWJlbCwgTGluaywgTWVtbywgTWVzc2FnZSwgUmVjaXBpZW50LCBSZWZlcmVuY2UsIFNQTFRva2VuIH0gZnJvbSAnLi90eXBlcy5qcyc7XG5cbi8qKlxuICogQSBTb2xhbmEgUGF5IHRyYW5zYWN0aW9uIHJlcXVlc3QgVVJMLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zYWN0aW9uUmVxdWVzdFVSTCB7XG4gICAgLyoqIGBsaW5rYCBpbiB0aGUgW1NvbGFuYSBQYXkgc3BlY10oaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS1wYXkvYmxvYi9tYXN0ZXIvU1BFQy5tZCNsaW5rKS4gKi9cbiAgICBsaW5rOiBMaW5rO1xuICAgIC8qKiBgbGFiZWxgIGluIHRoZSBbU29sYW5hIFBheSBzcGVjXShodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hLXBheS9ibG9iL21hc3Rlci9TUEVDLm1kI2xhYmVsLTEpLiAqL1xuICAgIGxhYmVsOiBMYWJlbCB8IHVuZGVmaW5lZDtcbiAgICAvKiogYG1lc3NhZ2VgIGluIHRoZSBbU29sYW5hIFBheSBzcGVjXShodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hLXBheS9ibG9iL21hc3Rlci9TUEVDLm1kI21lc3NhZ2UtMSkuICovXG4gICAgbWVzc2FnZTogTWVzc2FnZSB8IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBIFNvbGFuYSBQYXkgdHJhbnNmZXIgcmVxdWVzdCBVUkwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmZXJSZXF1ZXN0VVJMIHtcbiAgICAvKiogYHJlY2lwaWVudGAgaW4gdGhlIFtTb2xhbmEgUGF5IHNwZWNdKGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEtcGF5L2Jsb2IvbWFzdGVyL1NQRUMubWQjcmVjaXBpZW50KS4gKi9cbiAgICByZWNpcGllbnQ6IFJlY2lwaWVudDtcbiAgICAvKiogYGFtb3VudGAgaW4gdGhlIFtTb2xhbmEgUGF5IHNwZWNdKGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEtcGF5L2Jsb2IvbWFzdGVyL1NQRUMubWQjYW1vdW50KS4gKi9cbiAgICBhbW91bnQ6IEFtb3VudCB8IHVuZGVmaW5lZDtcbiAgICAvKiogYHNwbC10b2tlbmAgaW4gdGhlIFtTb2xhbmEgUGF5IHNwZWNdKGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEtcGF5L2Jsb2IvbWFzdGVyL1NQRUMubWQjc3BsLXRva2VuKS4gKi9cbiAgICBzcGxUb2tlbjogU1BMVG9rZW4gfCB1bmRlZmluZWQ7XG4gICAgLyoqIGByZWZlcmVuY2VgIGluIHRoZSBbU29sYW5hIFBheSBzcGVjXShodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hLXBheS9ibG9iL21hc3Rlci9TUEVDLm1kI3JlZmVyZW5jZSkuICovXG4gICAgcmVmZXJlbmNlOiBSZWZlcmVuY2VbXSB8IHVuZGVmaW5lZDtcbiAgICAvKiogYGxhYmVsYCBpbiB0aGUgW1NvbGFuYSBQYXkgc3BlY10oaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS1wYXkvYmxvYi9tYXN0ZXIvU1BFQy5tZCNsYWJlbCkuICovXG4gICAgbGFiZWw6IExhYmVsIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBgbWVzc2FnZWAgaW4gdGhlIFtTb2xhbmEgUGF5IHNwZWNdKGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEtcGF5L2Jsb2IvbWFzdGVyL1NQRUMubWQjbWVzc2FnZSkuICovXG4gICAgbWVzc2FnZTogTWVzc2FnZSB8IHVuZGVmaW5lZDtcbiAgICAvKiogYG1lbW9gIGluIHRoZSBbU29sYW5hIFBheSBzcGVjXShodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hLXBheS9ibG9iL21hc3Rlci9TUEVDLm1kI21lbW8pLiAqL1xuICAgIG1lbW86IE1lbW8gfCB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSBVUkwgY2FuJ3QgYmUgcGFyc2VkIGFzIGEgU29sYW5hIFBheSBVUkwuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJzZVVSTEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIG5hbWUgPSAnUGFyc2VVUkxFcnJvcic7XG59XG5cbi8qKlxuICogUGFyc2UgYSBTb2xhbmEgUGF5IFVSTC5cbiAqXG4gKiBAcGFyYW0gdXJsIC0gVVJMIHRvIHBhcnNlLlxuICpcbiAqIEB0aHJvd3Mge1BhcnNlVVJMRXJyb3J9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVVSTCh1cmw6IHN0cmluZyB8IFVSTCk6IFRyYW5zYWN0aW9uUmVxdWVzdFVSTCB8IFRyYW5zZmVyUmVxdWVzdFVSTCB7XG4gICAgaWYgKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh1cmwubGVuZ3RoID4gMjA0OCkgdGhyb3cgbmV3IFBhcnNlVVJMRXJyb3IoJ2xlbmd0aCBpbnZhbGlkJyk7XG4gICAgICAgIHVybCA9IG5ldyBVUkwodXJsKTtcbiAgICB9XG5cbiAgICBpZiAodXJsLnByb3RvY29sICE9PSBTT0xBTkFfUFJPVE9DT0wpIHRocm93IG5ldyBQYXJzZVVSTEVycm9yKCdwcm90b2NvbCBpbnZhbGlkJyk7XG4gICAgaWYgKCF1cmwucGF0aG5hbWUpIHRocm93IG5ldyBQYXJzZVVSTEVycm9yKCdwYXRobmFtZSBtaXNzaW5nJyk7XG5cbiAgICByZXR1cm4gL1s6JV0vLnRlc3QodXJsLnBhdGhuYW1lKSA/IHBhcnNlVHJhbnNhY3Rpb25SZXF1ZXN0VVJMKHVybCkgOiBwYXJzZVRyYW5zZmVyUmVxdWVzdFVSTCh1cmwpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRyYW5zYWN0aW9uUmVxdWVzdFVSTCh7IHBhdGhuYW1lLCBzZWFyY2hQYXJhbXMgfTogVVJMKTogVHJhbnNhY3Rpb25SZXF1ZXN0VVJMIHtcbiAgICBjb25zdCBsaW5rID0gbmV3IFVSTChkZWNvZGVVUklDb21wb25lbnQocGF0aG5hbWUpKTtcbiAgICBpZiAobGluay5wcm90b2NvbCAhPT0gSFRUUFNfUFJPVE9DT0wpIHRocm93IG5ldyBQYXJzZVVSTEVycm9yKCdsaW5rIGludmFsaWQnKTtcblxuICAgIGNvbnN0IGxhYmVsID0gc2VhcmNoUGFyYW1zLmdldCgnbGFiZWwnKSB8fCB1bmRlZmluZWQ7XG4gICAgY29uc3QgbWVzc2FnZSA9IHNlYXJjaFBhcmFtcy5nZXQoJ21lc3NhZ2UnKSB8fCB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBsaW5rLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgbWVzc2FnZSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVRyYW5zZmVyUmVxdWVzdFVSTCh7IHBhdGhuYW1lLCBzZWFyY2hQYXJhbXMgfTogVVJMKTogVHJhbnNmZXJSZXF1ZXN0VVJMIHtcbiAgICBsZXQgcmVjaXBpZW50OiBQdWJsaWNLZXk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVjaXBpZW50ID0gbmV3IFB1YmxpY0tleShwYXRobmFtZSk7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VVUkxFcnJvcigncmVjaXBpZW50IGludmFsaWQnKTtcbiAgICB9XG5cbiAgICBsZXQgYW1vdW50OiBCaWdOdW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY29uc3QgYW1vdW50UGFyYW0gPSBzZWFyY2hQYXJhbXMuZ2V0KCdhbW91bnQnKTtcbiAgICBpZiAoYW1vdW50UGFyYW0gIT0gbnVsbCkge1xuICAgICAgICBpZiAoIS9eXFxkKyhcXC5cXGQrKT8kLy50ZXN0KGFtb3VudFBhcmFtKSkgdGhyb3cgbmV3IFBhcnNlVVJMRXJyb3IoJ2Ftb3VudCBpbnZhbGlkJyk7XG5cbiAgICAgICAgYW1vdW50ID0gbmV3IEJpZ051bWJlcihhbW91bnRQYXJhbSk7XG4gICAgICAgIGlmIChhbW91bnQuaXNOYU4oKSkgdGhyb3cgbmV3IFBhcnNlVVJMRXJyb3IoJ2Ftb3VudCBOYU4nKTtcbiAgICAgICAgaWYgKGFtb3VudC5pc05lZ2F0aXZlKCkpIHRocm93IG5ldyBQYXJzZVVSTEVycm9yKCdhbW91bnQgbmVnYXRpdmUnKTtcbiAgICB9XG5cbiAgICBsZXQgc3BsVG9rZW46IFB1YmxpY0tleSB8IHVuZGVmaW5lZDtcbiAgICBjb25zdCBzcGxUb2tlblBhcmFtID0gc2VhcmNoUGFyYW1zLmdldCgnc3BsLXRva2VuJyk7XG4gICAgaWYgKHNwbFRva2VuUGFyYW0gIT0gbnVsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3BsVG9rZW4gPSBuZXcgUHVibGljS2V5KHNwbFRva2VuUGFyYW0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlVVJMRXJyb3IoJ3NwbC10b2tlbiBpbnZhbGlkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcmVmZXJlbmNlOiBQdWJsaWNLZXlbXSB8IHVuZGVmaW5lZDtcbiAgICBjb25zdCByZWZlcmVuY2VQYXJhbXMgPSBzZWFyY2hQYXJhbXMuZ2V0QWxsKCdyZWZlcmVuY2UnKTtcbiAgICBpZiAocmVmZXJlbmNlUGFyYW1zLmxlbmd0aCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVmZXJlbmNlID0gcmVmZXJlbmNlUGFyYW1zLm1hcCgocmVmZXJlbmNlKSA9PiBuZXcgUHVibGljS2V5KHJlZmVyZW5jZSkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlVVJMRXJyb3IoJ3JlZmVyZW5jZSBpbnZhbGlkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbCA9IHNlYXJjaFBhcmFtcy5nZXQoJ2xhYmVsJykgfHwgdW5kZWZpbmVkO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBzZWFyY2hQYXJhbXMuZ2V0KCdtZXNzYWdlJykgfHwgdW5kZWZpbmVkO1xuICAgIGNvbnN0IG1lbW8gPSBzZWFyY2hQYXJhbXMuZ2V0KCdtZW1vJykgfHwgdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVjaXBpZW50LFxuICAgICAgICBhbW91bnQsXG4gICAgICAgIHNwbFRva2VuLFxuICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgIGxhYmVsLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBtZW1vLFxuICAgIH07XG59XG4iLCAiLyoqXG4gKiBTb2xhbmEgUGF5IEludGVncmF0aW9uIC0gVmFuaWxsYSBKYXZhU2NyaXB0XG4gKlxuICogVGhpcyBtb2R1bGUgaGFuZGxlcyBTb2xhbmEgd2FsbGV0IGNvbm5lY3Rpb25zIGFuZCBTUEwgdG9rZW4gcGF5bWVudHNcbiAqIGZvciB0aGUgQ3J5cHRvVGF4IHdhbGxldCBhbmFseXNpcyBzZXJ2aWNlLlxuICovXG5cbmltcG9ydCB7IENvbm5lY3Rpb24sIFB1YmxpY0tleSwgVHJhbnNhY3Rpb24gfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuaW1wb3J0IHsgcGFyc2VVUkwsIGNyZWF0ZVRyYW5zZmVyIH0gZnJvbSAnQHNvbGFuYS9wYXknO1xuLy8gUG9seWZpbGwgQnVmZmVyIGZvciBicm93c2VyIHVzYWdlIChyZXF1aXJlZCBieSB3ZWIzLmpzIGRlcHMpXG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICF3aW5kb3cuQnVmZmVyKSB7XG4gICAgd2luZG93LkJ1ZmZlciA9IEJ1ZmZlcjtcbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCAtIHdpbGwgYmUgc2V0IGJ5IERqYW5nbyB0ZW1wbGF0ZVxuICovXG5sZXQgQ09ORklHID0gbnVsbDtcblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBwYXltZW50IHN5c3RlbSB3aXRoIGNvbmZpZ3VyYXRpb24gZnJvbSBEamFuZ29cbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZVBheW1lbnQoY29uZmlnKSB7XG4gICAgQ09ORklHID0gY29uZmlnO1xuICAgIGNvbnNvbGUubG9nKCdTb2xhbmEgUGF5IGluaXRpYWxpemVkIHdpdGggY29uZmlnOicsIENPTkZJRyk7XG59XG5cbi8qKlxuICogRGV0ZWN0IGF2YWlsYWJsZSBTb2xhbmEgd2FsbGV0IHByb3ZpZGVyXG4gKi9cbmZ1bmN0aW9uIGdldFdhbGxldFByb3ZpZGVyKCkge1xuICAgIC8vIENoZWNrIGZvciBQaGFudG9tXG4gICAgaWYgKHdpbmRvdy5waGFudG9tPy5zb2xhbmE/LmlzUGhhbnRvbSkge1xuICAgICAgICByZXR1cm4gd2luZG93LnBoYW50b20uc29sYW5hO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBTb2xmbGFyZVxuICAgIGlmICh3aW5kb3cuc29sZmxhcmU/LmlzU29sZmxhcmUpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zb2xmbGFyZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgQmFja3BhY2tcbiAgICBpZiAod2luZG93LmJhY2twYWNrPy5pc0JhY2twYWNrKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuYmFja3BhY2s7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgdG8gZ2VuZXJpYyB3aW5kb3cuc29sYW5hXG4gICAgaWYgKHdpbmRvdy5zb2xhbmEpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zb2xhbmE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgd2FsbGV0IGlzIGluc3RhbGxlZFxuICovXG5mdW5jdGlvbiBpc1dhbGxldEluc3RhbGxlZCgpIHtcbiAgICByZXR1cm4gZ2V0V2FsbGV0UHJvdmlkZXIoKSAhPT0gbnVsbDtcbn1cblxuLyoqXG4gKiBDb25uZWN0IHRvIHRoZSB1c2VyJ3MgU29sYW5hIHdhbGxldFxuICovXG5hc3luYyBmdW5jdGlvbiBjb25uZWN0V2FsbGV0KCkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0V2FsbGV0UHJvdmlkZXIoKTtcblxuICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBTb2xhbmEgd2FsbGV0IGZvdW5kLiBQbGVhc2UgaW5zdGFsbCBQaGFudG9tLCBTb2xmbGFyZSwgb3IgQmFja3BhY2suJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwcm92aWRlci5jb25uZWN0KCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5wdWJsaWNLZXk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IDQwMDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2FsbGV0IGNvbm5lY3Rpb24gcmVqZWN0ZWQgYnkgdXNlcicpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUcnkgdG8gY29ubmVjdCB0byB3YWxsZXQgc2lsZW50bHkgKGlmIHByZXZpb3VzbHkgYXV0aG9yaXplZClcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY29ubmVjdFdhbGxldFNpbGVudGx5KCkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0V2FsbGV0UHJvdmlkZXIoKTtcblxuICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwcm92aWRlci5jb25uZWN0KHsgb25seUlmVHJ1c3RlZDogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnB1YmxpY0tleTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBTaWxlbnQgZmFpbHVyZSAtIHdhbGxldCBub3QgcHJldmlvdXNseSBhdXRob3JpemVkXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYW5kIHNlbmQgcGF5bWVudCB0cmFuc2FjdGlvblxuICovXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVBbmRTZW5kUGF5bWVudChwYXltZW50VXJsLCBycGNVcmwgPSAnaHR0cHM6Ly9hcGkubWFpbm5ldC1iZXRhLnNvbGFuYS5jb20nKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBnZXRXYWxsZXRQcm92aWRlcigpO1xuXG4gICAgaWYgKCFwcm92aWRlciB8fCAhcHJvdmlkZXIucHVibGljS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBjb25uZWN0ZWQnKTtcbiAgICB9XG5cbiAgICAvLyBQYXJzZSBTb2xhbmEgUGF5IFVSTFxuICAgIGNvbnN0IHsgcmVjaXBpZW50LCBhbW91bnQsIHNwbFRva2VuLCByZWZlcmVuY2UsIG1lbW8gfSA9IHBhcnNlVVJMKHBheW1lbnRVcmwpO1xuXG4gICAgY29uc29sZS5sb2coJ1BheW1lbnQgZGV0YWlsczonLCB7XG4gICAgICAgIHJlY2lwaWVudDogcmVjaXBpZW50LnRvU3RyaW5nKCksXG4gICAgICAgIGFtb3VudDogYW1vdW50LnRvU3RyaW5nKCksXG4gICAgICAgIHNwbFRva2VuOiBzcGxUb2tlbj8udG9TdHJpbmcoKSxcbiAgICAgICAgcmVmZXJlbmNlOiByZWZlcmVuY2U/Lm1hcChyID0+IHIudG9TdHJpbmcoKSksXG4gICAgICAgIG1lbW9cbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSBjb25uZWN0aW9uXG4gICAgY29uc3QgY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKHJwY1VybCwgJ2NvbmZpcm1lZCcpO1xuXG4gICAgLy8gQ3JlYXRlIHRyYW5zZmVyIHRyYW5zYWN0aW9uXG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCBjcmVhdGVUcmFuc2Zlcihjb25uZWN0aW9uLCBwcm92aWRlci5wdWJsaWNLZXksIHtcbiAgICAgICAgcmVjaXBpZW50LFxuICAgICAgICBhbW91bnQsXG4gICAgICAgIHNwbFRva2VuLFxuICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgIG1lbW9cbiAgICB9KTtcblxuICAgIC8vIEdldCByZWNlbnQgYmxvY2toYXNoXG4gICAgY29uc3QgeyBibG9ja2hhc2gsIGxhc3RWYWxpZEJsb2NrSGVpZ2h0IH0gPSBhd2FpdCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgnY29uZmlybWVkJyk7XG4gICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoO1xuICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyID0gcHJvdmlkZXIucHVibGljS2V5O1xuXG4gICAgY29uc29sZS5sb2coJ1RyYW5zYWN0aW9uIGNyZWF0ZWQsIHJlcXVlc3Rpbmcgc2lnbmF0dXJlLi4uJyk7XG5cbiAgICAvLyBTaWduIGFuZCBzZW5kIHRyYW5zYWN0aW9uXG4gICAgY29uc3QgeyBzaWduYXR1cmUgfSA9IGF3YWl0IHByb3ZpZGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuXG4gICAgY29uc29sZS5sb2coJ1RyYW5zYWN0aW9uIHNlbnQ6Jywgc2lnbmF0dXJlKTtcblxuICAgIC8vIENvbmZpcm0gdHJhbnNhY3Rpb25cbiAgICBjb25zdCBjb25maXJtYXRpb24gPSBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgYmxvY2toYXNoLFxuICAgICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodFxuICAgIH0sICdjb25maXJtZWQnKTtcblxuICAgIGlmIChjb25maXJtYXRpb24udmFsdWUuZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gZmFpbGVkOiAnICsgSlNPTi5zdHJpbmdpZnkoY29uZmlybWF0aW9uLnZhbHVlLmVycikpO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdUcmFuc2FjdGlvbiBjb25maXJtZWQ6Jywgc2lnbmF0dXJlKTtcblxuICAgIHJldHVybiBzaWduYXR1cmU7XG59XG5cbi8qKlxuICogVmVyaWZ5IHBheW1lbnQgd2l0aCBiYWNrZW5kXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeVBheW1lbnRXaXRoQmFja2VuZChvcmRlcklkLCBzaWduYXR1cmUpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3BheW1lbnQtdmVyaWZ5LycsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnWC1DU1JGVG9rZW4nOiBnZXRDc3JmVG9rZW4oKVxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBvcmRlcl9pZDogb3JkZXJJZCxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlXG4gICAgICAgIH0pXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgaWYgKCFkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEubWVzc2FnZSB8fCAnUGF5bWVudCB2ZXJpZmljYXRpb24gZmFpbGVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogR2V0IENTUkYgdG9rZW4gZnJvbSBjb29raWVcbiAqL1xuZnVuY3Rpb24gZ2V0Q3NyZlRva2VuKCkge1xuICAgIGNvbnN0IG5hbWUgPSAnY3NyZnRva2VuJztcbiAgICBjb25zdCBjb29raWVzID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jyk7XG5cbiAgICBmb3IgKGxldCBjb29raWUgb2YgY29va2llcykge1xuICAgICAgICBjb29raWUgPSBjb29raWUudHJpbSgpO1xuICAgICAgICBpZiAoY29va2llLnN0YXJ0c1dpdGgobmFtZSArICc9JykpIHtcbiAgICAgICAgICAgIHJldHVybiBjb29raWUuc3Vic3RyaW5nKG5hbWUubGVuZ3RoICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogTWFpbiBwYXltZW50IGZsb3dcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1BheW1lbnQoY29uZmlnLCBjYWxsYmFja3MgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgICAgb25TdGF0dXNDaGFuZ2UgPSAoKSA9PiB7fSxcbiAgICAgICAgb25TdWNjZXNzID0gKCkgPT4ge30sXG4gICAgICAgIG9uRXJyb3IgPSAoKSA9PiB7fVxuICAgIH0gPSBjYWxsYmFja3M7XG5cbiAgICB0cnkge1xuICAgICAgICAvLyBDb25uZWN0IHdhbGxldFxuICAgICAgICBvblN0YXR1c0NoYW5nZSgnQ29ubmVjdGluZyB0byB3YWxsZXQuLi4nLCAnaW5mbycpO1xuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBhd2FpdCBjb25uZWN0V2FsbGV0KCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0ZWQgdG8gd2FsbGV0OicsIHB1YmxpY0tleS50b1N0cmluZygpKTtcblxuICAgICAgICAvLyBDcmVhdGUgYW5kIHNlbmQgcGF5bWVudFxuICAgICAgICBvblN0YXR1c0NoYW5nZSgnQ3JlYXRpbmcgcGF5bWVudCB0cmFuc2FjdGlvbi4uLicsICdpbmZvJyk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGNyZWF0ZUFuZFNlbmRQYXltZW50KFxuICAgICAgICAgICAgY29uZmlnLnBheW1lbnRVcmwsXG4gICAgICAgICAgICBjb25maWcucnBjVXJsIHx8ICdodHRwczovL2FwaS5tYWlubmV0LWJldGEuc29sYW5hLmNvbSdcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBWZXJpZnkgd2l0aCBiYWNrZW5kXG4gICAgICAgIG9uU3RhdHVzQ2hhbmdlKCdWZXJpZnlpbmcgcGF5bWVudC4uLicsICdpbmZvJyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZlcmlmeVBheW1lbnRXaXRoQmFja2VuZChjb25maWcub3JkZXJJZCwgc2lnbmF0dXJlKTtcblxuICAgICAgICBvblN0YXR1c0NoYW5nZShyZXN1bHQubWVzc2FnZSB8fCAnUGF5bWVudCBjb25maXJtZWQhJywgJ3N1Y2Nlc3MnKTtcbiAgICAgICAgb25TdWNjZXNzKHJlc3VsdCwgc2lnbmF0dXJlKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BheW1lbnQgZXJyb3I6JywgZXJyb3IpO1xuXG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlIHx8ICdQYXltZW50IGZhaWxlZCc7XG5cbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdyZWplY3RlZCcpKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnVHJhbnNhY3Rpb24gcmVqZWN0ZWQgYnkgdXNlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ2luc3VmZmljaWVudCcpKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnSW5zdWZmaWNpZW50IGZ1bmRzIGluIHdhbGxldCc7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ05vIFNvbGFuYSB3YWxsZXQnKSkge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gJ05vIFNvbGFuYSB3YWxsZXQgZGV0ZWN0ZWQuIFBsZWFzZSBpbnN0YWxsIFBoYW50b20sIFNvbGZsYXJlLCBvciBCYWNrcGFjay4nO1xuICAgICAgICB9XG5cbiAgICAgICAgb25TdGF0dXNDaGFuZ2UoZXJyb3JNZXNzYWdlLCAnZXJyb3InKTtcbiAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgfVxufVxuXG4vLyBFeHBvc2UgZnVuY3Rpb25zIHRvIGdsb2JhbCBzY29wZSBmb3IgRGphbmdvIHRlbXBsYXRlc1xud2luZG93LlNvbGFuYVBheW1lbnQgPSB7XG4gICAgaW5pdGlhbGl6ZTogaW5pdGlhbGl6ZVBheW1lbnQsXG4gICAgaXNXYWxsZXRJbnN0YWxsZWQsXG4gICAgY29ubmVjdFdhbGxldCxcbiAgICBjb25uZWN0V2FsbGV0U2lsZW50bHksXG4gICAgcHJvY2Vzc1BheW1lbnQsXG4gICAgdmVyaWZ5UGF5bWVudFdpdGhCYWNrZW5kXG59O1xuXG5jb25zb2xlLmxvZygnU29sYW5hIFBheW1lbnQgbW9kdWxlIGxvYWRlZCcpO1xuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFFQSxjQUFRLGFBQWE7QUFDckIsY0FBUSxjQUFjO0FBQ3RCLGNBQVEsZ0JBQWdCO0FBRXhCLFVBQUksU0FBUyxDQUFDO0FBQ2QsVUFBSSxZQUFZLENBQUM7QUFDakIsVUFBSSxNQUFNLE9BQU8sZUFBZSxjQUFjLGFBQWE7QUFFM0QsVUFBSSxPQUFPO0FBQ1gsV0FBUyxJQUFJLEdBQUcsTUFBTSxLQUFLLFFBQVEsSUFBSSxLQUFLLEVBQUUsR0FBRztBQUMvQyxlQUFPLENBQUMsSUFBSSxLQUFLLENBQUM7QUFDbEIsa0JBQVUsS0FBSyxXQUFXLENBQUMsQ0FBQyxJQUFJO0FBQUEsTUFDbEM7QUFIUztBQUFPO0FBT2hCLGdCQUFVLElBQUksV0FBVyxDQUFDLENBQUMsSUFBSTtBQUMvQixnQkFBVSxJQUFJLFdBQVcsQ0FBQyxDQUFDLElBQUk7QUFFL0IsZUFBUyxRQUFTLEtBQUs7QUFDckIsWUFBSUEsT0FBTSxJQUFJO0FBRWQsWUFBSUEsT0FBTSxJQUFJLEdBQUc7QUFDZixnQkFBTSxJQUFJLE1BQU0sZ0RBQWdEO0FBQUEsUUFDbEU7QUFJQSxZQUFJLFdBQVcsSUFBSSxRQUFRLEdBQUc7QUFDOUIsWUFBSSxhQUFhLEdBQUksWUFBV0E7QUFFaEMsWUFBSSxrQkFBa0IsYUFBYUEsT0FDL0IsSUFDQSxJQUFLLFdBQVc7QUFFcEIsZUFBTyxDQUFDLFVBQVUsZUFBZTtBQUFBLE1BQ25DO0FBR0EsZUFBUyxXQUFZLEtBQUs7QUFDeEIsWUFBSSxPQUFPLFFBQVEsR0FBRztBQUN0QixZQUFJLFdBQVcsS0FBSyxD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QixjQUFJLEtBQUssRUFBRSxDQUFDLElBQUk7QUFDaEIsY0FBSSxNQUFNLEtBQUs7QUFDZixjQUFJLE1BQU0sT0FBTztBQUNqQixjQUFJLEtBQUssRUFBRSxDQUFDLElBQUk7QUFDaEIsY0FBSSxNQUFNLEtBQUs7QUFDZixjQUFJLE1BQU0sT0FBTztBQUNqQixjQUFJLEtBQUssRUFBRSxDQUFDLElBQUk7QUFDaEIsY0FBSSxNQUFNLEtBQUs7QUFDZixjQUFJLE1BQU0sT0FBTztBQUNqQixjQUFJLEtBQUssRUFBRSxDQUFDLElBQUk7QUFDaEIsY0FBSSxNQUFNLEtBQUs7QUFDZixjQUFJLE1BQU0sT0FBTztBQUNqQixjQUFJLEtBQUssRUFBRSxDQUFDLElBQUk7QUFDaEIsY0FBSSxNQUFNLEtBQUs7QUFDZixjQUFJLE1BQU0sT0FBTztBQUNqQixjQUFJLEtBQUssRUFBRSxDQUFDLElBQUk7QUFDaEIsY0FBSSxNQUFNLEtBQUs7QUFDZixjQUFJLE1BQU0sT0FBTztBQUNqQixjQUFJLEtBQUssRUFBRSxDQUFDLElBQUk7QUFDaEIsY0FBSSxNQUFNLEtBQUs7QUFDZixjQUFJLE1BQU0sT0FBTztBQUNqQixjQUFJLEtBQUssRUFBRSxDQUFDLElBQUk7QUFDaEIsY0FBSSxNQUFNLEtBQUs7QUFDZixjQUFJLE1BQU0sT0FBTztBQUNqQixjQUFJLEtBQUssRUFBRSxDQUFDLElBQUk7QUFDaEIsY0FBSSxNQUFNLEtBQUs7QUFDZixjQUFJLE1BQU0sT0FBTztBQUNqQixjQUFJLEtBQUssRUFBRSxDQUFDLElBQUk7QUFDaEIsY0FBSSxNQUFNLEtBQUs7QUFDZixjQUFJLE1BQU0sT0FBTztBQUNqQixjQUFJLEtBQUssRUFBRSxDQUFDLElBQUk7QUFDaEIsY0FBSSxNQUFNLEtBQUs7QUFDZixjQUFJLE1BQU0sT0FBTztBQUNqQixjQUFJLEtBQUssRUFBRSxDQUFDLElBQUk7QUFDaEIsY0FBSSxNQUFNLEtBQUs7QUFDZixjQUFJLE1BQU0sT0FBTztBQUNqQixjQUFJLEtBQUssRUFBRSxDQUFDLElBQUk7QUFDaEIsY0FB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LEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxnQkFBTyxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNwQyxnQkFBTyxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNwQyxlQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxlQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxnQkFBTyxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNwQyxnQkFBTyxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNwQyxlQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGNBQUksTUFBUSxJQUFJLEtBQU0sT0FBTyxNQUFNLFNBQVcsTUFBTztBQUNyRCxlQUFPLE1BQU0sUUFBUSxNQUFPLE1BQU0sT0FBTyxNQUFPO0FBQ2hELGdCQUFNO0FBRU4sZUFBSyxLQUFLLEtBQUssS0FBSyxHQUFHO0FBQ3ZCLGdCQUFNLEtBQUssS0FBSyxLQUFLLEdBQUc7QUFDeEIsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZUFBSyxLQUFLLEtBQUssS0FBSyxHQUFHO0FBQ3ZCLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxlQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxnQkFBTyxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNwQyxnQkFBTyxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNwQyxlQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxlQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxnQkFBTyxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNwQyxnQkFBTyxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNwQyxlQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxjQUFJLE1BQVEsSUFBSSxLQUFNLE9BQU8sTUFBTSxTQUFXLE1BQU87QUFDckQsZUFBTyxNQUFNLFFBQVEsTUFBTyxNQUFNLE9BQU8sTUFBTztBQUNoRCxnQkFBTTtBQUVOLGVBQUssS0FBSyxLQUFLLEtBQUssR0FBRztBQUN2QixnQkFBTSxLQUFLLEtBQUssS0FBSyxHQUFHO0FBQ3hCLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGVBQUssS0FBSyxLQUFLLEtBQUssR0FBRztBQUN2QixlQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxnQkFBTyxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNwQyxnQkFBTyxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNwQyxlQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxlQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxnQkFBTyxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNwQyxnQkFBTyxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNwQyxlQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxlQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxnQkFBTyxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNwQyxnQkFBTyxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNwQyxlQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGNBQUksTUFBUSxJQUFJLEtBQU0sT0FBTyxNQUFNLFNBQVcsTUFBTztBQUNyRCxlQUFPLE1BQU0sUUFBUSxNQUFPLE1BQU0sT0FBTyxNQUFPO0FBQ2hELGdCQUFNO0FBRU4sZUFBSyxLQUFLLEtBQUssS0FBSyxHQUFHO0FBQ3ZCLGdCQUFNLEtBQUssS0FBSyxLQUFLLEdBQUc7QUFDeEIsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZUFBSyxLQUFLLEtBQUssS0FBSyxHQUFHO0FBQ3ZCLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxlQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxnQkFBTyxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNwQyxnQkFBTyxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNwQyxlQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxlQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxnQkFBTyxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNwQyxnQkFBTyxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNwQyxlQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxlQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxnQkFBTyxNQUFNLEtB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cEMsZUFBSyxLQUFLLEtBQUssS0FBSyxHQUFHO0FBQ3ZCLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxlQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxnQkFBTyxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNwQyxnQkFBTyxNQUFNLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNwQyxlQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZ0JBQU8sTUFBTSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDcEMsZUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUcsSUFBSztBQUNsQyxlQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ2xDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGdCQUFPLE1BQU0sS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFLO0FBQ3BDLGVBQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUs7QUFDbEMsY0FBSSxPQUFTLElBQUksS0FBTSxPQUFPLE1BQU0sU0FBVyxN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QUk7QUFDckMsVUFBSSxPQUFPO0FBQ1gsVUFBSSxPQUFPO0FBQ1gsVUFBSSxPQUFPO0FBQ1gsVUFBSSxPQUFPO0FBQ1gsVUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDLEdBQUcsR0FBRyxVQUFVO0FBQ3pDLFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsSUFBSSxVQUFVO0FBQzlDLFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsSUFBSSxTQUFTO0FBQzdDLFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsSUFBSSxXQUFXO0FBQy9DLFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsR0FBRyxVQUFVO0FBQzdDLFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsSUFBSSxVQUFVO0FBQzlDLFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsSUFBSSxXQUFXO0FBQy9DLFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsSUFBSSxTQUFTO0FBQzdDLFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsR0FBRyxVQUFVO0FBQzdDLFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsSUFBSSxXQUFXO0FBQy9DLFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsSUFBSSxNQUFNO0FBQzNDLFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsSUFBSSxXQUFXO0FBQ2hELFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsR0FBRyxVQUFVO0FBQzlDLFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsSUFBSSxTQUFTO0FBQzlDLFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsSUFBSSxXQUFXO0FBQ2hELFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsSUFBSSxVQUFVO0FBQy9DLFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsR0FBRyxVQUFVO0FBQzdDLFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsR0FBRyxXQUFXO0FBQzlDLFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsSUFBSSxTQUFTO0FBQzlDLFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQyxHQUFHLElBQUksVUFBVTtBQUMxQyxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLEdBQUcsVUFBVTtBQUM3QyxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHLEdBQUcsUUFBUTtBQUM1QyxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHLElBQUksVUFBVTtBQUMvQyxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLElBQUksVUFBVTtBQUM5QyxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLEdBQUcsU0FBUztBQUM1QyxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHLEdBQUcsV0FBVztBQUMvQyxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLElBQUksVUFBVTtBQUM5QyxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLElBQUksVUFBVTtBQUM5QyxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHLEdBQUcsV0FBVztBQUMvQyxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLEdBQUcsU0FBUztBQUM1QyxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLElBQUksVUFBVTtBQUM5QyxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHLElBQUksV0FBVztBQUNoRCxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLEdBQUcsT0FBTztBQUMxQyxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLElBQUksV0FBVztBQUMvQyxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHLElBQUksVUFBVTtBQUMvQyxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHLElBQUksU0FBUztBQUM5QyxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLEdBQUcsV0FBVztBQUM5QyxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLElBQUksVUFBVTtBQUM5QyxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLElBQUksVUFBVTtBQUM5QyxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHLElBQUksV0FBVztBQUNoRCxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHLEdBQUcsU0FBUztBQUM3QyxVQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUMsR0FBRyxJQUFJLFVBQVU7QUFDMUMsVUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxJQUFJLFVBQVU7QUFDOUMsVUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxJQUFJLFFBQVE7QUFDNUMsVUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxHQUFHLFVBQVU7QUFDN0MsVUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsR0FBRyxJQUFJLFVBQVU7QUFDL0MsVUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsR0FBRyxJQUFJLFNBQVM7QUFDOUMsVUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxJQUFJLFVBQVU7QUFDOUMsVUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDLEdBQUcsR0FBRyxVQUFVO0FBQ3pDLFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsSUFBSSxVQUFVO0FBQzlDLFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsSUFBSSxXQUFXO0FBQ2hELFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsSUFBSSxTQUFTO0FBQzdDLFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsR0FBRyxVQUFVO0FBQzlDLFVBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsSUFB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QUFHLElBQUksR0FBRyxHQUFFLElBQVMsSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLE9BQUMsRUFBRSxHQUFHLElBQUksR0FBRyxHQUFFLElBQVMsSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLE9BQUMsRUFBRSxHQUFHLElBQUksR0FBRyxHQUFFLElBQVMsSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLE9BQUMsRUFBRSxHQUFHLElBQUksR0FBRyxHQUFFLElBQVMsSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLE9BQUMsRUFBRSxHQUFHLElBQUksR0FBRyxHQUFFLElBQVMsSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLE9BQUMsRUFBRSxHQUFHLElBQUksR0FBRyxHQUFFLElBQVMsSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLE9BQUMsRUFBRSxHQUFHLElBQUksR0FBRyxHQUFFLElBQVMsSUFBSSxLQUFLLEtBQUssR0FBRyxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3BFLFdBQUssSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxFQUFFO0lBQ3pFO0lBQ1UsYUFBVTtBQUNsQixZQUFNLFlBQVksVUFBVTtJQUM5QjtJQUNBLFVBQU87QUFDTCxZQUFNLEtBQUssTUFBTTtBQUNqQixXQUFLLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcs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TUFBTSxzREFBc0Q7QUFDNUQsTUFBTSw0REFBNEQ7QUFDbEUsTUFBTSx3REFBd0Q7QUFDOUQsTUFBTSx3REFBd0Q7QUFDOUQsTUFBTSwrREFBK0Q7QUFDckUsTUFBTSxvREFBb0Q7QUFDMUQsTUFBTSxxREFBcUQ7QUFJM0QsTUFBTSw0Q0FBNEM7QUFDbEQsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTSxtREFBbUQ7QUFDekQsTUFBTSxtREFBbUQ7QUFDekQsTUFBTSw4REFBOEQ7QUFJcEUsTUFBTSw4REFBOEQ7QUFDcEUsTUFBTSxvREFBb0Q7QUFDMUQsTUFBTSwrREFBK0Q7QUFDckUsTUFBTSw2REFBNkQ7QUFDbkUsTUFBTSwrREFBK0Q7QUFDckUsTUFBTSwyREFBMkQ7QUFDakUsTUFBTSw2REFBNkQ7QUFDbkUsTUFBTSxpRUFBaUU7QUFJdkUsTUFBTSw2REFBNkQ7QUFJbkUsTUFBTSxtREFBbUQ7QUFDekQsTUFBTSxzREFBc0Q7QUFDNUQsTUFBTSxvREFBb0Q7QUFDMUQsTUFBTSwyREFBMkQ7QUFDakUsTUFBTSx3REFBd0Q7QUFJOUQsTUFBTSx1REFBdUQ7QUFDN0QsTUFBTSxtREFBbUQ7QUFDekQsTUFBTSxpREFBaUQ7QUFLdkQsTUFBTSwyQ0FBMkM7QUFDakQsTUFBTSxpREFBaUQ7QUFDdkQsTUFBTSxvREFBb0Q7QUFDMUQsTUFBTSw0REFBNEQ7QUFDbEUsTUFBTSx3REFBd0Q7QUFDOUQsTUFBTSwwREFBMEQ7QUFDaEUsTUFBTSxzREFBc0Q7QUFDNUQsTUFBTSx3REFBd0Q7QUFDOUQsTUFBTSw4REFBOEQ7QUFDcEUsTUFBTSwrREFBK0Q7QUFDckUsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTSwwREFBMEQ7QUFDaEUsTUFBTSx1REFBdUQ7QUFDN0QsTUFBTSxrRUFBa0U7QUFDeEUsTUFBTSxrRUFBa0U7QUFDeEUsTUFBTSwyREFBMkQ7QUFDakUsTUFBTSwwREFBMEQ7QUFDaEUsTUFBTSwyREFBMkQ7QUFDakUsTUFBTSx1REFBdUQ7QUFDN0QsTUFBTSx1REFBdUQ7QUFDN0QsTUFBTSwyREFBMkQ7QUFDakUsTUFBTSw2REFBNkQ7QUFDbkUsTUFBTSwwREFBMEQ7QUFDaEUsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTSw4REFBOEQ7QUFDcEUsTUFBTSxpRUFBaUU7QUFDdkUsTUFBTSwwQ0FBMEM7QUFDaEQsTUFBTSxpREFBaUQ7QUFDdkQsTUFBTSw0REFBNEQ7QUFDbEUsTUFBTSw2REFBNkQ7QUFDbkUsTUFBTSxzRUFBc0U7QUFDNUUsTUFBTSwwREFBMEQ7QUFDaEUsTUFBTSw4Q0FBOEM7QUFDcEQsTUFBTSxtREFBbUQ7QUFDekQsTUFBTSwwREFBMEQ7QUFDaEUsTUFBTSw0REFBNEQ7QUFDbEUsTUFBTSxpREFBaUQ7QUFDdkQsTUFBTSxtREFBbUQ7QUFDekQsTUFBTSxpRUFBaUU7QUFDdkUsTUFBTSx3REFBd0Q7QUFDOUQsTUFBTSxxRUFBcUU7QUFDM0UsTUFBTSw4REFBOEQ7QUFDcEUsTUFBTSw2REFBNkQ7QUFDbkUsTUFBTSw2Q0FBNkM7QUFDbkQsTUFBTSx1REFBdUQ7QUFDN0QsTUFBTSxrREFBa0Q7QUFDeEQsTUFBTSwyREFBMkQ7QUFDakUsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTSx1REFBdUQ7QUFDN0QsTUFBTSxzREFBc0Q7QUFDNUQsTUFBTSxpREFBaUQ7QUFDdkQsTUFBTSwwRUFBMEU7QUFDaEYsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTSx5RUFBeUU7QUFDL0UsTUFBTSwrRUFBK0U7QUFJckYsTUFBTSw2REFBNkQ7QUFDbkUsTUFBTSxpREFBaUQ7QUFDdkQsTUFBTSxnREFBZ0Q7QUFDdEQsTUFBTSwwREFBMEQ7QUFDaEUsTUFBTSx3REFBd0Q7QUFDOUQsTUFBTSxvREFBb0Q7QUFDMUQsTUFBTSw4REFBOEQ7QUFDcEUsTUFBTSw0REFBNEQ7QUFDbEUsTUFBTSw0REFBNEQ7QUFDbEUsTUFBTSx5RUFBeUU7QUFDL0UsTUFBTSwyREFBMkQ7QUFDakUsTUFBTSx1REFBdUQ7QUFJN0QsTUFBTSw4REFBOEQ7QUFDcEUsTUFBTSxtRUFBbUU7QUFDekUsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTSxxREFBcUQ7QUFDM0QsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTSx1RkFBdUY7QUFDN0YsTUFBTSx5RkFBeUY7QUFDL0YsTUFBTSx1RkFBdUY7QUFDN0YsTUFBTSxtRUFBbUU7QUFDekUsTUFBTSxnREFBZ0Q7QUFDdEQsTUFBTSw2Q0FBNkM7QUFDbkQsTUFBTSwrQ0FBK0M7QUFDckQsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTSw0RUFBNEU7QUFDbEYsTUFBTSwrRkFBK0Y7QUFDckcsTUFBTSwrREFBK0Q7QUFDckUsTUFBTSxpRUFBaUU7QUFDdkUsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTSw4REFBOEQ7QUFDcEUsTUFBTSw4RUFBOEU7QUFDcEYsTUFBTSxnREFBZ0Q7QUFLdEQsTUFBTSwyQ0FBMkM7QUFDakQsTUFBTSxrREFBa0Q7QUFDeEQsTUFBTSx3REFBd0Q7QUFDOUQsTUFBTSxxREFBcUQ7QUFDM0QsTUFBTSw2REFBNkQ7QUFDbkUsTUFBTSw4REFBOEQ7QUFDcEUsTUFBTSwyREFBMkQ7QUFDakUsTUFBTSxxREFBcUQ7QUFDM0QsTUFBTSx1REFBdUQ7QUFFN0QsTUFBTSx1REFBdUQ7QUFDN0QsTUFBTSw2REFBNkQ7QUFDbkUsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTSxxREFBcUQ7QUFDM0QsTUFBTSxpRUFBaUU7QUFDdkUsTUFBTSxvREFBb0Q7QUFDMUQsTUFBTSx1REFBdUQ7QUFDN0QsTUFBTSw4REFBOEQ7QUFDcEUsTUFBTSxxRUFBcUU7QUFDM0UsTUFBTSx1REFBdUQ7QUFDN0QsTUFBTSw0REFBNEQ7QUFDbEUsTUFBTSx1RUFBdUU7QUFDN0UsTUFBTSx5RUFBeUU7QUFDL0UsTUFBTSwwREFBMEQ7QUFDaEUsTUFBTSxrRUFBa0U7QUFDeEUsTUFBTSxzRUFBc0U7QUFDNUUsTUFBTSxxRUFBcUU7QUFDM0UsTUFBTSxzRUFBc0U7QUFDNUUsTUFBTSwrREFBK0Q7QUFDckUsTUFBTSxvRUFBb0U7QUFDMUUsTUFBTSx5RUFBeUU7QUFDL0UsTUFBTSx5REFBeUQ7QUFDL0QsTUFBTSwrREFBK0Q7QUFDckUsTUFBTSwwRUFBMEU7QUFDaEYs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LElBQUE7QUFDQSxJQUFBQSxrQkFBQUEsa0JBQUEsZUFBQSxJQUFBLEVBQUEsSUFBQTtBQUNBLElBQUFBLGtCQUFBQSxrQkFBQSxhQUFBLElBQUEsRUFBQSxJQUFBO0FBQ0EsSUFBQUEsa0JBQUFBLGtCQUFBLGlCQUFBLElBQUEsRUFBQSxJQUFBO0FBQ0EsSUFBQUEsa0JBQUFBLGtCQUFBLGdCQUFBLElBQUEsRUFBQSxJQUFBO0FBQ0EsSUFBQUEsa0JBQUFBLGtCQUFBLGVBQUEsSUFBQSxFQUFBLElBQUE7QUFDQSxJQUFBQSxrQkFBQUEsa0JBQUEsYUFBQSxJQUFBLEVBQUEsSUFBQTtBQUNBLElBQUFBLGtCQUFBQSxrQkFBQSxvQkFBQSxJQUFBLEVBQUEsSUFBQTtBQUNBLElBQUFBLGtCQUFBQSxrQkFBQSxZQUFBLElBQUEsRUFBQSxJQUFBO0FBQ0EsSUFBQUEsa0JBQUFBLGtCQUFBLG9CQUFBLElBQUEsRUFBQSxJQUFBO0FBQ0EsSUFBQUEsa0JBQUFBLGtCQUFBLHFCQUFBLElBQUEsRUFBQSxJQUFBO0FBQ0EsSUFBQUEsa0JBQUFBLGtCQUFBLGlCQUFBLElBQUEsRUFBQSxJQUFBO0FBQ0EsSUFBQUEsa0JBQUFBLGtCQUFBLG9CQUFBLElBQUEsRUFBQSxJQUFBO0FBQ0EsSUFBQUEsa0JBQUFBLGtCQUFBLDBCQUFBLElBQUEsRUFBQSxJQUFBO0FBQ0EsSUFBQUEsa0JBQUFBLGtCQUFBLGtCQUFBLElBQUEsRUFBQSxJQUFBO0FBQ0EsSUFBQUEsa0JBQUFBLGtCQUFBLGtCQUFBLElBQUEsRUFBQSxJQUFBO0FBQ0EsSUFBQUEsa0JBQUFBLGtCQUFBLDhCQUFBLElBQUEsRUFBQSxJQUFBO0FBQ0EsSUFBQUEsa0JBQUFBLGtCQUFBLHNCQUFBLElBQUEsRUFBQSxJQUFBO0FBQ0EsSUFBQUEsa0JBQUFBLGtCQUFBLCtCQUFBLElBQUEsRUFBQSxJQUFBO0FBQ0EsSUFBQUEsa0JBQUFBLGtCQUFBLDhCQUFBLElBQUEsRUFBQSxJQUFBO0FBQ0EsSUFBQUEsa0JBQUFBLGtCQUFBLFlBQUEsSUFBQSxFQUFBLElBQUE7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O0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNKO0FBRUEsVUFBUSxJQUFJLDhCQUE4QjsiLAogICJuYW1lcyI6IFsibGVuIiwgImkiLCAibGVuMiIsICJvZmZzZXQiLCAiaXNMRSIsICJCdWZmZXIiLCAic3RyaW5nIiwgImFycmF5IiwgImNvbXBhcmUiLCAidXRmOFRvQnl0ZXMiLCAiaSIsICJvZmZzZXQiLCAiYnl0ZUxlbmd0aCIsICJ0eXBlIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgImFzc2VydCIsICJCTiIsICJudW1iZXIiLCAiQnVmZmVyIiwgInN0cmluZyIsICJtb2QiLCAiY2xvbmUiLCAidG9CdWZmZXIiLCAiYWxsb2NhdGUiLCAiYWRkIiwgImNvbWIxME11bFRvIiwgIm1hc2siLCAiaXNPZGQiLCAic3BsaXQiLCAicHJpbWUiLCAiQnVmZmVyIiwgIkJBU0UiLCAiaSIsICJqIiwgInN0cmluZyIsICJpblJhbmdlIiwgInN0cmluZyIsICJUZXh0RGVjb2RlciIsICJUZXh0RW5jb2RlciIsICJvZmZzZXQiLCAibW9kIiwgImFycmF5IiwgInN0cmluZyIsICJzZXJpYWxpemUiLCAiZGVzZXJpYWxpemUiLCAiZGVzZXJpYWxpemVVbmNoZWNrZWQiLCAib2Zmc2V0IiwgInNwbGl0IiwgInNwYW4iLCAidW5pb24iLCAiQm9vbGVhbiIsICJ2YWxpZGF0ZSIsICJvZmZzZXQiLCAib2Zmc2V0IiwgInZlcnNpb24iLCAib2Zmc2V0IiwgIlVSTCIsICJvZmZzZXQiLCAidmVyc2lvbiIsICJlcnIiLCAiRXZlbnRFbWl0dGVyIiwgInJlcXVpcmVfYnJvd3NlciIsICJ0b0JpZ0ludExFIiwgInRvQmlnSW50QkUiLCAidG9CdWZmZXJMRSIsICJ0b0J1ZmZlckJFIiwgImNyeXB0byIsICJpbnN0YW5jZSIsICJhcnJheSIsICJjcnlwdG8iLCAiaXNMRSIsICJfMzJuIiwgIm9mZnNldCIsICJvZmZzZXQiLCAiZ2VuIiwgIl8wbiIsICJfMW4iLCAiXzBuIiwgIm51bWJlciIsICJfMW4iLCAiRnAiLCAiRnAiLCAiXzFuIiwgImlzTEUiLCAiXzBuIiwgImYiLCAiXzFuIiwgImlzTEUiLCAiXzFuIiwgIl8wbiIsICJfMW4iLCAibWFzayIsICJ3aW5kb3ciLCAib2Zmc2V0IiwgImYiLCAid2JpdHMiLCAiaXNMRSIsICJ0eXBlIiwgIl8wbiIsICJGcCIsICJGbiIsICJfMG4iLCAiXzFuIiwgIl8ybiIsICJfOG4iLCAiRnAiLCAiRm4iLCAidXZSYXRpbyIsICJmIiwgInAiLCAiQkFTRSIsICJyYW5kb21CeXRlcyIsICJhZGp1c3RTY2FsYXJCeXRlcyIsICJnZXRQdWJsaWNLZXkiLCAic2lnbiIsICJ2ZXJpZnkiLCAicHVibGljS2V5IiwgImVkZHNhIiwgIl8wbiIsICJfMW4iLCAiXzJuIiwgIl8zbiIsICJfNW4iLCAiXzhuIiwgInYzIiwgIm51bWJlciIsICJfMW4iLCAibW9kIiwgIl8wbiIsICJzaGEyNTYiLCAib2Zmc2V0IiwgIlNvbGFuYUVycm9yIiwgIm9mZnNldCIsICJTb2xhbmFFcnJvciIsICJvZmZzZXQiLCAiY29tYmluZUNvZGVjIiwgInN0cnVjdCIsICJ0eXBlIiwgImNvZXJjZSIsICJtYXNrIiwgInR1cGxlIiwgInN0cnVjdCIsICJzdHJ1Y3QiLCAic3RydWN0IiwgIkV2ZW50RW1pdHRlciIsICJ0eXBlIiwgIl8wbiIsICJfMW4iLCAiXzJuIiwgIl83biIsICJfMm4iLCAiXzBuIiwgIl8xbiIsICJzZXEiLCAiXzNuIiwgIl80biIsICJGbiIsICJGcCIsICJlbmRvIiwgImYiLCAiRnAiLCAiRm4iLCAicHVibGljS2V5IiwgImdldFB1YmxpY0tleSIsICJyYW5kb21CeXRlcyIsICJobWFjIiwgIm51bWJlciIsICJfMW4iLCAiciIsICJzIiwgIl8ybiIsICJfMG4iLCAic2lnbiIsICJ2ZXJpZnkiLCAiaXMiLCAiRnAiLCAiRm4iLCAiY3JlYXRlIiwgIl8ybiIsICJfM24iLCAiZ2VuZXJhdGVQcml2YXRlS2V5IiwgImVkMjU1MTkiLCAidXRpbHMiLCAicmFuZG9tUHJpdmF0ZUtleSIsICJnZW5lcmF0ZUtleXBhaXIiLCAicHJpdmF0ZVNjYWxhciIsICJwdWJsaWNLZXkiLCAiZ2V0UHVibGljS2V5IiwgInNlY3JldEtleSIsICJVaW50OEFycmF5IiwgInNldCIsICJpc09uQ3VydmUiLCAiRXh0ZW5kZWRQb2ludCIsICJmcm9tSGV4IiwgInNpZ24iLCAibWVzc2FnZSIsICJzbGljZSIsICJ2ZXJpZnkiLCAidG9CdWZmZXIiLCAiYXJyIiwgIkJ1ZmZlciIsICJpc0J1ZmZlciIsICJmcm9tIiwgImJ1ZmZlciIsICJieXRlT2Zmc2V0IiwgImJ5dGVMZW5ndGgiLCAiU3RydWN0IiwgImNvbnN0cnVjdG9yIiwgInByb3BlcnRpZXMiLCAiT2JqZWN0IiwgImFzc2lnbiIsICJlbmNvZGUiLCAic2VyaWFsaXplIiwgIlNPTEFOQV9TQ0hFTUEiLCAiZGVjb2RlIiwgImRhdGEiLCAiZGVzZXJpYWxpemUiLCAiZGVjb2RlVW5jaGVja2VkIiwgImRlc2VyaWFsaXplVW5jaGVja2VkIiwgIlNPTEFOQV9TQ0hFTUEiLCAiTWFwIiwgIk1BWF9TRUVEX0xFTkdUSCIsICJQVUJMSUNfS0VZX0xFTkdUSCIsICJpc1B1YmxpY0tleURhdGEiLCAidmFsdWUiLCAiX2JuIiwgInVuZGVmaW5lZCIsICJ1bmlxdWVQdWJsaWNLZXlDb3VudGVyIiwgIlB1YmxpY0tleSIsICJTdHJ1Y3QiLCAiY29uc3RydWN0b3IiLCAiZGVjb2RlZCIsICJiczU4IiwgImRlY29kZSIsICJsZW5ndGgiLCAiRXJyb3IiLCAiQk4iLCAiYnl0ZUxlbmd0aCIsICJ1bmlxdWUiLCAia2V5IiwgInRvQnVmZmVyIiwgImVxdWFscyIsICJwdWJsaWNLZXkiLCAiZXEiLCAidG9CYXNlNTgiLCAiZW5jb2RlIiwgInRvQnl0ZXMiLCAidG9KU09OIiwgImJ1ZiIsICJVaW50OEFycmF5IiwgImJ1ZmZlciIsICJieXRlT2Zmc2V0IiwgImIiLCAidG9BcnJheUxpa2UiLCAiQnVmZmVyIiwgInplcm9QYWQiLCAiYWxsb2MiLCAiY29weSIsICJTeW1ib2wiLCAidG9TdHJpbmdUYWciLCAidG9TdHJpbmciLCAiY3JlYXRlV2l0aFNlZWQiLCAiZnJvbVB1YmxpY0tleSIsICJzZWVkIiwgInByb2dyYW1JZCIsICJjb25jYXQiLCAiZnJvbSIsICJwdWJsaWNLZXlCeXRlcyIsICJzaGEyNTYiLCAiY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jIiwgInNlZWRzIiwgImZvckVhY2giLCAiVHlwZUVycm9yIiwgImlzT25DdXJ2ZSIsICJjcmVhdGVQcm9ncmFtQWRkcmVzcyIsICJmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jIiwgIm5vbmNlIiwgImFkZHJlc3MiLCAic2VlZHNXaXRoTm9uY2UiLCAiZXJyIiwgImZpbmRQcm9ncmFtQWRkcmVzcyIsICJwdWJrZXlEYXRhIiwgInB1YmtleSIsICJfUHVibGljS2V5IiwgImRlZmF1bHQiLCAic2V0IiwgImtpbmQiLCAiZmllbGRzIiwgIkJQRl9MT0FERVJfREVQUkVDQVRFRF9QUk9HUkFNX0lEIiwgIlB1YmxpY0tleSIsICJQQUNLRVRfREFUQV9TSVpFIiwgIlZFUlNJT05fUFJFRklYX01BU0siLCAiU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyIsICJUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3IiLCAiRXJyb3IiLCAiY29uc3RydWN0b3IiLCAic2lnbmF0dXJlIiwgIk9iamVjdCIsICJkZWZpbmVQcm9wZXJ0eSIsICJwcm90b3R5cGUiLCAidmFsdWUiLCAiVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yIiwgInRpbWVvdXRTZWNvbmRzIiwgInRvRml4ZWQiLCAiVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IiLCAiTWVzc2FnZUFjY291bnRLZXlzIiwgInN0YXRpY0FjY291bnRLZXlzIiwgImFjY291bnRLZXlzRnJvbUxvb2t1cHMiLCAia2V5U2VnbWVudHMiLCAicHVzaCIsICJ3cml0YWJsZSIsICJyZWFkb25seSIsICJnZXQiLCAiaW5kZXgiLCAia2V5U2VnbWVudCIsICJsZW5ndGgiLCAiZmxhdCIsICJjb21waWxlSW5zdHJ1Y3Rpb25zIiwgImluc3RydWN0aW9ucyIsICJVOF9NQVgiLCAia2V5SW5kZXhNYXAiLCAiTWFwIiwgImZvckVhY2giLCAia2V5IiwgInNldCIsICJ0b0Jhc2U1OCIsICJmaW5kS2V5SW5kZXgiLCAia2V5SW5kZXgiLCAidW5kZWZpbmVkIiwgIm1hcCIsICJpbnN0cnVjdGlvbiIsICJwcm9ncmFtSWRJbmRleCIsICJwcm9ncmFtSWQiLCAiYWNjb3VudEtleUluZGV4ZXMiLCAia2V5cyIsICJtZXRhIiwgInB1YmtleSIsICJkYXRhIiwgInB1YmxpY0tleSIsICJwcm9wZXJ0eSIsICJibG9iIiwgInJ1c3RTdHJpbmciLCAicHJvcGVydHkiLCAicnNsIiwgInN0cnVjdCIsICJ1MzIiLCAiYmxvYiIsICJvZmZzZXQiLCAiX2RlY29kZSIsICJkZWNvZGUiLCAiYmluZCIsICJfZW5jb2RlIiwgImVuY29kZSIsICJyc2xTaGltIiwgImIiLCAiZGF0YSIsICJ0b1N0cmluZyIsICJzdHIiLCAiY2hhcnMiLCAiQnVmZmVyIiwgImZyb20iLCAiYWxsb2MiLCAic3BhbiIsICJsZW5ndGgiLCAiYXV0aG9yaXplZCIsICJwdWJsaWNLZXkiLCAibG9ja3VwIiwgIm5zNjQiLCAidm90ZUluaXQiLCAidTgiLCAidm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncyIsICJnZXRBbGxvYyIsICJ0eXBlIiwgImZpZWxkcyIsICJnZXRJdGVtQWxsb2MiLCAiaXRlbSIsICJmaWVsZCIsICJBcnJheSIsICJpc0FycmF5IiwgImVsZW1lbnRMYXlvdXQiLCAibGF5b3V0IiwgImZvckVhY2giLCAiZGVjb2RlTGVuZ3RoIiwgImJ5dGVzIiwgImxlbiIsICJzaXplIiwgImVsZW0iLCAic2hpZnQiLCAiZW5jb2RlTGVuZ3RoIiwgInJlbV9sZW4iLCAicHVzaCIsICJhc3NlcnQiLCAiY29uZGl0aW9uIiwgIm1lc3NhZ2UiLCAiRXJyb3IiLCAiQ29tcGlsZWRLZXlzIiwgImNvbnN0cnVjdG9yIiwgInBheWVyIiwgImtleU1ldGFNYXAiLCAiY29tcGlsZSIsICJpbnN0cnVjdGlvbnMiLCAiTWFwIiwgImdldE9ySW5zZXJ0RGVmYXVsdCIsICJwdWJrZXkiLCAiYWRkcmVzcyIsICJ0b0Jhc2U1OCIsICJrZXlNZXRhIiwgImdldCIsICJ1bmRlZmluZWQiLCAiaXNTaWduZXIiLCAiaXNXcml0YWJsZSIsICJpc0ludm9rZWQiLCAic2V0IiwgInBheWVyS2V5TWV0YSIsICJpeCIsICJwcm9ncmFtSWQiLCAiYWNjb3VudE1ldGEiLCAia2V5cyIsICJnZXRNZXNzYWdlQ29tcG9uZW50cyIsICJtYXBFbnRyaWVzIiwgImVudHJpZXMiLCAid3JpdGFibGVTaWduZXJzIiwgImZpbHRlciIsICJtZXRhIiwgInJlYWRvbmx5U2lnbmVycyIsICJ3cml0YWJsZU5vblNpZ25lcnMiLCAicmVhZG9ubHlOb25TaWduZXJzIiwgImhlYWRlciIsICJudW1SZXF1aXJlZFNpZ25hdHVyZXMiLCAibnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyIsICJudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMiLCAicGF5ZXJBZGRyZXNzIiwgInN0YXRpY0FjY291bnRLZXlzIiwgIm1hcCIsICJQdWJsaWNLZXkiLCAiZXh0cmFjdFRhYmxlTG9va3VwIiwgImxvb2t1cFRhYmxlIiwgIndyaXRhYmxlSW5kZXhlcyIsICJkcmFpbmVkV3JpdGFibGVLZXlzIiwgImRyYWluS2V5c0ZvdW5kSW5Mb29rdXBUYWJsZSIsICJzdGF0ZSIsICJhZGRyZXNzZXMiLCAicmVhZG9ubHlJbmRleGVzIiwgImRyYWluZWRSZWFkb25seUtleXMiLCAiYWNjb3VudEtleSIsICJrZXkiLCAid3JpdGFibGUiLCAicmVhZG9ubHkiLCAibG9va3VwVGFibGVFbnRyaWVzIiwgImtleU1ldGFGaWx0ZXIiLCAibG9va3VwVGFibGVJbmRleGVzIiwgImRyYWluZWRLZXlzIiwgImxvb2t1cFRhYmxlSW5kZXgiLCAiZmluZEluZGV4IiwgImVudHJ5IiwgImVxdWFscyIsICJkZWxldGUiLCAiRU5EX09GX0JVRkZFUl9FUlJPUl9NRVNTQUdFIiwgImd1YXJkZWRTaGlmdCIsICJieXRlQXJyYXkiLCAiZ3VhcmRlZFNwbGljZSIsICJhcmdzIiwgInN0YXJ0IiwgInNwbGljZSIsICJNZXNzYWdlIiwgImFjY291bnRLZXlzIiwgInJlY2VudEJsb2NraGFzaCIsICJpbmRleFRvUHJvZ3JhbUlkcyIsICJhY2NvdW50IiwgInByb2dyYW1JZEluZGV4IiwgInZlcnNpb24iLCAiY29tcGlsZWRJbnN0cnVjdGlvbnMiLCAiYWNjb3VudEtleUluZGV4ZXMiLCAiYWNjb3VudHMiLCAiYnM1OCIsICJhZGRyZXNzVGFibGVMb29rdXBzIiwgImdldEFjY291bnRLZXlzIiwgIk1lc3NhZ2VBY2NvdW50S2V5cyIsICJjb21waWxlZEtleXMiLCAicGF5ZXJLZXkiLCAiY29tcGlsZUluc3RydWN0aW9ucyIsICJpc0FjY291bnRTaWduZXIiLCAiaW5kZXgiLCAiaXNBY2NvdW50V3JpdGFibGUiLCAibnVtU2lnbmVkQWNjb3VudHMiLCAidW5zaWduZWRBY2NvdW50SW5kZXgiLCAibnVtVW5zaWduZWRBY2NvdW50cyIsICJudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMiLCAibnVtV3JpdGFibGVTaWduZWRBY2NvdW50cyIsICJpc1Byb2dyYW1JZCIsICJoYXMiLCAicHJvZ3JhbUlkcyIsICJ2YWx1ZXMiLCAibm9uUHJvZ3JhbUlkcyIsICJfIiwgInNlcmlhbGl6ZSIsICJudW1LZXlzIiwgImtleUNvdW50IiwgInNob3J0dmVjIiwgImluc3RydWN0aW9uIiwgImtleUluZGljZXNDb3VudCIsICJkYXRhQ291bnQiLCAia2V5SW5kaWNlcyIsICJkYXRhTGVuZ3RoIiwgImluc3RydWN0aW9uQ291bnQiLCAiaW5zdHJ1Y3Rpb25CdWZmZXIiLCAiUEFDS0VUX0RBVEFfU0laRSIsICJjb3B5IiwgImluc3RydWN0aW9uQnVmZmVyTGVuZ3RoIiwgImluc3RydWN0aW9uTGF5b3V0IiwgInNlcSIsICJzbGljZSIsICJzaWduRGF0YUxheW91dCIsICJMYXlvdXQiLCAidHJhbnNhY3Rpb24iLCAidG9CdWZmZXIiLCAidG9CeXRlcyIsICJzaWduRGF0YSIsICJidWZmZXIiLCAiVkVSU0lPTl9QUkVGSVhfTUFTSyIsICJhY2NvdW50Q291bnQiLCAiaSIsICJQVUJMSUNfS0VZX0xFTkdUSCIsICJkYXRhU2xpY2UiLCAibWVzc2FnZUFyZ3MiLCAiTWVzc2FnZVYwIiwgIm51bUFjY291bnRLZXlzRnJvbUxvb2t1cHMiLCAiY291bnQiLCAibG9va3VwIiwgImFjY291bnRLZXlzRnJvbUxvb2t1cHMiLCAiYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMiLCAicmVzb2x2ZUFkZHJlc3NUYWJsZUxvb2t1cHMiLCAibnVtU3RhdGljQWNjb3VudEtleXMiLCAibG9va3VwQWNjb3VudEtleXNJbmRleCIsICJudW1Xcml0YWJsZUxvb2t1cEFjY291bnRLZXlzIiwgInJlZHVjZSIsICJ0YWJsZUxvb2t1cCIsICJ0YWJsZUFjY291bnQiLCAiZmluZCIsICJsb29rdXBUYWJsZUFjY291bnRzIiwgImV4dHJhY3RSZXN1bHQiLCAiYWRkcmVzc1RhYmxlTG9va3VwIiwgImVuY29kZWRTdGF0aWNBY2NvdW50S2V5c0xlbmd0aCIsICJzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zIiwgInNlcmlhbGl6ZUluc3RydWN0aW9ucyIsICJlbmNvZGVkSW5zdHJ1Y3Rpb25zTGVuZ3RoIiwgInNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzIiwgInNlcmlhbGl6ZUFkZHJlc3NUYWJsZUxvb2t1cHMiLCAiZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgiLCAibWVzc2FnZUxheW91dCIsICJzZXJpYWxpemVkTWVzc2FnZSIsICJVaW50OEFycmF5IiwgIk1FU1NBR0VfVkVSU0lPTl8wX1BSRUZJWCIsICJzZXJpYWxpemVkTWVzc2FnZUxlbmd0aCIsICJwcmVmaXgiLCAic3RhdGljQWNjb3VudEtleXNMZW5ndGgiLCAiaW5zdHJ1Y3Rpb25zTGVuZ3RoIiwgImFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgiLCAic2VyaWFsaXplZExlbmd0aCIsICJlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGgiLCAiZW5jb2RlZERhdGFMZW5ndGgiLCAiZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aCIsICJlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoIiwgImFkZHJlc3NUYWJsZUxvb2t1cExheW91dCIsICJkZXNlcmlhbGl6ZSIsICJtYXNrZWRQcmVmaXgiLCAiYWNjb3VudEtleUluZGV4ZXNMZW5ndGgiLCAiYWRkcmVzc1RhYmxlTG9va3Vwc0NvdW50IiwgIndyaXRhYmxlSW5kZXhlc0xlbmd0aCIsICJyZWFkb25seUluZGV4ZXNMZW5ndGgiLCAiVHJhbnNhY3Rpb25TdGF0dXMiLCAiREVGQVVMVF9TSUdOQVRVUkUiLCAiQnVmZmVyIiwgImFsbG9jIiwgIlNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMiLCAiZmlsbCIsICJUcmFuc2FjdGlvbkluc3RydWN0aW9uIiwgImNvbnN0cnVjdG9yIiwgIm9wdHMiLCAia2V5cyIsICJwcm9ncmFtSWQiLCAiZGF0YSIsICJ0b0pTT04iLCAibWFwIiwgInB1YmtleSIsICJpc1NpZ25lciIsICJpc1dyaXRhYmxlIiwgIlRyYW5zYWN0aW9uIiwgInNpZ25hdHVyZSIsICJzaWduYXR1cmVzIiwgImxlbmd0aCIsICJmZWVQYXllciIsICJpbnN0cnVjdGlvbnMiLCAicmVjZW50QmxvY2toYXNoIiwgImxhc3RWYWxpZEJsb2NrSGVpZ2h0IiwgIm5vbmNlSW5mbyIsICJtaW5Ob25jZUNvbnRleHRTbG90IiwgIl9tZXNzYWdlIiwgIl9qc29uIiwgIk9iamVjdCIsICJwcm90b3R5cGUiLCAiaGFzT3duUHJvcGVydHkiLCAiY2FsbCIsICJtaW5Db250ZXh0U2xvdCIsICJibG9ja2hhc2giLCAibm9uY2UiLCAibm9uY2VJbnN0cnVjdGlvbiIsICJpbnN0cnVjdGlvbiIsICJzaWduZXJzIiwgInB1YmxpY0tleSIsICJhZGQiLCAiaXRlbXMiLCAiRXJyb3IiLCAiZm9yRWFjaCIsICJpdGVtIiwgImNvbmNhdCIsICJwdXNoIiwgImNvbXBpbGVNZXNzYWdlIiwgIkpTT04iLCAic3RyaW5naWZ5IiwgImNvbnNvbGUiLCAid2FybiIsICJpIiwgInVuZGVmaW5lZCIsICJwcm9ncmFtSWRzIiwgImFjY291bnRNZXRhcyIsICJhY2NvdW50TWV0YSIsICJ0b1N0cmluZyIsICJpbmNsdWRlcyIsICJQdWJsaWNLZXkiLCAidW5pcXVlTWV0YXMiLCAicHVia2V5U3RyaW5nIiwgInVuaXF1ZUluZGV4IiwgImZpbmRJbmRleCIsICJ4IiwgInNvcnQiLCAieSIsICJvcHRpb25zIiwgImxvY2FsZU1hdGNoZXIiLCAidXNhZ2UiLCAic2Vuc2l0aXZpdHkiLCAiaWdub3JlUHVuY3R1YXRpb24iLCAibnVtZXJpYyIsICJjYXNlRmlyc3QiLCAidG9CYXNlNTgiLCAibG9jYWxlQ29tcGFyZSIsICJmZWVQYXllckluZGV4IiwgImVxdWFscyIsICJwYXllck1ldGEiLCAic3BsaWNlIiwgInVuc2hpZnQiLCAibnVtUmVxdWlyZWRTaWduYXR1cmVzIiwgIm51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMiLCAibnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzIiwgInNpZ25lZEtleXMiLCAidW5zaWduZWRLZXlzIiwgImFjY291bnRLZXlzIiwgImNvbXBpbGVkSW5zdHJ1Y3Rpb25zIiwgInByb2dyYW1JZEluZGV4IiwgImluZGV4T2YiLCAiYWNjb3VudHMiLCAibWV0YSIsICJiczU4IiwgImVuY29kZSIsICJpbnZhcmlhbnQiLCAia2V5SW5kZXgiLCAiTWVzc2FnZSIsICJoZWFkZXIiLCAiX2NvbXBpbGUiLCAibWVzc2FnZSIsICJzbGljZSIsICJ2YWxpZCIsICJldmVyeSIsICJwYWlyIiwgImluZGV4IiwgInNlcmlhbGl6ZU1lc3NhZ2UiLCAic2VyaWFsaXplIiwgImdldEVzdGltYXRlZEZlZSIsICJjb25uZWN0aW9uIiwgImdldEZlZUZvck1lc3NhZ2UiLCAidmFsdWUiLCAic2V0U2lnbmVycyIsICJzZWVuIiwgIlNldCIsICJmaWx0ZXIiLCAia2V5IiwgImhhcyIsICJzaWduIiwgInVuaXF1ZVNpZ25lcnMiLCAic2lnbmVyIiwgIl9wYXJ0aWFsU2lnbiIsICJwYXJ0aWFsU2lnbiIsICJzaWduRGF0YSIsICJzZWNyZXRLZXkiLCAiX2FkZFNpZ25hdHVyZSIsICJ0b0J1ZmZlciIsICJhZGRTaWduYXR1cmUiLCAic2lncGFpciIsICJmcm9tIiwgInZlcmlmeVNpZ25hdHVyZXMiLCAicmVxdWlyZUFsbFNpZ25hdHVyZXMiLCAic2lnbmF0dXJlRXJyb3JzIiwgIl9nZXRNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyIsICJlcnJvcnMiLCAibWlzc2luZyIsICJ2ZXJpZnkiLCAidG9CeXRlcyIsICJpbnZhbGlkIiwgImNvbmZpZyIsICJhc3NpZ24iLCAic2lnRXJyb3JzIiwgImVycm9yTWVzc2FnZSIsICJwIiwgImpvaW4iLCAiX3NlcmlhbGl6ZSIsICJzaWduYXR1cmVDb3VudCIsICJzaG9ydHZlYyIsICJ0cmFuc2FjdGlvbkxlbmd0aCIsICJ3aXJlVHJhbnNhY3Rpb24iLCAiY29weSIsICJQQUNLRVRfREFUQV9TSVpFIiwgImtleU9iaiIsICJidWZmZXIiLCAiYnl0ZUFycmF5IiwgImd1YXJkZWRTcGxpY2UiLCAicG9wdWxhdGUiLCAidHJhbnNhY3Rpb24iLCAic2lnUHVia2V5UGFpciIsICJkZWNvZGUiLCAiYWNjb3VudCIsICJzb21lIiwgImlzQWNjb3VudFNpZ25lciIsICJpc0FjY291bnRXcml0YWJsZSIsICJOVU1fVElDS1NfUEVSX1NFQ09ORCIsICJERUZBVUxUX1RJQ0tTX1BFUl9TTE9UIiwgIk5VTV9TTE9UU19QRVJfU0VDT05EIiwgIk1TX1BFUl9TTE9UIiwgIlNZU1ZBUl9DTE9DS19QVUJLRVkiLCAiUHVibGljS2V5IiwgIlNZU1ZBUl9FUE9DSF9TQ0hFRFVMRV9QVUJLRVkiLCAiU1lTVkFSX0lOU1RSVUNUSU9OU19QVUJLRVkiLCAiU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVkiLCAiU1lTVkFSX1JFTlRfUFVCS0VZIiwgIlNZU1ZBUl9SRVdBUkRTX1BVQktFWSIsICJTWVNWQVJfU0xPVF9IQVNIRVNfUFVCS0VZIiwgIlNZU1ZBUl9TTE9UX0hJU1RPUllfUFVCS0VZIiwgIlNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSIsICJTZW5kVHJhbnNhY3Rpb25FcnJvciIsICJFcnJvciIsICJjb25zdHJ1Y3RvciIsICJhY3Rpb24iLCAic2lnbmF0dXJlIiwgInRyYW5zYWN0aW9uTWVzc2FnZSIsICJsb2dzIiwgIm1heWJlTG9nc091dHB1dCIsICJKU09OIiwgInN0cmluZ2lmeSIsICJzbGljZSIsICJndWlkZVRleHQiLCAibWVzc2FnZSIsICJhIiwgInRyYW5zYWN0aW9uTG9ncyIsICJ1bmRlZmluZWQiLCAidHJhbnNhY3Rpb25FcnJvciIsICJBcnJheSIsICJpc0FycmF5IiwgImNhY2hlZExvZ3MiLCAiZ2V0TG9ncyIsICJjb25uZWN0aW9uIiwgIlByb21pc2UiLCAicmVzb2x2ZSIsICJyZWplY3QiLCAiZ2V0VHJhbnNhY3Rpb24iLCAidGhlbiIsICJ0eCIsICJtZXRhIiwgImxvZ01lc3NhZ2VzIiwgImNhdGNoIiwgIlNvbGFuYUpTT05SUENFcnJvciIsICJFcnJvciIsICJjb25zdHJ1Y3RvciIsICJjb2RlIiwgIm1lc3NhZ2UiLCAiZGF0YSIsICJjdXN0b21NZXNzYWdlIiwgIm5hbWUiLCAic2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbiIsICJjb25uZWN0aW9uIiwgInRyYW5zYWN0aW9uIiwgInNpZ25lcnMiLCAib3B0aW9ucyIsICJzZW5kT3B0aW9ucyIsICJza2lwUHJlZmxpZ2h0IiwgInByZWZsaWdodENvbW1pdG1lbnQiLCAiY29tbWl0bWVudCIsICJtYXhSZXRyaWVzIiwgIm1pbkNvbnRleHRTbG90IiwgInNpZ25hdHVyZSIsICJzZW5kVHJhbnNhY3Rpb24iLCAic3RhdHVzIiwgInJlY2VudEJsb2NraGFzaCIsICJsYXN0VmFsaWRCbG9ja0hlaWdodCIsICJjb25maXJtVHJhbnNhY3Rpb24iLCAiYWJvcnRTaWduYWwiLCAiYmxvY2toYXNoIiwgInZhbHVlIiwgIm1pbk5vbmNlQ29udGV4dFNsb3QiLCAibm9uY2VJbmZvIiwgIm5vbmNlSW5zdHJ1Y3Rpb24iLCAibm9uY2VBY2NvdW50UHVia2V5IiwgImtleXMiLCAicHVia2V5IiwgIm5vbmNlVmFsdWUiLCAibm9uY2UiLCAiY29uc29sZSIsICJ3YXJuIiwgImVyciIsICJTZW5kVHJhbnNhY3Rpb25FcnJvciIsICJhY3Rpb24iLCAidHJhbnNhY3Rpb25NZXNzYWdlIiwgIkpTT04iLCAic3RyaW5naWZ5IiwgInNsZWVwIiwgIm1zIiwgIlByb21pc2UiLCAicmVzb2x2ZSIsICJzZXRUaW1lb3V0IiwgImVuY29kZURhdGEiLCAidHlwZSIsICJmaWVsZHMiLCAiYWxsb2NMZW5ndGgiLCAibGF5b3V0IiwgInNwYW4iLCAiTGF5b3V0IiwgIkJ1ZmZlciIsICJhbGxvYyIsICJsYXlvdXRGaWVsZHMiLCAiT2JqZWN0IiwgImFzc2lnbiIsICJpbnN0cnVjdGlvbiIsICJpbmRleCIsICJlbmNvZGUiLCAiRmVlQ2FsY3VsYXRvckxheW91dCIsICJudTY0IiwgIk5vbmNlQWNjb3VudExheW91dCIsICJzdHJ1Y3QiLCAidTMyIiwgIkxheW91dCIsICJOT05DRV9BQ0NPVU5UX0xFTkdUSCIsICJzcGFuIiwgIk5vbmNlQWNjb3VudCIsICJjb25zdHJ1Y3RvciIsICJhcmdzIiwgImF1dGhvcml6ZWRQdWJrZXkiLCAibm9uY2UiLCAiZmVlQ2FsY3VsYXRvciIsICJmcm9tQWNjb3VudERhdGEiLCAiYnVmZmVyIiwgIm5vbmNlQWNjb3VudCIsICJkZWNvZGUiLCAidG9CdWZmZXIiLCAiUHVibGljS2V5IiwgInRvU3RyaW5nIiwgInU2NCIsICJwcm9wZXJ0eSIsICJsYXlvdXQiLCAiYmxvYiIsICJiaW5kIiwgImVuY29kZSIsICJiaWdJbnRMYXlvdXQiLCAiY29kZWMiLCAiZ2V0VTY0Q29kZWMiLCAib2Zmc2V0IiwgInNyYyIsICJiaWdJbnQiLCAiU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMiLCAiT2JqZWN0IiwgImZyZWV6ZSIsICJDcmVhdGUiLCAiaW5kZXgiLCAibGF5b3V0IiwgInN0cnVjdCIsICJ1MzIiLCAibnM2NCIsICJMYXlvdXQiLCAiQXNzaWduIiwgIlRyYW5zZmVyIiwgInU2NCIsICJDcmVhdGVXaXRoU2VlZCIsICJBZHZhbmNlTm9uY2VBY2NvdW50IiwgIldpdGhkcmF3Tm9uY2VBY2NvdW50IiwgIkluaXRpYWxpemVOb25jZUFjY291bnQiLCAiQXV0aG9yaXplTm9uY2VBY2NvdW50IiwgIkFsbG9jYXRlIiwgIkFsbG9jYXRlV2l0aFNlZWQiLCAiQXNzaWduV2l0aFNlZWQiLCAiVHJhbnNmZXJXaXRoU2VlZCIsICJVcGdyYWRlTm9uY2VBY2NvdW50IiwgIlN5c3RlbVByb2dyYW0iLCAiY29uc3RydWN0b3IiLCAiY3JlYXRlQWNjb3VudCIsICJwYXJhbXMiLCAidHlwZSIsICJkYXRhIiwgImVuY29kZURhdGEiLCAibGFtcG9ydHMiLCAic3BhY2UiLCAicHJvZ3JhbUlkIiwgInRvQnVmZmVyIiwgIlRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24iLCAia2V5cyIsICJwdWJrZXkiLCAiZnJvbVB1YmtleSIsICJpc1NpZ25lciIsICJpc1dyaXRhYmxlIiwgIm5ld0FjY291bnRQdWJrZXkiLCAidHJhbnNmZXIiLCAiQmlnSW50IiwgInNlZWQiLCAiYmFzZVB1YmtleSIsICJ0b1B1YmtleSIsICJhc3NpZ24iLCAiYmFzZSIsICJhY2NvdW50UHVia2V5IiwgImNyZWF0ZUFjY291bnRXaXRoU2VlZCIsICJlcXVhbHMiLCAicHVzaCIsICJjcmVhdGVOb25jZUFjY291bnQiLCAidHJhbnNhY3Rpb24iLCAiVHJhbnNhY3Rpb24iLCAiYWRkIiwgIm5vbmNlUHVia2V5IiwgIk5PTkNFX0FDQ09VTlRfTEVOR1RIIiwgImluaXRQYXJhbXMiLCAiYXV0aG9yaXplZFB1YmtleSIsICJub25jZUluaXRpYWxpemUiLCAiYXV0aG9yaXplZCIsICJpbnN0cnVjdGlvbkRhdGEiLCAiU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVkiLCAiU1lTVkFSX1JFTlRfUFVCS0VZIiwgIm5vbmNlQWR2YW5jZSIsICJub25jZVdpdGhkcmF3IiwgIm5vbmNlQXV0aG9yaXplIiwgIm5ld0F1dGhvcml6ZWRQdWJrZXkiLCAiYWxsb2NhdGUiLCAiUHVibGljS2V5IiwgIkNIVU5LX1NJWkUiLCAiUEFDS0VUX0RBVEFfU0laRSIsICJMb2FkZXIiLCAiZ2V0TWluTnVtU2lnbmF0dXJlcyIsICJkYXRhTGVuZ3RoIiwgIk1hdGgiLCAiY2VpbCIsICJjaHVua1NpemUiLCAibG9hZCIsICJjb25uZWN0aW9uIiwgInBheWVyIiwgInByb2dyYW0iLCAiYmFsYW5jZU5lZWRlZCIsICJnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb24iLCAibGVuZ3RoIiwgInByb2dyYW1JbmZvIiwgImdldEFjY291bnRJbmZvIiwgInB1YmxpY0tleSIsICJleGVjdXRhYmxlIiwgImNvbnNvbGUiLCAiZXJyb3IiLCAib3duZXIiLCAic2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbiIsICJjb21taXRtZW50IiwgImRhdGFMYXlvdXQiLCAic2VxIiwgInU4IiwgIm9mZnNldCIsICJhcnJheSIsICJ0cmFuc2FjdGlvbnMiLCAiYnl0ZXMiLCAic2xpY2UiLCAiQnVmZmVyIiwgImFsbG9jIiwgImVuY29kZSIsICJpbnN0cnVjdGlvbiIsICJieXRlc0xlbmd0aCIsICJieXRlc0xlbmd0aFBhZGRpbmciLCAiX3JwY0VuZHBvaW50IiwgImluY2x1ZGVzIiwgIlJFUVVFU1RTX1BFUl9TRUNPTkQiLCAic2xlZXAiLCAiUHJvbWlzZSIsICJhbGwiLCAic3BhbiIsICJkZXBsb3lDb21taXRtZW50IiwgImZpbmFsaXplU2lnbmF0dXJlIiwgInNlbmRUcmFuc2FjdGlvbiIsICJwcmVmbGlnaHRDb21taXRtZW50IiwgImNvbnRleHQiLCAidmFsdWUiLCAiY29uZmlybVRyYW5zYWN0aW9uIiwgInNpZ25hdHVyZSIsICJsYXN0VmFsaWRCbG9ja0hlaWdodCIsICJibG9ja2hhc2giLCAicmVjZW50QmxvY2toYXNoIiwgImVyciIsICJFcnJvciIsICJKU09OIiwgInN0cmluZ2lmeSIsICJjdXJyZW50U2xvdCIsICJnZXRTbG90IiwgInNsb3QiLCAicmVzb2x2ZSIsICJzZXRUaW1lb3V0IiwgInJvdW5kIiwgIk1TX1BFUl9TTE9UIiwgIkJQRl9MT0FERVJfUFJPR1JBTV9JRCIsICJzdHJpbmdpZnkiLCAiZmFzdFN0YWJsZVN0cmluZ2lmeSIsICJNSU5JTVVNX1NMT1RfUEVSX0VQT0NIIiwgInRyYWlsaW5nWmVyb3MiLCAibiIsICJuZXh0UG93ZXJPZlR3byIsICJFcG9jaFNjaGVkdWxlIiwgImNvbnN0cnVjdG9yIiwgInNsb3RzUGVyRXBvY2giLCAibGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0IiwgIndhcm11cCIsICJmaXJzdE5vcm1hbEVwb2NoIiwgImZpcnN0Tm9ybWFsU2xvdCIsICJnZXRFcG9jaCIsICJzbG90IiwgImdldEVwb2NoQW5kU2xvdEluZGV4IiwgImVwb2NoIiwgImVwb2NoTGVuIiwgImdldFNsb3RzSW5FcG9jaCIsICJzbG90SW5kZXgiLCAibm9ybWFsU2xvdEluZGV4IiwgIm5vcm1hbEVwb2NoSW5kZXgiLCAiTWF0aCIsICJmbG9vciIsICJnZXRGaXJzdFNsb3RJbkVwb2NoIiwgInBvdyIsICJnZXRMYXN0U2xvdEluRXBvY2giLCAiZ2xvYmFsVGhpcyIsICJmZXRjaCIsICJScGNXZWJTb2NrZXRDbGllbnQiLCAiQ29tbW9uQ2xpZW50IiwgImFkZHJlc3MiLCAib3B0aW9ucyIsICJnZW5lcmF0ZV9yZXF1ZXN0X2lkIiwgIndlYlNvY2tldEZhY3RvcnkiLCAidXJsIiwgInJwYyIsICJjcmVhdGVScGMiLCAiYXV0b2Nvbm5lY3QiLCAibWF4X3JlY29ubmVjdHMiLCAicmVjb25uZWN0IiwgInJlY29ubmVjdF9pbnRlcnZhbCIsICJ1bmRlcmx5aW5nU29ja2V0IiwgInNvY2tldCIsICJjYWxsIiwgImFyZ3MiLCAicmVhZHlTdGF0ZSIsICJQcm9taXNlIiwgInJlamVjdCIsICJFcnJvciIsICJub3RpZnkiLCAiZGVjb2RlRGF0YSIsICJ0eXBlIiwgImRhdGEiLCAiZGVjb2RlZCIsICJsYXlvdXQiLCAiZGVjb2RlIiwgImVyciIsICJ0eXBlSW5kZXgiLCAiaW5kZXgiLCAiTE9PS1VQX1RBQkxFX01FVEFfU0laRSIsICJBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50IiwgImtleSIsICJzdGF0ZSIsICJpc0FjdGl2ZSIsICJVNjRfTUFYIiwgIkJpZ0ludCIsICJkZWFjdGl2YXRpb25TbG90IiwgImRlc2VyaWFsaXplIiwgImFjY291bnREYXRhIiwgIm1ldGEiLCAiTG9va3VwVGFibGVNZXRhTGF5b3V0IiwgInNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4iLCAibGVuZ3RoIiwgImFzc2VydCIsICJudW1TZXJpYWxpemVkQWRkcmVzc2VzIiwgImFkZHJlc3NlcyIsICJzdHJ1Y3QiLCAic2VxIiwgIkxheW91dCIsICJzbGljZSIsICJsYXN0RXh0ZW5kZWRTbG90IiwgImxhc3RFeHRlbmRlZFNsb3RTdGFydEluZGV4IiwgImxhc3RFeHRlbmRlZFN0YXJ0SW5kZXgiLCAiYXV0aG9yaXR5IiwgIlB1YmxpY0tleSIsICJ1bmRlZmluZWQiLCAibWFwIiwgInUzMiIsICJ1NjQiLCAibnU2NCIsICJ1OCIsICJvZmZzZXQiLCAiVVJMX1JFIiwgIm1ha2VXZWJzb2NrZXRVcmwiLCAiZW5kcG9pbnQiLCAibWF0Y2hlcyIsICJtYXRjaCIsICJUeXBlRXJyb3IiLCAiXyIsICJob3N0aXNoIiwgInBvcnRXaXRoQ29sb24iLCAicmVzdCIsICJwcm90b2NvbCIsICJzdGFydHNXaXRoIiwgInN0YXJ0UG9ydCIsICJwYXJzZUludCIsICJ3ZWJzb2NrZXRQb3J0IiwgIlB1YmxpY0tleUZyb21TdHJpbmciLCAiY29lcmNlIiwgImluc3RhbmNlIiwgInN0cmluZyIsICJ2YWx1ZSIsICJSYXdBY2NvdW50RGF0YVJlc3VsdCIsICJ0dXBsZSIsICJsaXRlcmFsIiwgIkJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSIsICJCdWZmZXIiLCAiZnJvbSIsICJCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUyIsICJhc3NlcnRFbmRwb2ludFVybCIsICJwdXRhdGl2ZVVybCIsICJ0ZXN0IiwgImV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyIsICJjb21taXRtZW50T3JDb25maWciLCAiY29tbWl0bWVudCIsICJjb25maWciLCAic3BlY2lmaWVkQ29tbWl0bWVudCIsICJzcGVjaWZpZWRDb25maWciLCAiYXBwbHlEZWZhdWx0TWVtY21wRW5jb2RpbmdUb0ZpbHRlcnMiLCAiZmlsdGVycyIsICJmaWx0ZXIiLCAibWVtY21wIiwgImVuY29kaW5nIiwgImNyZWF0ZVJwY1Jlc3VsdCIsICJyZXN1bHQiLCAidW5pb24iLCAicGljayIsICJqc29ucnBjIiwgImlkIiwgImVycm9yIiwgImNvZGUiLCAidW5rbm93biIsICJtZXNzYWdlIiwgIm9wdGlvbmFsIiwgImFueSIsICJVbmtub3duUnBjUmVzdWx0IiwgImpzb25ScGNSZXN1bHQiLCAic2NoZW1hIiwgImNyZWF0ZSIsICJqc29uUnBjUmVzdWx0QW5kQ29udGV4dCIsICJjb250ZXh0IiwgIm51bWJlciIsICJub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0IiwgInZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UiLCAidmVyc2lvbiIsICJyZXNwb25zZSIsICJNZXNzYWdlVjAiLCAiaGVhZGVyIiwgInN0YXRpY0FjY291bnRLZXlzIiwgImFjY291bnRLZXlzIiwgImFjY291bnRLZXkiLCAicmVjZW50QmxvY2toYXNoIiwgImNvbXBpbGVkSW5zdHJ1Y3Rpb25zIiwgImluc3RydWN0aW9ucyIsICJpeCIsICJwcm9ncmFtSWRJbmRleCIsICJhY2NvdW50S2V5SW5kZXhlcyIsICJhY2NvdW50cyIsICJiczU4IiwgImFkZHJlc3NUYWJsZUxvb2t1cHMiLCAiTWVzc2FnZSIsICJHZXRJbmZsYXRpb25Hb3Zlcm5vclJlc3VsdCIsICJmb3VuZGF0aW9uIiwgImZvdW5kYXRpb25UZXJtIiwgImluaXRpYWwiLCAidGFwZXIiLCAidGVybWluYWwiLCAiR2V0SW5mbGF0aW9uUmV3YXJkUmVzdWx0IiwgImFycmF5IiwgIm51bGxhYmxlIiwgImVmZmVjdGl2ZVNsb3QiLCAiYW1vdW50IiwgInBvc3RCYWxhbmNlIiwgImNvbW1pc3Npb24iLCAiR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUmVzdWx0IiwgInByaW9yaXRpemF0aW9uRmVlIiwgIkdldEluZmxhdGlvblJhdGVSZXN1bHQiLCAidG90YWwiLCAidmFsaWRhdG9yIiwgIkdldEVwb2NoSW5mb1Jlc3VsdCIsICJzbG90c0luRXBvY2giLCAiYWJzb2x1dGVTbG90IiwgImJsb2NrSGVpZ2h0IiwgInRyYW5zYWN0aW9uQ291bnQiLCAiR2V0RXBvY2hTY2hlZHVsZVJlc3VsdCIsICJib29sZWFuIiwgIkdldExlYWRlclNjaGVkdWxlUmVzdWx0IiwgInJlY29yZCIsICJUcmFuc2FjdGlvbkVycm9yUmVzdWx0IiwgIlNpZ25hdHVyZVN0YXR1c1Jlc3VsdCIsICJTaWduYXR1cmVSZWNlaXZlZFJlc3VsdCIsICJWZXJzaW9uUmVzdWx0IiwgIlBhcnNlZEluc3RydWN0aW9uU3RydWN0IiwgInByb2dyYW0iLCAicHJvZ3JhbUlkIiwgInBhcnNlZCIsICJQYXJ0aWFsbHlEZWNvZGVkSW5zdHJ1Y3Rpb25TdHJ1Y3QiLCAiU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZVN0cnVjdCIsICJsb2dzIiwgImV4ZWN1dGFibGUiLCAib3duZXIiLCAibGFtcG9ydHMiLCAicmVudEVwb2NoIiwgInVuaXRzQ29uc3VtZWQiLCAicmV0dXJuRGF0YSIsICJpbm5lckluc3RydWN0aW9ucyIsICJCbG9ja1Byb2R1Y3Rpb25SZXNwb25zZVN0cnVjdCIsICJieUlkZW50aXR5IiwgInJhbmdlIiwgImZpcnN0U2xvdCIsICJsYXN0U2xvdCIsICJjcmVhdGVScGNDbGllbnQiLCAiaHR0cEhlYWRlcnMiLCAiY3VzdG9tRmV0Y2giLCAiZmV0Y2hNaWRkbGV3YXJlIiwgImRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0IiwgImh0dHBBZ2VudCIsICJmZXRjaEltcGwiLCAiYWdlbnQiLCAiY29uc29sZSIsICJ3YXJuIiwgImZldGNoV2l0aE1pZGRsZXdhcmUiLCAiaW5mbyIsICJpbml0IiwgIm1vZGlmaWVkRmV0Y2hBcmdzIiwgInJlc29sdmUiLCAibW9kaWZpZWRJbmZvIiwgIm1vZGlmaWVkSW5pdCIsICJjbGllbnRCcm93c2VyIiwgIlJwY0NsaWVudCIsICJyZXF1ZXN0IiwgImNhbGxiYWNrIiwgIm1ldGhvZCIsICJib2R5IiwgImhlYWRlcnMiLCAiT2JqZWN0IiwgImFzc2lnbiIsICJDT01NT05fSFRUUF9IRUFERVJTIiwgInRvb19tYW55X3JlcXVlc3RzX3JldHJpZXMiLCAicmVzIiwgIndhaXRUaW1lIiwgInN0YXR1cyIsICJzdGF0dXNUZXh0IiwgInNsZWVwIiwgInRleHQiLCAib2siLCAiY3JlYXRlUnBjUmVxdWVzdCIsICJjbGllbnQiLCAiY3JlYXRlUnBjQmF0Y2hSZXF1ZXN0IiwgInJlcXVlc3RzIiwgImJhdGNoIiwgInBhcmFtcyIsICJtZXRob2ROYW1lIiwgIkdldEluZmxhdGlvbkdvdmVybm9yUnBjUmVzdWx0IiwgIkdldEluZmxhdGlvblJhdGVScGNSZXN1bHQiLCAiR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUnBjUmVzdWx0IiwgIkdldEVwb2NoSW5mb1JwY1Jlc3VsdCIsICJHZXRFcG9jaFNjaGVkdWxlUnBjUmVzdWx0IiwgIkdldExlYWRlclNjaGVkdWxlUnBjUmVzdWx0IiwgIlNsb3RScGNSZXN1bHQiLCAiR2V0U3VwcGx5UnBjUmVzdWx0IiwgImNpcmN1bGF0aW5nIiwgIm5vbkNpcmN1bGF0aW5nIiwgIm5vbkNpcmN1bGF0aW5nQWNjb3VudHMiLCAiVG9rZW5BbW91bnRSZXN1bHQiLCAidWlBbW91bnQiLCAiZGVjaW1hbHMiLCAidWlBbW91bnRTdHJpbmciLCAiR2V0VG9rZW5MYXJnZXN0QWNjb3VudHNSZXN1bHQiLCAiR2V0VG9rZW5BY2NvdW50c0J5T3duZXIiLCAicHVia2V5IiwgImFjY291bnQiLCAiUGFyc2VkQWNjb3VudERhdGFSZXN1bHQiLCAic3BhY2UiLCAiR2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIiLCAiR2V0TGFyZ2VzdEFjY291bnRzUnBjUmVzdWx0IiwgIkFjY291bnRJbmZvUmVzdWx0IiwgIktleWVkQWNjb3VudEluZm9SZXN1bHQiLCAiUGFyc2VkT3JSYXdBY2NvdW50RGF0YSIsICJBcnJheSIsICJpc0FycmF5IiwgIlBhcnNlZEFjY291bnRJbmZvUmVzdWx0IiwgIktleWVkUGFyc2VkQWNjb3VudEluZm9SZXN1bHQiLCAiU3Rha2VBY3RpdmF0aW9uUmVzdWx0IiwgImFjdGl2ZSIsICJpbmFjdGl2ZSIsICJHZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJScGNSZXN1bHQiLCAic2lnbmF0dXJlIiwgIm1lbW8iLCAiYmxvY2tUaW1lIiwgIkdldFNpZ25hdHVyZXNGb3JBZGRyZXNzUnBjUmVzdWx0IiwgIkFjY291bnROb3RpZmljYXRpb25SZXN1bHQiLCAic3Vic2NyaXB0aW9uIiwgIlByb2dyYW1BY2NvdW50SW5mb1Jlc3VsdCIsICJQcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvblJlc3VsdCIsICJTbG90SW5mb1Jlc3VsdCIsICJwYXJlbnQiLCAicm9vdCIsICJTbG90Tm90aWZpY2F0aW9uUmVzdWx0IiwgIlNsb3RVcGRhdGVSZXN1bHQiLCAidGltZXN0YW1wIiwgInN0YXRzIiwgIm51bVRyYW5zYWN0aW9uRW50cmllcyIsICJudW1TdWNjZXNzZnVsVHJhbnNhY3Rpb25zIiwgIm51bUZhaWxlZFRyYW5zYWN0aW9ucyIsICJtYXhUcmFuc2FjdGlvbnNQZXJFbnRyeSIsICJTbG90VXBkYXRlTm90aWZpY2F0aW9uUmVzdWx0IiwgIlNpZ25hdHVyZU5vdGlmaWNhdGlvblJlc3VsdCIsICJSb290Tm90aWZpY2F0aW9uUmVzdWx0IiwgIkNvbnRhY3RJbmZvUmVzdWx0IiwgImdvc3NpcCIsICJ0cHUiLCAiVm90ZUFjY291bnRJbmZvUmVzdWx0IiwgInZvdGVQdWJrZXkiLCAibm9kZVB1YmtleSIsICJhY3RpdmF0ZWRTdGFrZSIsICJlcG9jaFZvdGVBY2NvdW50IiwgImVwb2NoQ3JlZGl0cyIsICJsYXN0Vm90ZSIsICJyb290U2xvdCIsICJHZXRWb3RlQWNjb3VudHMiLCAiY3VycmVudCIsICJkZWxpbnF1ZW50IiwgIkNvbmZpcm1hdGlvblN0YXR1cyIsICJTaWduYXR1cmVTdGF0dXNSZXNwb25zZSIsICJjb25maXJtYXRpb25zIiwgImNvbmZpcm1hdGlvblN0YXR1cyIsICJHZXRTaWduYXR1cmVTdGF0dXNlc1JwY1Jlc3VsdCIsICJHZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb25ScGNSZXN1bHQiLCAiQWRkcmVzc1RhYmxlTG9va3VwU3RydWN0IiwgIndyaXRhYmxlSW5kZXhlcyIsICJyZWFkb25seUluZGV4ZXMiLCAiQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQiLCAic2lnbmF0dXJlcyIsICJudW1SZXF1aXJlZFNpZ25hdHVyZXMiLCAibnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyIsICJudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMiLCAiQW5ub3RhdGVkQWNjb3VudEtleSIsICJzaWduZXIiLCAid3JpdGFibGUiLCAic291cmNlIiwgIkNvbmZpcm1lZFRyYW5zYWN0aW9uQWNjb3VudHNNb2RlUmVzdWx0IiwgIlBhcnNlZEluc3RydWN0aW9uUmVzdWx0IiwgIlJhd0luc3RydWN0aW9uUmVzdWx0IiwgIkluc3RydWN0aW9uUmVzdWx0IiwgIlVua25vd25JbnN0cnVjdGlvblJlc3VsdCIsICJQYXJzZWRPclJhd0luc3RydWN0aW9uIiwgIlBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0IiwgIlRva2VuQmFsYW5jZVJlc3VsdCIsICJhY2NvdW50SW5kZXgiLCAibWludCIsICJ1aVRva2VuQW1vdW50IiwgIkxvYWRlZEFkZHJlc3Nlc1Jlc3VsdCIsICJyZWFkb25seSIsICJDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQiLCAiZmVlIiwgInByZUJhbGFuY2VzIiwgInBvc3RCYWxhbmNlcyIsICJsb2dNZXNzYWdlcyIsICJwcmVUb2tlbkJhbGFuY2VzIiwgInBvc3RUb2tlbkJhbGFuY2VzIiwgImxvYWRlZEFkZHJlc3NlcyIsICJjb21wdXRlVW5pdHNDb25zdW1lZCIsICJjb3N0VW5pdHMiLCAiUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0IiwgIlRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdCIsICJSZXdhcmRzUmVzdWx0IiwgInJld2FyZFR5cGUiLCAiR2V0QmxvY2tScGNSZXN1bHQiLCAiYmxvY2toYXNoIiwgInByZXZpb3VzQmxvY2toYXNoIiwgInBhcmVudFNsb3QiLCAidHJhbnNhY3Rpb25zIiwgInRyYW5zYWN0aW9uIiwgInJld2FyZHMiLCAiR2V0Tm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCIsICJHZXRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCIsICJHZXRQYXJzZWRCbG9ja1JwY1Jlc3VsdCIsICJHZXRQYXJzZWRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCIsICJHZXRQYXJzZWROb25lTW9kZUJsb2NrUnBjUmVzdWx0IiwgIkdldENvbmZpcm1lZEJsb2NrUnBjUmVzdWx0IiwgIkdldEJsb2NrU2lnbmF0dXJlc1JwY1Jlc3VsdCIsICJHZXRUcmFuc2FjdGlvblJwY1Jlc3VsdCIsICJHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCIsICJHZXRMYXRlc3RCbG9ja2hhc2hScGNSZXN1bHQiLCAibGFzdFZhbGlkQmxvY2tIZWlnaHQiLCAiSXNCbG9ja2hhc2hWYWxpZFJwY1Jlc3VsdCIsICJQZXJmU2FtcGxlUmVzdWx0IiwgIm51bVRyYW5zYWN0aW9ucyIsICJudW1TbG90cyIsICJzYW1wbGVQZXJpb2RTZWNzIiwgIkdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1JwY1Jlc3VsdCIsICJHZXRGZWVDYWxjdWxhdG9yUnBjUmVzdWx0IiwgImZlZUNhbGN1bGF0b3IiLCAibGFtcG9ydHNQZXJTaWduYXR1cmUiLCAiUmVxdWVzdEFpcmRyb3BScGNSZXN1bHQiLCAiU2VuZFRyYW5zYWN0aW9uUnBjUmVzdWx0IiwgIkxvZ3NSZXN1bHQiLCAiTG9nc05vdGlmaWNhdGlvblJlc3VsdCIsICJwcm9jZXNzIiwgIkNvbm5lY3Rpb24iLCAiX2NvbW1pdG1lbnQiLCAiX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IiwgIl9ycGNFbmRwb2ludCIsICJfcnBjV3NFbmRwb2ludCIsICJfcnBjQ2xpZW50IiwgIl9ycGNSZXF1ZXN0IiwgIl9ycGNCYXRjaFJlcXVlc3QiLCAiX3JwY1dlYlNvY2tldCIsICJfcnBjV2ViU29ja2V0Q29ubmVjdGVkIiwgIl9ycGNXZWJTb2NrZXRIZWFydGJlYXQiLCAiX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0IiwgIl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uIiwgIl9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZyIsICJfcG9sbGluZ0Jsb2NraGFzaCIsICJfYmxvY2toYXNoSW5mbyIsICJsYXRlc3RCbG9ja2hhc2giLCAibGFzdEZldGNoIiwgInRyYW5zYWN0aW9uU2lnbmF0dXJlcyIsICJzaW11bGF0ZWRTaWduYXR1cmVzIiwgIl9uZXh0Q2xpZW50U3Vic2NyaXB0aW9uSWQiLCAiX3N1YnNjcmlwdGlvbkRpc3Bvc2VGdW5jdGlvbnNCeUNsaWVudFN1YnNjcmlwdGlvbklkIiwgIl9zdWJzY3JpcHRpb25IYXNoQnlDbGllbnRTdWJzY3JpcHRpb25JZCIsICJfc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2giLCAiX3N1YnNjcmlwdGlvbkNhbGxiYWNrc0J5U2VydmVyU3Vic2NyaXB0aW9uSWQiLCAiX3N1YnNjcmlwdGlvbnNCeUhhc2giLCAiX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYyIsICJTZXQiLCAiZ2V0QmxvY2tIZWlnaHQiLCAicmVxdWVzdFByb21pc2VzIiwgIl9idWlsZEFyZ3MiLCAicmVxdWVzdEhhc2giLCAidW5zYWZlUmVzIiwgIlNvbGFuYUpTT05SUENFcnJvciIsICJ3c0VuZHBvaW50IiwgImNvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IiwgIkluZmluaXR5IiwgIm9uIiwgIl93c09uT3BlbiIsICJiaW5kIiwgIl93c09uRXJyb3IiLCAiX3dzT25DbG9zZSIsICJfd3NPbkFjY291bnROb3RpZmljYXRpb24iLCAiX3dzT25Qcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvbiIsICJfd3NPblNsb3ROb3RpZmljYXRpb24iLCAiX3dzT25TbG90VXBkYXRlc05vdGlmaWNhdGlvbiIsICJfd3NPblNpZ25hdHVyZU5vdGlmaWNhdGlvbiIsICJfd3NPblJvb3ROb3RpZmljYXRpb24iLCAiX3dzT25Mb2dzTm90aWZpY2F0aW9uIiwgInJwY0VuZHBvaW50IiwgImdldEJhbGFuY2VBbmRDb250ZXh0IiwgInB1YmxpY0tleSIsICJ0b0Jhc2U1OCIsICJnZXRCYWxhbmNlIiwgInRoZW4iLCAieCIsICJjYXRjaCIsICJlIiwgImdldEJsb2NrVGltZSIsICJnZXRNaW5pbXVtTGVkZ2VyU2xvdCIsICJnZXRGaXJzdEF2YWlsYWJsZUJsb2NrIiwgImdldFN1cHBseSIsICJjb25maWdBcmciLCAiZ2V0VG9rZW5TdXBwbHkiLCAidG9rZW5NaW50QWRkcmVzcyIsICJnZXRUb2tlbkFjY291bnRCYWxhbmNlIiwgInRva2VuQWRkcmVzcyIsICJnZXRUb2tlbkFjY291bnRzQnlPd25lciIsICJvd25lckFkZHJlc3MiLCAiX2FyZ3MiLCAicHVzaCIsICJnZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lciIsICJnZXRMYXJnZXN0QWNjb3VudHMiLCAiYXJnIiwgImdldFRva2VuTGFyZ2VzdEFjY291bnRzIiwgIm1pbnRBZGRyZXNzIiwgImdldEFjY291bnRJbmZvQW5kQ29udGV4dCIsICJnZXRQYXJzZWRBY2NvdW50SW5mbyIsICJnZXRBY2NvdW50SW5mbyIsICJnZXRNdWx0aXBsZVBhcnNlZEFjY291bnRzIiwgInB1YmxpY0tleXMiLCAicmF3Q29uZmlnIiwgImtleXMiLCAiZ2V0TXVsdGlwbGVBY2NvdW50c0luZm9BbmRDb250ZXh0IiwgImdldE11bHRpcGxlQWNjb3VudHNJbmZvIiwgImdldFN0YWtlQWN0aXZhdGlvbiIsICJnZXRQcm9ncmFtQWNjb3VudHMiLCAiY29uZmlnT3JDb21taXRtZW50IiwgImNvbmZpZ1dpdGhvdXRFbmNvZGluZyIsICJiYXNlU2NoZW1hIiwgIndpdGhDb250ZXh0IiwgImdldFBhcnNlZFByb2dyYW1BY2NvdW50cyIsICJjb25maXJtVHJhbnNhY3Rpb24iLCAic3RyYXRlZ3kiLCAicmF3U2lnbmF0dXJlIiwgImFib3J0U2lnbmFsIiwgImFib3J0ZWQiLCAicmVhc29uIiwgImRlY29kZWRTaWduYXR1cmUiLCAiY29uZmlybVRyYW5zYWN0aW9uVXNpbmdMZWdhY3lUaW1lb3V0U3RyYXRlZ3kiLCAiY29uZmlybVRyYW5zYWN0aW9uVXNpbmdCbG9ja0hlaWdodEV4Y2VlZGFuY2VTdHJhdGVneSIsICJjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0R1cmFibGVOb25jZVN0cmF0ZWd5IiwgImdldENhbmNlbGxhdGlvblByb21pc2UiLCAic2lnbmFsIiwgImFkZEV2ZW50TGlzdGVuZXIiLCAiZ2V0VHJhbnNhY3Rpb25Db25maXJtYXRpb25Qcm9taXNlIiwgInNpZ25hdHVyZVN1YnNjcmlwdGlvbklkIiwgImRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyIiwgImRvbmUiLCAiY29uZmlybWF0aW9uUHJvbWlzZSIsICJvblNpZ25hdHVyZSIsICJfX3R5cGUiLCAiVHJhbnNhY3Rpb25TdGF0dXMiLCAiUFJPQ0VTU0VEIiwgInN1YnNjcmlwdGlvblNldHVwUHJvbWlzZSIsICJyZXNvbHZlU3Vic2NyaXB0aW9uU2V0dXAiLCAiX29uU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2UiLCAibmV4dFN0YXRlIiwgImdldFNpZ25hdHVyZVN0YXR1cyIsICJhYm9ydENvbmZpcm1hdGlvbiIsICJyZW1vdmVTaWduYXR1cmVMaXN0ZW5lciIsICJleHBpcnlQcm9taXNlIiwgImNoZWNrQmxvY2tIZWlnaHQiLCAiX2UiLCAiY3VycmVudEJsb2NrSGVpZ2h0IiwgIkJMT0NLSEVJR0hUX0VYQ0VFREVEIiwgImNhbmNlbGxhdGlvblByb21pc2UiLCAib3V0Y29tZSIsICJyYWNlIiwgIlRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvciIsICJtaW5Db250ZXh0U2xvdCIsICJub25jZUFjY291bnRQdWJrZXkiLCAibm9uY2VWYWx1ZSIsICJjdXJyZW50Tm9uY2VWYWx1ZSIsICJsYXN0Q2hlY2tlZFNsb3QiLCAiZ2V0Q3VycmVudE5vbmNlVmFsdWUiLCAibm9uY2VBY2NvdW50IiwgImdldE5vbmNlQW5kQ29udGV4dCIsICJub25jZSIsICJOT05DRV9JTlZBTElEIiwgInNsb3RJbldoaWNoTm9uY2VEaWRBZHZhbmNlIiwgInNpZ25hdHVyZVN0YXR1cyIsICJjb21taXRtZW50Rm9yU3RhdHVzIiwgIlRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yIiwgInRpbWVvdXRJZCIsICJ0aW1lb3V0TXMiLCAic2V0VGltZW91dCIsICJUSU1FRF9PVVQiLCAiVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yIiwgImNsZWFyVGltZW91dCIsICJnZXRDbHVzdGVyTm9kZXMiLCAiZ2V0Vm90ZUFjY291bnRzIiwgImdldFNsb3QiLCAiZ2V0U2xvdExlYWRlciIsICJnZXRTbG90TGVhZGVycyIsICJzdGFydFNsb3QiLCAibGltaXQiLCAidmFsdWVzIiwgImdldFNpZ25hdHVyZVN0YXR1c2VzIiwgImdldFRyYW5zYWN0aW9uQ291bnQiLCAiZ2V0VG90YWxTdXBwbHkiLCAiZXhjbHVkZU5vbkNpcmN1bGF0aW5nQWNjb3VudHNMaXN0IiwgImdldEluZmxhdGlvbkdvdmVybm9yIiwgImdldEluZmxhdGlvblJld2FyZCIsICJnZXRJbmZsYXRpb25SYXRlIiwgImdldEVwb2NoSW5mbyIsICJnZXRFcG9jaFNjaGVkdWxlIiwgImVwb2NoU2NoZWR1bGUiLCAiZ2V0TGVhZGVyU2NoZWR1bGUiLCAiZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uIiwgImRhdGFMZW5ndGgiLCAiZ2V0UmVjZW50QmxvY2toYXNoQW5kQ29udGV4dCIsICJnZXRMYXRlc3RCbG9ja2hhc2hBbmRDb250ZXh0IiwgInRvSlNPTiIsICJnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXMiLCAiZ2V0RmVlQ2FsY3VsYXRvckZvckJsb2NraGFzaCIsICJnZXRGZWVGb3JNZXNzYWdlIiwgIndpcmVNZXNzYWdlIiwgInRvQnVmZmVyIiwgInNlcmlhbGl6ZSIsICJ0b1N0cmluZyIsICJnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXMiLCAibG9ja2VkV3JpdGFibGVBY2NvdW50cyIsICJnZXRSZWNlbnRCbG9ja2hhc2giLCAiZ2V0TGF0ZXN0QmxvY2toYXNoIiwgImlzQmxvY2toYXNoVmFsaWQiLCAiZ2V0VmVyc2lvbiIsICJnZXRHZW5lc2lzSGFzaCIsICJnZXRCbG9jayIsICJfYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZCIsICJ0cmFuc2FjdGlvbkRldGFpbHMiLCAiZ2V0UGFyc2VkQmxvY2siLCAiZ2V0QmxvY2tQcm9kdWN0aW9uIiwgImV4dHJhIiwgImMiLCAiZ2V0VHJhbnNhY3Rpb24iLCAiZ2V0UGFyc2VkVHJhbnNhY3Rpb24iLCAiZ2V0UGFyc2VkVHJhbnNhY3Rpb25zIiwgImdldFRyYW5zYWN0aW9ucyIsICJnZXRDb25maXJtZWRCbG9jayIsICJibG9jayIsICJUcmFuc2FjdGlvbiIsICJwb3B1bGF0ZSIsICJnZXRCbG9ja3MiLCAiZW5kU2xvdCIsICJnZXRCbG9ja1NpZ25hdHVyZXMiLCAiZ2V0Q29uZmlybWVkQmxvY2tTaWduYXR1cmVzIiwgImdldENvbmZpcm1lZFRyYW5zYWN0aW9uIiwgImdldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uIiwgImdldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9ucyIsICJnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzcyIsICJmaXJzdEF2YWlsYWJsZUJsb2NrIiwgInVudGlsIiwgImluY2x1ZGVzIiwgImhpZ2hlc3RDb25maXJtZWRSb290IiwgImJlZm9yZSIsICJjb25maXJtZWRTaWduYXR1cmVJbmZvIiwgImdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMiIsICJnZXRTaWduYXR1cmVzRm9yQWRkcmVzcyIsICJnZXRBZGRyZXNzTG9va3VwVGFibGUiLCAiYWNjb3VudEluZm8iLCAiTm9uY2VBY2NvdW50IiwgImZyb21BY2NvdW50RGF0YSIsICJnZXROb25jZSIsICJyZXF1ZXN0QWlyZHJvcCIsICJ0byIsICJfYmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0IiwgImRpc2FibGVDYWNoZSIsICJ0aW1lU2luY2VGZXRjaCIsICJEYXRlIiwgIm5vdyIsICJleHBpcmVkIiwgIl9wb2xsTmV3QmxvY2toYXNoIiwgInN0YXJ0VGltZSIsICJjYWNoZWRMYXRlc3RCbG9ja2hhc2giLCAiY2FjaGVkQmxvY2toYXNoIiwgImkiLCAiTVNfUEVSX1NMT1QiLCAiZ2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvbiIsICJzaW11bGF0ZVRyYW5zYWN0aW9uIiwgInRyYW5zYWN0aW9uT3JNZXNzYWdlIiwgImNvbmZpZ09yU2lnbmVycyIsICJpbmNsdWRlQWNjb3VudHMiLCAidmVyc2lvbmVkVHgiLCAid2lyZVRyYW5zYWN0aW9uIiwgImVuY29kZWRUcmFuc2FjdGlvbiIsICJvcmlnaW5hbFR4IiwgImZlZVBheWVyIiwgIm5vbmNlSW5mbyIsICJfbWVzc2FnZSIsICJfanNvbiIsICJzaWduZXJzIiwgInNpZ24iLCAiX2NvbXBpbGUiLCAic2lnbkRhdGEiLCAiX3NlcmlhbGl6ZSIsICJub25Qcm9ncmFtSWRzIiwgInNpZ1ZlcmlmeSIsICJ0cmFjZUluZGVudCIsICJsb2dUcmFjZSIsICJqb2luIiwgIlNlbmRUcmFuc2FjdGlvbkVycm9yIiwgImFjdGlvbiIsICJ0cmFuc2FjdGlvbk1lc3NhZ2UiLCAic2VuZFRyYW5zYWN0aW9uIiwgInNpZ25lcnNPck9wdGlvbnMiLCAic2VuZFJhd1RyYW5zYWN0aW9uIiwgInJhd1RyYW5zYWN0aW9uIiwgInNlbmRFbmNvZGVkVHJhbnNhY3Rpb24iLCAic2tpcFByZWZsaWdodCIsICJwcmVmbGlnaHRDb21taXRtZW50IiwgIm1heFJldHJpZXMiLCAic2V0SW50ZXJ2YWwiLCAiX3VwZGF0ZVN1YnNjcmlwdGlvbnMiLCAiTnVtYmVyIiwgIk1BWF9TQUZFX0lOVEVHRVIiLCAiY2xlYXJJbnRlcnZhbCIsICJlbnRyaWVzIiwgImZvckVhY2giLCAiaGFzaCIsICJfc2V0U3Vic2NyaXB0aW9uIiwgIm5leHRTdWJzY3JpcHRpb24iLCAicHJldlN0YXRlIiwgInN0YXRlQ2hhbmdlQ2FsbGJhY2tzIiwgImNiIiwgImNsaWVudFN1YnNjcmlwdGlvbklkIiwgImFkZCIsICJkZWxldGUiLCAic2l6ZSIsICJjbG9zZSIsICJsb2ciLCAiY29ubmVjdCIsICJhY3RpdmVXZWJTb2NrZXRHZW5lcmF0aW9uIiwgImlzQ3VycmVudENvbm5lY3Rpb25TdGlsbEFjdGl2ZSIsICJhbGwiLCAiY2FsbGJhY2tzIiwgInNlcnZlclN1YnNjcmlwdGlvbklkIiwgInVuc3Vic2NyaWJlTWV0aG9kIiwgImhhcyIsICJfaGFuZGxlU2VydmVyTm90aWZpY2F0aW9uIiwgImNhbGxiYWNrQXJncyIsICJub3RpZmljYXRpb24iLCAiX21ha2VTdWJzY3JpcHRpb24iLCAic3Vic2NyaXB0aW9uQ29uZmlnIiwgImV4aXN0aW5nU3Vic2NyaXB0aW9uIiwgIm9uQWNjb3VudENoYW5nZSIsICJyZW1vdmVBY2NvdW50Q2hhbmdlTGlzdGVuZXIiLCAiX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uIiwgImFjY291bnRJZCIsICJvblByb2dyYW1BY2NvdW50Q2hhbmdlIiwgIm1heWJlRmlsdGVycyIsICJyZW1vdmVQcm9ncmFtQWNjb3VudENoYW5nZUxpc3RlbmVyIiwgIm9uTG9ncyIsICJtZW50aW9ucyIsICJyZW1vdmVPbkxvZ3NMaXN0ZW5lciIsICJvblNsb3RDaGFuZ2UiLCAicmVtb3ZlU2xvdENoYW5nZUxpc3RlbmVyIiwgIm9uU2xvdFVwZGF0ZSIsICJyZW1vdmVTbG90VXBkYXRlTGlzdGVuZXIiLCAic3Vic2NyaXB0aW9uTmFtZSIsICJkaXNwb3NlIiwgIm92ZXJyaWRlIiwgIl9lcnIiLCAib25TaWduYXR1cmVXaXRoT3B0aW9ucyIsICJvblJvb3RDaGFuZ2UiLCAicmVtb3ZlUm9vdENoYW5nZUxpc3RlbmVyIiwgIktleXBhaXIiLCAia2V5cGFpciIsICJfa2V5cGFpciIsICJnZW5lcmF0ZUtleXBhaXIiLCAiZ2VuZXJhdGUiLCAiZnJvbVNlY3JldEtleSIsICJzZWNyZXRLZXkiLCAiYnl0ZUxlbmd0aCIsICJza2lwVmFsaWRhdGlvbiIsICJwcml2YXRlU2NhbGFyIiwgImNvbXB1dGVkUHVibGljS2V5IiwgImdldFB1YmxpY0tleSIsICJpaSIsICJmcm9tU2VlZCIsICJzZWVkIiwgIlVpbnQ4QXJyYXkiLCAic2V0IiwgIkxPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTIiwgImZyZWV6ZSIsICJDcmVhdGVMb29rdXBUYWJsZSIsICJiaWdpbnRMYXlvdXQiLCAiRnJlZXplTG9va3VwVGFibGUiLCAiRXh0ZW5kTG9va3VwVGFibGUiLCAiRGVhY3RpdmF0ZUxvb2t1cFRhYmxlIiwgIkNsb3NlTG9va3VwVGFibGUiLCAiQWRkcmVzc0xvb2t1cFRhYmxlUHJvZ3JhbSIsICJjb25zdHJ1Y3RvciIsICJjcmVhdGVMb29rdXBUYWJsZSIsICJwYXJhbXMiLCAibG9va3VwVGFibGVBZGRyZXNzIiwgImJ1bXBTZWVkIiwgIlB1YmxpY0tleSIsICJmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jIiwgImF1dGhvcml0eSIsICJ0b0J1ZmZlciIsICJnZXRVNjRFbmNvZGVyIiwgImVuY29kZSIsICJyZWNlbnRTbG90IiwgInByb2dyYW1JZCIsICJ0eXBlIiwgIkxPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTIiwgIkNyZWF0ZUxvb2t1cFRhYmxlIiwgImRhdGEiLCAiZW5jb2RlRGF0YSIsICJCaWdJbnQiLCAia2V5cyIsICJwdWJrZXkiLCAiaXNTaWduZXIiLCAiaXNXcml0YWJsZSIsICJwYXllciIsICJTeXN0ZW1Qcm9ncmFtIiwgIlRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24iLCAiZnJlZXplTG9va3VwVGFibGUiLCAiRnJlZXplTG9va3VwVGFibGUiLCAibG9va3VwVGFibGUiLCAiZXh0ZW5kTG9va3VwVGFibGUiLCAiRXh0ZW5kTG9va3VwVGFibGUiLCAiYWRkcmVzc2VzIiwgIm1hcCIsICJhZGRyIiwgInRvQnl0ZXMiLCAicHVzaCIsICJkZWFjdGl2YXRlTG9va3VwVGFibGUiLCAiRGVhY3RpdmF0ZUxvb2t1cFRhYmxlIiwgImNsb3NlTG9va3VwVGFibGUiLCAiQ2xvc2VMb29rdXBUYWJsZSIsICJyZWNpcGllbnQiLCAiQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUyIsICJPYmplY3QiLCAiZnJlZXplIiwgIlJlcXVlc3RVbml0cyIsICJpbmRleCIsICJsYXlvdXQiLCAic3RydWN0IiwgInU4IiwgInUzMiIsICJSZXF1ZXN0SGVhcEZyYW1lIiwgIlNldENvbXB1dGVVbml0TGltaXQiLCAiU2V0Q29tcHV0ZVVuaXRQcmljZSIsICJ1NjQiLCAiQ29tcHV0ZUJ1ZGdldFByb2dyYW0iLCAiY29uc3RydWN0b3IiLCAicmVxdWVzdFVuaXRzIiwgInBhcmFtcyIsICJ0eXBlIiwgImRhdGEiLCAiZW5jb2RlRGF0YSIsICJUcmFuc2FjdGlvbkluc3RydWN0aW9uIiwgImtleXMiLCAicHJvZ3JhbUlkIiwgInJlcXVlc3RIZWFwRnJhbWUiLCAic2V0Q29tcHV0ZVVuaXRMaW1pdCIsICJzZXRDb21wdXRlVW5pdFByaWNlIiwgIm1pY3JvTGFtcG9ydHMiLCAiQmlnSW50IiwgIlB1YmxpY0tleSIsICJQUklWQVRFX0tFWV9CWVRFUyIsICJQVUJMSUNfS0VZX0JZVEVTIiwgIlNJR05BVFVSRV9CWVRFUyIsICJFRDI1NTE5X0lOU1RSVUNUSU9OX0xBWU9VVCIsICJ1MTYiLCAiRWQyNTUxOVByb2dyYW0iLCAiY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoUHVibGljS2V5IiwgInB1YmxpY0tleSIsICJtZXNzYWdlIiwgInNpZ25hdHVyZSIsICJpbnN0cnVjdGlvbkluZGV4IiwgImFzc2VydCIsICJsZW5ndGgiLCAicHVibGljS2V5T2Zmc2V0IiwgInNwYW4iLCAic2lnbmF0dXJlT2Zmc2V0IiwgIm1lc3NhZ2VEYXRhT2Zmc2V0IiwgIm51bVNpZ25hdHVyZXMiLCAiaW5zdHJ1Y3Rpb25EYXRhIiwgIkJ1ZmZlciIsICJhbGxvYyIsICJlbmNvZGUiLCAicGFkZGluZyIsICJzaWduYXR1cmVJbnN0cnVjdGlvbkluZGV4IiwgInB1YmxpY0tleUluc3RydWN0aW9uSW5kZXgiLCAibWVzc2FnZURhdGFTaXplIiwgIm1lc3NhZ2VJbnN0cnVjdGlvbkluZGV4IiwgImZpbGwiLCAiY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoUHJpdmF0ZUtleSIsICJwcml2YXRlS2V5IiwgImtleXBhaXIiLCAiS2V5cGFpciIsICJmcm9tU2VjcmV0S2V5IiwgInRvQnl0ZXMiLCAic2lnbiIsICJzZWNyZXRLZXkiLCAiZXJyb3IiLCAiRXJyb3IiLCAiZWNkc2FTaWduIiwgIm1zZ0hhc2giLCAicHJpdktleSIsICJzZWNwMjU2azEiLCAidG9Db21wYWN0UmF3Qnl0ZXMiLCAicmVjb3ZlcnkiLCAidXRpbHMiLCAiaXNWYWxpZFByaXZhdGVLZXkiLCAicHVibGljS2V5Q3JlYXRlIiwgImdldFB1YmxpY0tleSIsICJFVEhFUkVVTV9BRERSRVNTX0JZVEVTIiwgIlNJR05BVFVSRV9PRkZTRVRTX1NFUklBTElaRURfU0laRSIsICJTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VUIiwgImJsb2IiLCAiU2VjcDI1NmsxUHJvZ3JhbSIsICJwdWJsaWNLZXlUb0V0aEFkZHJlc3MiLCAiZnJvbSIsICJrZWNjYWtfMjU2IiwgInRvQnVmZmVyIiwgInNsaWNlIiwgInJlY292ZXJ5SWQiLCAiY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoRXRoQWRkcmVzcyIsICJldGhBZGRyZXNzIiwgInJhd0FkZHJlc3MiLCAic3RhcnRzV2l0aCIsICJzdWJzdHIiLCAiZGF0YVN0YXJ0IiwgImV0aEFkZHJlc3NPZmZzZXQiLCAiZXRoQWRkcmVzc0luc3RydWN0aW9uSW5kZXgiLCAicGtleSIsICJtZXNzYWdlSGFzaCIsICJTVEFLRV9DT05GSUdfSUQiLCAiTG9ja3VwIiwgImNvbnN0cnVjdG9yIiwgInVuaXhUaW1lc3RhbXAiLCAiZXBvY2giLCAiY3VzdG9kaWFuIiwgIl9Mb2NrdXAiLCAiZGVmYXVsdCIsICJQdWJsaWNLZXkiLCAiU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUyIsICJPYmplY3QiLCAiZnJlZXplIiwgIkluaXRpYWxpemUiLCAiaW5kZXgiLCAibGF5b3V0IiwgInN0cnVjdCIsICJ1MzIiLCAiTGF5b3V0IiwgIkF1dGhvcml6ZSIsICJEZWxlZ2F0ZSIsICJTcGxpdCIsICJuczY0IiwgIldpdGhkcmF3IiwgIkRlYWN0aXZhdGUiLCAiTWVyZ2UiLCAiQXV0aG9yaXplV2l0aFNlZWQiLCAiU3Rha2VBdXRob3JpemF0aW9uTGF5b3V0IiwgIlN0YWtlciIsICJXaXRoZHJhd2VyIiwgIlN0YWtlUHJvZ3JhbSIsICJjb25zdHJ1Y3RvciIsICJpbml0aWFsaXplIiwgInBhcmFtcyIsICJzdGFrZVB1YmtleSIsICJhdXRob3JpemVkIiwgImxvY2t1cCIsICJtYXliZUxvY2t1cCIsICJMb2NrdXAiLCAiZGVmYXVsdCIsICJ0eXBlIiwgImRhdGEiLCAiZW5jb2RlRGF0YSIsICJzdGFrZXIiLCAidG9CdWZmZXIiLCAid2l0aGRyYXdlciIsICJ1bml4VGltZXN0YW1wIiwgImVwb2NoIiwgImN1c3RvZGlhbiIsICJpbnN0cnVjdGlvbkRhdGEiLCAia2V5cyIsICJwdWJrZXkiLCAiaXNTaWduZXIiLCAiaXNXcml0YWJsZSIsICJTWVNWQVJfUkVOVF9QVUJLRVkiLCAicHJvZ3JhbUlkIiwgIlRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24iLCAiY3JlYXRlQWNjb3VudFdpdGhTZWVkIiwgInRyYW5zYWN0aW9uIiwgIlRyYW5zYWN0aW9uIiwgImFkZCIsICJTeXN0ZW1Qcm9ncmFtIiwgImZyb21QdWJrZXkiLCAibmV3QWNjb3VudFB1YmtleSIsICJiYXNlUHVia2V5IiwgInNlZWQiLCAibGFtcG9ydHMiLCAic3BhY2UiLCAiY3JlYXRlQWNjb3VudCIsICJkZWxlZ2F0ZSIsICJhdXRob3JpemVkUHVia2V5IiwgInZvdGVQdWJrZXkiLCAiU1lTVkFSX0NMT0NLX1BVQktFWSIsICJTWVNWQVJfU1RBS0VfSElTVE9SWV9QVUJLRVkiLCAiU1RBS0VfQ09ORklHX0lEIiwgImF1dGhvcml6ZSIsICJuZXdBdXRob3JpemVkUHVia2V5IiwgInN0YWtlQXV0aG9yaXphdGlvblR5cGUiLCAiY3VzdG9kaWFuUHVia2V5IiwgIm5ld0F1dGhvcml6ZWQiLCAicHVzaCIsICJhdXRob3JpemVXaXRoU2VlZCIsICJhdXRob3JpdHlCYXNlIiwgImF1dGhvcml0eVNlZWQiLCAiYXV0aG9yaXR5T3duZXIiLCAic3BsaXRJbnN0cnVjdGlvbiIsICJzcGxpdFN0YWtlUHVia2V5IiwgInNwbGl0IiwgInJlbnRFeGVtcHRSZXNlcnZlIiwgInNwbGl0V2l0aFNlZWQiLCAiYWxsb2NhdGUiLCAiYWNjb3VudFB1YmtleSIsICJ0cmFuc2ZlciIsICJ0b1B1YmtleSIsICJtZXJnZSIsICJzb3VyY2VTdGFrZVB1YktleSIsICJ3aXRoZHJhdyIsICJkZWFjdGl2YXRlIiwgIlB1YmxpY0tleSIsICJWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMiLCAiT2JqZWN0IiwgImZyZWV6ZSIsICJJbml0aWFsaXplQWNjb3VudCIsICJpbmRleCIsICJsYXlvdXQiLCAic3RydWN0IiwgInUzMiIsICJMYXlvdXQiLCAiQXV0aG9yaXplIiwgIldpdGhkcmF3IiwgIm5zNjQiLCAiVXBkYXRlVmFsaWRhdG9ySWRlbnRpdHkiLCAiQXV0aG9yaXplV2l0aFNlZWQiLCAiVm90ZUF1dGhvcml6YXRpb25MYXlvdXQiLCAiVm90ZXIiLCAiV2l0aGRyYXdlciIsICJWb3RlUHJvZ3JhbSIsICJjb25zdHJ1Y3RvciIsICJpbml0aWFsaXplQWNjb3VudCIsICJwYXJhbXMiLCAidm90ZVB1YmtleSIsICJub2RlUHVia2V5IiwgInZvdGVJbml0IiwgInR5cGUiLCAiZGF0YSIsICJlbmNvZGVEYXRhIiwgInRvQnVmZmVyIiwgImF1dGhvcml6ZWRWb3RlciIsICJhdXRob3JpemVkV2l0aGRyYXdlciIsICJjb21taXNzaW9uIiwgImluc3RydWN0aW9uRGF0YSIsICJrZXlzIiwgInB1YmtleSIsICJpc1NpZ25lciIsICJpc1dyaXRhYmxlIiwgIlNZU1ZBUl9SRU5UX1BVQktFWSIsICJTWVNWQVJfQ0xPQ0tfUFVCS0VZIiwgInByb2dyYW1JZCIsICJUcmFuc2FjdGlvbkluc3RydWN0aW9uIiwgImNyZWF0ZUFjY291bnQiLCAidHJhbnNhY3Rpb24iLCAiVHJhbnNhY3Rpb24iLCAiYWRkIiwgIlN5c3RlbVByb2dyYW0iLCAiZnJvbVB1YmtleSIsICJuZXdBY2NvdW50UHVia2V5IiwgImxhbXBvcnRzIiwgInNwYWNlIiwgImF1dGhvcml6ZSIsICJhdXRob3JpemVkUHVia2V5IiwgIm5ld0F1dGhvcml6ZWRQdWJrZXkiLCAidm90ZUF1dGhvcml6YXRpb25UeXBlIiwgIm5ld0F1dGhvcml6ZWQiLCAiYXV0aG9yaXplV2l0aFNlZWQiLCAiY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlCYXNlUHVia2V5IiwgImN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXkiLCAiY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkIiwgInZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3MiLCAid2l0aGRyYXciLCAiYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXkiLCAidG9QdWJrZXkiLCAic2FmZVdpdGhkcmF3IiwgImN1cnJlbnRWb3RlQWNjb3VudEJhbGFuY2UiLCAicmVudEV4ZW1wdE1pbmltdW0iLCAiRXJyb3IiLCAidXBkYXRlVmFsaWRhdG9ySWRlbnRpdHkiLCAiUHVibGljS2V5IiwgIlZBTElEQVRPUl9JTkZPX0tFWSIsICJJbmZvU3RyaW5nIiwgInBpY2siLCAibmFtZSIsICJzdHJpbmciLCAid2Vic2l0ZSIsICJvcHRpb25hbCIsICJkZXRhaWxzIiwgImljb25VcmwiLCAia2V5YmFzZVVzZXJuYW1lIiwgIlZPVEVfUFJPR1JBTV9JRCIsICJQdWJsaWNLZXkiLCAiVm90ZUFjY291bnRMYXlvdXQiLCAic3RydWN0IiwgIkxheW91dCIsICJ1OCIsICJudTY0IiwgInNlcSIsICJ1MzIiLCAib2Zmc2V0IiwgIkxBTVBPUlRTX1BFUl9TT0wiLCAiQmlnTnVtYmVyIiwgInNpZ24iLCAiY29tcGFyZSIsICJmb3JtYXQiLCAiaW1wb3J0X2J1ZmZlcl9sYXlvdXQiLCAib2Zmc2V0IiwgImJpZ0ludCIsICJ1NjQiLCAiaW1wb3J0X2J1ZmZlcl9sYXlvdXQiLCAib2Zmc2V0IiwgImJvb2wiLCAiaW1wb3J0X2J1ZmZlcl9sYXlvdXQiLCAicHVibGljS2V5IiwgIm9mZnNldCIsICJUb2tlbkluc3RydWN0aW9uIiwgImltcG9ydF9idWZmZXJfbGF5b3V0IiwgIkFjY291bnRUeXBlIiwgImltcG9ydF9idWZmZXJfbGF5b3V0IiwgImltcG9ydF9idWZmZXJfbGF5b3V0IiwgInB1YmxpY0tleSIsICJBY2NvdW50U3RhdGUiLCAicHVibGljS2V5IiwgInU2NCIsICJpbXBvcnRfYnVmZmVyX2xheW91dCIsICJ1NjQiLCAicHVibGljS2V5IiwgInU2NCIsICJyZWZlcmVuY2UiLCAiaW1wb3J0X2J1ZmZlciIsICJwdWJsaWNLZXkiXQp9Cg==
